<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Embedding Julia · The Julia Language</title><meta name="title" content="Embedding Julia · The Julia Language"><meta property="og:title" content="Embedding Julia · The Julia Language"><meta property="twitter:title" content="Embedding Julia · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/embedding/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/embedding/"><link rel="canonical" href="index.html"><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li class="is-active"><a class="tocitem" href="">Embedding Julia</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#High-Level-Embedding"><span>High-Level Embedding</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#High-Level-Embedding"><span>高レベルの埋め込み</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#High-Level-Embedding-on-Windows-with-Visual-Studio"><span>High-Level Embedding on Windows with Visual Studio</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#High-Level-Embedding-on-Windows-with-Visual-Studio"><span>Visual Studioを使用したWindowsでの高レベルの埋め込み</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Converting-Types"><span>Converting Types</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Converting-Types"><span>型の変換</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Calling-Julia-Functions"><span>Calling Julia Functions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Calling-Julia-Functions"><span>Julia関数の呼び出し</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Memory-Management"><span>Memory Management</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Memory-Management"><span>メモリ管理</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Working-with-Arrays"><span>Working with Arrays</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Working-with-Arrays"><span>配列の操作</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Exceptions"><span>Exceptions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Exceptions"><span>例外</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">Juliaの埋め込み</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">Juliaの埋め込み</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/embedding.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Embedding-Julia" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Embedding-Julia">Embedding Julia</a><a id="Embedding-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Embedding-Julia" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Embedding-Julia">Juliaの埋め込み</a><a id="Embedding-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Embedding-Julia" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">As we have seen in <a href="../calling-c-and-fortran-code/index.html#Calling-C-and-Fortran-Code">Calling C and Fortran Code</a>, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia functions from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python, Rust or C#). Even though Rust and C++ can use the C embedding API directly, both have packages helping with it, for C++ <a href="https://github.com/Clemapfel/jluna">Jluna</a> is useful.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">私たちが<a href="../calling-c-and-fortran-code/index.html#Calling-C-and-Fortran-Code">CおよびFortranコードの呼び出し</a>で見たように、JuliaはCで書かれた関数を呼び出すためのシンプルで効率的な方法を提供しています。しかし、逆にCコードからJulia関数を呼び出す必要がある状況もあります。これは、すべてをC/C++で書き直すことなく、Juliaコードをより大きなC/C++プロジェクトに統合するために使用できます。Juliaにはこれを可能にするC APIがあります。ほとんどすべてのプログラミング言語にはC関数を呼び出す方法があるため、JuliaのC APIはさらに言語ブリッジを構築するためにも使用できます（例：Python、Rust、C#からJuliaを呼び出す）。RustとC++はC埋め込みAPIを直接使用できますが、両方ともそれを助けるパッケージがあります。C++の場合、<a href="https://github.com/Clemapfel/jluna">Jluna</a>が便利です。</span></p><h2 id="High-Level-Embedding" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#High-Level-Embedding">High-Level Embedding</a><a id="High-Level-Embedding-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-Embedding" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#High-Level-Embedding">高レベルの埋め込み</a><a id="High-Level-Embedding-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-Embedding" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text"><strong>Note</strong>: This section covers embedding Julia code in C on Unix-like operating systems. For doing this on Windows, please see the section following this, <a href="#High-Level-Embedding-on-Windows-with-Visual-Studio">High-Level Embedding on Windows with Visual Studio</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>注意</strong>: このセクションでは、Unix系オペレーティングシステムでのCにおけるJuliaコードの埋め込みについて説明します。Windowsでこれを行うには、次のセクション<a href="#High-Level-Embedding-on-Windows-with-Visual-Studio">Visual Studioを使用したWindowsでの高レベルの埋め込み</a>を参照してください。</span></p><p data-translated="true"><span class="original-text">We start with a simple C program that initializes Julia and calls some Julia code:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaを初期化し、いくつかのJuliaコードを呼び出すシンプルなCプログラムから始めます。</span></p><pre><code class="language-c hljs">#include &lt;julia.h&gt;
JULIA_DEFINE_FAST_TLS // only define this once, in an executable (not in a shared library) if you want fast code.

int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string("print(sqrt(2.0))");

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}</code></pre><p data-translated="true"><span class="original-text">In order to build this program you must add the path to the Julia header to the include path and link against <code>libjulia</code>. For instance, when Julia is installed to <code>$JULIA_DIR</code>, one can compile the above test program <code>test.c</code> with <code>gcc</code> using:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このプログラムをビルドするには、Juliaヘッダーへのパスをインクルードパスに追加し、<code>libjulia</code>にリンクする必要があります。たとえば、Juliaが<code>$JULIA_DIR</code>にインストールされている場合、上記のテストプログラム<code>test.c</code>を<code>gcc</code>を使用してコンパイルできます:</span></p><pre><code class="nohighlight hljs">gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib -Wl,-rpath,$JULIA_DIR/lib test.c -ljulia</code></pre><p data-translated="true"><span class="original-text">Alternatively, look at the <code>embedding.c</code> program in the Julia source tree in the <code>test/embedding/</code> folder. The file <code>cli/loader_exe.c</code> program is another simple example of how to set <code>jl_options</code> options while linking against <code>libjulia</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">または、Juliaソースツリーの<code>test/embedding/</code>フォルダーにある<code>embedding.c</code>プログラムを確認してください。ファイル<code>cli/loader_exe.c</code>プログラムは、<code>libjulia</code>にリンクしながら<code>jl_options</code>オプションを設定する方法の別のシンプルな例です。</span></p><p data-translated="true"><span class="original-text">The first thing that must be done before calling any other Julia C function is to initialize Julia. This is done by calling <code>jl_init</code>, which tries to automatically determine Julia's install location. If you need to specify a custom location, or specify which system image to load, use <code>jl_init_with_image_file</code> or <code>jl_init_with_image_handle</code> instead.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">他のJulia C関数を呼び出す前に最初に行うべきことは、Juliaを初期化することです。これは、Juliaのインストール場所を自動的に特定しようとする<code>jl_init</code>を呼び出すことで行います。カスタムの場所を指定する必要がある場合や、読み込むシステムイメージを指定する必要がある場合は、代わりに<code>jl_init_with_image_file</code>または<code>jl_init_with_image_handle</code>を使用してください。</span></p><p data-translated="true"><span class="original-text">The second statement in the test program evaluates a Julia statement using a call to <code>jl_eval_string</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">テストプログラムの2番目のステートメントは、<code>jl_eval_string</code>を呼び出してJuliaステートメントを評価します。</span></p><p data-translated="true"><span class="original-text">Before the program terminates, it is strongly recommended that <code>jl_atexit_hook</code> is called. The above example program calls this just before returning from <code>main</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プログラムが終了する前に、<code>jl_atexit_hook</code>を呼び出すことを強くお勧めします。上記の例プログラムは、<code>main</code>から戻る直前にこれを呼び出します。</span></p><div class="admonition is-info" id="Note-ee4cd1d918bcf5c4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ee4cd1d918bcf5c4" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Currently, dynamically linking with the <code>libjulia</code> shared library requires passing the <code>RTLD_GLOBAL</code> option. In Python, this looks like:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">現在、<code>libjulia</code>共有ライブラリと動的にリンクするには、<code>RTLD_GLOBAL</code>オプションを渡す必要があります。Pythonでは、これは次のようになります:</span></p><pre><code class="nohighlight hljs">&gt;&gt;&gt; julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)
&gt;&gt;&gt; julia.jl_init.argtypes = []
&gt;&gt;&gt; julia.jl_init()
250593296</code></pre></div></div><div class="admonition is-info" id="Note-d101edd765525bd0"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d101edd765525bd0" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">If the julia program needs to access symbols from the main executable, it may be necessary to add the <code>-Wl,--export-dynamic</code> linker flag at compile time on Linux in addition to the ones generated by <code>julia-config.jl</code> described below. This is not necessary when compiling a shared library.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もしjuliaプログラムがメイン実行ファイルからシンボルにアクセスする必要がある場合、以下に説明する<code>julia-config.jl</code>によって生成されるものに加えて、Linuxでコンパイル時に<code>-Wl,--export-dynamic</code>リンカーフラグを追加する必要があるかもしれません。共有ライブラリをコンパイルする際にはこれは必要ありません。</span></p></div></div><h3 id="Using-julia-config-to-automatically-determine-build-parameters" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Using-julia-config-to-automatically-determine-build-parameters">Using julia-config to automatically determine build parameters</a><a id="Using-julia-config-to-automatically-determine-build-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Using-julia-config-to-automatically-determine-build-parameters" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Using-julia-config-to-automatically-determine-build-parameters">julia-configを使用してビルドパラメータを自動的に決定する</a><a id="Using-julia-config-to-automatically-determine-build-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Using-julia-config-to-automatically-determine-build-parameters" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The script <code>julia-config.jl</code> was created to aid in determining what build parameters are required by a program that uses embedded Julia. This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution. This script is located in the Julia shared data directory.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>julia-config.jl</code>スクリプトは、埋め込みJuliaを使用するプログラムに必要なビルドパラメータを決定するのを助けるために作成されました。このスクリプトは、呼び出された特定のJuliaディストリビューションのビルドパラメータとシステム構成を使用して、そのディストリビューションと相互作用するために必要なコンパイラフラグをエクスポートします。このスクリプトは、Juliaの共有データディレクトリにあります。</span></p><h4 id="Example" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Example">例</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></span></h4><pre><code class="language-c hljs">#include &lt;julia.h&gt;

int main(int argc, char *argv[])
{
    jl_init();
    (void)jl_eval_string("println(sqrt(2.0))");
    jl_atexit_hook(0);
    return 0;
}</code></pre><h4 id="On-the-command-line" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#On-the-command-line">On the command line</a><a id="On-the-command-line-1"></a><a class="docs-heading-anchor-permalink" href="#On-the-command-line" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#On-the-command-line">コマンドラインで</a><a id="On-the-command-line-1"></a><a class="docs-heading-anchor-permalink" href="#On-the-command-line" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">A simple use of this script is from the command line. Assuming that <code>julia-config.jl</code> is located in <code>/usr/local/julia/share/julia</code>, it can be invoked on the command line directly and takes any combination of three flags:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このスクリプトの簡単な使用法はコマンドラインからです。<code>julia-config.jl</code>が<code>/usr/local/julia/share/julia</code>にあると仮定すると、コマンドラインから直接呼び出すことができ、3つのフラグの任意の組み合わせを取ります。</span></p><pre><code class="nohighlight hljs">/usr/local/julia/share/julia/julia-config.jl
Usage: julia-config [--cflags|--ldflags|--ldlibs]</code></pre><p data-translated="true"><span class="original-text">If the above example source is saved in the file <code>embed_example.c</code>, then the following command will compile it into an executable program on Linux and Windows (MSYS2 environment). On macOS, substitute <code>clang</code> for <code>gcc</code>.:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記の例のソースが<code>embed_example.c</code>というファイルに保存されている場合、次のコマンドはLinuxおよびWindows（MSYS2環境）で実行可能なプログラムにコンパイルします。macOSでは、<code>gcc</code>の代わりに<code>clang</code>を使用してください。</span></p><pre><code class="nohighlight hljs">/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c</code></pre><h4 id="Use-in-Makefiles" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Use-in-Makefiles">Use in Makefiles</a><a id="Use-in-Makefiles-1"></a><a class="docs-heading-anchor-permalink" href="#Use-in-Makefiles" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Use-in-Makefiles">Makefileでの使用</a><a id="Use-in-Makefiles-1"></a><a class="docs-heading-anchor-permalink" href="#Use-in-Makefiles" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">In general, embedding projects will be more complicated than the above example, and so the following allows general makefile support as well – assuming GNU make because of the use of the <strong>shell</strong> macro expansions. Furthermore, although <code>julia-config.jl</code> is usually in the <code>/usr/local</code> directory, if it isn't, then Julia itself can be used to find <code>julia-config.jl</code>, and the makefile can take advantage of this. The above example is extended to use a makefile:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般的に、埋め込みプロジェクトは上記の例よりも複雑になるため、以下は一般的なmakefileサポートも提供します - <strong>shell</strong>マクロ展開を使用しているためGNU makeを前提としています。さらに、<code>julia-config.jl</code>は通常<code>/usr/local</code>ディレクトリにありますが、そうでない場合はJulia自体を使用して<code>julia-config.jl</code>を見つけることができ、makefileはこれを活用できます。上記の例はmakefileを使用するように拡張されます。</span></p><pre><code class="nohighlight hljs">JL_SHARE = $(shell julia -e 'print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, "julia"))')
CFLAGS   += $(shell $(JL_SHARE)/julia-config.jl --cflags)
CXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
LDFLAGS  += $(shell $(JL_SHARE)/julia-config.jl --ldflags)
LDLIBS   += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)

all: embed_example</code></pre><p data-translated="true"><span class="original-text">Now the build command is simply <code>make</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これでビルドコマンドは単に<code>make</code>です。</span></p><h2 id="High-Level-Embedding-on-Windows-with-Visual-Studio" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#High-Level-Embedding-on-Windows-with-Visual-Studio">High-Level Embedding on Windows with Visual Studio</a><a id="High-Level-Embedding-on-Windows-with-Visual-Studio-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-Embedding-on-Windows-with-Visual-Studio" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#High-Level-Embedding-on-Windows-with-Visual-Studio">Visual Studioを使用したWindowsでの高レベル埋め込み</a><a id="High-Level-Embedding-on-Windows-with-Visual-Studio-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-Embedding-on-Windows-with-Visual-Studio" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">If the <code>JULIA_DIR</code> environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The <code>bin</code> folder under JULIA_DIR should be on the system PATH.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もし<code>JULIA_DIR</code>環境変数が設定されていない場合は、Visual Studioを開始する前にシステムパネルを使用して追加してください。JULIA_DIRの下の<code>bin</code>フォルダーはシステムPATHに含まれている必要があります。</span></p><p data-translated="true"><span class="original-text">We start by opening Visual Studio and creating a new Console Application project. Open the 'stdafx.h' header file, and add the following lines at the end:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">まず、Visual Studioを開き、新しいコンソールアプリケーションプロジェクトを作成します。'stdafx.h'ヘッダーファイルを開き、最後に次の行を追加します：</span></p><pre><code class="language-c hljs">#include &lt;julia.h&gt;</code></pre><p data-translated="true"><span class="original-text">Then, replace the main() function in the project with this code:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次に、プロジェクト内のmain()関数をこのコードに置き換えます：</span></p><pre><code class="language-c hljs">int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string("print(sqrt(2.0))");

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}</code></pre><p data-translated="true"><span class="original-text">The next step is to set up the project to find the Julia include files and the libraries. It's important to know whether the Julia installation is 32- or 64-bit. Remove any platform configuration that doesn't correspond to the Julia installation before proceeding.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のステップは、プロジェクトがJuliaのインクルードファイルとライブラリを見つけられるように設定することです。Juliaのインストールが32ビットか64ビットかを知ることが重要です。進む前に、Juliaのインストールに対応しないプラットフォーム設定は削除してください。</span></p><p data-translated="true"><span class="original-text">Using the project Properties dialog, go to <code>C/C++</code> | <code>General</code> and add <code>$(JULIA_DIR)\include\julia\</code> to the Additional Include Directories property. Then, go to the <code>Linker</code> | <code>General</code> section and add <code>$(JULIA_DIR)\lib</code> to the Additional Library Directories property. Finally, under <code>Linker</code> | <code>Input</code>, add <code>libjulia.dll.a;libopenlibm.dll.a;</code> to the list of libraries.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロジェクトのプロパティダイアログを使用して、<code>C/C++</code> | <code>General</code>に移動し、<code>$(JULIA_DIR)\include\julia\</code>を追加のインクルードディレクトリプロパティに追加します。次に、<code>Linker</code> | <code>General</code>セクションに移動し、<code>$(JULIA_DIR)\lib</code>を追加のライブラリディレクトリプロパティに追加します。最後に、<code>Linker</code> | <code>Input</code>の下で、<code>libjulia.dll.a;libopenlibm.dll.a;</code>をライブラリのリストに追加します。</span></p><p data-translated="true"><span class="original-text">At this point, the project should build and run.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この時点で、プロジェクトはビルドされて実行されるはずです。</span></p><h2 id="Converting-Types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Converting-Types">Converting Types</a><a id="Converting-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-Types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Converting-Types">型の変換</a><a id="Converting-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-Types" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Real applications will not only need to execute expressions, but also return their values to the host program. <code>jl_eval_string</code> returns a <code>jl_value_t*</code>, which is a pointer to a heap-allocated Julia object. Storing simple data types like <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> in this way is called <code>boxing</code>, and extracting the stored primitive data is called <code>unboxing</code>. Our improved sample program that calculates the square root of 2 in Julia and reads back the result in C has a body that now contains this code:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実際のアプリケーションは、式を実行するだけでなく、その値をホストプログラムに返す必要があります。<code>jl_eval_string</code>は、ヒープに割り当てられたJuliaオブジェクトへのポインタである<code>jl_value_t*</code>を返します。このようにして<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>のような単純なデータ型を保存することを<code>boxing</code>と呼び、保存されたプリミティブデータを抽出することを<code>unboxing</code>と呼びます。2の平方根をJuliaで計算し、Cで結果を読み取る改善されたサンプルプログラムの本体には、現在このコードが含まれています：</span></p><pre><code class="language-c hljs">jl_value_t *ret = jl_eval_string("sqrt(2.0)");

if (jl_typeis(ret, jl_float64_type)) {
    double ret_unboxed = jl_unbox_float64(ret);
    printf("sqrt(2.0) in C: %e \n", ret_unboxed);
}
else {
    printf("ERROR: unexpected return type from sqrt(::Float64)\n");
}</code></pre><p data-translated="true"><span class="original-text">In order to check whether <code>ret</code> is of a specific Julia type, we can use the <code>jl_isa</code>, <code>jl_typeis</code>, or <code>jl_is_...</code> functions. By typing <code>typeof(sqrt(2.0))</code> into the Julia shell we can see that the return type is <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> (<code>double</code> in C). To convert the boxed Julia value into a C double the <code>jl_unbox_float64</code> function is used in the above code snippet.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ret</code>が特定のJulia型であるかどうかを確認するために、<code>jl_isa</code>、<code>jl_typeis</code>、または<code>jl_is_...</code>関数を使用できます。Juliaシェルに<code>typeof(sqrt(2.0))</code>と入力すると、戻り値の型が<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>（Cでは<code>double</code>）であることがわかります。ボックス化されたJulia値をCのdoubleに変換するために、上記のコードスニペットでは<code>jl_unbox_float64</code>関数が使用されています。</span></p><p data-translated="true"><span class="original-text">Corresponding <code>jl_box_...</code> functions are used to convert the other way:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">対応する <code>jl_box_...</code> 関数は、逆方向に変換するために使用されます。</span></p><pre><code class="language-c hljs">jl_value_t *a = jl_box_float64(3.0);
jl_value_t *b = jl_box_float32(3.0f);
jl_value_t *c = jl_box_int32(3);</code></pre><p data-translated="true"><span class="original-text">As we will see next, boxing is required to call Julia functions with specific arguments.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次に見るように、特定の引数を持つJulia関数を呼び出すにはボクシングが必要です。</span></p><h2 id="Calling-Julia-Functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Calling-Julia-Functions">Calling Julia Functions</a><a id="Calling-Julia-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-Julia-Functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Calling-Julia-Functions">Julia関数の呼び出し</a><a id="Calling-Julia-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-Julia-Functions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">While <code>jl_eval_string</code> allows C to obtain the result of a Julia expression, it does not allow passing arguments computed in C to Julia. For this you will need to invoke Julia functions directly, using <code>jl_call</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_eval_string</code> はCがJulia式の結果を取得することを可能にしますが、Cで計算された引数をJuliaに渡すことはできません。これには、<code>jl_call</code>を使用してJulia関数を直接呼び出す必要があります。</span></p><pre><code class="language-c hljs">jl_function_t *func = jl_get_function(jl_base_module, "sqrt");
jl_value_t *argument = jl_box_float64(2.0);
jl_value_t *ret = jl_call1(func, argument);</code></pre><p data-translated="true"><span class="original-text">In the first step, a handle to the Julia function <code>sqrt</code> is retrieved by calling <code>jl_get_function</code>. The first argument passed to <code>jl_get_function</code> is a pointer to the <code>Base</code> module in which <code>sqrt</code> is defined. Then, the double value is boxed using <code>jl_box_float64</code>. Finally, in the last step, the function is called using <code>jl_call1</code>. <code>jl_call0</code>, <code>jl_call2</code>, and <code>jl_call3</code> functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use <code>jl_call</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初のステップでは、<code>jl_get_function</code>を呼び出すことでJulia関数<code>sqrt</code>へのハンドルを取得します。<code>jl_get_function</code>に渡される最初の引数は、<code>sqrt</code>が定義されている<code>Base</code>モジュールへのポインタです。次に、ダブル値は<code>jl_box_float64</code>を使用してボクシングされます。最後のステップでは、<code>jl_call1</code>を使用して関数が呼び出されます。引数の数に応じて便利に処理するために、<code>jl_call0</code>、<code>jl_call2</code>、および<code>jl_call3</code>関数も存在します。より多くの引数を渡すには、<code>jl_call</code>を使用します。</span></p><pre><code class="nohighlight hljs">jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)</code></pre><p data-translated="true"><span class="original-text">Its second argument <code>args</code> is an array of <code>jl_value_t*</code> arguments and <code>nargs</code> is the number of arguments.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">その第二引数<code>args</code>は<code>jl_value_t*</code>引数の配列であり、<code>nargs</code>は引数の数です。</span></p><p data-translated="true"><span class="original-text">There is also an alternative, possibly simpler, way of calling Julia functions and that is via <a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a>. Using <code>@cfunction</code> allows you to do the type conversions on the Julia side, which is typically easier than doing it on the C side. The <code>sqrt</code> example above would with <code>@cfunction</code> be written as:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia関数を呼び出すための別の、より簡単な方法もあり、それは<a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a>を介してです。<code>@cfunction</code>を使用すると、Julia側で型変換を行うことができ、通常はC側で行うよりも簡単です。上記の<code>sqrt</code>の例は、<code>@cfunction</code>を使用して次のように書かれます：</span></p><pre><code class="language-c hljs">double (*sqrt_jl)(double) = jl_unbox_voidpointer(jl_eval_string("@cfunction(sqrt, Float64, (Float64,))"));
double ret = sqrt_jl(2.0);</code></pre><p data-translated="true"><span class="original-text">where we first define a C callable function in Julia, extract the function pointer from it, and finally call it. In addition to simplifying type conversions by doing them in the higher-level language, calling Julia functions via <code>@cfunction</code> pointers eliminates the dynamic-dispatch overhead required by <code>jl_call</code> (for which all of the arguments are "boxed"), and should have performance equivalent to native C function pointers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、最初にJuliaでC呼び出し可能な関数を定義し、そこから関数ポインタを抽出し、最後にそれを呼び出します。高水準言語で型変換を行うことで簡素化するだけでなく、<code>@cfunction</code>ポインタを介してJulia関数を呼び出すことで、すべての引数が「ボクシング」される<code>jl_call</code>によって必要とされる動的ディスパッチのオーバーヘッドが排除され、ネイティブC関数ポインタと同等のパフォーマンスを持つはずです。</span></p><h2 id="Memory-Management" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Memory-Management">Memory Management</a><a id="Memory-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Management" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Memory-Management">メモリ管理</a><a id="Memory-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Management" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">As we have seen, Julia objects are represented in C as pointers of type <code>jl_value_t*</code>. This raises the question of who is responsible for freeing these objects.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">見たように、JuliaオブジェクトはCでは<code>jl_value_t*</code>型のポインタとして表現されます。これにより、これらのオブジェクトを解放する責任が誰にあるのかという疑問が生じます。</span></p><p data-translated="true"><span class="original-text">Typically, Julia objects are freed by the garbage collector (GC), but the GC does not automatically know that we are holding a reference to a Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">通常、Juliaオブジェクトはガベージコレクタ（GC）によって解放されますが、GCはCからJulia値への参照を保持していることを自動的に認識しません。これは、GCがオブジェクトを解放してしまう可能性があり、ポインタが無効になることを意味します。</span></p><p data-translated="true"><span class="original-text">The GC will only run when new Julia objects are being allocated. Calls like <code>jl_box_float64</code> perform allocation, but allocation might also happen at any point in running Julia code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">GCは新しいJuliaオブジェクトが割り当てられるときのみ実行されます。<code>jl_box_float64</code>のような呼び出しは割り当てを行いますが、Juliaコードの実行中の任意の時点で割り当てが発生する可能性もあります。</span></p><p data-translated="true"><span class="original-text">When writing code that embeds Julia, it is generally safe to use <code>jl_value_t*</code> values in between <code>jl_...</code> calls (as GC will only get triggered by those calls). But in order to make sure that values can survive <code>jl_...</code> calls, we have to tell Julia that we still hold a reference to Julia <a href="https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf">root</a> values, a process called "GC rooting". Rooting a value will ensure that the garbage collector does not accidentally identify this value as unused and free the memory backing that value. This can be done using the <code>JL_GC_PUSH</code> macros:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaを埋め込むコードを書く際には、一般的に<code>jl_value_t*</code>値を<code>jl_...</code>呼び出しの間で使用することは安全です（GCはこれらの呼び出しによってのみトリガーされるため）。しかし、値が<code>jl_...</code>呼び出しを生き延びることを確実にするためには、Juliaに対してまだJuliaの<a href="https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf">root</a>値への参照を保持していることを伝える必要があります。このプロセスは「GCルーティング」と呼ばれます。値をルート化することで、ガベージコレクタがこの値を未使用として誤って識別し、その値を支えるメモリを解放しないようにします。これは<code>JL_GC_PUSH</code>マクロを使用して行うことができます。</span></p><pre><code class="language-c hljs">jl_value_t *ret = jl_eval_string("sqrt(2.0)");
JL_GC_PUSH1(&amp;ret);
// Do something with ret
JL_GC_POP();</code></pre><p data-translated="true"><span class="original-text">The <code>JL_GC_POP</code> call releases the references established by the previous <code>JL_GC_PUSH</code>. Note that <code>JL_GC_PUSH</code> stores references on the C stack, so it must be exactly paired with a <code>JL_GC_POP</code> before the scope is exited. That is, before the function returns, or control flow otherwise leaves the block in which the <code>JL_GC_PUSH</code> was invoked.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>JL_GC_POP</code>呼び出しは、前の<code>JL_GC_PUSH</code>によって確立された参照を解放します。<code>JL_GC_PUSH</code>はCスタックに参照を保存するため、スコープを抜ける前に必ず<code>JL_GC_POP</code>と正確にペアにする必要があります。つまり、関数が戻る前、または制御フローが<code>JL_GC_PUSH</code>が呼び出されたブロックを離れる前に行う必要があります。</span></p><p data-translated="true"><span class="original-text">Several Julia values can be pushed at once using the <code>JL_GC_PUSH2</code> to <code>JL_GC_PUSH6</code> macros:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複数のJulia値を同時にプッシュするには、<code>JL_GC_PUSH2</code>から<code>JL_GC_PUSH6</code>マクロを使用できます。</span></p><pre><code class="nohighlight hljs">JL_GC_PUSH2(&amp;ret1, &amp;ret2);
// ...
JL_GC_PUSH6(&amp;ret1, &amp;ret2, &amp;ret3, &amp;ret4, &amp;ret5, &amp;ret6);</code></pre><p data-translated="true"><span class="original-text">To push an array of Julia values one can use the <code>JL_GC_PUSHARGS</code> macro, which can be used as follows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia値の配列をプッシュするには、<code>JL_GC_PUSHARGS</code>マクロを使用できます。これは次のように使用できます：</span></p><pre><code class="language-c hljs">jl_value_t **args;
JL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects
args[0] = some_value;
args[1] = some_other_value;
// Do something with args (e.g. call jl_... functions)
JL_GC_POP();</code></pre><p data-translated="true"><span class="original-text">Each scope must have only one call to <code>JL_GC_PUSH*</code>, and should be paired with only a single <code>JL_GC_POP</code> call. If all necessary variables you want to root cannot be pushed by a one single call to <code>JL_GC_PUSH*</code>, or if there are more than 6 variables to be pushed and using an array of arguments is not an option, then one can use inner blocks:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各スコープには<code>JL_GC_PUSH*</code>への呼び出しが1回だけ必要であり、単一の<code>JL_GC_POP</code>呼び出しとペアにする必要があります。ルート化したいすべての変数を1回の<code>JL_GC_PUSH*</code>呼び出しでプッシュできない場合、またはプッシュする変数が6つを超える場合、引数の配列を使用できない場合は、内部ブロックを使用できます。</span></p><pre><code class="language-c hljs">jl_value_t *ret1 = jl_eval_string("sqrt(2.0)");
JL_GC_PUSH1(&amp;ret1);
jl_value_t *ret2 = 0;
{
    jl_function_t *func = jl_get_function(jl_base_module, "exp");
    ret2 = jl_call1(func, ret1);
    JL_GC_PUSH1(&amp;ret2);
    // Do something with ret2.
    JL_GC_POP();    // This pops ret2.
}
JL_GC_POP();    // This pops ret1.</code></pre><p data-translated="true"><span class="original-text">Note that it is not necessary to have valid <code>jl_value_t*</code> values before calling <code>JL_GC_PUSH*</code>. It is fine to have a number of them initialized to <code>NULL</code>, pass those to <code>JL_GC_PUSH*</code> and then create the actual Julia values. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>JL_GC_PUSH*</code>を呼び出す前に有効な<code>jl_value_t*</code>値を持つ必要はないことに注意してください。いくつかの値を<code>NULL</code>に初期化しておき、それらを<code>JL_GC_PUSH*</code>に渡し、その後に実際のJulia値を作成することは問題ありません。例えば：</span></p><pre><code class="nohighlight hljs">jl_value_t *ret1 = NULL, *ret2 = NULL;
JL_GC_PUSH2(&amp;ret1, &amp;ret2);
ret1 = jl_eval_string("sqrt(2.0)");
ret2 = jl_eval_string("sqrt(3.0)");
// Use ret1 and ret2
JL_GC_POP();</code></pre><p data-translated="true"><span class="original-text">If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use <code>JL_GC_PUSH*</code>. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global <code>IdDict</code> that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数（またはブロックスコープ）間で変数へのポインタを保持する必要がある場合、<code>JL_GC_PUSH*</code>を使用することはできません。この場合、Juliaのグローバルスコープに変数への参照を作成して保持する必要があります。これを達成する簡単な方法は、GCによる解放を避けるために参照を保持するグローバル<code>IdDict</code>を使用することです。ただし、この方法は可変型に対してのみ正しく機能します。</span></p><pre><code class="language-c hljs">// This functions shall be executed only once, during the initialization.
jl_value_t* refs = jl_eval_string("refs = IdDict()");
jl_function_t* setindex = jl_get_function(jl_base_module, "setindex!");

...

// `var` is the variable we want to protect between function calls.
jl_value_t* var = 0;

...

// `var` is a `Vector{Float64}`, which is mutable.
var = jl_eval_string("[sqrt(2.0); sqrt(4.0); sqrt(6.0)]");

// To protect `var`, add its reference to `refs`.
jl_call3(setindex, refs, var, var);</code></pre><p data-translated="true"><span class="original-text">If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a <code>RefValue{Any}</code> before it is pushed to <code>IdDict</code>. In this approach, the container has to be created or filled in via C code using, for example, the function <code>jl_new_struct</code>. If the container is created by <code>jl_call*</code>, then you will need to reload the pointer to be used in C code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">変数が不変の場合、<code>IdDict</code>にプッシュする前に、同等の可変コンテナにラップする必要があります。好ましくは、<code>RefValue{Any}</code>にラップします。このアプローチでは、コンテナはCコードを使用して作成または埋め込む必要があります。例えば、<code>jl_new_struct</code>関数を使用します。コンテナが<code>jl_call*</code>によって作成される場合、Cコードで使用するためにポインタを再読み込みする必要があります。</span></p><pre><code class="language-c hljs">// This functions shall be executed only once, during the initialization.
jl_value_t* refs = jl_eval_string("refs = IdDict()");
jl_function_t* setindex = jl_get_function(jl_base_module, "setindex!");
jl_datatype_t* reft = (jl_datatype_t*)jl_eval_string("Base.RefValue{Any}");

...

// `var` is the variable we want to protect between function calls.
jl_value_t* var = 0;

...

// `var` is a `Float64`, which is immutable.
var = jl_eval_string("sqrt(2.0)");

// Protect `var` until we add its reference to `refs`.
JL_GC_PUSH1(&amp;var);

// Wrap `var` in `RefValue{Any}` and push to `refs` to protect it.
jl_value_t* rvar = jl_new_struct(reft, var);
JL_GC_POP();

jl_call3(setindex, refs, rvar, rvar);</code></pre><p data-translated="true"><span class="original-text">The GC can be allowed to deallocate a variable by removing the reference to it from <code>refs</code> using the function <code>delete!</code>, provided that no other reference to the variable is kept anywhere:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">GCは、<code>refs</code>から変数への参照を削除することで、その変数を解放することが許可されます。ただし、どこにもその変数への他の参照が保持されていない場合に限ります。</span></p><pre><code class="language-c hljs">jl_function_t* delete = jl_get_function(jl_base_module, "delete!");
jl_call2(delete, refs, rvar);</code></pre><p data-translated="true"><span class="original-text">As an alternative for very simple cases, it is possible to just create a global container of type <code>Vector{Any}</code> and fetch the elements from that when necessary, or even to create one global variable per pointer using</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">非常に単純なケースの代替として、<code>Vector{Any}</code>型のグローバルコンテナを作成し、必要に応じてそこから要素を取得することが可能です。または、ポインタごとに1つのグローバル変数を作成することもできます。</span></p><pre><code class="language-c hljs">jl_module_t *mod = jl_main_module;
jl_sym_t *var = jl_symbol("var");
jl_binding_t *bp = jl_get_binding_wr(mod, var, 1);
jl_checked_assignment(bp, mod, var, val);</code></pre><h3 id="Updating-fields-of-GC-managed-objects" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Updating-fields-of-GC-managed-objects">Updating fields of GC-managed objects</a><a id="Updating-fields-of-GC-managed-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-fields-of-GC-managed-objects" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Updating-fields-of-GC-managed-objects">GC管理オブジェクトのフィールドの更新</a><a id="Updating-fields-of-GC-managed-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-fields-of-GC-managed-objects" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The garbage collector also operates under the assumption that it is aware of every older-generation object pointing to a younger-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the <code>jl_gc_wb</code> (write barrier) function like so:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ガーベジコレクタは、若い世代のオブジェクトを指すすべての古い世代のオブジェクトを認識しているという前提の下で動作します。この前提を破るポインタが更新されるたびに、<code>jl_gc_wb</code>（書き込みバリア）関数を使用してコレクタに通知する必要があります。</span></p><pre><code class="language-c hljs">jl_value_t *parent = some_old_value, *child = some_young_value;
((some_specific_type*)parent)-&gt;field = child;
jl_gc_wb(parent, child);</code></pre><p data-translated="true"><span class="original-text">It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the <code>parent</code> object has just been allocated and no garbage collection has run since then. Note that most <code>jl_...</code> functions can sometimes invoke garbage collection.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実行時にどの値が古くなるかを予測することは一般的に不可能なので、書き込みバリアはすべての明示的なストアの後に挿入する必要があります。注目すべき例外は、<code>parent</code>オブジェクトがちょうど割り当てられた場合で、その後ガーベジコレクションが実行されていない場合です。ほとんどの<code>jl_...</code>関数は、時折ガーベジコレクションを呼び出すことがあることに注意してください。</span></p><p data-translated="true"><span class="original-text">The write barrier is also necessary for arrays of pointers when updating their data directly. Calling <code>jl_array_ptr_set</code> is usually much preferred. But direct updates can be done. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">書き込みバリアは、ポインタの配列のデータを直接更新する際にも必要です。通常、<code>jl_array_ptr_set</code>を呼び出す方が好まれます。しかし、直接更新も可能です。例えば：</span></p><pre><code class="language-c hljs">jl_array_t *some_array = ...; // e.g. a Vector{Any}
void **data = jl_array_data(some_array, void*);
jl_value_t *some_value = ...;
data[0] = some_value;
jl_gc_wb(jl_array_owner(some_array), some_value);</code></pre><h3 id="Controlling-the-Garbage-Collector" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Controlling-the-Garbage-Collector">Controlling the Garbage Collector</a><a id="Controlling-the-Garbage-Collector-1"></a><a class="docs-heading-anchor-permalink" href="#Controlling-the-Garbage-Collector" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Controlling-the-Garbage-Collector">ガーベジコレクタの制御</a><a id="Controlling-the-Garbage-Collector-1"></a><a class="docs-heading-anchor-permalink" href="#Controlling-the-Garbage-Collector" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">There are some functions to control the GC. In normal use cases, these should not be necessary.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">GCを制御するためのいくつかの関数があります。通常の使用ケースでは、これらは必要ないはずです。</span></p><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Function</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">説明</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>jl_gc_collect()</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_gc_collect()</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Force a GC run</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">GCの実行を強制する</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>jl_gc_enable(0)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_gc_enable(0)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Disable the GC, return previous state as int</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">GCを無効にし、前の状態をintとして返します</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>jl_gc_enable(1)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_gc_enable(1)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Enable the GC,  return previous state as int</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">GCを有効にし、前の状態をintとして返します</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>jl_gc_is_enabled()</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_gc_is_enabled()</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Return current state as int</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">現在の状態をintとして返します</span></td></tr></tbody></table><h2 id="Working-with-Arrays" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Working-with-Arrays">Working with Arrays</a><a id="Working-with-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Arrays" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Working-with-Arrays">配列の操作</a><a id="Working-with-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Arrays" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Julia and C can share array data without copying. The next example will show how this works.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">JuliaとCは、データをコピーすることなく配列データを共有できます。次の例でこれがどのように機能するかを示します。</span></p><p data-translated="true"><span class="original-text">Julia arrays are represented in C by the datatype <code>jl_array_t*</code>. Basically, <code>jl_array_t</code> is a struct that contains:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの配列は、Cではデータ型<code>jl_array_t*</code>で表されます。基本的に、<code>jl_array_t</code>は以下を含む構造体です：</span></p><ul><li data-translated="true"><span class="original-text">Information about the datatype</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">データ型に関する情報</span></li><li data-translated="true"><span class="original-text">A pointer to the data block</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">データブロックへのポインタ</span></li><li data-translated="true"><span class="original-text">Information about the sizes of the array</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列のサイズに関する情報</span></li></ul><p data-translated="true"><span class="original-text">To keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 can be done like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単にするために、1D配列から始めます。長さ10のFloat64要素を含む配列を作成するには、次のようにします：</span></p><pre><code class="language-c hljs">jl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);
jl_array_t* x          = jl_alloc_array_1d(array_type, 10);</code></pre><p data-translated="true"><span class="original-text">Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、すでに配列を割り当てている場合は、そのデータの周りに薄いラッパーを生成できます：</span></p><pre><code class="language-c hljs">double *existingArray = (double*)malloc(sizeof(double)*10);
jl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);</code></pre><p data-translated="true"><span class="original-text">The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call <code>free</code> on the data pointer when the array is no longer referenced.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最後の引数は、Juliaがデータの所有権を持つべきかどうかを示すブール値です。この引数がゼロでない場合、GCは配列がもはや参照されていないときにデータポインタに対して<code>free</code>を呼び出します。</span></p><p data-translated="true"><span class="original-text">In order to access the data of <code>x</code>, we can use <code>jl_array_data</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>x</code>のデータにアクセスするために、<code>jl_array_data</code>を使用できます：</span></p><pre><code class="language-c hljs">double *xData = jl_array_data(x, double);</code></pre><p data-translated="true"><span class="original-text">Now we can fill the array:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これで配列を埋めることができます：</span></p><pre><code class="language-c hljs">for (size_t i = 0; i &lt; jl_array_nrows(x); i++)
    xData[i] = i;</code></pre><p data-translated="true"><span class="original-text">Now let us call a Julia function that performs an in-place operation on <code>x</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次に、<code>x</code>に対してインプレース操作を行うJulia関数を呼び出しましょう：</span></p><pre><code class="language-c hljs">jl_function_t *func = jl_get_function(jl_base_module, "reverse!");
jl_call1(func, (jl_value_t*)x);</code></pre><p data-translated="true"><span class="original-text">By printing the array, one can verify that the elements of <code>x</code> are now reversed.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列を印刷することで、<code>x</code>の要素が逆になっていることを確認できます。</span></p><h3 id="Accessing-Returned-Arrays" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Accessing-Returned-Arrays">Accessing Returned Arrays</a><a id="Accessing-Returned-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-Returned-Arrays" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Accessing-Returned-Arrays">返された配列へのアクセス</a><a id="Accessing-Returned-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-Returned-Arrays" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">If a Julia function returns an array, the return value of <code>jl_eval_string</code> and <code>jl_call</code> can be cast to a <code>jl_array_t*</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの関数が配列を返す場合、<code>jl_eval_string</code>および<code>jl_call</code>の戻り値は<code>jl_array_t*</code>にキャストできます。</span></p><pre><code class="language-c hljs">jl_function_t *func  = jl_get_function(jl_base_module, "reverse");
jl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);</code></pre><p data-translated="true"><span class="original-text">Now the content of <code>y</code> can be accessed as before using <code>jl_array_data</code>. As always, be sure to keep a reference to the array while it is in use.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">今、<code>y</code>の内容には以前と同様に<code>jl_array_data</code>を使用してアクセスできます。常に、配列が使用されている間はその参照を保持することを忘れないでください。</span></p><h3 id="Multidimensional-Arrays" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Multidimensional-Arrays">Multidimensional Arrays</a><a id="Multidimensional-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Multidimensional-Arrays" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Multidimensional-Arrays">多次元配列</a><a id="Multidimensional-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Multidimensional-Arrays" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの多次元配列は、メモリに列優先順序で格納されます。以下は2D配列を作成し、そのプロパティにアクセスするコードです：</span></p><pre><code class="language-c hljs">// Create 2D array of float64 type
jl_value_t *array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 2);
int dims[] = {10,5};
jl_array_t *x  = jl_alloc_array_nd(array_type, dims, 2);

// Get array pointer
double *p = jl_array_data(x, double);
// Get number of dimensions
int ndims = jl_array_ndims(x);
// Get the size of the i-th dim
size_t size0 = jl_array_dim(x,0);
size_t size1 = jl_array_dim(x,1);

// Fill array with data
for(size_t i=0; i&lt;size1; i++)
    for(size_t j=0; j&lt;size0; j++)
        p[j + size0*i] = i + j;</code></pre><p data-translated="true"><span class="original-text">Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling <code>jl_array_dim</code>) in order to read as idiomatic C code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの配列は1ベースのインデックスを使用しますが、C APIは0ベースのインデックスを使用します（例えば、<code>jl_array_dim</code>を呼び出す際）ので、慣用的なCコードとして読み取ることができます。</span></p><h2 id="Exceptions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Exceptions">Exceptions</a><a id="Exceptions-1"></a><a class="docs-heading-anchor-permalink" href="#Exceptions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Exceptions">例外</a><a id="Exceptions-1"></a><a class="docs-heading-anchor-permalink" href="#Exceptions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Julia code can throw exceptions. For example, consider:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaのコードは例外をスローすることがあります。例えば、次のように考えてみてください：</span></p><pre><code class="language-c hljs">jl_eval_string("this_function_does_not_exist()");</code></pre><p data-translated="true"><span class="original-text">This call will appear to do nothing. However, it is possible to check whether an exception was thrown:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この呼び出しは何もしていないように見えます。しかし、例外がスローされたかどうかを確認することは可能です：</span></p><pre><code class="language-c hljs">if (jl_exception_occurred())
    printf("%s \n", jl_typeof_str(jl_exception_occurred()));</code></pre><p data-translated="true"><span class="original-text">If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into <code>libjulia</code> with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例外をサポートする言語（例：Python、C#、C++）からJulia C APIを使用している場合、各<code>libjulia</code>への呼び出しを、例外がスローされたかどうかをチェックする関数でラップし、ホスト言語で例外を再スローすることが理にかなっています。</span></p><h3 id="Throwing-Julia-Exceptions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Throwing-Julia-Exceptions">Throwing Julia Exceptions</a><a id="Throwing-Julia-Exceptions-1"></a><a class="docs-heading-anchor-permalink" href="#Throwing-Julia-Exceptions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Throwing-Julia-Exceptions">Julia例外のスロー</a><a id="Throwing-Julia-Exceptions-1"></a><a class="docs-heading-anchor-permalink" href="#Throwing-Julia-Exceptions" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions to indicate errors. A typical type check looks like:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの呼び出し可能な関数を書く際には、引数を検証し、エラーを示すために例外を投げる必要がある場合があります。典型的な型チェックは次のようになります：</span></p><pre><code class="language-c hljs">if (!jl_typeis(val, jl_float64_type)) {
    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);
}</code></pre><p data-translated="true"><span class="original-text">General exceptions can be raised using the functions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般的な例外は次の関数を使用して発生させることができます：</span></p><pre><code class="language-c hljs">void jl_error(const char *str);
void jl_errorf(const char *fmt, ...);</code></pre><p data-translated="true"><span class="original-text"><code>jl_error</code> takes a C string, and <code>jl_errorf</code> is called like <code>printf</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_error</code>はC文字列を受け取り、<code>jl_errorf</code>は<code>printf</code>のように呼び出されます：</span></p><pre><code class="language-c hljs">jl_errorf("argument x = %d is too large", x);</code></pre><p data-translated="true"><span class="original-text">where in this example <code>x</code> is assumed to be an integer.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例では、<code>x</code>は整数であると仮定されています。</span></p><h3 id="Thread-safety" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Thread-safety">Thread-safety</a><a id="Thread-safety-1"></a><a class="docs-heading-anchor-permalink" href="#Thread-safety" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Thread-safety">スレッドセーフ</a><a id="Thread-safety-1"></a><a class="docs-heading-anchor-permalink" href="#Thread-safety" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">In general, the Julia C API is not fully thread-safe. When embedding Julia in a multi-threaded application care needs to be taken not to violate the following restrictions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般に、JuliaのC APIは完全にスレッドセーフではありません。マルチスレッドアプリケーションにJuliaを埋め込む際には、以下の制限を違反しないように注意する必要があります：</span></p><ul><li data-translated="true"><span class="original-text"><code>jl_init()</code> may only be called once in the application life-time. The same applies to <code>jl_atexit_hook()</code>, and it may only be called after <code>jl_init()</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_init()</code>はアプリケーションのライフタイム中に一度だけ呼び出すことができます。同様に、<code>jl_atexit_hook()</code>も<code>jl_init()</code>の後にのみ呼び出すことができます。</span></li><li data-translated="true"><span class="original-text"><code>jl_...()</code> API functions may only be called from the thread in which <code>jl_init()</code> was called, <em>or from threads started by the Julia runtime</em>. Calling Julia API functions from user-started threads is not supported, and may lead to undefined behaviour and crashes.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_...()</code> API関数は、<code>jl_init()</code>が呼び出されたスレッドからのみ呼び出すことができ、<em>またはJuliaランタイムによって開始されたスレッドから呼び出すことができます</em>。ユーザーが開始したスレッドからJulia API関数を呼び出すことはサポートされておらず、未定義の動作やクラッシュを引き起こす可能性があります。</span></li></ul><p data-translated="true"><span class="original-text">The second condition above implies that you can not safely call <code>jl_...()</code> functions from threads that were not started by Julia (the thread calling <code>jl_init()</code> being the exception). For example, the following is not supported and will most likely segfault:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記の第二の条件は、<code>jl_...()</code>関数をJuliaによって開始されていないスレッドから安全に呼び出すことができないことを意味します（<code>jl_init()</code>を呼び出すスレッドは例外です）。例えば、以下のような呼び出しはサポートされておらず、最も可能性が高いのはセグメンテーションフォルトを引き起こします：</span></p><pre><code class="language-c hljs">void *func(void*)
{
    // Wrong, jl_eval_string() called from thread that was not started by Julia
    jl_eval_string("println(Threads.threadid())");
    return NULL;
}

int main()
{
    pthread_t t;

    jl_init();

    // Start a new thread
    pthread_create(&amp;t, NULL, func, NULL);
    pthread_join(t, NULL);

    jl_atexit_hook(0);
}</code></pre><p data-translated="true"><span class="original-text">Instead, performing all Julia calls from the same user-created thread will work:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">代わりに、すべてのJulia呼び出しを同じユーザー作成スレッドから行うことで動作します：</span></p><pre><code class="language-c hljs">void *func(void*)
{
    // Okay, all jl_...() calls from the same thread,
    // even though it is not the main application thread
    jl_init();
    jl_eval_string("println(Threads.threadid())");
    jl_atexit_hook(0);
    return NULL;
}

int main()
{
    pthread_t t;
    // Create a new thread, which runs func()
    pthread_create(&amp;t, NULL, func, NULL);
    pthread_join(t, NULL);
}</code></pre><p data-translated="true"><span class="original-text">An example of calling the Julia C API from a thread started by Julia itself:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia自身によって開始されたスレッドからJulia C APIを呼び出す例：</span></p><pre><code class="language-c hljs">#include &lt;julia/julia.h&gt;
JULIA_DEFINE_FAST_TLS

double c_func(int i)
{
    printf("[C %08x] i = %d\n", pthread_self(), i);

    // Call the Julia sqrt() function to compute the square root of i, and return it
    jl_function_t *sqrt = jl_get_function(jl_base_module, "sqrt");
    jl_value_t* arg = jl_box_int32(i);
    double ret = jl_unbox_float64(jl_call1(sqrt, arg));

    return ret;
}

int main()
{
    jl_init();

    // Define a Julia function func() that calls our c_func() defined in C above
    jl_eval_string("func(i) = ccall(:c_func, Float64, (Int32,), i)");

    // Call func() multiple times, using multiple threads to do so
    jl_eval_string("println(Threads.threadpoolsize())");
    jl_eval_string("use(i) = println(\"[J $(Threads.threadid())] i = $(i) -&gt; $(func(i))\")");
    jl_eval_string("Threads.@threads for i in 1:5 use(i) end");

    jl_atexit_hook(0);
}</code></pre><p data-translated="true"><span class="original-text">If we run this code with 2 Julia threads we get the following output (note: the output will vary per run and system):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このコードを2つのJuliaスレッドで実行すると、次の出力が得られます（注意：出力は実行やシステムによって異なります）：</span></p><pre><code class="language-sh hljs">$ JULIA_NUM_THREADS=2 ./thread_example
2
[C 3bfd9c00] i = 1
[C 23938640] i = 4
[J 1] i = 1 -&gt; 1.0
[C 3bfd9c00] i = 2
[J 1] i = 2 -&gt; 1.4142135623730951
[C 3bfd9c00] i = 3
[J 2] i = 4 -&gt; 2.0
[C 23938640] i = 5
[J 1] i = 3 -&gt; 1.7320508075688772
[J 2] i = 5 -&gt; 2.23606797749979</code></pre><p data-translated="true"><span class="original-text">As can be seen, Julia thread 1 corresponds to pthread ID 3bfd9c00, and Julia thread 2 corresponds to ID 23938640, showing that indeed multiple threads are used at the C level, and that we can safely call Julia C API routines from those threads.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ご覧の通り、Juliaスレッド1はpthread ID 3bfd9c00に対応し、Juliaスレッド2はID 23938640に対応しています。これは、Cレベルで実際に複数のスレッドが使用されていることを示しており、これらのスレッドからJulia C APIルーチンを安全に呼び出すことができることを示しています。</span></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../environment-variables/index.html">« Environment Variables</a><a class="docs-footer-nextpage" href="../code-loading/index.html">Code Loading »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>