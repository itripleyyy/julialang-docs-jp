<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Metaprogramming · The Julia Language</title><meta name="title" content="Metaprogramming · The Julia Language"><meta property="og:title" content="Metaprogramming · The Julia Language"><meta property="twitter:title" content="Metaprogramming · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/metaprogramming/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/metaprogramming/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bi1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li class="is-active"><a class="tocitem" href="">Metaprogramming</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Program-representation"><span>Program representation</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Program-representation"><span>プログラムの表現</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Expressions-and-evaluation"><span>Expressions and evaluation</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Expressions-and-evaluation"><span>式と評価</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-macros"><span>Macros</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-macros"><span>マクロ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Code-Generation"><span>Code Generation</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Code-Generation"><span>コード生成</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#meta-non-standard-string-literals"><span>Non-Standard String Literals</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#meta-non-standard-string-literals"><span>非標準文字列リテラル</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Generated-functions"><span>Generated functions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Generated-functions"><span>生成された関数</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">メタプログラミング</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">メタプログラミング</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/metaprogramming.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Metaprogramming" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Metaprogramming">Metaprogramming</a><a id="Metaprogramming-1"></a><a class="docs-heading-anchor-permalink" href="#Metaprogramming" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Metaprogramming">メタプログラミング</a><a id="Metaprogramming-1"></a><a class="docs-heading-anchor-permalink" href="#Metaprogramming" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style macros operating at the level of <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax trees</a>. In contrast, preprocessor "macro" systems, like that of C and C++, perform textual manipulation and substitution before any actual parsing or interpretation occurs. Because all data types and code in Julia are represented by Julia data structures, powerful <a href="https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29">reflection</a> capabilities are available to explore the internals of a program and its types just like any other data.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia言語におけるLispの最も強力な遺産は、そのメタプログラミングサポートです。Lispのように、Juliaは自分自身のコードを言語自体のデータ構造として表現します。コードは言語内から作成および操作できるオブジェクトによって表現されるため、プログラムが自分自身のコードを変換および生成することが可能です。これにより、追加のビルドステップなしで高度なコード生成が可能になり、<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">抽象構文木</a>のレベルで動作する真のLispスタイルのマクロも可能になります。それに対して、CやC++のようなプリプロセッサの「マクロ」システムは、実際の解析や解釈が行われる前にテキストの操作や置換を行います。Juliaではすべてのデータ型とコードがJuliaのデータ構造によって表現されるため、プログラムやその型の内部を探るための強力な<a href="https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29">リフレクション</a>機能が利用可能です。</span></p><div class="admonition is-warning" id="Warning-236086b2f091409e"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-236086b2f091409e" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Metaprogramming is a powerful tool, but it introduces complexity that can make code more difficult to understand. For example, it can be surprisingly hard to get scope rules correct. Metaprogramming should typically be used only when other approaches such as <a href="../functions/index.html#man-anonymous-functions">higher order functions</a> and <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closures</a> cannot be applied.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メタプログラミングは強力なツールですが、コードを理解しにくくする複雑さをもたらします。例えば、スコープルールを正しく取得するのは驚くほど難しい場合があります。メタプログラミングは、通常、<a href="../functions/index.html#man-anonymous-functions">高階関数</a>や<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">クロージャ</a>などの他のアプローチが適用できない場合にのみ使用されるべきです。</span></p><p data-translated="true"><span class="original-text"><code>eval</code> and defining new macros should be typically used as a last resort. It is almost never a good idea to use <code>Meta.parse</code> or convert an arbitrary string into Julia code. For manipulating Julia code, use the <code>Expr</code> data structure directly to avoid the complexity of how Julia syntax is parsed.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>eval</code>や新しいマクロの定義は、通常、最後の手段として使用されるべきです。<code>Meta.parse</code>を使用したり、任意の文字列をJuliaコードに変換するのはほとんど良いアイデアではありません。Juliaコードを操作するには、<code>Expr</code>データ構造を直接使用して、Julia構文がどのように解析されるかの複雑さを避けてください。</span></p><p data-translated="true"><span class="original-text">The best uses of metaprogramming often implement most of their functionality in runtime helper functions, striving to minimize the amount of code they generate.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メタプログラミングの最良の使用法は、しばしば実行時ヘルパー関数にほとんどの機能を実装し、生成するコードの量を最小限に抑えることを目指します。</span></p></div></div><h2 id="Program-representation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Program-representation">Program representation</a><a id="Program-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Program-representation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Program-representation">プログラムの表現</a><a id="Program-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Program-representation" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Every Julia program starts life as a string:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべてのJuliaプログラムは文字列として始まります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; prog = "1 + 1"
"1 + 1"</code></pre><p data-translated="true"><span class="original-text"><strong>What happens next?</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>次に何が起こるのですか？</strong></span></p><p data-translated="true"><span class="original-text">The next step is to <a href="https://en.wikipedia.org/wiki/Parsing#Computer_languages#Computer_languages">parse</a> each string into an object called an expression, represented by the Julia type <a href="../../base/base/index.html#Core.Expr"><code>Expr</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のステップは、各文字列を式と呼ばれるオブジェクトに<a href="https://en.wikipedia.org/wiki/Parsing#Computer_languages#Computer_languages">解析</a>することです。これはJulia型<a href="../../base/base/index.html#Core.Expr"><code>Expr</code></a>で表されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; ex1 = Meta.parse(prog)
:(1 + 1)

julia&gt; typeof(ex1)
Expr</code></pre><p data-translated="true"><span class="original-text"><code>Expr</code> objects contain two parts:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Expr</code>オブジェクトは2つの部分を含みます：</span></p><ul><li data-translated="true"><span class="original-text">a <a href="../../base/base/index.html#Core.Symbol"><code>Symbol</code></a> identifying the kind of expression. A symbol is an <a href="https://en.wikipedia.org/wiki/String_interning">interned string</a> identifier (more discussion below).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">式の種類を識別する<a href="../../base/base/index.html#Core.Symbol"><code>Symbol</code></a>。シンボルは<a href="https://en.wikipedia.org/wiki/String_interning">インターンされた文字列</a>識別子です（詳細は以下で説明します）。</span></li></ul><pre><code class="language-julia-repl hljs">julia&gt; ex1.head
:call</code></pre><ul><li data-translated="true"><span class="original-text">the expression arguments, which may be symbols, other expressions, or literal values:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">式の引数、これはシンボル、他の式、またはリテラル値である可能性があります：</span></li></ul><pre><code class="language-julia-repl hljs">julia&gt; ex1.args
3-element Vector{Any}:
  :+
 1
 1</code></pre><p data-translated="true"><span class="original-text">Expressions may also be constructed directly in <a href="https://en.wikipedia.org/wiki/Polish_notation">prefix notation</a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://en.wikipedia.org/wiki/Polish_notation">プレフィックス表記</a>で直接構築された式もあります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; ex2 = Expr(:call, :+, 1, 1)
:(1 + 1)</code></pre><p data-translated="true"><span class="original-text">The two expressions constructed above – by parsing and by direct construction – are equivalent:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記で構築された2つの式 – パースによるものと直接構築によるもの – は等価です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; ex1 == ex2
true</code></pre><p data-translated="true"><span class="original-text"><strong>The key point here is that Julia code is internally represented as a data structure that is accessible from the language itself.</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>ここでの重要な点は、Juliaコードが内部的にデータ構造として表現されており、言語自体からアクセス可能であるということです。</strong></span></p><p data-translated="true"><span class="original-text">The <a href="../../base/io-network/index.html#Base.dump"><code>dump</code></a> function provides indented and annotated display of <code>Expr</code> objects:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/io-network/index.html#Base.dump"><code>dump</code></a>関数は、<code>Expr</code>オブジェクトのインデントされた注釈付き表示を提供します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; dump(ex2)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 1</code></pre><p data-translated="true"><span class="original-text"><code>Expr</code> objects may also be nested:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Expr</code>オブジェクトはネストすることもできます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; ex3 = Meta.parse("(4 + 4) / 2")
:((4 + 4) / 2)</code></pre><p data-translated="true"><span class="original-text">Another way to view expressions is with <code>Meta.show_sexpr</code>, which displays the <a href="https://en.wikipedia.org/wiki/S-expression">S-expression</a> form of a given <code>Expr</code>, which may look very familiar to users of Lisp. Here's an example illustrating the display on a nested <code>Expr</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">式を表示する別の方法は、<code>Meta.show_sexpr</code>を使用することで、与えられた<code>Expr</code>の<a href="https://en.wikipedia.org/wiki/S-expression">S式</a>形式を表示します。これはLispのユーザーには非常に馴染みのあるものに見えるかもしれません。ネストされた<code>Expr</code>の表示を示す例を以下に示します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Meta.show_sexpr(ex3)
(:call, :/, (:call, :+, 4, 4), 2)</code></pre><h3 id="Symbols" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Symbols">Symbols</a><a id="Symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Symbols" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Symbols">シンボル</a><a id="Symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Symbols" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The <code>:</code> character has two syntactic purposes in Julia. The first form creates a <a href="../../base/base/index.html#Core.Symbol"><code>Symbol</code></a>, an <a href="https://en.wikipedia.org/wiki/String_interning">interned string</a> used as one building-block of expressions, from valid identifiers:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>:</code>文字はJuliaにおいて2つの構文的目的を持っています。最初の形式は、有効な識別子から式の構成要素として使用される<a href="../../base/base/index.html#Core.Symbol"><code>Symbol</code></a>、すなわち<a href="https://en.wikipedia.org/wiki/String_interning">インターニングされた文字列</a>を作成します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; s = :foo
:foo

julia&gt; typeof(s)
Symbol</code></pre><p data-translated="true"><span class="original-text">The <a href="../../base/base/index.html#Core.Symbol"><code>Symbol</code></a> constructor takes any number of arguments and creates a new symbol by concatenating their string representations together:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Core.Symbol"><code>Symbol</code></a>コンストラクタは任意の数の引数を取り、それらの文字列表現を連結して新しいシンボルを作成します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; :foo === Symbol("foo")
true

julia&gt; Symbol("1foo") # `:1foo` would not work, as `1foo` is not a valid identifier
Symbol("1foo")

julia&gt; Symbol("func",10)
:func10

julia&gt; Symbol(:var,'_',"sym")
:var_sym</code></pre><p data-translated="true"><span class="original-text">In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate <a href="../variables-and-scoping/index.html#scope-of-variables">scope</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">式の文脈において、シンボルは変数へのアクセスを示すために使用されます。式が評価されると、シンボルは適切な<a href="../variables-and-scoping/index.html#scope-of-variables">スコープ</a>内でそのシンボルに束縛された値に置き換えられます。</span></p><p data-translated="true"><span class="original-text">Sometimes extra parentheses around the argument to <code>:</code> are needed to avoid ambiguity in parsing:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">時々、<code>:</code>への引数の周りに追加の括弧が必要で、解析の曖昧さを避けることができます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; :(:)
:(:)

julia&gt; :(::)
:(::)</code></pre><h2 id="Expressions-and-evaluation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Expressions-and-evaluation">Expressions and evaluation</a><a id="Expressions-and-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions-and-evaluation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Expressions-and-evaluation">式と評価</a><a id="Expressions-and-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions-and-evaluation" title="Permalink"></a></span></h2><h3 id="Quoting" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Quoting">Quoting</a><a id="Quoting-1"></a><a class="docs-heading-anchor-permalink" href="#Quoting" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Quoting">引用</a><a id="Quoting-1"></a><a class="docs-heading-anchor-permalink" href="#Quoting" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The second syntactic purpose of the <code>:</code> character is to create expression objects without using the explicit <a href="../../base/base/index.html#Core.Expr"><code>Expr</code></a> constructor. This is referred to as <em>quoting</em>. The <code>:</code> character, followed by paired parentheses around a single statement of Julia code, produces an <code>Expr</code> object based on the enclosed code. Here is an example of the short form used to quote an arithmetic expression:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>:</code>文字の第二の構文的目的は、明示的な<a href="../../base/base/index.html#Core.Expr"><code>Expr</code></a>コンストラクタを使用せずに式オブジェクトを作成することです。これは<em>引用</em>と呼ばれます。<code>:</code>文字の後に、Juliaコードの単一のステートメントを囲む対の括弧が続くと、囲まれたコードに基づいて<code>Expr</code>オブジェクトが生成されます。ここに、算術式を引用するために使用される短い形式の例があります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; ex = :(a+b*c+1)
:(a + b * c + 1)

julia&gt; typeof(ex)
Expr</code></pre><p data-translated="true"><span class="original-text">(to view the structure of this expression, try <code>ex.head</code> and <code>ex.args</code>, or use <a href="../../base/io-network/index.html#Base.dump"><code>dump</code></a> as above or <a href="../../base/io-network/index.html#Base.Meta.@dump"><code>Meta.@dump</code></a>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(この式の構造を表示するには、<code>ex.head</code>と<code>ex.args</code>を試すか、上記のように<a href="../../base/io-network/index.html#Base.dump"><code>dump</code></a>を使用するか、<a href="../../base/io-network/index.html#Base.Meta.@dump"><code>Meta.@dump</code></a>を使用してください)</span></p><p data-translated="true"><span class="original-text">Note that equivalent expressions may be constructed using <a href="../../base/base/index.html#Base.Meta.parse-Tuple{AbstractString, Int64}"><code>Meta.parse</code></a> or the direct <code>Expr</code> form:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">等価な式は、<a href="../../base/base/index.html#Base.Meta.parse-Tuple{AbstractString, Int64}"><code>Meta.parse</code></a>や直接の<code>Expr</code>形式を使用して構築できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt;      :(a + b*c + 1)       ==
       Meta.parse("a + b*c + 1") ==
       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)
true</code></pre><p data-translated="true"><span class="original-text">Expressions provided by the parser generally only have symbols, other expressions, and literal values as their args, whereas expressions constructed by Julia code can have arbitrary run-time values without literal forms as args. In this specific example, <code>+</code> and <code>a</code> are symbols, <code>*(b,c)</code> is a subexpression, and <code>1</code> is a literal 64-bit signed integer.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パーサーによって提供される式は、一般的にシンボル、他の式、およびリテラル値を引数として持ちますが、Juliaコードによって構築された式は、リテラル形式なしで任意の実行時値を引数として持つことができます。この特定の例では、<code>+</code>と<code>a</code>はシンボルであり、<code>*(b,c)</code>はサブ式であり、<code>1</code>はリテラルの64ビット符号付き整数です。</span></p><p data-translated="true"><span class="original-text">There is a second syntactic form of quoting for multiple expressions: blocks of code enclosed in <code>quote ... end</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複数の式のための引用の第二の構文形式があります：<code>quote ... end</code>で囲まれたコードのブロック。</span></p><pre><code class="language-julia-repl hljs">julia&gt; ex = quote
           x = 1
           y = 2
           x + y
       end
quote
    #= none:2 =#
    x = 1
    #= none:3 =#
    y = 2
    #= none:4 =#
    x + y
end

julia&gt; typeof(ex)
Expr</code></pre><h3 id="man-expression-interpolation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-expression-interpolation">Interpolation</a><a id="man-expression-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#man-expression-interpolation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-expression-interpolation">補間</a><a id="man-expression-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#man-expression-interpolation" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Direct construction of <a href="../../base/base/index.html#Core.Expr"><code>Expr</code></a> objects with value arguments is powerful, but <code>Expr</code> constructors can be tedious compared to "normal" Julia syntax. As an alternative, Julia allows <em>interpolation</em> of literals or expressions into quoted expressions. Interpolation is indicated by a prefix <code>$</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Core.Expr"><code>Expr</code></a>オブジェクトを値引数で直接構築することは強力ですが、<code>Expr</code>コンストラクタは「通常の」Julia構文と比較して面倒な場合があります。代替として、Juliaはリテラルや式を引用された式に<em>補間</em>することを許可します。補間はプレフィックス<code>$</code>によって示されます。</span></p><p data-translated="true"><span class="original-text">In this example, the value of variable <code>a</code> is interpolated:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例では、変数 <code>a</code> の値が補間されています：</span></p><pre><code class="language-julia-repl hljs">julia&gt; a = 1;

julia&gt; ex = :($a + b)
:(1 + b)</code></pre><p data-translated="true"><span class="original-text">Interpolating into an unquoted expression is not supported and will cause a compile-time error:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引用されていない式への補間はサポートされておらず、コンパイル時エラーを引き起こします：</span></p><pre><code class="language-julia-repl hljs">julia&gt; $a + b
ERROR: syntax: "$" expression outside quote</code></pre><p data-translated="true"><span class="original-text">In this example, the tuple <code>(1,2,3)</code> is interpolated as an expression into a conditional test:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例では、タプル <code>(1,2,3)</code> が条件テストの式として補間されています：</span></p><pre><code class="language-julia-repl hljs">julia&gt; ex = :(a in $:((1,2,3)) )
:(a in (1, 2, 3))</code></pre><p data-translated="true"><span class="original-text">The use of <code>$</code> for expression interpolation is intentionally reminiscent of <a href="../strings/index.html#string-interpolation">string interpolation</a> and <a href="../running-external-programs/index.html#command-interpolation">command interpolation</a>. Expression interpolation allows convenient, readable programmatic construction of complex Julia expressions.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>$</code> を使用した式の補間は、意図的に <a href="../strings/index.html#string-interpolation">文字列補間</a> および <a href="../running-external-programs/index.html#command-interpolation">コマンド補間</a> を思い起こさせるものです。式の補間は、複雑なJulia式をプログラム的に便利で読みやすく構築することを可能にします。</span></p><h3 id="Splatting-interpolation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Splatting-interpolation">Splatting interpolation</a><a id="Splatting-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Splatting-interpolation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Splatting-interpolation">スプラッティング補間</a><a id="Splatting-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Splatting-interpolation" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Notice that the <code>$</code> interpolation syntax allows inserting only a single expression into an enclosing expression. Occasionally, you have an array of expressions and need them all to become arguments of the surrounding expression. This can be done with the syntax <code>$(xs...)</code>. For example, the following code generates a function call where the number of arguments is determined programmatically:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">注意すべきは、<code>$</code> 補間構文は、囲まれた式に単一の式のみを挿入することを許可するということです。時には、式の配列があり、それらすべてを周囲の式の引数にする必要があります。これは、構文 <code>$(xs...)</code> を使用して行うことができます。例えば、以下のコードは、引数の数がプログラム的に決定される関数呼び出しを生成します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; args = [:x, :y, :z];

julia&gt; :(f(1, $(args...)))
:(f(1, x, y, z))</code></pre><h3 id="Nested-quote" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Nested-quote">Nested quote</a><a id="Nested-quote-1"></a><a class="docs-heading-anchor-permalink" href="#Nested-quote" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Nested-quote">ネストされた引用</a><a id="Nested-quote-1"></a><a class="docs-heading-anchor-permalink" href="#Nested-quote" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Naturally, it is possible for quote expressions to contain other quote expressions. Understanding how interpolation works in these cases can be a bit tricky. Consider this example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">当然のことながら、引用式が他の引用式を含むことは可能です。これらのケースで補間がどのように機能するかを理解するのは少し難しい場合があります。この例を考えてみてください：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = :(1 + 2);

julia&gt; e = quote quote $x end end
quote
    #= none:1 =#
    $(Expr(:quote, quote
    #= none:1 =#
    $(Expr(:$, :x))
end))
end</code></pre><p data-translated="true"><span class="original-text">Notice that the result contains <code>$x</code>, which means that <code>x</code> has not been evaluated yet. In other words, the <code>$</code> expression "belongs to" the inner quote expression, and so its argument is only evaluated when the inner quote expression is:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">結果に <code>$x</code> が含まれていることに注意してください。これは、<code>x</code> がまだ評価されていないことを意味します。言い換えれば、<code>$</code> 式は内側の引用式に「属しており」、その引数は内側の引用式が評価されるときにのみ評価されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; eval(e)
quote
    #= none:1 =#
    1 + 2
end</code></pre><p data-translated="true"><span class="original-text">However, the outer <code>quote</code> expression is able to interpolate values inside the <code>$</code> in the inner quote. This is done with multiple <code>$</code>s:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、外側の <code>quote</code> 式は、内側の引用の <code>$</code> 内にある値を補間することができます。これは複数の <code>$</code> を使用して行われます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; e = quote quote $$x end end
quote
    #= none:1 =#
    $(Expr(:quote, quote
    #= none:1 =#
    $(Expr(:$, :(1 + 2)))
end))
end</code></pre><p data-translated="true"><span class="original-text">Notice that <code>(1 + 2)</code> now appears in the result instead of the symbol <code>x</code>. Evaluating this expression yields an interpolated <code>3</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">注意してください、<code>(1 + 2)</code>が結果に現れ、シンボル<code>x</code>の代わりになっています。この式を評価すると、補間された<code>3</code>が得られます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; eval(e)
quote
    #= none:1 =#
    3
end</code></pre><p data-translated="true"><span class="original-text">The intuition behind this behavior is that <code>x</code> is evaluated once for each <code>$</code>: one <code>$</code> works similarly to <code>eval(:x)</code>, giving <code>x</code>'s value, while two <code>$</code>s do the equivalent of <code>eval(eval(:x))</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この動作の直感的な理解は、<code>x</code>が各<code>$</code>ごとに一度評価されることにあります：1つの<code>$</code>は<code>eval(:x)</code>と同様に機能し、<code>x</code>の値を返しますが、2つの<code>$</code>は<code>eval(eval(:x))</code>と同等の動作をします。</span></p><h3 id="man-quote-node" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-quote-node">QuoteNode</a><a id="man-quote-node-1"></a><a class="docs-heading-anchor-permalink" href="#man-quote-node" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-quote-node">QuoteNode</a><a id="man-quote-node-1"></a><a class="docs-heading-anchor-permalink" href="#man-quote-node" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The usual representation of a <code>quote</code> form in an AST is an <a href="../../base/base/index.html#Core.Expr"><code>Expr</code></a> with head <code>:quote</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ASTにおける<code>quote</code>形式の通常の表現は、ヘッドが<code>:quote</code>の<a href="../../base/base/index.html#Core.Expr"><code>Expr</code></a>です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; dump(Meta.parse(":(1+2)"))
Expr
  head: Symbol quote
  args: Array{Any}((1,))
    1: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol +
        2: Int64 1
        3: Int64 2</code></pre><p data-translated="true"><span class="original-text">As we have seen, such expressions support interpolation with <code>$</code>. However, in some situations it is necessary to quote code <em>without</em> performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type <code>QuoteNode</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ご覧のように、そのような式は<code>$</code>による補間をサポートします。しかし、いくつかの状況では、補間を行わずにコードを引用する必要があります。この種の引用にはまだ構文がありませんが、内部的には<code>QuoteNode</code>型のオブジェクトとして表現されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; eval(Meta.quot(Expr(:$, :(1+2))))
3

julia&gt; eval(QuoteNode(Expr(:$, :(1+2))))
:($(Expr(:$, :(1 + 2))))</code></pre><p data-translated="true"><span class="original-text">The parser yields <code>QuoteNode</code>s for simple quoted items like symbols:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パーサーは、シンボルのような単純な引用項目に対して<code>QuoteNode</code>を生成します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; dump(Meta.parse(":x"))
QuoteNode
  value: Symbol x</code></pre><p data-translated="true"><span class="original-text"><code>QuoteNode</code> can also be used for certain advanced metaprogramming tasks.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>QuoteNode</code>は、特定の高度なメタプログラミングタスクにも使用できます。</span></p><h3 id="Evaluating-expressions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Evaluating-expressions">Evaluating expressions</a><a id="Evaluating-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-expressions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Evaluating-expressions">式の評価</a><a id="Evaluating-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-expressions" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Given an expression object, one can cause Julia to evaluate (execute) it at global scope using <a href="../../base/base/index.html#eval"><code>eval</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">式オブジェクトが与えられた場合、<a href="../../base/base/index.html#eval"><code>eval</code></a>を使用して、Juliaにそれをグローバルスコープで評価（実行）させることができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; ex1 = :(1 + 2)
:(1 + 2)

julia&gt; eval(ex1)
3

julia&gt; ex = :(a + b)
:(a + b)

julia&gt; eval(ex)
ERROR: UndefVarError: `b` not defined in `Main`
[...]

julia&gt; a = 1; b = 2;

julia&gt; eval(ex)
3</code></pre><p data-translated="true"><span class="original-text">Every <a href="../modules/index.html#modules">module</a> has its own <a href="../../base/base/index.html#eval"><code>eval</code></a> function that evaluates expressions in its global scope. Expressions passed to <a href="../../base/base/index.html#eval"><code>eval</code></a> are not limited to returning values – they can also have side-effects that alter the state of the enclosing module's environment:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべての<a href="../modules/index.html#modules">モジュール</a>には、そのグローバルスコープで式を評価する独自の<a href="../../base/base/index.html#eval"><code>eval</code></a>関数があります。<a href="../../base/base/index.html#eval"><code>eval</code></a>に渡される式は、値を返すことに制限されず、囲んでいるモジュールの環境の状態を変更する副作用を持つこともあります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; ex = :(x = 1)
:(x = 1)

julia&gt; x
ERROR: UndefVarError: `x` not defined in `Main`

julia&gt; eval(ex)
1

julia&gt; x
1</code></pre><p data-translated="true"><span class="original-text">Here, the evaluation of an expression object causes a value to be assigned to the global variable <code>x</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、式オブジェクトの評価がグローバル変数<code>x</code>に値を割り当てる原因となります。</span></p><p data-translated="true"><span class="original-text">Since expressions are just <code>Expr</code> objects which can be constructed programmatically and then evaluated, it is possible to dynamically generate arbitrary code which can then be run using <a href="../../base/base/index.html#eval"><code>eval</code></a>. Here is a simple example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">式はプログラム的に構築され、その後評価される<code>Expr</code>オブジェクトに過ぎないため、任意のコードを動的に生成し、<a href="../../base/base/index.html#eval"><code>eval</code></a>を使用して実行することが可能です。以下は簡単な例です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; a = 1;

julia&gt; ex = Expr(:call, :+, a, :b)
:(1 + b)

julia&gt; a = 0; b = 2;

julia&gt; eval(ex)
3</code></pre><p data-translated="true"><span class="original-text">The value of <code>a</code> is used to construct the expression <code>ex</code> which applies the <code>+</code> function to the value 1 and the variable <code>b</code>. Note the important distinction between the way <code>a</code> and <code>b</code> are used:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>a</code>の値は、値1と変数<code>b</code>に<code>+</code>関数を適用する式<code>ex</code>を構築するために使用されます。<code>a</code>と<code>b</code>の使用方法の重要な違いに注意してください：</span></p><ul><li data-translated="true"><span class="original-text">The value of the <em>variable</em> <code>a</code> at expression construction time is used as an immediate value in the expression. Thus, the value of <code>a</code> when the expression is evaluated no longer matters: the value in the expression is already <code>1</code>, independent of whatever the value of <code>a</code> might be.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">式構築時の<em>変数</em><code>a</code>の値は、式内で即時値として使用されます。したがって、式が評価されるときの<code>a</code>の値はもはや重要ではありません：式内の値はすでに<code>1</code>であり、<code>a</code>の値が何であれ独立しています。</span></li><li data-translated="true"><span class="original-text">On the other hand, the <em>symbol</em> <code>:b</code> is used in the expression construction, so the value of the variable <code>b</code> at that time is irrelevant – <code>:b</code> is just a symbol and the variable <code>b</code> need not even be defined. At expression evaluation time, however, the value of the symbol <code>:b</code> is resolved by looking up the value of the variable <code>b</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一方、<em>シンボル</em><code>:b</code>は式構築に使用されるため、その時点での変数<code>b</code>の値は無関係です – <code>:b</code>は単なるシンボルであり、変数<code>b</code>は定義されている必要すらありません。しかし、式評価時には、シンボル<code>:b</code>の値は変数<code>b</code>の値を参照することによって解決されます。</span></li></ul><h3 id="Functions-on-Expressions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Functions-on-Expressions">Functions on <code>Expr</code>essions</a><a id="Functions-on-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-on-Expressions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Functions-on-Expressions">式に関する<code>Expr</code>の関数</a><a id="Functions-on-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-on-Expressions" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have already seen one example of a function returning <a href="../../base/base/index.html#Core.Expr"><code>Expr</code></a> objects: the <a href="../../base/base/index.html#Base.Meta.parse-Tuple{AbstractString, Int64}"><code>Meta.parse</code></a> function, which takes a string of Julia code and returns the corresponding <code>Expr</code>. A function can also take one or more <code>Expr</code> objects as arguments, and return another <code>Expr</code>. Here is a simple, motivating example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記で示唆したように、Juliaの非常に便利な機能の1つは、Julia自身の中でJuliaコードを生成し操作する能力です。すでに<code>Expr</code>オブジェクトを返す関数の例を見ました：文字列のJuliaコードを受け取り、対応する<code>Expr</code>を返す<a href="../../base/base/index.html#Base.Meta.parse-Tuple{AbstractString, Int64}"><code>Meta.parse</code></a>関数です。関数は1つ以上の<code>Expr</code>オブジェクトを引数として受け取り、別の<code>Expr</code>を返すこともできます。以下は簡単で動機付けとなる例です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function math_expr(op, op1, op2)
           expr = Expr(:call, op, op1, op2)
           return expr
       end
math_expr (generic function with 1 method)

julia&gt;  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))
:(1 + 4 * 5)

julia&gt; eval(ex)
21</code></pre><p data-translated="true"><span class="original-text">As another example, here is a function that doubles any numeric argument, but leaves expressions alone:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">別の例として、任意の数値引数を2倍にするが、式はそのままにする関数を示します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function make_expr2(op, opr1, opr2)
           opr1f, opr2f = map(x -&gt; isa(x, Number) ? 2*x : x, (opr1, opr2))
           retexpr = Expr(:call, op, opr1f, opr2f)
           return retexpr
       end
make_expr2 (generic function with 1 method)

julia&gt; make_expr2(:+, 1, 2)
:(2 + 4)

julia&gt; ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))
:(2 + 5 * 8)

julia&gt; eval(ex)
42</code></pre><h2 id="man-macros" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-macros">Macros</a><a id="man-macros-1"></a><a class="docs-heading-anchor-permalink" href="#man-macros" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-macros">マクロ</a><a id="man-macros-1"></a><a class="docs-heading-anchor-permalink" href="#man-macros" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Macros provide a mechanism to include generated code in the final body of a program. A macro maps a tuple of arguments to a returned <em>expression</em>, and the resulting expression is compiled directly rather than requiring a runtime <a href="../../base/base/index.html#eval"><code>eval</code></a> call. Macro arguments may include expressions, literal values, and symbols.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マクロは、生成されたコードをプログラムの最終的な本体に含めるメカニズムを提供します。マクロは引数のタプルを返される<em>式</em>にマッピングし、結果の式はランタイムの<a href="../../base/base/index.html#eval"><code>eval</code></a>呼び出しを必要とせずに直接コンパイルされます。マクロの引数には、式、リテラル値、およびシンボルが含まれる場合があります。</span></p><h3 id="Basics" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Basics">基本</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Here is an extraordinarily simple macro:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここに非常にシンプルなマクロがあります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; macro sayhello()
           return :( println("Hello, world!") )
       end
@sayhello (macro with 1 method)</code></pre><p data-translated="true"><span class="original-text">Macros have a dedicated character in Julia's syntax: the <code>@</code> (at-sign), followed by the unique name declared in a <code>macro NAME ... end</code> block. In this example, the compiler will replace all instances of <code>@sayhello</code> with:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マクロはJuliaの構文において専用の文字を持っています：<code>@</code>（アットサイン）、その後に<code>macro NAME ... end</code>ブロックで宣言されたユニークな名前が続きます。この例では、コンパイラはすべての<code>@sayhello</code>のインスタンスを次のように置き換えます：</span></p><pre><code class="language-julia hljs">:( println("Hello, world!") )</code></pre><p data-translated="true"><span class="original-text">When <code>@sayhello</code> is entered in the REPL, the expression executes immediately, thus we only see the evaluation result:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@sayhello</code>がREPLに入力されると、式は即座に実行されるため、評価結果のみが表示されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @sayhello()
Hello, world!</code></pre><p data-translated="true"><span class="original-text">Now, consider a slightly more complex macro:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さて、もう少し複雑なマクロを考えてみましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; macro sayhello(name)
           return :( println("Hello, ", $name) )
       end
@sayhello (macro with 1 method)</code></pre><p data-translated="true"><span class="original-text">This macro takes one argument: <code>name</code>. When <code>@sayhello</code> is encountered, the quoted expression is <em>expanded</em> to interpolate the value of the argument into the final expression:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このマクロは1つの引数を取ります：<code>name</code>。<code>@sayhello</code>に遭遇すると、引用された式は引数の値を最終的な式に補間するように<em>展開</em>されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @sayhello("human")
Hello, human</code></pre><p data-translated="true"><span class="original-text">We can view the quoted return expression using the function <a href="../../base/base/index.html#Base.macroexpand"><code>macroexpand</code></a> (<strong>important note:</strong> this is an extremely useful tool for debugging macros):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引用された戻り式を表示するには、<a href="../../base/base/index.html#Base.macroexpand"><code>macroexpand</code></a>関数を使用できます（<strong>重要な注意：</strong>これはマクロのデバッグに非常に便利なツールです）：</span></p><pre><code class="language-julia-repl hljs">julia&gt; ex = macroexpand(Main, :(@sayhello("human")) )
:(Main.println("Hello, ", "human"))

julia&gt; typeof(ex)
Expr</code></pre><p data-translated="true"><span class="original-text">We can see that the <code>"human"</code> literal has been interpolated into the expression.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで、<code>"human"</code>リテラルが式に補間されたことがわかります。</span></p><p data-translated="true"><span class="original-text">There also exists a macro <a href="../../base/base/index.html#Base.@macroexpand"><code>@macroexpand</code></a> that is perhaps a bit more convenient than the <code>macroexpand</code> function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、<a href="../../base/base/index.html#Base.@macroexpand"><code>@macroexpand</code></a>というマクロも存在し、これは<code>macroexpand</code>関数よりも少し便利かもしれません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @macroexpand @sayhello "human"
:(println("Hello, ", "human"))</code></pre><h3 id="Hold-up:-why-macros?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Hold-up:-why-macros?">Hold up: why macros?</a><a id="Hold-up:-why-macros?-1"></a><a class="docs-heading-anchor-permalink" href="#Hold-up:-why-macros?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Hold-up:-why-macros?">ちょっと待って：なぜマクロなのか？</a><a id="Hold-up:-why-macros?-1"></a><a class="docs-heading-anchor-permalink" href="#Hold-up:-why-macros?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">We have already seen a function <code>f(::Expr...) -&gt; Expr</code> in a previous section. In fact, <a href="../../base/base/index.html#Base.macroexpand"><code>macroexpand</code></a> is also such a function. So, why do macros exist?</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">前のセクションで、関数 <code>f(::Expr...) -&gt; Expr</code> を既に見ました。実際、<a href="../../base/base/index.html#Base.macroexpand"><code>macroexpand</code></a> もそのような関数です。では、マクロはなぜ存在するのでしょうか？</span></p><p data-translated="true"><span class="original-text">Macros are necessary because they execute when code is parsed, therefore, macros allow the programmer to generate and include fragments of customized code <em>before</em> the full program is run. To illustrate the difference, consider the following example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マクロは、コードが解析されるときに実行されるため、プログラマーがプログラム全体が実行される前にカスタマイズされたコードの断片を生成して含めることを可能にするため、必要です。違いを示すために、次の例を考えてみましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; macro twostep(arg)
           println("I execute at parse time. The argument is: ", arg)
           return :(println("I execute at runtime. The argument is: ", $arg))
       end
@twostep (macro with 1 method)

julia&gt; ex = macroexpand(Main, :(@twostep :(1, 2, 3)) );
I execute at parse time. The argument is: :((1, 2, 3))</code></pre><p data-translated="true"><span class="original-text">The first call to <a href="../../base/io-network/index.html#Base.println"><code>println</code></a> is executed when <a href="../../base/base/index.html#Base.macroexpand"><code>macroexpand</code></a> is called. The resulting expression contains <em>only</em> the second <code>println</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初の <a href="../../base/io-network/index.html#Base.println"><code>println</code></a> の呼び出しは、<a href="../../base/base/index.html#Base.macroexpand"><code>macroexpand</code></a> が呼び出されたときに実行されます。結果として得られる式には、<em>のみ</em> 2番目の <code>println</code> が含まれます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; typeof(ex)
Expr

julia&gt; ex
:(println("I execute at runtime. The argument is: ", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))

julia&gt; eval(ex)
I execute at runtime. The argument is: (1, 2, 3)</code></pre><h3 id="Macro-invocation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Macro-invocation">Macro invocation</a><a id="Macro-invocation-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-invocation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Macro-invocation">マクロの呼び出し</a><a id="Macro-invocation-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-invocation" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Macros are invoked with the following general syntax:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マクロは次の一般的な構文で呼び出されます：</span></p><pre><code class="language-julia hljs">@name expr1 expr2 ...
@name(expr1, expr2, ...)</code></pre><p data-translated="true"><span class="original-text">Note the distinguishing <code>@</code> before the macro name and the lack of commas between the argument expressions in the first form, and the lack of whitespace after <code>@name</code> in the second form. The two styles should not be mixed. For example, the following syntax is different from the examples above; it passes the tuple <code>(expr1, expr2, ...)</code> as one argument to the macro:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マクロ名の前にある区別する <code>@</code> と、最初の形式の引数式の間にカンマがないこと、そして2番目の形式の <code>@name</code> の後に空白がないことに注意してください。これらの2つのスタイルは混合してはいけません。例えば、次の構文は上記の例とは異なり、タプル <code>(expr1, expr2, ...)</code> をマクロへの1つの引数として渡します：</span></p><pre><code class="language-julia hljs">@name (expr1, expr2, ...)</code></pre><p data-translated="true"><span class="original-text">An alternative way to invoke a macro over an array literal (or comprehension) is to juxtapose both without using parentheses. In this case, the array will be the only expression fed to the macro. The following syntax is equivalent (and different from <code>@name [a b] * v</code>):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列リテラル（または内包表記）に対してマクロを呼び出す別の方法は、括弧を使用せずに両者を並べることです。この場合、配列はマクロに供給される唯一の式になります。次の構文は等価です（<code>@name [a b] * v</code> とは異なります）：</span></p><pre><code class="language-julia hljs">@name[a b] * v
@name([a b]) * v</code></pre><p data-translated="true"><span class="original-text">It is important to emphasize that macros receive their arguments as expressions, literals, or symbols. One way to explore macro arguments is to call the <a href="../../base/io-network/index.html#Base.show-Tuple{IO, Any}"><code>show</code></a> function within the macro body:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マクロが引数を式、リテラル、またはシンボルとして受け取ることを強調することが重要です。マクロ引数を探る方法の1つは、マクロ本体内で <a href="../../base/io-network/index.html#Base.show-Tuple{IO, Any}"><code>show</code></a> 関数を呼び出すことです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; macro showarg(x)
           show(x)
           # ... remainder of macro, returning an expression
       end
@showarg (macro with 1 method)

julia&gt; @showarg(a)
:a

julia&gt; @showarg(1+1)
:(1 + 1)

julia&gt; @showarg(println("Yo!"))
:(println("Yo!"))

julia&gt; @showarg(1)        # Numeric literal
1

julia&gt; @showarg("Yo!")    # String literal
"Yo!"

julia&gt; @showarg("Yo! $("hello")")    # String with interpolation is an Expr rather than a String
:("Yo! $("hello")")</code></pre><p data-translated="true"><span class="original-text">In addition to the given argument list, every macro is passed extra arguments named <code>__source__</code> and <code>__module__</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">指定された引数リストに加えて、すべてのマクロには <code>__source__</code> と <code>__module__</code> という名前の追加引数が渡されます。</span></p><p data-translated="true"><span class="original-text">The argument <code>__source__</code> provides information (in the form of a <code>LineNumberNode</code> object) about the parser location of the <code>@</code> sign from the macro invocation. This allows macros to include better error diagnostic information, and is commonly used by logging, string-parser macros, and docs, for example, as well as to implement the <a href="../../base/base/index.html#Base.@__LINE__"><code>@__LINE__</code></a>, <a href="../../base/base/index.html#Base.@__FILE__"><code>@__FILE__</code></a>, and <a href="../../base/base/index.html#Base.@__DIR__"><code>@__DIR__</code></a> macros.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数 <code>__source__</code> は、マクロ呼び出しからの <code>@</code> 記号のパーサー位置に関する情報（<code>LineNumberNode</code> オブジェクトの形式で）を提供します。これにより、マクロはより良いエラー診断情報を含めることができ、例えば、ロギング、文字列パーサーマクロ、ドキュメントなどで一般的に使用されます。また、<a href="../../base/base/index.html#Base.@__LINE__"><code>@__LINE__</code></a>、<a href="../../base/base/index.html#Base.@__FILE__"><code>@__FILE__</code></a>、および <a href="../../base/base/index.html#Base.@__DIR__"><code>@__DIR__</code></a> マクロを実装するためにも使用されます。</span></p><p data-translated="true"><span class="original-text">The location information can be accessed by referencing <code>__source__.line</code> and <code>__source__.file</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">位置情報は <code>__source__.line</code> と <code>__source__.file</code> を参照することでアクセスできます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; macro __LOCATION__(); return QuoteNode(__source__); end
@__LOCATION__ (macro with 1 method)

julia&gt; dump(
            @__LOCATION__(
       ))
LineNumberNode
  line: Int64 2
  file: Symbol none</code></pre><p data-translated="true"><span class="original-text">The argument <code>__module__</code> provides information (in the form of a <code>Module</code> object) about the expansion context of the macro invocation. This allows macros to look up contextual information, such as existing bindings, or to insert the value as an extra argument to a runtime function call doing self-reflection in the current module.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数 <code>__module__</code> は、マクロ呼び出しの展開コンテキストに関する情報（<code>Module</code> オブジェクトの形式で）を提供します。これにより、マクロは既存のバインディングなどのコンテキスト情報を参照したり、現在のモジュールで自己反映を行うランタイム関数呼び出しに追加の引数として値を挿入したりできます。</span></p><h3 id="Building-an-advanced-macro" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Building-an-advanced-macro">Building an advanced macro</a><a id="Building-an-advanced-macro-1"></a><a class="docs-heading-anchor-permalink" href="#Building-an-advanced-macro" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Building-an-advanced-macro">高度なマクロの構築</a><a id="Building-an-advanced-macro-1"></a><a class="docs-heading-anchor-permalink" href="#Building-an-advanced-macro" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Here is a simplified definition of Julia's <a href="../../base/base/index.html#Base.@assert"><code>@assert</code></a> macro:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここに、Juliaの<a href="../../base/base/index.html#Base.@assert"><code>@assert</code></a>マクロの簡略化された定義があります:</span></p><pre><code class="language-julia-repl hljs">julia&gt; macro assert(ex)
           return :( $ex ? nothing : throw(AssertionError($(string(ex)))) )
       end
@assert (macro with 1 method)</code></pre><p data-translated="true"><span class="original-text">This macro can be used like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このマクロは次のように使用できます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; @assert 1 == 1.0

julia&gt; @assert 1 == 0
ERROR: AssertionError: 1 == 0</code></pre><p data-translated="true"><span class="original-text">In place of the written syntax, the macro call is expanded at parse time to its returned result. This is equivalent to writing:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">書かれた構文の代わりに、マクロ呼び出しはパース時にその返された結果に展開されます。これは次のように書くことと同等です:</span></p><pre><code class="language-julia hljs">1 == 1.0 ? nothing : throw(AssertionError("1 == 1.0"))
1 == 0 ? nothing : throw(AssertionError("1 == 0"))</code></pre><p data-translated="true"><span class="original-text">That is, in the first call, the expression <code>:(1 == 1.0)</code> is spliced into the test condition slot, while the value of <code>string(:(1 == 1.0))</code> is spliced into the assertion message slot. The entire expression, thus constructed, is placed into the syntax tree where the <code>@assert</code> macro call occurs. Then at execution time, if the test expression evaluates to true, then <a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a> is returned, whereas if the test is false, an error is raised indicating the asserted expression that was false. Notice that it would not be possible to write this as a function, since only the <em>value</em> of the condition is available and it would be impossible to display the expression that computed it in the error message.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">つまり、最初の呼び出しでは、式 <code>:(1 == 1.0)</code> がテスト条件スロットに挿入され、<code>string(:(1 == 1.0))</code> の値がアサーションメッセージスロットに挿入されます。このように構築された全体の式は、<code>@assert</code>マクロ呼び出しが発生する構文木に配置されます。実行時に、テスト式が真に評価されると、<a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a> が返されますが、テストが偽の場合は、偽であったアサートされた式を示すエラーが発生します。このように、条件の<em>値</em>のみが利用可能であり、エラーメッセージにそれを計算した式を表示することは不可能であるため、これを関数として書くことはできません。</span></p><p data-translated="true"><span class="original-text">The actual definition of <code>@assert</code> in Julia Base is more complicated. It allows the user to optionally specify their own error message, instead of just printing the failed expression. Just like in functions with a variable number of arguments (<a href="../functions/index.html#Varargs-Functions">Varargs Functions</a>), this is specified with an ellipses following the last argument:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia Baseにおける<code>@assert</code>の実際の定義はより複雑です。これは、ユーザーが失敗した式を単に印刷するのではなく、独自のエラーメッセージをオプションで指定できるようにします。可変数の引数を持つ関数と同様に（<a href="../functions/index.html#Varargs-Functions">可変引数関数</a>）、これは最後の引数の後にエリプシスを指定することで行います:</span></p><pre><code class="language-julia-repl hljs">julia&gt; macro assert(ex, msgs...)
           msg_body = isempty(msgs) ? ex : msgs[1]
           msg = string(msg_body)
           return :($ex ? nothing : throw(AssertionError($msg)))
       end
@assert (macro with 1 method)</code></pre><p data-translated="true"><span class="original-text">Now <code>@assert</code> has two modes of operation, depending upon the number of arguments it receives! If there's only one argument, the tuple of expressions captured by <code>msgs</code> will be empty and it will behave the same as the simpler definition above. But now if the user specifies a second argument, it is printed in the message body instead of the failing expression. You can inspect the result of a macro expansion with the aptly named <a href="../../base/base/index.html#Base.@macroexpand"><code>@macroexpand</code></a> macro:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">現在、<code>@assert</code>は受け取る引数の数に応じて2つの動作モードを持っています！引数が1つだけの場合、<code>msgs</code>によってキャプチャされた式のタプルは空になり、上記の簡単な定義と同じように動作します。しかし、ユーザーが2番目の引数を指定すると、それは失敗した式の代わりにメッセージ本文に印刷されます。マクロ展開の結果を、適切に名付けられた<a href="../../base/base/index.html#Base.@macroexpand"><code>@macroexpand</code></a>マクロで確認できます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; @macroexpand @assert a == b
:(if Main.a == Main.b
        Main.nothing
    else
        Main.throw(Main.AssertionError("a == b"))
    end)

julia&gt; @macroexpand @assert a==b "a should equal b!"
:(if Main.a == Main.b
        Main.nothing
    else
        Main.throw(Main.AssertionError("a should equal b!"))
    end)</code></pre><p data-translated="true"><span class="original-text">There is yet another case that the actual <code>@assert</code> macro handles: what if, in addition to printing "a should equal b," we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., <code>@assert a==b "a ($a) should equal b ($b)!"</code>, but this won't work as expected with the above macro. Can you see why? Recall from <a href="../strings/index.html#string-interpolation">string interpolation</a> that an interpolated string is rewritten to a call to <a href="../../base/strings/index.html#Base.string"><code>string</code></a>. Compare:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実際の<code>@assert</code>マクロが処理するもう1つのケースがあります: "aはbと等しいべき"と印刷するだけでなく、それらの値も印刷したい場合はどうでしょうか？カスタムメッセージで文字列補間を使用しようとするかもしれませんが、例えば<code>@assert a==b "a ($a) は b ($b) と等しいべきです！"</code>のように、上記のマクロでは期待通りに動作しません。なぜか分かりますか？<a href="../strings/index.html#string-interpolation">文字列補間</a>から思い出してください。補間された文字列は、<a href="../../base/strings/index.html#Base.string"><code>string</code></a>への呼び出しに書き換えられます。比較してみてください:</span></p><pre><code class="language-julia-repl hljs">julia&gt; typeof(:("a should equal b"))
String

julia&gt; typeof(:("a ($a) should equal b ($b)!"))
Expr

julia&gt; dump(:("a ($a) should equal b ($b)!"))
Expr
  head: Symbol string
  args: Array{Any}((5,))
    1: String "a ("
    2: Symbol a
    3: String ") should equal b ("
    4: Symbol b
    5: String ")!"</code></pre><p data-translated="true"><span class="original-text">So now instead of getting a plain string in <code>msg_body</code>, the macro is receiving a full expression that will need to be evaluated in order to display as expected. This can be spliced directly into the returned expression as an argument to the <a href="../../base/strings/index.html#Base.string"><code>string</code></a> call; see <a href="https://github.com/JuliaLang/julia/blob/master/base/error.jl"><code>error.jl</code></a> for the complete implementation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、<code>msg_body</code>にプレーンな文字列を取得する代わりに、マクロは期待通りに表示するために評価する必要がある完全な式を受け取ります。これは、<a href="../../base/strings/index.html#Base.string"><code>string</code></a>呼び出しの引数として返された式に直接スプライスできます。完全な実装については<a href="https://github.com/JuliaLang/julia/blob/master/base/error.jl"><code>error.jl</code></a>を参照してください。</span></p><p data-translated="true"><span class="original-text">The <code>@assert</code> macro makes great use of splicing into quoted expressions to simplify the manipulation of expressions inside the macro body.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@assert</code>マクロは、マクロ本体内の式の操作を簡素化するために、引用された式へのスプライスを大いに活用します。</span></p><h3 id="Hygiene" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Hygiene">Hygiene</a><a id="Hygiene-1"></a><a class="docs-heading-anchor-permalink" href="#Hygiene" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Hygiene">Hygiene</a><a id="Hygiene-1"></a><a class="docs-heading-anchor-permalink" href="#Hygiene" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">An issue that arises in more complex macros is that of <a href="https://en.wikipedia.org/wiki/Hygienic_macro">hygiene</a>. In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often <em>expected</em> to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as <code>msg</code> in <code>@assert</code> above) follow the <a href="../variables-and-scoping/index.html#scope-of-variables">normal scoping block behavior</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より複雑なマクロで発生する問題は、<a href="https://en.wikipedia.org/wiki/Hygienic_macro">hygiene</a>の問題です。簡単に言えば、マクロは、返された式に導入した変数が、展開される周囲のコードに存在する変数と偶然に衝突しないようにする必要があります。逆に、マクロに引数として渡される式は、周囲のコードの文脈で評価されることが<em>期待される</em>ことが多く、既存の変数と相互作用し、変更します。別の懸念は、マクロが定義されたモジュールとは異なるモジュールで呼び出される可能性があるという事実から生じます。この場合、すべてのグローバル変数が正しいモジュールに解決されることを確認する必要があります。Juliaは、テキストマクロ展開（Cのような）を持つ言語に対してすでに大きな利点を持っており、返された式のみを考慮すればよいのです。他のすべての変数（上記の<code>msg</code>のような<code>@assert</code>内の変数）は、<a href="../variables-and-scoping/index.html#scope-of-variables">通常のスコープブロックの動作</a>に従います。</span></p><p data-translated="true"><span class="original-text">To demonstrate these issues, let us consider writing a <code>@time</code> macro that takes an expression as its argument, records the time, evaluates the expression, records the time again, prints the difference between the before and after times, and then has the value of the expression as its final value. The macro might look like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの問題を示すために、式を引数として取り、時間を記録し、式を評価し、再度時間を記録し、前後の時間の差を印刷し、式の値を最終値とする<code>@time</code>マクロを書くことを考えてみましょう。マクロは次のようになります。</span></p><pre><code class="language-julia hljs">macro time(ex)
    return quote
        local t0 = time_ns()
        local val = $ex
        local t1 = time_ns()
        println("elapsed time: ", (t1-t0)/1e9, " seconds")
        val
    end
end</code></pre><p data-translated="true"><span class="original-text">Here, we want <code>t0</code>, <code>t1</code>, and <code>val</code> to be private temporary variables, and we want <code>time_ns</code> to refer to the <a href="../../base/base/index.html#Base.time_ns"><code>time_ns</code></a> function in Julia Base, not to any <code>time_ns</code> variable the user might have (the same applies to <code>println</code>). Imagine the problems that could occur if the user expression <code>ex</code> also contained assignments to a variable called <code>t0</code>, or defined its own <code>time_ns</code> variable. We might get errors, or mysteriously incorrect behavior.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、<code>t0</code>、<code>t1</code>、および<code>val</code>をプライベートな一時変数にしたいと考えており、<code>time_ns</code>はユーザーが持っているかもしれない<code>time_ns</code>変数ではなく、Julia Baseの<a href="../../base/base/index.html#Base.time_ns"><code>time_ns</code></a>関数を参照する必要があります（<code>println</code>にも同様が適用されます）。ユーザーの式<code>ex</code>が<code>t0</code>という変数への代入を含んでいたり、独自の<code>time_ns</code>変数を定義していた場合に発生する可能性のある問題を想像してみてください。エラーが発生したり、神秘的に不正確な動作が起こるかもしれません。</span></p><p data-translated="true"><span class="original-text">Julia's macro expander solves these problems in the following way. First, variables within a macro result are classified as either local or global. A variable is considered local if it is assigned to (and not declared global), declared local, or used as a function argument name. Otherwise, it is considered global. Local variables are then renamed to be unique (using the <a href="../../base/base/index.html#Base.gensym"><code>gensym</code></a> function, which generates new symbols), and global variables are resolved within the macro definition environment. Therefore both of the above concerns are handled; the macro's locals will not conflict with any user variables, and <code>time_ns</code> and <code>println</code> will refer to the Julia Base definitions.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaのマクロ展開器は、これらの問題を次のように解決します。まず、マクロの結果内の変数は、ローカルまたはグローバルのいずれかに分類されます。変数は、代入されている（グローバルとして宣言されていない）、ローカルとして宣言されている、または関数引数名として使用されている場合はローカルと見なされます。それ以外の場合はグローバルと見なされます。ローカル変数は一意になるように名前が変更され（新しいシンボルを生成する<a href="../../base/base/index.html#Base.gensym"><code>gensym</code></a>関数を使用）、グローバル変数はマクロ定義環境内で解決されます。したがって、上記の2つの懸念は処理されます。マクロのローカルはユーザー変数と衝突せず、<code>time_ns</code>と<code>println</code>はJulia Baseの定義を参照します。</span></p><p data-translated="true"><span class="original-text">One problem remains however. Consider the following use of this macro:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、1つの問題が残っています。このマクロの次の使用を考えてみてください。</span></p><pre><code class="language-julia hljs">module MyModule
import Base.@time

time_ns() = ... # compute something

@time time_ns()
end</code></pre><p data-translated="true"><span class="original-text">Here the user expression <code>ex</code> is a call to <code>time_ns</code>, but not the same <code>time_ns</code> function that the macro uses. It clearly refers to <code>MyModule.time_ns</code>. Therefore we must arrange for the code in <code>ex</code> to be resolved in the macro call environment. This is done by "escaping" the expression with <a href="../../base/base/index.html#Base.esc"><code>esc</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで、ユーザーの式<code>ex</code>は<code>time_ns</code>への呼び出しですが、マクロが使用するのとは異なる<code>time_ns</code>関数です。これは明らかに<code>MyModule.time_ns</code>を参照しています。したがって、<code>ex</code>内のコードがマクロ呼び出し環境で解決されるように手配する必要があります。これは、<a href="../../base/base/index.html#Base.esc"><code>esc</code></a>を使用して式を「エスケープ」することで行われます。</span></p><pre><code class="language-julia hljs">macro time(ex)
    ...
    local val = $(esc(ex))
    ...
end</code></pre><p data-translated="true"><span class="original-text">An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be resolved in the macro call environment.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このようにラップされた式は、マクロ展開器によってそのまま放置され、出力にそのまま貼り付けられます。したがって、マクロ呼び出し環境で解決されます。</span></p><p data-translated="true"><span class="original-text">This escaping mechanism can be used to "violate" hygiene when necessary, in order to introduce or manipulate user variables. For example, the following macro sets <code>x</code> to zero in the call environment:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このエスケープ機構は、必要に応じてユーザー変数を導入または操作するために「違反」するために使用できます。例えば、次のマクロは呼び出し環境で<code>x</code>をゼロに設定します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; macro zerox()
           return esc(:(x = 0))
       end
@zerox (macro with 1 method)

julia&gt; function foo()
           x = 1
           @zerox
           return x # is zero
       end
foo (generic function with 1 method)

julia&gt; foo()
0</code></pre><p data-translated="true"><span class="original-text">This kind of manipulation of variables should be used judiciously, but is occasionally quite handy.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この種の変数の操作は慎重に使用すべきですが、時には非常に便利です。</span></p><p data-translated="true"><span class="original-text">Getting the hygiene rules correct can be a formidable challenge. Before using a macro, you might want to consider whether a function closure would be sufficient. Another useful strategy is to defer as much work as possible to runtime. For example, many macros simply wrap their arguments in a <code>QuoteNode</code> or other similar <a href="../../base/base/index.html#Core.Expr"><code>Expr</code></a>. Some examples of this include <code>@task body</code> which simply returns <code>schedule(Task(() -&gt; $body))</code>, and <code>@eval expr</code>, which simply returns <code>eval(QuoteNode(expr))</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ハイジーンルールを正しく理解することは非常に困難な課題です。マクロを使用する前に、関数クロージャが十分であるかどうかを考慮することをお勧めします。もう一つの有用な戦略は、可能な限り多くの作業をランタイムに遅延させることです。例えば、多くのマクロは単にその引数を<code>QuoteNode</code>や他の類似の<a href="../../base/base/index.html#Core.Expr"><code>Expr</code></a>でラップします。この例には、単に<code>@task body</code>が<code>schedule(Task(() -&gt; $body))</code>を返すものや、<code>@eval expr</code>が<code>eval(QuoteNode(expr))</code>を返すものが含まれます。</span></p><p data-translated="true"><span class="original-text">To demonstrate, we might rewrite the <code>@time</code> example above as:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例を示すために、上記の<code>@time</code>の例を書き換えることができます：</span></p><pre><code class="language-julia hljs">macro time(expr)
    return :(timeit(() -&gt; $(esc(expr))))
end
function timeit(f)
    t0 = time_ns()
    val = f()
    t1 = time_ns()
    println("elapsed time: ", (t1-t0)/1e9, " seconds")
    return val
end</code></pre><p data-translated="true"><span class="original-text">However, we don't do this for a good reason: wrapping the <code>expr</code> in a new scope block (the anonymous function) also slightly changes the meaning of the expression (the scope of any variables in it), while we want <code>@time</code> to be usable with minimum impact on the wrapped code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、私たちは良い理由からこれを行いません：<code>expr</code>を新しいスコープブロック（匿名関数）でラップすることは、式の意味（その中の変数のスコープ）をわずかに変更しますが、<code>@time</code>はラップされたコードに最小限の影響で使用できるようにしたいのです。</span></p><h3 id="Macros-and-dispatch" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Macros-and-dispatch">Macros and dispatch</a><a id="Macros-and-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Macros-and-dispatch" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Macros-and-dispatch">マクロとディスパッチ</a><a id="Macros-and-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Macros-and-dispatch" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Macros, just like Julia functions, are generic. This means they can also have multiple method definitions, thanks to multiple dispatch:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マクロは、Juliaの関数と同様に、ジェネリックです。これは、複数のディスパッチのおかげで、複数のメソッド定義を持つことができることを意味します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; macro m end
@m (macro with 0 methods)

julia&gt; macro m(args...)
           println("$(length(args)) arguments")
       end
@m (macro with 1 method)

julia&gt; macro m(x,y)
           println("Two arguments")
       end
@m (macro with 2 methods)

julia&gt; @m "asd"
1 arguments

julia&gt; @m 1 2
Two arguments</code></pre><p data-translated="true"><span class="original-text">However one should keep in mind, that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST evaluates to at runtime:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、マクロのディスパッチは、マクロに渡されるASTの型に基づいていることを念頭に置くべきです。ASTがランタイムで評価される型ではありません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; macro m(::Int)
           println("An Integer")
       end
@m (macro with 3 methods)

julia&gt; @m 2
An Integer

julia&gt; x = 2
2

julia&gt; @m x
1 arguments</code></pre><h2 id="Code-Generation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Code-Generation">Code Generation</a><a id="Code-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Generation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Code-Generation">コード生成</a><a id="Code-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Generation" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">When a significant amount of repetitive boilerplate code is required, it is common to generate it programmatically to avoid redundancy. In most languages, this requires an extra build step, and a separate program to generate the repetitive code. In Julia, expression interpolation and <a href="../../base/base/index.html#eval"><code>eval</code></a> allow such code generation to take place in the normal course of program execution. For example, consider the following custom type</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">大量の繰り返しのボイラープレートコードが必要な場合、冗長性を避けるためにプログラム的に生成することが一般的です。ほとんどの言語では、これには追加のビルドステップと、繰り返しコードを生成するための別のプログラムが必要です。Juliaでは、式の補間と<a href="../../base/base/index.html#eval"><code>eval</code></a>により、そのようなコード生成がプログラム実行の通常の過程で行われることができます。例えば、次のカスタムタイプを考えてみてください</span></p><pre><code class="language-julia hljs">struct MyNumber
    x::Float64
end
# output
</code></pre><p data-translated="true"><span class="original-text">for which we want to add a number of methods to. We can do this programmatically in the following loop:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">私たちが追加したいメソッドの数です。これを次のループでプログラム的に行うことができます：</span></p><pre><code class="language-julia hljs">for op = (:sin, :cos, :tan, :log, :exp)
    eval(quote
        Base.$op(a::MyNumber) = MyNumber($op(a.x))
    end)
end
# output
</code></pre><p data-translated="true"><span class="original-text">and we can now use those functions with our custom type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そして、私たちは今、カスタムタイプでそれらの関数を使用できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = MyNumber(π)
MyNumber(3.141592653589793)

julia&gt; sin(x)
MyNumber(1.2246467991473532e-16)

julia&gt; cos(x)
MyNumber(-1.0)</code></pre><p data-translated="true"><span class="original-text">In this manner, Julia acts as its own <a href="https://en.wikipedia.org/wiki/Preprocessor">preprocessor</a>, and allows code generation from inside the language. The above code could be written slightly more tersely using the <code>:</code> prefix quoting form:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このようにして、Juliaは自らの<a href="https://en.wikipedia.org/wiki/Preprocessor">プリプロセッサ</a>として機能し、言語内からコード生成を可能にします。上記のコードは、<code>:</code>プレフィックス引用形式を使用して、もう少し簡潔に書くことができます：</span></p><pre><code class="language-julia hljs">for op = (:sin, :cos, :tan, :log, :exp)
    eval(:(Base.$op(a::MyNumber) = MyNumber($op(a.x))))
end</code></pre><p data-translated="true"><span class="original-text">This sort of in-language code generation, however, using the <code>eval(quote(...))</code> pattern, is common enough that Julia comes with a macro to abbreviate this pattern:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、この種の言語内コード生成は、<code>eval(quote(...))</code>パターンを使用することで一般的であり、Juliaにはこのパターンを短縮するためのマクロが付属しています：</span></p><pre><code class="language-julia hljs">for op = (:sin, :cos, :tan, :log, :exp)
    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))
end</code></pre><p data-translated="true"><span class="original-text">The <a href="../../base/base/index.html#Base.@eval"><code>@eval</code></a> macro rewrites this call to be precisely equivalent to the above longer versions. For longer blocks of generated code, the expression argument given to <a href="../../base/base/index.html#Base.@eval"><code>@eval</code></a> can be a block:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Base.@eval"><code>@eval</code></a>マクロは、この呼び出しを上記の長いバージョンと正確に同等に書き換えます。生成されたコードの長いブロックの場合、<a href="../../base/base/index.html#Base.@eval"><code>@eval</code></a>に与えられる式引数はブロックにすることができます：</span></p><pre><code class="language-julia hljs">@eval begin
    # multiple lines
end</code></pre><h2 id="meta-non-standard-string-literals" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#meta-non-standard-string-literals">Non-Standard String Literals</a><a id="meta-non-standard-string-literals-1"></a><a class="docs-heading-anchor-permalink" href="#meta-non-standard-string-literals" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#meta-non-standard-string-literals">非標準文字列リテラル</a><a id="meta-non-standard-string-literals-1"></a><a class="docs-heading-anchor-permalink" href="#meta-non-standard-string-literals" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Recall from <a href="../strings/index.html#non-standard-string-literals">Strings</a> that string literals prefixed by an identifier are called non-standard string literals, and can have different semantics than un-prefixed string literals. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../strings/index.html#non-standard-string-literals">文字列</a>から思い出してください。識別子でプレフィックスされた文字列リテラルは非標準文字列リテラルと呼ばれ、プレフィックスのない文字列リテラルとは異なる意味を持つことがあります。例えば：</span></p><ul><li data-translated="true"><span class="original-text"><code>r"^\s*(?:#|$)"</code> produces a <a href="../strings/index.html#man-regex-literals">regular expression object</a> rather than a string</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>r"^\s*(?:#|$)"</code>は文字列ではなく<a href="../strings/index.html#man-regex-literals">正規表現オブジェクト</a>を生成します。</span></li><li data-translated="true"><span class="original-text"><code>b"DATA\xff\u2200"</code> is a <a href="../strings/index.html#man-byte-array-literals">byte array literal</a> for <code>[68,65,84,65,255,226,136,128]</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>b"DATA\xff\u2200"</code>は<code>[68,65,84,65,255,226,136,128]</code>のための<a href="../strings/index.html#man-byte-array-literals">バイト配列リテラル</a>です。</span></li></ul><p data-translated="true"><span class="original-text">Perhaps surprisingly, these behaviors are not hard-coded into the Julia parser or compiler. Instead, they are custom behaviors provided by a general mechanism that anyone can use: prefixed string literals are parsed as calls to specially-named macros. For example, the regular expression macro is just the following:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">驚くべきことに、これらの動作はJuliaのパーサーやコンパイラにハードコーディングされているわけではありません。代わりに、プレフィックス付き文字列リテラルは特別に名前付けされたマクロへの呼び出しとして解析される一般的なメカニズムによって提供されるカスタム動作です。例えば、正規表現マクロは次のようになります：</span></p><pre><code class="language-julia hljs">macro r_str(p)
    Regex(p)
end</code></pre><p data-translated="true"><span class="original-text">That's all. This macro says that the literal contents of the string literal <code>r"^\s*(?:#|$)"</code> should be passed to the <code>@r_str</code> macro and the result of that expansion should be placed in the syntax tree where the string literal occurs. In other words, the expression <code>r"^\s*(?:#|$)"</code> is equivalent to placing the following object directly into the syntax tree:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">以上です。このマクロは、文字列リテラル <code>r"^\s*(?:#|$)"</code> のリテラル内容が <code>@r_str</code> マクロに渡され、その展開結果が文字列リテラルが出現する構文木に配置されるべきであることを示しています。言い換えれば、式 <code>r"^\s*(?:#|$)"</code> は、次のオブジェクトを構文木に直接配置することと同等です：</span></p><pre><code class="language-julia hljs">Regex("^\\s*(?:#|\$)")</code></pre><p data-translated="true"><span class="original-text">Not only is the string literal form shorter and far more convenient, but it is also more efficient: since the regular expression is compiled and the <code>Regex</code> object is actually created <em>when the code is compiled</em>, the compilation occurs only once, rather than every time the code is executed. Consider if the regular expression occurs in a loop:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列リテラル形式は短く、はるかに便利であるだけでなく、効率も良いです。正規表現はコンパイルされ、<code>Regex</code> オブジェクトは実際に <em>コードがコンパイルされるときに</em> 作成されるため、コンパイルはコードが実行されるたびではなく、一度だけ行われます。正規表現がループ内で発生する場合を考えてみてください：</span></p><pre><code class="language-julia hljs">for line = lines
    m = match(r"^\s*(?:#|$)", line)
    if m === nothing
        # non-comment
    else
        # comment
    end
end</code></pre><p data-translated="true"><span class="original-text">Since the regular expression <code>r"^\s*(?:#|$)"</code> is compiled and inserted into the syntax tree when this code is parsed, the expression is only compiled once instead of each time the loop is executed. In order to accomplish this without macros, one would have to write this loop like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">正規表現 <code>r"^\s*(?:#|$)"</code> は、このコードが解析されるときにコンパイルされ、構文木に挿入されるため、式はループが実行されるたびではなく、一度だけコンパイルされます。これをマクロなしで実現するには、次のようにループを書く必要があります：</span></p><pre><code class="language-julia hljs">re = Regex("^\\s*(?:#|\$)")
for line = lines
    m = match(re, line)
    if m === nothing
        # non-comment
    else
        # comment
    end
end</code></pre><p data-translated="true"><span class="original-text">Moreover, if the compiler could not determine that the regex object was constant over all loops, certain optimizations might not be possible, making this version still less efficient than the more convenient literal form above. Of course, there are still situations where the non-literal form is more convenient: if one needs to interpolate a variable into the regular expression, one must take this more verbose approach; in cases where the regular expression pattern itself is dynamic, potentially changing upon each loop iteration, a new regular expression object must be constructed on each iteration. In the vast majority of use cases, however, regular expressions are not constructed based on run-time data. In this majority of cases, the ability to write regular expressions as compile-time values is invaluable.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さらに、コンパイラが正規表現オブジェクトがすべてのループで定数であることを判断できない場合、特定の最適化が不可能になる可能性があり、このバージョンは上記の便利なリテラル形式よりも効率が悪くなります。もちろん、非リテラル形式がより便利な状況もあります。正規表現に変数を補間する必要がある場合は、より冗長なアプローチを取らなければなりません。また、正規表現パターン自体が動的で、各ループの反復ごとに変更される可能性がある場合は、各反復で新しい正規表現オブジェクトを構築する必要があります。しかし、ほとんどの使用ケースでは、正規表現は実行時データに基づいて構築されることはありません。この大多数のケースでは、コンパイル時値として正規表現を書く能力は非常に貴重です。</span></p><p data-translated="true"><span class="original-text">The mechanism for user-defined string literals is deeply, profoundly powerful. Not only are Julia's non-standard literals implemented using it, but the command literal syntax (<code>`echo "Hello, $person"`</code>) is also implemented using the following innocuous-looking macro:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ユーザー定義の文字列リテラルのメカニズムは、非常に強力です。ジュリアの非標準リテラルはこれを使用して実装されているだけでなく、コマンドリテラル構文 (<code>`echo "Hello, $person"`</code>) も次の無害に見えるマクロを使用して実装されています：</span></p><pre><code class="language-julia hljs">macro cmd(str)
    :(cmd_gen($(shell_parse(str)[1])))
end</code></pre><p data-translated="true"><span class="original-text">Of course, a large amount of complexity is hidden in the functions used in this macro definition, but they are just functions, written entirely in Julia. You can read their source and see precisely what they do – and all they do is construct expression objects to be inserted into your program's syntax tree.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もちろん、このマクロ定義で使用される関数には多くの複雑さが隠されていますが、それらはすべてジュリアで書かれた関数です。ソースを読むことができ、正確に何をしているかを見ることができます。そして、彼らが行うことは、プログラムの構文木に挿入される式オブジェクトを構築することだけです。</span></p><p data-translated="true"><span class="original-text">Like string literals, command literals can also be prefixed by an identifier to form what are called non-standard command literals. These command literals are parsed as calls to specially-named macros. For example, the syntax <code>custom`literal`</code> is parsed as <code>@custom_cmd "literal"</code>. Julia itself does not contain any non-standard command literals, but packages can make use of this syntax. Aside from the different syntax and the <code>_cmd</code> suffix instead of the <code>_str</code> suffix, non-standard command literals behave exactly like non-standard string literals.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列リテラルと同様に、コマンドリテラルも識別子でプレフィックスを付けて非標準コマンドリテラルと呼ばれるものを形成できます。これらのコマンドリテラルは、特別に名前付けされたマクロへの呼び出しとして解析されます。たとえば、構文 <code>custom`literal`</code> は <code>@custom_cmd "literal"</code> として解析されます。ジュリア自体には非標準コマンドリテラルは含まれていませんが、パッケージはこの構文を利用できます。異なる構文と <code>_cmd</code> サフィックスが <code>_str</code> サフィックスの代わりに使用されることを除けば、非標準コマンドリテラルは非標準文字列リテラルとまったく同じように動作します。</span></p><p data-translated="true"><span class="original-text">In the event that two modules provide non-standard string or command literals with the same name, it is possible to qualify the string or command literal with a module name. For instance, if both <code>Foo</code> and <code>Bar</code> provide non-standard string literal <code>@x_str</code>, then one can write <code>Foo.x"literal"</code> or <code>Bar.x"literal"</code> to disambiguate between the two.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">2つのモジュールが同じ名前の非標準文字列またはコマンドリテラルを提供する場合、モジュール名で文字列またはコマンドリテラルを修飾することが可能です。たとえば、<code>Foo</code> と <code>Bar</code> の両方が非標準文字列リテラル <code>@x_str</code> を提供している場合、<code>Foo.x"literal"</code> または <code>Bar.x"literal"</code> と書くことで、両者を区別できます。</span></p><p data-translated="true"><span class="original-text">Another way to define a macro would be like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マクロを定義する別の方法は次のようになります：</span></p><pre><code class="language-julia hljs">macro foo_str(str, flag)
    # do stuff
end</code></pre><p data-translated="true"><span class="original-text">This macro can then be called with the following syntax:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このマクロは次の構文で呼び出すことができます：</span></p><pre><code class="language-julia hljs">foo"str"flag</code></pre><p data-translated="true"><span class="original-text">The type of flag in the above mentioned syntax would be a <code>String</code> with contents of whatever trails after the string literal.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記の構文におけるフラグのタイプは、文字列リテラルの後に続く内容を持つ<code>String</code>です。</span></p><h2 id="Generated-functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Generated-functions">Generated functions</a><a id="Generated-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Generated-functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Generated-functions">生成された関数</a><a id="Generated-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Generated-functions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">A very special macro is <a href="../../base/base/index.html#Base.@generated"><code>@generated</code></a>, which allows you to define so-called <em>generated functions</em>. These have the capability to generate specialized code depending on the types of their arguments with more flexibility and/or less code than what can be achieved with multiple dispatch. While macros work with expressions at parse time and cannot access the types of their inputs, a generated function gets expanded at a time when the types of the arguments are known, but the function is not yet compiled.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">非常に特別なマクロは<a href="../../base/base/index.html#Base.@generated"><code>@generated</code></a>で、いわゆる<em>生成された関数</em>を定義することを可能にします。これらは、引数の型に応じて特化したコードを生成する能力を持ち、複数のディスパッチで達成できるよりも柔軟性があり、または少ないコードで実現できます。マクロはパース時に式で動作し、入力の型にアクセスできませんが、生成された関数は引数の型が知られている時点で展開されますが、関数はまだコンパイルされていません。</span></p><p data-translated="true"><span class="original-text">Instead of performing some calculation or action, a generated function declaration returns a quoted expression which then forms the body for the method corresponding to the types of the arguments. When a generated function is called, the expression it returns is compiled and then run. To make this efficient, the result is usually cached. And to make this inferable, only a limited subset of the language is usable. Thus, generated functions provide a flexible way to move work from run time to compile time, at the expense of greater restrictions on allowed constructs.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">何らかの計算やアクションを実行する代わりに、生成された関数の宣言は引用された式を返し、それが引数の型に対応するメソッドの本体を形成します。生成された関数が呼び出されると、返された式がコンパイルされて実行されます。これを効率的にするために、結果は通常キャッシュされます。また、これを推論可能にするために、使用できる言語のサブセットは限られています。したがって、生成された関数は、許可される構造に対する制限が大きくなる代わりに、実行時からコンパイル時に作業を移動する柔軟な方法を提供します。</span></p><p data-translated="true"><span class="original-text">When defining generated functions, there are five main differences to ordinary functions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">生成された関数を定義する際には、通常の関数とは5つの主な違いがあります：</span></p><ol><li data-translated="true"><span class="original-text">You annotate the function declaration with the <code>@generated</code> macro. This adds some information to the AST that lets the compiler know that this is a generated function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数宣言に<code>@generated</code>マクロを注釈します。これにより、コンパイラがこれが生成された関数であることを知るための情報がASTに追加されます。</span></li><li data-translated="true"><span class="original-text">In the body of the generated function you only have access to the <em>types</em> of the arguments – not their values.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">生成された関数の本体では、引数の<em>型</em>にのみアクセスできます - 値にはアクセスできません。</span></li><li data-translated="true"><span class="original-text">Instead of calculating something or performing some action, you return a <em>quoted expression</em> which, when evaluated, does what you want.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">何かを計算したりアクションを実行する代わりに、評価されるとあなたが望むことを行う<em>引用された式</em>を返します。</span></li><li data-translated="true"><span class="original-text">Generated functions are only permitted to call functions that were defined <em>before</em> the definition of the generated function. (Failure to follow this may result in getting <code>MethodErrors</code> referring to functions from a future world-age.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">生成された関数は、生成された関数の定義<em>前に</em>定義された関数のみを呼び出すことが許可されています。（これに従わないと、未来のワールドエイジの関数を参照する<code>MethodErrors</code>が発生する可能性があります。）</span></li><li data-translated="true"><span class="original-text">Generated functions must not <em>mutate</em> or <em>observe</em> any non-constant global state (including, for example, IO, locks, non-local dictionaries, or using <a href="../../base/base/index.html#Base.hasmethod"><code>hasmethod</code></a>). This means they can only read global constants, and cannot have any side effects. In other words, they must be completely pure. Due to an implementation limitation, this also means that they currently cannot define a closure or generator.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">生成された関数は、非定数のグローバル状態（例えば、IO、ロック、非ローカル辞書、または<a href="../../base/base/index.html#Base.hasmethod"><code>hasmethod</code></a>を使用することを含む）を<em>変更</em>したり<em>観察</em>したりしてはいけません。これは、グローバル定数を読み取ることしかできず、副作用を持つことができないことを意味します。言い換えれば、完全に純粋でなければなりません。実装の制限により、現在はクロージャやジェネレーターを定義することもできません。</span></li></ol><p data-translated="true"><span class="original-text">It's easiest to illustrate this with an example. We can declare a generated function <code>foo</code> as</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これを例で示すのが最も簡単です。生成された関数<code>foo</code>を次のように宣言できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; @generated function foo(x)
           Core.println(x)
           return :(x * x)
       end
foo (generic function with 1 method)</code></pre><p data-translated="true"><span class="original-text">Note that the body returns a quoted expression, namely <code>:(x * x)</code>, rather than just the value of <code>x * x</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ボディは、単に<code>x * x</code>の値ではなく、引用された式<code>:(x * x)</code>を返すことに注意してください。</span></p><p data-translated="true"><span class="original-text">From the caller's perspective, this is identical to a regular function; in fact, you don't have to know whether you're calling a regular or generated function. Let's see how <code>foo</code> behaves:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">呼び出し元の視点から見ると、これは通常の関数と同じです。実際、通常の関数を呼び出しているのか生成された関数を呼び出しているのかを知る必要はありません。<code>foo</code>がどのように動作するか見てみましょう。</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = foo(2); # note: output is from println() statement in the body
Int64

julia&gt; x           # now we print x
4

julia&gt; y = foo("bar");
String

julia&gt; y
"barbar"</code></pre><p data-translated="true"><span class="original-text">So, we see that in the body of the generated function, <code>x</code> is the <em>type</em> of the passed argument, and the value returned by the generated function, is the result of evaluating the quoted expression we returned from the definition, now with the <em>value</em> of <code>x</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、生成された関数のボディ内では、<code>x</code>は渡された引数の<em>型</em>であり、生成された関数が返す値は、定義から返された引用された式を、<em>値</em>としての<code>x</code>で評価した結果です。</span></p><p data-translated="true"><span class="original-text">What happens if we evaluate <code>foo</code> again with a type that we have already used?</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すでに使用した型で<code>foo</code>を再評価するとどうなりますか？</span></p><pre><code class="language-julia-repl hljs">julia&gt; foo(4)
16</code></pre><p data-translated="true"><span class="original-text">Note that there is no printout of <a href="../../base/numbers/index.html#Core.Int64"><code>Int64</code></a>. We can see that the body of the generated function was only executed once here, for the specific set of argument types, and the result was cached. After that, for this example, the expression returned from the generated function on the first invocation was re-used as the method body. However, the actual caching behavior is an implementation-defined performance optimization, so it is invalid to depend too closely on this behavior.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/numbers/index.html#Core.Int64"><code>Int64</code></a>の出力はありません。ここでは、生成された関数のボディが特定の引数型のセットに対してのみ一度実行され、その結果がキャッシュされたことがわかります。その後、この例では、最初の呼び出しから生成された関数が返した式がメソッドボディとして再利用されました。ただし、実際のキャッシング動作は実装依存のパフォーマンス最適化であるため、この動作に過度に依存することは無効です。</span></p><p data-translated="true"><span class="original-text">The number of times a generated function is generated <em>might</em> be only once, but it <em>might</em> also be more often, or appear to not happen at all. As a consequence, you should <em>never</em> write a generated function with side effects - when, and how often, the side effects occur is undefined. (This is true for macros too - and just like for macros, the use of <a href="../../base/base/index.html#eval"><code>eval</code></a> in a generated function is a sign that you're doing something the wrong way.) However, unlike macros, the runtime system cannot correctly handle a call to <a href="../../base/base/index.html#eval"><code>eval</code></a>, so it is disallowed.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">生成された関数が生成される回数は<em>一度だけ</em>である可能性がありますが、<em>もっと頻繁</em>である可能性もありますし、全く発生しないように見えることもあります。その結果、<em>副作用</em>を持つ生成された関数を書くことは<em>決して</em>してはいけません。副作用がいつ、どのくらいの頻度で発生するかは未定義です。（これはマクロにも当てはまります - マクロと同様に、生成された関数内での<a href="../../base/base/index.html#eval"><code>eval</code></a>の使用は、間違った方法で何かをしているサインです。）ただし、マクロとは異なり、ランタイムシステムは<a href="../../base/base/index.html#eval"><code>eval</code></a>への呼び出しを正しく処理できないため、これは許可されていません。</span></p><p data-translated="true"><span class="original-text">It is also important to see how <code>@generated</code> functions interact with method redefinition. Following the principle that a correct <code>@generated</code> function must not observe any mutable state or cause any mutation of global state, we see the following behavior. Observe that the generated function <em>cannot</em> call any method that was not defined prior to the <em>definition</em> of the generated function itself.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@generated</code>関数がメソッドの再定義とどのように相互作用するかを見ることも重要です。正しい<code>@generated</code>関数は、可変状態を観察したり、グローバル状態を変更したりしてはいけないという原則に従い、次のような動作が見られます。生成された関数は、生成された関数自体の<em>定義</em>以前に定義されていないメソッドを<em>呼び出すことができない</em>ことに注意してください。</span></p><p data-translated="true"><span class="original-text">Initially <code>f(x)</code> has one definition</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初に<code>f(x)</code>には1つの定義があります。</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = "original definition";</code></pre><p data-translated="true"><span class="original-text">Define other operations that use <code>f(x)</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>f(x)</code>を使用する他の操作を定義します:</span></p><pre><code class="language-julia-repl hljs">julia&gt; g(x) = f(x);

julia&gt; @generated gen1(x) = f(x);

julia&gt; @generated gen2(x) = :(f(x));</code></pre><p data-translated="true"><span class="original-text">We now add some new definitions for <code>f(x)</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで、<code>f(x)</code>の新しい定義をいくつか追加します:</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(x::Int) = "definition for Int";

julia&gt; f(x::Type{Int}) = "definition for Type{Int}";</code></pre><p data-translated="true"><span class="original-text">and compare how these results differ:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そして、これらの結果がどのように異なるかを比較します:</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(1)
"definition for Int"

julia&gt; g(1)
"definition for Int"

julia&gt; gen1(1)
"original definition"

julia&gt; gen2(1)
"definition for Int"</code></pre><p data-translated="true"><span class="original-text">Each method of a generated function has its own view of defined functions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">生成された関数の各メソッドは、定義された関数の独自の見方を持っています:</span></p><pre><code class="language-julia-repl hljs">julia&gt; @generated gen1(x::Real) = f(x);

julia&gt; gen1(1)
"definition for Type{Int}"</code></pre><p data-translated="true"><span class="original-text">The example generated function <code>foo</code> above did not do anything a normal function <code>foo(x) = x * x</code> could not do (except printing the type on the first invocation, and incurring higher overhead). However, the power of a generated function lies in its ability to compute different quoted expressions depending on the types passed to it:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記の例の生成された関数<code>foo</code>は、通常の関数<code>foo(x) = x * x</code>ができないことは何もしていません（最初の呼び出し時に型を印刷することと、より高いオーバーヘッドを伴うことを除いて）。しかし、生成された関数の力は、渡された型に応じて異なる引用された式を計算する能力にあります:</span></p><pre><code class="language-julia-repl hljs">julia&gt; @generated function bar(x)
           if x &lt;: Integer
               return :(x ^ 2)
           else
               return :(x)
           end
       end
bar (generic function with 1 method)

julia&gt; bar(4)
16

julia&gt; bar("baz")
"baz"</code></pre><p data-translated="true"><span class="original-text">(although of course this contrived example would be more easily implemented using multiple dispatch...)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(もちろん、この作り話の例は、複数のディスパッチを使用してより簡単に実装できます...)</span></p><p data-translated="true"><span class="original-text">Abusing this will corrupt the runtime system and cause undefined behavior:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これを乱用すると、ランタイムシステムが破損し、未定義の動作を引き起こします:</span></p><pre><code class="language-julia-repl hljs">julia&gt; @generated function baz(x)
           if rand() &lt; .9
               return :(x^2)
           else
               return :("boo!")
           end
       end
baz (generic function with 1 method)</code></pre><p data-translated="true"><span class="original-text">Since the body of the generated function is non-deterministic, its behavior, <em>and the behavior of all subsequent code</em> is undefined.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">生成された関数の本体は非決定的であるため、その動作、<em>およびその後のすべてのコードの動作</em>は未定義です。</span></p><p data-translated="true"><span class="original-text"><em>Don't copy these examples!</em></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><em>これらの例をコピーしないでください!</em></span></p><p data-translated="true"><span class="original-text">These examples are hopefully helpful to illustrate how generated functions work, both in the definition end and at the call site; however, <em>don't copy them</em>, for the following reasons:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの例は、生成された関数がどのように機能するかを、定義の側と呼び出しサイトの両方で示すのに役立つことを願っています。ただし、<em>これらをコピーしないでください</em>、以下の理由から:</span></p><ul><li data-translated="true"><span class="original-text">the <code>foo</code> function has side-effects (the call to <code>Core.println</code>), and it is undefined exactly when, how often or how many times these side-effects will occur</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>foo</code>関数には副作用があります（<code>Core.println</code>への呼び出し）し、これらの副作用がいつ、どのくらいの頻度で、または何回発生するかは正確には未定義です。</span></li><li data-translated="true"><span class="original-text">the <code>bar</code> function solves a problem that is better solved with multiple dispatch - defining <code>bar(x) = x</code> and <code>bar(x::Integer) = x ^ 2</code> will do the same thing, but it is both simpler and faster.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>bar</code>関数は、複数のディスパッチで解決する方が良い問題を解決します - <code>bar(x) = x</code>と<code>bar(x::Integer) = x ^ 2</code>を定義することで同じことができますが、これはより簡単で速いです。</span></li><li data-translated="true"><span class="original-text">the <code>baz</code> function is pathological</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>baz</code>関数は病的です。</span></li></ul><p data-translated="true"><span class="original-text">Note that the set of operations that should not be attempted in a generated function is unbounded, and the runtime system can currently only detect a subset of the invalid operations. There are many other operations that will simply corrupt the runtime system without notification, usually in subtle ways not obviously connected to the bad definition. Because the function generator is run during inference, it must respect all of the limitations of that code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">生成された関数で試みるべきでない操作のセットは無限であり、ランタイムシステムは現在、無効な操作のサブセットしか検出できません。他にも多くの操作があり、通知なしにランタイムシステムを単に破損させることがありますが、通常は悪い定義に明らかに関連しない微妙な方法で発生します。関数ジェネレーターは推論中に実行されるため、そのコードのすべての制限を尊重しなければなりません。</span></p><p data-translated="true"><span class="original-text">Some operations that should not be attempted include:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">試みるべきでない操作には以下が含まれます：</span></p><ol><li><p data-translated="true"><span class="original-text">Caching of native pointers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ネイティブポインタのキャッシング。</span></p></li><li><p data-translated="true"><span class="original-text">Interacting with the contents or methods of <code>Core.Compiler</code> in any way.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Core.Compiler</code>の内容やメソッドに何らかの形で相互作用すること。</span></p></li><li><p data-translated="true"><span class="original-text">Observing any mutable state.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">可変状態を観察すること。</span></p><ul><li data-translated="true"><span class="original-text">Inference on the generated function may be run at <em>any</em> time, including while your code is attempting to observe or mutate this state.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">生成された関数の推論は<em>いつでも</em>実行される可能性があり、あなたのコードがこの状態を観察または変更しようとしている間に実行されることもあります。</span></li></ul></li><li><p data-translated="true"><span class="original-text">Taking any locks: C code you call out to may use locks internally, (for example, it is not problematic to call <code>malloc</code>, even though most implementations require locks internally) but don't attempt to hold or acquire any while executing Julia code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ロックを取得すること：呼び出すCコードは内部でロックを使用する場合があります（例えば、<code>malloc</code>を呼び出すことは問題ありませんが、ほとんどの実装は内部でロックを必要とします）が、Juliaコードを実行中にロックを保持または取得しようとしないでください。</span></p></li><li><p data-translated="true"><span class="original-text">Calling any function that is defined after the body of the generated function. This condition is relaxed for incrementally-loaded precompiled modules to allow calling any function in the module.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">生成された関数の本体の後に定義された任意の関数を呼び出すこと。この条件は、モジュール内の任意の関数を呼び出すことを許可するために、インクリメンタルにロードされたプリコンパイルモジュールに対して緩和されます。</span></p></li></ol><p data-translated="true"><span class="original-text">Alright, now that we have a better understanding of how generated functions work, let's use them to build some more advanced (and valid) functionality...</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さて、生成関数の動作についてより良い理解が得られたので、これを使ってもう少し高度で（かつ有効な）機能を構築してみましょう...</span></p><h3 id="An-advanced-example" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#An-advanced-example">An advanced example</a><a id="An-advanced-example-1"></a><a class="docs-heading-anchor-permalink" href="#An-advanced-example" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#An-advanced-example">高度な例</a><a id="An-advanced-example-1"></a><a class="docs-heading-anchor-permalink" href="#An-advanced-example" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Julia's base library has an internal <code>sub2ind</code> function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index <code>i</code> that can be used to index into an array <code>A</code> using <code>A[i]</code>, instead of <code>A[x,y,z,...]</code>. One possible implementation is the following:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの基本ライブラリには、n次元配列への線形インデックスを計算するための内部<code>sub2ind</code>関数があります。これは、n個の多重線形インデックスのセットに基づいています。言い換えれば、<code>A[i]</code>を使用して配列<code>A</code>にインデックスを付けるために使用できるインデックス<code>i</code>を計算します。<code>A[x,y,z,...]</code>の代わりに。可能な実装の一例は以下の通りです。</span></p><pre><code class="language-julia-repl hljs">julia&gt; function sub2ind_loop(dims::NTuple{N}, I::Integer...) where N
           ind = I[N] - 1
           for i = N-1:-1:1
               ind = I[i]-1 + dims[i]*ind
           end
           return ind + 1
       end;

julia&gt; sub2ind_loop((3, 5), 1, 2)
4</code></pre><p data-translated="true"><span class="original-text">The same thing can be done using recursion:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同じことを再帰を使用して行うこともできます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; sub2ind_rec(dims::Tuple{}) = 1;

julia&gt; sub2ind_rec(dims::Tuple{}, i1::Integer, I::Integer...) =
           i1 == 1 ? sub2ind_rec(dims, I...) : throw(BoundsError());

julia&gt; sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer) = i1;

julia&gt; sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer, I::Integer...) =
           i1 + dims[1] * (sub2ind_rec(Base.tail(dims), I...) - 1);

julia&gt; sub2ind_rec((3, 5), 1, 2)
4</code></pre><p data-translated="true"><span class="original-text">Both these implementations, although different, do essentially the same thing: a runtime loop over the dimensions of the array, collecting the offset in each dimension into the final index.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの実装は異なりますが、基本的には同じことを行っています：配列の次元に対するランタイムループを実行し、各次元のオフセットを最終インデックスに集めます。</span></p><p data-translated="true"><span class="original-text">However, all the information we need for the loop is embedded in the type information of the arguments. This allows the compiler to move the iteration to compile time and eliminate the runtime loops altogether. We can utilize generated functions to achieve a similar effect; in compiler parlance, we use generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating the linear index, we build up an <em>expression</em> that calculates the index:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、ループに必要なすべての情報は、引数の型情報に埋め込まれています。これにより、コンパイラはイテレーションをコンパイル時に移動し、ランタイムループを完全に排除することができます。生成関数を利用して同様の効果を達成できます。コンパイラ用語では、生成関数を使用してループを手動で展開します。本文はほぼ同じになりますが、線形インデックスを計算する代わりに、インデックスを計算する<em>式</em>を構築します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end;

julia&gt; sub2ind_gen((3, 5), 1, 2)
4</code></pre><p data-translated="true"><span class="original-text"><strong>What code will this generate?</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>このコードは何を生成しますか？</strong></span></p><p data-translated="true"><span class="original-text">An easy way to find out is to extract the body into another (regular) function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単な方法は、本文を別の（通常の）関数に抽出することです:</span></p><pre><code class="language-julia-repl hljs">julia&gt; function sub2ind_gen_impl(dims::Type{T}, I...) where T &lt;: NTuple{N,Any} where N
           length(I) == N || return :(error("partial indexing is unsupported"))
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end;

julia&gt; @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           return sub2ind_gen_impl(dims, I...)
       end;

julia&gt; sub2ind_gen((3, 5), 1, 2)
4</code></pre><p data-translated="true"><span class="original-text">We can now execute <code>sub2ind_gen_impl</code> and examine the expression it returns:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これで、<code>sub2ind_gen_impl</code>を実行し、返される式を調べることができます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; sub2ind_gen_impl(Tuple{Int,Int}, Int, Int)
:(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1)</code></pre><p data-translated="true"><span class="original-text">So, the method body that will be used here doesn't include a loop at all - just indexing into the two tuples, multiplication and addition/subtraction. All the looping is performed compile-time, and we avoid looping during execution entirely. Thus, we only loop <em>once per type</em>, in this case once per <code>N</code> (except in edge cases where the function is generated more than once - see disclaimer above).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、ここで使用されるメソッド本体にはループが全く含まれていません - ただ2つのタプルへのインデックス付け、乗算、加算/減算のみです。すべてのループ処理はコンパイル時に行われ、実行中のループを完全に回避します。したがって、<em>型ごとに1回だけ</em>ループします。この場合、<code>N</code>ごとに1回（関数が複数回生成されるエッジケースを除く - 上記の免責事項を参照）。</span></p><h3 id="Optionally-generated-functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Optionally-generated-functions">Optionally-generated functions</a><a id="Optionally-generated-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Optionally-generated-functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Optionally-generated-functions">オプションで生成された関数</a><a id="Optionally-generated-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Optionally-generated-functions" title="パーマリンク"></a></span></h3><p data-translated="true"><span class="original-text">Generated functions can achieve high efficiency at run time, but come with a compile time cost: a new function body must be generated for every combination of concrete argument types. Typically, Julia is able to compile "generic" versions of functions that will work for any arguments, but with generated functions this is impossible. This means that programs making heavy use of generated functions might be impossible to statically compile.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">生成された関数は実行時に高い効率を達成できますが、コンパイル時のコストが伴います：具体的な引数の型のすべての組み合わせに対して新しい関数本体を生成する必要があります。通常、Juliaは任意の引数に対して機能する「ジェネリック」バージョンの関数をコンパイルできますが、生成された関数ではこれは不可能です。これは、生成された関数を多く使用するプログラムが静的にコンパイルできない可能性があることを意味します。</span></p><p data-translated="true"><span class="original-text">To solve this problem, the language provides syntax for writing normal, non-generated alternative implementations of generated functions. Applied to the <code>sub2ind</code> example above, it would look like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この問題を解決するために、言語は生成された関数の通常の非生成代替実装を書くための構文を提供します。上記の<code>sub2ind</code>の例に適用すると、次のようになります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function sub2ind_gen_impl(dims::Type{T}, I...) where T &lt;: NTuple{N,Any} where N
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end;

julia&gt; function sub2ind_gen_fallback(dims::NTuple{N}, I) where N
           ind = I[N] - 1
           for i = (N - 1):-1:1
               ind = I[i] - 1 + dims[i]*ind
           end
           return ind + 1
       end;

julia&gt; function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           length(I) == N || error("partial indexing is unsupported")
           if @generated
               return sub2ind_gen_impl(dims, I...)
           else
               return sub2ind_gen_fallback(dims, I)
           end
       end;

julia&gt; sub2ind_gen((3, 5), 1, 2)
4</code></pre><p data-translated="true"><span class="original-text">Internally, this code creates two implementations of the function: a generated one where the first block in <code>if @generated</code> is used, and a normal one where the <code>else</code> block is used. Inside the <code>then</code> part of the <code>if @generated</code> block, code has the same semantics as other generated functions: argument names refer to types, and the code should return an expression. Multiple <code>if @generated</code> blocks may occur, in which case the generated implementation uses all of the <code>then</code> blocks and the alternate implementation uses all of the <code>else</code> blocks.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">内部的に、このコードは関数の2つの実装を作成します：最初のブロックが<code>if @generated</code>で使用される生成されたものと、<code>else</code>ブロックが使用される通常のものです。<code>if @generated</code>ブロックの<code>then</code>部分の内部では、コードは他の生成された関数と同じ意味を持ちます：引数名は型を参照し、コードは式を返す必要があります。複数の<code>if @generated</code>ブロックが発生する場合、生成された実装はすべての<code>then</code>ブロックを使用し、代替実装はすべての<code>else</code>ブロックを使用します。</span></p><p data-translated="true"><span class="original-text">Notice that we added an error check to the top of the function. This code will be common to both versions, and is run-time code in both versions (it will be quoted and returned as an expression from the generated version). That means that the values and types of local variables are not available at code generation time –- the code-generation code can only see the types of arguments.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数の先頭にエラーチェックを追加したことに注意してください。このコードは両方のバージョンに共通であり、両方のバージョンで実行時コードです（生成されたバージョンから式として引用され、返されます）。つまり、ローカル変数の値と型はコード生成時には利用できません –– コード生成コードは引数の型しか見ることができません。</span></p><p data-translated="true"><span class="original-text">In this style of definition, the code generation feature is essentially an optional optimization. The compiler will use it if convenient, but otherwise may choose to use the normal implementation instead. This style is preferred, since it allows the compiler to make more decisions and compile programs in more ways, and since normal code is more readable than code-generating code. However, which implementation is used depends on compiler implementation details, so it is essential for the two implementations to behave identically.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この定義スタイルでは、コード生成機能は本質的にオプションの最適化です。コンパイラは便利な場合にそれを使用しますが、そうでない場合は通常の実装を使用することを選択するかもしれません。このスタイルは好まれます。なぜなら、コンパイラがより多くの決定を下し、プログラムをより多くの方法でコンパイルできるようにし、通常のコードがコード生成コードよりも読みやすいためです。しかし、どの実装が使用されるかはコンパイラの実装の詳細に依存するため、2つの実装が同一に動作することが重要です。</span></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../documentation/index.html">« Documentation</a><a class="docs-footer-nextpage" href="../arrays/index.html">Single- and multi-dimensional Arrays »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>