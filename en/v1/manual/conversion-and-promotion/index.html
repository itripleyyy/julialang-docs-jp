<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Conversion and Promotion · The Julia Language</title><meta name="title" content="Conversion and Promotion · The Julia Language"><meta property="og:title" content="Conversion and Promotion · The Julia Language"><meta property="twitter:title" content="Conversion and Promotion · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/"><link rel="canonical" href="index.html"><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li class="is-active"><a class="tocitem" href="">Conversion and Promotion</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Conversion"><span>Conversion</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Conversion"><span>変換</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Promotion"><span>Promotion</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Promotion"><span>プロモーション</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">変換とプロモーション</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">変換とプロモーション</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/conversion-and-promotion.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="conversion-and-promotion" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#conversion-and-promotion">Conversion and Promotion</a><a id="conversion-and-promotion-1"></a><a class="docs-heading-anchor-permalink" href="#conversion-and-promotion" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#conversion-and-promotion">変換とプロモーション</a><a id="conversion-and-promotion-1"></a><a class="docs-heading-anchor-permalink" href="#conversion-and-promotion" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including <a href="../integers-and-floating-point-numbers/index.html#Integers-and-Floating-Point-Numbers">Integers and Floating-Point Numbers</a>, <a href="../mathematical-operations/index.html#Mathematical-Operations-and-Elementary-Functions">Mathematical Operations and Elementary Functions</a>, <a href="../types/index.html#man-types">Types</a>, and <a href="../methods/index.html#Methods">Methods</a>. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは、<a href="../integers-and-floating-point-numbers/index.html#Integers-and-Floating-Point-Numbers">整数と浮動小数点数</a>、<a href="../mathematical-operations/index.html#Mathematical-Operations-and-Elementary-Functions">数学的操作と基本関数</a>、<a href="../types/index.html#man-types">型</a>、および<a href="../methods/index.html#Methods">メソッド</a>を含むさまざまな他のセクションで言及されている、数学演算子の引数を共通の型に昇格させるシステムを持っています。このセクションでは、この昇格システムがどのように機能するか、また新しい型に拡張し、組み込みの数学演算子以外の関数に適用する方法について説明します。伝統的に、プログラミング言語は算術引数の昇格に関して二つのキャンプに分かれます：</span></p><ul><li data-translated="true"><span class="original-text"><strong>Automatic promotion for built-in arithmetic types and operators.</strong> In most languages, built-in numeric types, when used as operands to arithmetic operators with infix syntax, such as <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, are automatically promoted to a common type to produce the expected results. C, Java, Perl, and Python, to name a few, all correctly compute the sum <code>1 + 1.5</code> as the floating-point value <code>2.5</code>, even though one of the operands to <code>+</code> is an integer. These systems are convenient and designed carefully enough that they are generally all-but-invisible to the programmer: hardly anyone consciously thinks of this promotion taking place when writing such an expression, but compilers and interpreters must perform conversion before addition since integers and floating-point values cannot be added as-is. Complex rules for such automatic conversions are thus inevitably part of specifications and implementations for such languages.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>組み込みの算術型と演算子に対する自動昇格。</strong> ほとんどの言語では、<code>+</code>、<code>-</code>、<code>*</code>、および<code>/</code>のような中置構文の算術演算子のオペランドとして使用される組み込みの数値型は、期待される結果を生成するために自動的に共通の型に昇格されます。C、Java、Perl、Pythonなどは、<code>1 + 1.5</code>の合計を浮動小数点値<code>2.5</code>として正しく計算します。これは、<code>+</code>のオペランドの一つが整数であるにもかかわらずです。これらのシステムは便利で、プログラマーにとってほとんど見えないように設計されています：このような式を書くときに、この昇格が行われることを意識する人はほとんどいませんが、コンパイラやインタプリタは加算の前に変換を行う必要があります。整数と浮動小数点値はそのままでは加算できないからです。このような自動変換のための複雑なルールは、したがって、これらの言語の仕様や実装の一部となるのは避けられません。</span></li><li data-translated="true"><span class="original-text"><strong>No automatic promotion.</strong> This camp includes Ada and ML – very "strict" statically typed languages. In these languages, every conversion must be explicitly specified by the programmer. Thus, the example expression <code>1 + 1.5</code> would be a compilation error in both Ada and ML. Instead one must write <code>real(1) + 1.5</code>, explicitly converting the integer <code>1</code> to a floating-point value before performing addition. Explicit conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic conversion: integer literals are promoted to the expected integer type automatically, and floating-point literals are similarly promoted to appropriate floating-point types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>自動昇格なし。</strong> このキャンプには、AdaやMLなどの非常に「厳格な」静的型付け言語が含まれます。これらの言語では、すべての変換はプログラマーによって明示的に指定されなければなりません。したがって、例の式<code>1 + 1.5</code>は、AdaとMLの両方でコンパイルエラーになります。代わりに、<code>real(1) + 1.5</code>と書かなければならず、整数<code>1</code>を浮動小数点値に明示的に変換してから加算を行います。しかし、どこでも明示的な変換を行うのは非常に不便であるため、Adaでもある程度の自動変換があります：整数リテラルは期待される整数型に自動的に昇格され、浮動小数点リテラルも同様に適切な浮動小数点型に昇格されます。</span></li></ul><p data-translated="true"><span class="original-text">In a sense, Julia falls into the "no automatic promotion" category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch – something which Julia's dispatch and type systems are particularly well-suited to handle. "Automatic" promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ある意味で、Juliaは「自動昇格なし」のカテゴリーに入ります：数学演算子は特別な構文を持つ関数であり、関数の引数は自動的に変換されることはありません。しかし、さまざまな混合引数型に数学的操作を適用することは、ポリモーフィックな多重ディスパッチの極端なケースであることに気づくかもしれません。これは、Juliaのディスパッチと型システムが特にうまく処理できるものです。数学的オペランドの「自動的」昇格は、特別な適用として現れます：Juliaは、オペランド型の特定の組み合わせに対する実装が存在しない場合に呼び出される数学演算子のための事前定義されたキャッチオールディスパッチルールを備えています。これらのキャッチオールルールは、最初にすべてのオペランドをユーザー定義の昇格ルールを使用して共通の型に昇格し、その後、結果として得られた同じ型の値に対して問題の演算子の専門的な実装を呼び出します。ユーザー定義の型は、他の型への変換のためのメソッドを定義し、他の型と混合されたときに昇格すべき型を定義するいくつかの昇格ルールを提供することで、この昇格システムに簡単に参加できます。</span></p><h2 id="Conversion" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Conversion">変換</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The standard way to obtain a value of a certain type <code>T</code> is to call the type's constructor, <code>T(x)</code>. However, there are cases where it's convenient to convert a value from one type to another without the programmer asking for it explicitly. One example is assigning a value into an array: if <code>A</code> is a <code>Vector{Float64}</code>, the expression <code>A[1] = 2</code> should work by automatically converting the <code>2</code> from <code>Int</code> to <code>Float64</code>, and storing the result in the array. This is done via the <a href="../../base/base/index.html#Base.convert"><code>convert</code></a> function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特定の型 <code>T</code> の値を取得する標準的な方法は、その型のコンストラクタ <code>T(x)</code> を呼び出すことです。しかし、プログラマーが明示的に要求しなくても、ある型から別の型に値を変換することが便利な場合があります。一例として、配列に値を代入することが挙げられます。もし <code>A</code> が <code>Vector{Float64}</code> であれば、式 <code>A[1] = 2</code> は、<code>2</code> を <code>Int</code> から <code>Float64</code> に自動的に変換し、その結果を配列に格納することで機能するべきです。これは <a href="../../base/base/index.html#Base.convert"><code>convert</code></a> 関数を介して行われます。</span></p><p data-translated="true"><span class="original-text">The <code>convert</code> function generally takes two arguments: the first is a type object and the second is a value to convert to that type. The returned value is the value converted to an instance of given type. The simplest way to understand this function is to see it in action:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般に、<code>convert</code> 関数は二つの引数を取ります。最初の引数は型オブジェクトで、二番目の引数はその型に変換する値です。返される値は、指定された型のインスタンスに変換された値です。この関数を理解する最も簡単な方法は、実際に動作を見てみることです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = 12
12

julia&gt; typeof(x)
Int64

julia&gt; xu = convert(UInt8, x)
0x0c

julia&gt; typeof(xu)
UInt8

julia&gt; xf = convert(AbstractFloat, x)
12.0

julia&gt; typeof(xf)
Float64

julia&gt; a = Any[1 2 3; 4 5 6]
2×3 Matrix{Any}:
 1  2  3
 4  5  6

julia&gt; convert(Array{Float64}, a)
2×3 Matrix{Float64}:
 1.0  2.0  3.0
 4.0  5.0  6.0</code></pre><p data-translated="true"><span class="original-text">Conversion isn't always possible, in which case a <a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a> is thrown indicating that <code>convert</code> doesn't know how to perform the requested conversion:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">変換は常に可能ではなく、その場合は <a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a> がスローされ、<code>convert</code> が要求された変換を実行する方法を知らないことを示します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; convert(AbstractFloat, "foo")
ERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat
[...]</code></pre><p data-translated="true"><span class="original-text">Some languages consider parsing strings as numbers or formatting numbers as strings to be conversions (many dynamic languages will even perform conversion for you automatically). This is not the case in Julia. Even though some strings can be parsed as numbers, most strings are not valid representations of numbers, and only a very limited subset of them are. Therefore in Julia the dedicated <a href="../../base/numbers/index.html#Base.parse"><code>parse</code></a> function must be used to perform this operation, making it more explicit.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">いくつかの言語では、文字列を数値として解析したり、数値を文字列としてフォーマットすることを変換と見なします（多くの動的言語では、自動的に変換を行うことさえあります）。しかし、Julia ではそうではありません。いくつかの文字列は数値として解析できるものの、ほとんどの文字列は数値の有効な表現ではなく、その中で有効なものは非常に限られています。したがって、Julia ではこの操作を実行するために専用の <a href="../../base/numbers/index.html#Base.parse"><code>parse</code></a> 関数を使用する必要があり、より明示的になります。</span></p><h3 id="When-is-convert-called?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#When-is-convert-called?">When is <code>convert</code> called?</a><a id="When-is-convert-called?-1"></a><a class="docs-heading-anchor-permalink" href="#When-is-convert-called?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#When-is-convert-called?"><code>convert</code> はいつ呼ばれますか？</a><a id="When-is-convert-called?-1"></a><a class="docs-heading-anchor-permalink" href="#When-is-convert-called?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The following language constructs call <code>convert</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次の言語構造が <code>convert</code> を呼び出します：</span></p><ul><li data-translated="true"><span class="original-text">Assigning to an array converts to the array's element type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列への代入は、配列の要素型に変換します。</span></li><li data-translated="true"><span class="original-text">Assigning to a field of an object converts to the declared type of the field.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">オブジェクトのフィールドへの代入は、そのフィールドの宣言された型に変換します。</span></li><li data-translated="true"><span class="original-text">Constructing an object with <a href="../../base/base/index.html#new"><code>new</code></a> converts to the object's declared field types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#new"><code>new</code></a> を使用してオブジェクトを構築することは、オブジェクトの宣言されたフィールド型に変換します。</span></li><li data-translated="true"><span class="original-text">Assigning to a variable with a declared type (e.g. <code>local x::T</code>) converts to that type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">宣言された型を持つ変数への代入（例：<code>local x::T</code>）は、その型に変換します。</span></li><li data-translated="true"><span class="original-text">A function with a declared return type converts its return value to that type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">宣言された戻り値の型を持つ関数は、その戻り値をその型に変換します。</span></li><li data-translated="true"><span class="original-text">Passing a value to <a href="../../base/c/index.html#ccall"><code>ccall</code></a> converts it to the corresponding argument type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/c/index.html#ccall"><code>ccall</code></a>に値を渡すと、それは対応する引数の型に変換されます。</span></li></ul><h3 id="Conversion-vs.-Construction" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Conversion-vs.-Construction">Conversion vs. Construction</a><a id="Conversion-vs.-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-vs.-Construction" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Conversion-vs.-Construction">変換と構築</a><a id="Conversion-vs.-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-vs.-Construction" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Note that the behavior of <code>convert(T, x)</code> appears to be nearly identical to <code>T(x)</code>. Indeed, it usually is. However, there is a key semantic difference: since <code>convert</code> can be called implicitly, its methods are restricted to cases that are considered "safe" or "unsurprising". <code>convert</code> will only convert between types that represent the same basic kind of thing (e.g. different representations of numbers, or different string encodings). It is also usually lossless; converting a value to a different type and back again should result in the exact same value.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>convert(T, x)</code>の動作は、<code>T(x)</code>とほぼ同じであるように見えます。実際、通常はそうです。しかし、重要な意味の違いがあります：<code>convert</code>は暗黙的に呼び出すことができるため、そのメソッドは「安全」または「驚かない」ケースに制限されています。<code>convert</code>は、同じ基本的な種類のものを表す型間でのみ変換を行います（例：異なる数値の表現や異なる文字列エンコーディング）。また、通常は損失がありません；値を異なる型に変換して再び戻すと、正確に同じ値が得られるはずです。</span></p><p data-translated="true"><span class="original-text">There are four general kinds of cases where constructors differ from <code>convert</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コンストラクタが<code>convert</code>と異なる一般的なケースは4つあります：</span></p><h4 id="Constructors-for-types-unrelated-to-their-arguments" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Constructors-for-types-unrelated-to-their-arguments">Constructors for types unrelated to their arguments</a><a id="Constructors-for-types-unrelated-to-their-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors-for-types-unrelated-to-their-arguments" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Constructors-for-types-unrelated-to-their-arguments">引数に関連しない型のコンストラクタ</a><a id="Constructors-for-types-unrelated-to-their-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors-for-types-unrelated-to-their-arguments" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">Some constructors don't implement the concept of "conversion". For example, <code>Timer(2)</code> creates a 2-second timer, which is not really a "conversion" from an integer to a timer.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一部のコンストラクタは「変換」の概念を実装していません。例えば、<code>Timer(2)</code>は2秒のタイマーを作成しますが、これは整数からタイマーへの「変換」ではありません。</span></p><h4 id="Mutable-collections" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Mutable-collections">Mutable collections</a><a id="Mutable-collections-1"></a><a class="docs-heading-anchor-permalink" href="#Mutable-collections" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Mutable-collections">可変コレクション</a><a id="Mutable-collections-1"></a><a class="docs-heading-anchor-permalink" href="#Mutable-collections" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text"><code>convert(T, x)</code> is expected to return the original <code>x</code> if <code>x</code> is already of type <code>T</code>. In contrast, if <code>T</code> is a mutable collection type then <code>T(x)</code> should always make a new collection (copying elements from <code>x</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>convert(T, x)</code>は、<code>x</code>がすでに型<code>T</code>である場合、元の<code>x</code>を返すことが期待されます。対照的に、<code>T</code>が可変コレクション型である場合、<code>T(x)</code>は常に新しいコレクションを作成する必要があります（<code>x</code>から要素をコピーします）。</span></p><h4 id="Wrapper-types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Wrapper-types">Wrapper types</a><a id="Wrapper-types-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Wrapper-types">ラッパー型</a><a id="Wrapper-types-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-types" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">For some types which "wrap" other values, the constructor may wrap its argument inside a new object even if it is already of the requested type. For example <code>Some(x)</code> wraps <code>x</code> to indicate that a value is present (in a context where the result might be a <code>Some</code> or <code>nothing</code>). However, <code>x</code> itself might be the object <code>Some(y)</code>, in which case the result is <code>Some(Some(y))</code>, with two levels of wrapping. <code>convert(Some, x)</code>, on the other hand, would just return <code>x</code> since it is already a <code>Some</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">他の値を「ラップ」するタイプのいくつかでは、コンストラクタは引数が要求されたタイプであっても、新しいオブジェクトの中にその引数をラップする場合があります。例えば、<code>Some(x)</code>は、結果が<code>Some</code>または<code>nothing</code>である可能性があるコンテキストで値が存在することを示すために<code>x</code>をラップします。しかし、<code>x</code>自体がオブジェクト<code>Some(y)</code>である場合、結果は<code>Some(Some(y))</code>となり、2つのラッピングレベルになります。一方、<code>convert(Some, x)</code>は、<code>x</code>がすでに<code>Some</code>であるため、単に<code>x</code>を返します。</span></p><h4 id="Constructors-that-don't-return-instances-of-their-own-type" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Constructors-that-don't-return-instances-of-their-own-type">Constructors that don't return instances of their own type</a><a id="Constructors-that-don't-return-instances-of-their-own-type-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors-that-don't-return-instances-of-their-own-type" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Constructors-that-don't-return-instances-of-their-own-type">自身の型のインスタンスを返さないコンストラクタ</a><a id="Constructors-that-don't-return-instances-of-their-own-type-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors-that-don't-return-instances-of-their-own-type" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">In <em>very rare</em> cases it might make sense for the constructor <code>T(x)</code> to return an object not of type <code>T</code>. This could happen if a wrapper type is its own inverse (e.g. <code>Flip(Flip(x)) === x</code>), or to support an old calling syntax for backwards compatibility when a library is restructured. But <code>convert(T, x)</code> should always return a value of type <code>T</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><em>非常に稀</em>なケースでは、コンストラクタ<code>T(x)</code>が型<code>T</code>ではないオブジェクトを返すことが意味を持つ場合があります。これは、ラッパータイプが自身の逆である場合（例：<code>Flip(Flip(x)) === x</code>）や、ライブラリが再構成される際に後方互換性のために古い呼び出し構文をサポートするために発生する可能性があります。しかし、<code>convert(T, x)</code>は常に型<code>T</code>の値を返すべきです。</span></p><h3 id="Defining-New-Conversions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Defining-New-Conversions">Defining New Conversions</a><a id="Defining-New-Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-New-Conversions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Defining-New-Conversions">新しい変換の定義</a><a id="Defining-New-Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-New-Conversions" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">When defining a new type, initially all ways of creating it should be defined as constructors. If it becomes clear that implicit conversion would be useful, and that some constructors meet the above "safety" criteria, then <code>convert</code> methods can be added. These methods are typically quite simple, as they only need to call the appropriate constructor. Such a definition might look like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">新しい型を定義する際には、最初はそれを作成するすべての方法をコンストラクタとして定義する必要があります。暗黙の変換が有用であることが明らかになり、いくつかのコンストラクタが上記の「安全性」基準を満たす場合、<code>convert</code>メソッドを追加できます。これらのメソッドは通常非常にシンプルで、適切なコンストラクタを呼び出すだけで済みます。このような定義は次のようになります：</span></p><pre><code class="language-julia hljs">import Base: convert
convert(::Type{MyType}, x) = MyType(x)</code></pre><p data-translated="true"><span class="original-text">The type of the first argument of this method is <a href="../types/index.html#man-typet-type"><code>Type{MyType}</code></a>, the only instance of which is <code>MyType</code>. Thus, this method is only invoked when the first argument is the type value <code>MyType</code>. Notice the syntax used for the first argument: the argument name is omitted prior to the <code>::</code> symbol, and only the type is given. This is the syntax in Julia for a function argument whose type is specified but whose value does not need to be referenced by name.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このメソッドの最初の引数の型は<a href="../types/index.html#man-typet-type"><code>Type{MyType}</code></a>であり、その唯一のインスタンスは<code>MyType</code>です。したがって、このメソッドは最初の引数が型値<code>MyType</code>であるときのみ呼び出されます。最初の引数に使用される構文に注意してください：引数名は<code>::</code>シンボルの前に省略され、型のみが指定されています。これは、型が指定されているが値を名前で参照する必要がない関数引数のためのJuliaの構文です。</span></p><p data-translated="true"><span class="original-text">All instances of some abstract types are by default considered "sufficiently similar" that a universal <code>convert</code> definition is provided in Julia Base. For example, this definition states that it's valid to <code>convert</code> any <code>Number</code> type to any other by calling a 1-argument constructor:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべての抽象型のインスタンスはデフォルトで「十分に似ている」と見なされ、Julia Baseには普遍的な<code>convert</code>定義が提供されています。例えば、この定義は、1引数のコンストラクタを呼び出すことで任意の<code>Number</code>型を他の任意の型に<code>convert</code>することが有効であると述べています：</span></p><pre><code class="language-julia hljs">convert(::Type{T}, x::Number) where {T&lt;:Number} = T(x)::T</code></pre><p data-translated="true"><span class="original-text">This means that new <code>Number</code> types only need to define constructors, since this definition will handle <code>convert</code> for them. An identity conversion is also provided to handle the case where the argument is already of the requested type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、新しい<code>Number</code>型はコンストラクタを定義するだけで済むことを意味します。この定義が<code>convert</code>を処理するためです。引数がすでに要求された型である場合を処理するために、アイデンティティ変換も提供されています：</span></p><pre><code class="language-julia hljs">convert(::Type{T}, x::T) where {T&lt;:Number} = x</code></pre><p data-translated="true"><span class="original-text">Similar definitions exist for <code>AbstractString</code>, <a href="../../base/arrays/index.html#Core.AbstractArray"><code>AbstractArray</code></a>, and <a href="../../base/collections/index.html#Base.AbstractDict"><code>AbstractDict</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>AbstractString</code>、<a href="../../base/arrays/index.html#Core.AbstractArray"><code>AbstractArray</code></a>、および<a href="../../base/collections/index.html#Base.AbstractDict"><code>AbstractDict</code></a>についても同様の定義があります。</span></p><h2 id="Promotion" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Promotion">Promotion</a><a id="Promotion-1"></a><a class="docs-heading-anchor-permalink" href="#Promotion" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Promotion">昇格</a><a id="Promotion-1"></a><a class="docs-heading-anchor-permalink" href="#Promotion" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Promotion refers to converting values of mixed types to a single common type. Although it is not strictly necessary, it is generally implied that the common type to which the values are converted can faithfully represent all of the original values. In this sense, the term "promotion" is appropriate since the values are converted to a "greater" type – i.e. one which can represent all of the input values in a single common type. It is important, however, not to confuse this with object-oriented (structural) super-typing, or Julia's notion of abstract super-types: promotion has nothing to do with the type hierarchy, and everything to do with converting between alternate representations. For instance, although every <a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a> value can also be represented as a <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> value, <code>Int32</code> is not a subtype of <code>Float64</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロモーションとは、異なる型の値を単一の共通型に変換することを指します。厳密には必要ではありませんが、一般的には、値が変換される共通型は元のすべての値を忠実に表現できることが暗黙の前提とされています。この意味で、「プロモーション」という用語は適切です。なぜなら、値は「より大きな」型、すなわちすべての入力値を単一の共通型で表現できる型に変換されるからです。しかし、これはオブジェクト指向（構造的）スーパタイプや、Juliaの抽象スーパタイプの概念と混同しないことが重要です。プロモーションは型階層とは無関係であり、代替表現間の変換に関係しています。たとえば、すべての<a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a>値は<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>値としても表現できますが、<code>Int32</code>は<code>Float64</code>のサブタイプではありません。</span></p><p data-translated="true"><span class="original-text">Promotion to a common "greater" type is performed in Julia by the <a href="../../base/base/index.html#Base.promote"><code>promote</code></a> function, which takes any number of arguments, and returns a tuple of the same number of values, converted to a common type, or throws an exception if promotion is not possible. The most common use case for promotion is to convert numeric arguments to a common type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">共通の「より大きな」型へのプロモーションは、<a href="../../base/base/index.html#Base.promote"><code>promote</code></a>関数によってJuliaで実行されます。この関数は任意の数の引数を受け取り、共通型に変換された同じ数の値のタプルを返すか、プロモーションが不可能な場合は例外をスローします。プロモーションの最も一般的な使用ケースは、数値引数を共通型に変換することです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; promote(1, 2.5)
(1.0, 2.5)

julia&gt; promote(1, 2.5, 3)
(1.0, 2.5, 3.0)

julia&gt; promote(2, 3//4)
(2//1, 3//4)

julia&gt; promote(1, 2.5, 3, 3//4)
(1.0, 2.5, 3.0, 0.75)

julia&gt; promote(1.5, im)
(1.5 + 0.0im, 0.0 + 1.0im)

julia&gt; promote(1 + 2im, 3//4)
(1//1 + 2//1*im, 3//4 + 0//1*im)</code></pre><p data-translated="true"><span class="original-text">Floating-point values are promoted to the largest of the floating-point argument types. Integer values are promoted to the largest of the integer argument types. If the types are the same size but differ in signedness, the unsigned type is chosen. Mixtures of integers and floating-point values are promoted to a floating-point type big enough to hold all the values. Integers mixed with rationals are promoted to rationals. Rationals mixed with floats are promoted to floats. Complex values mixed with real values are promoted to the appropriate kind of complex value.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">浮動小数点値は、浮動小数点引数型の中で最も大きな型にプロモーションされます。整数値は、整数引数型の中で最も大きな型にプロモーションされます。型が同じサイズで符号が異なる場合は、符号なし型が選択されます。整数と浮動小数点値の混合は、すべての値を保持できる十分な大きさの浮動小数点型にプロモーションされます。整数と有理数の混合は、有理数にプロモーションされます。有理数と浮動小数点の混合は、浮動小数点にプロモーションされます。実数と複素数の混合は、適切な種類の複素数にプロモーションされます。</span></p><p data-translated="true"><span class="original-text">That is really all there is to using promotions. The rest is just a matter of clever application, the most typical "clever" application being the definition of catch-all methods for numeric operations like the arithmetic operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>. Here are some of the catch-all method definitions given in <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl"><code>promotion.jl</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロモーションを使用する際に本当に必要なことはこれだけです。残りは巧妙な応用の問題であり、最も典型的な「巧妙な」応用は、算術演算子<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>のような数値演算のためのキャッチオールメソッドの定義です。以下は、<a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl"><code>promotion.jl</code></a>に示されているキャッチオールメソッドの定義です：</span></p><pre><code class="language-julia hljs">+(x::Number, y::Number) = +(promote(x,y)...)
-(x::Number, y::Number) = -(promote(x,y)...)
*(x::Number, y::Number) = *(promote(x,y)...)
/(x::Number, y::Number) = /(promote(x,y)...)</code></pre><p data-translated="true"><span class="original-text">These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying and dividing pairs of numeric values, promote the values to a common type and then try again. That's all there is to it: nowhere else does one ever need to worry about promotion to a common numeric type for arithmetic operations – it just happens automatically. There are definitions of catch-all promotion methods for a number of other arithmetic and mathematical functions in <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl"><code>promotion.jl</code></a>, but beyond that, there are hardly any calls to <code>promote</code> required in Julia Base. The most common usages of <code>promote</code> occur in outer constructors methods, provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate common type. For example, recall that <a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl"><code>rational.jl</code></a> provides the following outer constructor method:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらのメソッド定義は、数値値のペアを加算、減算、乗算、除算するためのより具体的なルールがない場合、値を共通型にプロモーションし、再度試みることを示しています。それが全てです：算術演算のために共通の数値型へのプロモーションを心配する必要はどこにもありません – 自動的に発生します。<a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl"><code>promotion.jl</code></a>には、他の多くの算術および数学関数のためのキャッチオールプロモーションメソッドの定義がありますが、それを超えて、Julia Baseで<code>promote</code>を呼び出す必要はほとんどありません。<code>promote</code>の最も一般的な使用は、混合型のコンストラクタ呼び出しを適切な共通型にプロモーションされたフィールドを持つ内部型に委任するために提供される外部コンストラクタメソッドで発生します。たとえば、<a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl"><code>rational.jl</code></a>が提供する以下の外部コンストラクタメソッドを思い出してください：</span></p><pre><code class="language-julia hljs">Rational(n::Integer, d::Integer) = Rational(promote(n,d)...)</code></pre><p data-translated="true"><span class="original-text">This allows calls like the following to work:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これにより、次のような呼び出しが機能します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = Rational(Int8(15),Int32(-5))
-3//1

julia&gt; typeof(x)
Rational{Int32}</code></pre><p data-translated="true"><span class="original-text">For most user-defined types, it is better practice to require programmers to supply the expected types to constructor functions explicitly, but sometimes, especially for numeric problems, it can be convenient to do promotion automatically.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ほとんどのユーザー定義型では、プログラマーがコンストラクタ関数に期待される型を明示的に提供することを要求する方が良いプラクティスですが、特に数値問題の場合、自動的にプロモーションを行うことが便利な場合があります。</span></p><h3 id="Defining-Promotion-Rules" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Defining-Promotion-Rules">Defining Promotion Rules</a><a id="Defining-Promotion-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Promotion-Rules" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Defining-Promotion-Rules">プロモーションルールの定義</a><a id="Defining-Promotion-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Promotion-Rules" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Although one could, in principle, define methods for the <code>promote</code> function directly, this would require many redundant definitions for all possible permutations of argument types. Instead, the behavior of <code>promote</code> is defined in terms of an auxiliary function called <a href="../../base/base/index.html#Base.promote_rule"><code>promote_rule</code></a>, which one can provide methods for. The <code>promote_rule</code> function takes a pair of type objects and returns another type object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">原則として、<code>promote</code>関数のメソッドを直接定義することも可能ですが、これはすべての引数型の可能な順列に対して多くの冗長な定義を必要とします。代わりに、<code>promote</code>の動作は、<a href="../../base/base/index.html#Base.promote_rule"><code>promote_rule</code></a>と呼ばれる補助関数の観点で定義されており、メソッドを提供することができます。<code>promote_rule</code>関数は、型オブジェクトのペアを受け取り、引数型のインスタンスが返された型にプロモーションされるように、別の型オブジェクトを返します。したがって、ルールを定義することによって：</span></p><pre><code class="language-julia hljs">import Base: promote_rule
promote_rule(::Type{Float64}, ::Type{Float32}) = Float64</code></pre><p data-translated="true"><span class="original-text">one declares that when 64-bit and 32-bit floating-point values are promoted together, they should be promoted to 64-bit floating-point. The promotion type does not need to be one of the argument types. For example, the following promotion rules both occur in Julia Base:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">64ビットと32ビットの浮動小数点値が一緒にプロモーションされるとき、64ビット浮動小数点にプロモーションされるべきことを宣言します。プロモーション型は引数型の1つである必要はありません。たとえば、以下のプロモーションルールは、Julia Baseで両方とも発生します：</span></p><pre><code class="language-julia hljs">promote_rule(::Type{BigInt}, ::Type{Float64}) = BigFloat
promote_rule(::Type{BigInt}, ::Type{Int8}) = BigInt</code></pre><p data-translated="true"><span class="original-text">In the latter case, the result type is <a href="../../base/numbers/index.html#Base.GMP.BigInt"><code>BigInt</code></a> since <code>BigInt</code> is the only type large enough to hold integers for arbitrary-precision integer arithmetic. Also note that one does not need to define both <code>promote_rule(::Type{A}, ::Type{B})</code> and <code>promote_rule(::Type{B}, ::Type{A})</code> – the symmetry is implied by the way <code>promote_rule</code> is used in the promotion process.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">後者の場合、結果の型は<a href="../../base/numbers/index.html#Base.GMP.BigInt"><code>BigInt</code></a>です。なぜなら、<code>BigInt</code>は任意精度整数演算のために整数を保持するのに十分な唯一の型だからです。また、<code>promote_rule(::Type{A}, ::Type{B})</code>と<code>promote_rule(::Type{B}, ::Type{A})</code>の両方を定義する必要はありません。対称性は、<code>promote_rule</code>が昇格プロセスで使用される方法によって暗示されています。</span></p><p data-translated="true"><span class="original-text">The <code>promote_rule</code> function is used as a building block to define a second function called <a href="../../base/base/index.html#Base.promote_type"><code>promote_type</code></a>, which, given any number of type objects, returns the common type to which those values, as arguments to <code>promote</code> should be promoted. Thus, if one wants to know, in absence of actual values, what type a collection of values of certain types would promote to, one can use <code>promote_type</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>promote_rule</code>関数は、<a href="../../base/base/index.html#Base.promote_type"><code>promote_type</code></a>という2番目の関数を定義するためのビルディングブロックとして使用されます。これは、任意の数の型オブジェクトを受け取り、それらの値が<code>promote</code>の引数として昇格されるべき共通の型を返します。したがって、実際の値がない場合に、特定の型の値のコレクションがどの型に昇格されるかを知りたい場合は、<code>promote_type</code>を使用できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; promote_type(Int8, Int64)
Int64</code></pre><p data-translated="true"><span class="original-text">Note that we do <strong>not</strong> overload <code>promote_type</code> directly: we overload <code>promote_rule</code> instead. <code>promote_type</code> uses <code>promote_rule</code>, and adds the symmetry. Overloading it directly can cause ambiguity errors. We overload <code>promote_rule</code> to define how things should be promoted, and we use <code>promote_type</code> to query that.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">私たちは<strong>直接</strong>に<code>promote_type</code>をオーバーロードしないことに注意してください。代わりに<code>promote_rule</code>をオーバーロードします。<code>promote_type</code>は<code>promote_rule</code>を使用し、対称性を追加します。直接オーバーロードすると曖昧さのエラーが発生する可能性があります。私たちは<code>promote_rule</code>をオーバーロードして、どのように昇格すべきかを定義し、<code>promote_type</code>を使用してそれを照会します。</span></p><p data-translated="true"><span class="original-text">Internally, <code>promote_type</code> is used inside of <code>promote</code> to determine what type argument values should be converted to for promotion. The curious reader can read the code in <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl"><code>promotion.jl</code></a>, which defines the complete promotion mechanism in about 35 lines.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">内部的に、<code>promote_type</code>は<code>promote</code>内で使用され、昇格のために型引数の値がどの型に変換されるべきかを決定します。興味のある読者は、昇格メカニズム全体を約35行で定義している<a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl"><code>promotion.jl</code></a>のコードを読むことができます。</span></p><h3 id="Case-Study:-Rational-Promotions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Case-Study:-Rational-Promotions">Case Study: Rational Promotions</a><a id="Case-Study:-Rational-Promotions-1"></a><a class="docs-heading-anchor-permalink" href="#Case-Study:-Rational-Promotions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Case-Study:-Rational-Promotions">ケーススタディ: 有理数の昇格</a><a id="Case-Study:-Rational-Promotions-1"></a><a class="docs-heading-anchor-permalink" href="#Case-Study:-Rational-Promotions" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Finally, we finish off our ongoing case study of Julia's rational number type, which makes relatively sophisticated use of the promotion mechanism with the following promotion rules:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最後に、昇格メカニズムを比較的高度に利用するJuliaの有理数型の進行中のケーススタディを締めくくります。以下の昇格ルールがあります。</span></p><pre><code class="language-julia hljs">import Base: promote_rule
promote_rule(::Type{Rational{T}}, ::Type{S}) where {T&lt;:Integer,S&lt;:Integer} = Rational{promote_type(T,S)}
promote_rule(::Type{Rational{T}}, ::Type{Rational{S}}) where {T&lt;:Integer,S&lt;:Integer} = Rational{promote_type(T,S)}
promote_rule(::Type{Rational{T}}, ::Type{S}) where {T&lt;:Integer,S&lt;:AbstractFloat} = promote_type(T,S)</code></pre><p data-translated="true"><span class="original-text">The first rule says that promoting a rational number with any other integer type promotes to a rational type whose numerator/denominator type is the result of promotion of its numerator/denominator type with the other integer type. The second rule applies the same logic to two different types of rational numbers, resulting in a rational of the promotion of their respective numerator/denominator types. The third and final rule dictates that promoting a rational with a float results in the same type as promoting the numerator/denominator type with the float.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初のルールは、有理数を他の任意の整数型と昇格させると、その分子/分母の型が他の整数型との昇格の結果となる有理型に昇格することを示しています。第二のルールは、異なる2つの有理数型に同じ論理を適用し、それぞれの分子/分母型の昇格の結果として有理数を生成します。第三のルールは、有理数を浮動小数点数と昇格させると、分子/分母型を浮動小数点数と昇格させたのと同じ型になることを示しています。</span></p><p data-translated="true"><span class="original-text">This small handful of promotion rules, together with the type's constructors and the default <code>convert</code> method for numbers, are sufficient to make rational numbers interoperate completely naturally with all of Julia's other numeric types – integers, floating-point numbers, and complex numbers. By providing appropriate conversion methods and promotion rules in the same manner, any user-defined numeric type can interoperate just as naturally with Julia's predefined numerics.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この少数の昇格ルールと、型のコンストラクタおよび数値のデフォルト<code>convert</code>メソッドは、有理数がJuliaの他のすべての数値型（整数、浮動小数点数、複素数）と完全に自然に相互運用できるようにするのに十分です。適切な変換メソッドと昇格ルールを同様に提供することで、ユーザー定義の数値型もJuliaの定義済み数値と同様に自然に相互運用できます。</span></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../constructors/index.html">« Constructors</a><a class="docs-footer-nextpage" href="../interfaces/index.html">Interfaces »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>