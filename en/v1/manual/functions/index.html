<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Functions · The Julia Language</title><meta name="title" content="Functions · The Julia Language"><meta property="og:title" content="Functions · The Julia Language"><meta property="twitter:title" content="Functions · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/functions/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/functions/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bi1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li class="is-active"><a class="tocitem" href="">Functions</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-argument-passing"><span>Argument Passing Behavior</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-argument-passing"><span>引数渡しの動作</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Argument-type-declarations"><span>Argument-type declarations</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Argument-type-declarations"><span>引数型の宣言</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#The-return-Keyword"><span>The <code>return</code> Keyword</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#The-return-Keyword"><span>キーワード <code>return</code></span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Operators-Are-Functions"><span>Operators Are Functions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Operators-Are-Functions"><span>演算子は関数である</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Operators-With-Special-Names"><span>Operators With Special Names</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Operators-With-Special-Names"><span>特別な名前を持つ演算子</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-anonymous-functions"><span>Anonymous Functions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-anonymous-functions"><span>無名関数</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Tuples"><span>Tuples</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Tuples"><span>タプル</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Named-Tuples"><span>Named Tuples</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Named-Tuples"><span>名前付きタプル</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#destructuring-assignment"><span>Destructuring Assignment and Multiple Return Values</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#destructuring-assignment"><span>分割代入と複数の戻り値</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Property-destructuring"><span>Property destructuring</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Property-destructuring"><span>プロパティの分割代入</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-argument-destructuring"><span>Argument destructuring</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-argument-destructuring"><span>引数の分解</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Varargs-Functions"><span>Varargs Functions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Varargs-Functions"><span>可変長引数関数</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Optional-Arguments"><span>Optional Arguments</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Optional-Arguments"><span>オプション引数</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Keyword-Arguments"><span>Keyword Arguments</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Keyword-Arguments"><span>キーワード引数</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Evaluation-Scope-of-Default-Values"><span>Evaluation Scope of Default Values</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Evaluation-Scope-of-Default-Values"><span>デフォルト値の評価スコープ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Do-Block-Syntax-for-Function-Arguments"><span>Do-Block Syntax for Function Arguments</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Do-Block-Syntax-for-Function-Arguments"><span>関数引数のためのDo-Block構文</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Function-composition-and-piping"><span>Function composition and piping</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Function-composition-and-piping"><span>関数の合成とパイピング</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-vectorized"><span>Dot Syntax for Vectorizing Functions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-vectorized"><span>関数のベクトル化のためのドット構文</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Further-Reading"><span>Further Reading</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Further-Reading"><span>さらに読む</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">関数</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">関数</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-functions">Functions</a><a id="man-functions-1"></a><a class="docs-heading-anchor-permalink" href="#man-functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-functions">関数</a><a id="man-functions-1"></a><a class="docs-heading-anchor-permalink" href="#man-functions" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, because they can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaにおいて、関数は引数の値のタプルを戻り値にマッピングするオブジェクトです。Juliaの関数は純粋な数学的関数ではなく、プログラムのグローバルな状態を変更したり影響を受けたりすることがあります。Juliaで関数を定義するための基本的な構文は次のとおりです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function f(x, y)
           x + y
       end
f (generic function with 1 method)</code></pre><p data-translated="true"><span class="original-text">This function accepts two arguments <code>x</code> and <code>y</code> and returns the value of the last expression evaluated, which is <code>x + y</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この関数は2つの引数<code>x</code>と<code>y</code>を受け取り、評価された最後の式の値、すなわち<code>x + y</code>を返します。</span></p><p data-translated="true"><span class="original-text">There is a second, more terse syntax for defining a function in Julia. The traditional function declaration syntax demonstrated above is equivalent to the following compact "assignment form":</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、関数を定義するための2番目の、より簡潔な構文があります。上記の従来の関数宣言構文は、次のコンパクトな「代入形式」と同等です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(x, y) = x + y
f (generic function with 1 method)</code></pre><p data-translated="true"><span class="original-text">In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see <a href="../control-flow/index.html#man-compound-expressions">Compound Expressions</a>). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">代入形式では、関数の本体は単一の式でなければなりませんが、複合式であることもできます（<a href="../control-flow/index.html#man-compound-expressions">複合式</a>を参照）。短くシンプルな関数定義はJuliaでは一般的です。短い関数構文はそれに応じて非常に慣用的であり、タイピングと視覚的なノイズの両方を大幅に減少させます。</span></p><p data-translated="true"><span class="original-text">A function is called using the traditional parenthesis syntax:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数は従来の括弧構文を使用して呼び出されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(2, 3)
5</code></pre><p data-translated="true"><span class="original-text">Without parentheses, the expression <code>f</code> refers to the function object, and can be passed around like any other value:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">括弧なしで、式<code>f</code>は関数オブジェクトを指し、他の値と同様に渡すことができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; g = f;

julia&gt; g(2, 3)
5</code></pre><p data-translated="true"><span class="original-text">As with variables, Unicode can also be used for function names:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">変数と同様に、関数名にもUnicodeを使用できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; ∑(x, y) = x + y
∑ (generic function with 1 method)

julia&gt; ∑(2, 3)
5</code></pre><h2 id="man-argument-passing" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-argument-passing">Argument Passing Behavior</a><a id="man-argument-passing-1"></a><a class="docs-heading-anchor-permalink" href="#man-argument-passing" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-argument-passing">引数渡しの動作</a><a id="man-argument-passing-1"></a><a class="docs-heading-anchor-permalink" href="#man-argument-passing" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Julia function arguments follow a convention sometimes called "pass-by-sharing", which means that values are not copied when they are passed to functions. Function arguments themselves act as new variable <em>bindings</em> (new "names" that can refer to values), much like <a href="../variables/index.html#man-assignment-expressions">assignments</a> <code>argument_name = argument_value</code>, so that the objects they refer to are identical to the passed values. Modifications to mutable values (such as <code>Array</code>s) made within a function will be visible to the caller. (This is the same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの関数引数は、"pass-by-sharing"と呼ばれる慣習に従います。これは、値が関数に渡されるときにコピーされないことを意味します。関数引数自体は、新しい変数の<em>バインディング</em>（値を参照できる新しい"名前"）として機能し、<a href="../variables/index.html#man-assignment-expressions">代入</a> <code>argument_name = argument_value</code>のように、参照するオブジェクトは渡された値と同一です。関数内で行われた可変値（<code>Array</code>など）の変更は、呼び出し元に見えることになります。（これは、Scheme、ほとんどのLisp、Python、Ruby、Perlなどの他の動的言語でも見られる同様の動作です。）</span></p><p data-translated="true"><span class="original-text">For example, in the function</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、関数内で</span></p><pre><code class="language-julia hljs">function f(x, y)
    x[1] = 42    # mutates x
    y = 7 + y    # new binding for y, no mutation
    return y
end</code></pre><p data-translated="true"><span class="original-text">The statement <code>x[1] = 42</code> <em>mutates</em> the object <code>x</code>, and hence this change <em>will</em> be visible in the array passed by the caller for this argument. On the other hand, the assignment <code>y = 7 + y</code> changes the <em>binding</em> ("name") <code>y</code> to refer to a new value <code>7 + y</code>, rather than mutating the <em>original</em> object referred to by <code>y</code>, and hence does <em>not</em> change the corresponding argument passed by the caller. This can be seen if we call <code>f(x, y)</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文<code>x[1] = 42</code>は、オブジェクト<code>x</code>を<em>変異させる</em>ため、この変更は呼び出し元がこの引数に渡した配列に<em>表示される</em>ことになります。一方、代入<code>y = 7 + y</code>は、<em>バインディング</em>（"名前"）<code>y</code>を新しい値<code>7 + y</code>を参照するように変更しますが、<code>y</code>が参照する<em>元の</em>オブジェクトを変異させることはなく、したがって呼び出し元が渡した対応する引数は<em>変更されません</em>。これは、<code>f(x, y)</code>を呼び出すと確認できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; a = [4, 5, 6]
3-element Vector{Int64}:
 4
 5
 6

julia&gt; b = 3
3

julia&gt; f(a, b) # returns 7 + b == 10
10

julia&gt; a  # a[1] is changed to 42 by f
3-element Vector{Int64}:
 42
  5
  6

julia&gt; b  # not changed
3</code></pre><p data-translated="true"><span class="original-text">As a common convention in Julia (not a syntactic requirement), such a function would <a href="../../base/punctuation/index.html#man-punctuation">typically be named <code>f!(x, y)</code></a> rather than <code>f(x, y)</code>, as a visual reminder at the call site that at least one of the arguments (often the first one) is being mutated.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの一般的な慣習として（構文上の要件ではありません）、そのような関数は<a href="../../base/punctuation/index.html#man-punctuation">通常<code>f!(x, y)</code></a>と名付けられ、呼び出し時に少なくとも1つの引数（しばしば最初のもの）が変異していることを視覚的に思い出させます。</span></p><div class="admonition is-warning" id="Shared-memory-between-arguments-58da70ec41fdc138"><header class="admonition-header">Shared memory between arguments<a class="admonition-anchor" href="#Shared-memory-between-arguments-58da70ec41fdc138" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">The behavior of a mutating function can be unexpected when a mutated argument shares memory with another argument, a situation known as aliasing (e.g. when one is a view of the other). Unless the function docstring explicitly indicates that aliasing produces the expected result, it is the responsibility of the caller to ensure proper behavior on such inputs.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">変異する関数の動作は、変異した引数が別の引数とメモリを共有している場合、予期しないことがあります。この状況はエイリアシングとして知られています（例えば、一方が他方のビューである場合）。関数のドキュメントにエイリアシングが期待される結果を生むことが明示的に示されていない限り、呼び出し元がそのような入力に対して適切な動作を保証する責任があります。</span></p></div></div><h2 id="Argument-type-declarations" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Argument-type-declarations">Argument-type declarations</a><a id="Argument-type-declarations-1"></a><a class="docs-heading-anchor-permalink" href="#Argument-type-declarations" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Argument-type-declarations">引数型宣言</a><a id="Argument-type-declarations-1"></a><a class="docs-heading-anchor-permalink" href="#Argument-type-declarations" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">You can declare the types of function arguments by appending <code>::TypeName</code> to the argument name, as usual for <a href="../types/index.html#Type-Declarations">Type Declarations</a> in Julia. For example, the following function computes <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a> recursively:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数名に<code>::TypeName</code>を追加することで、関数引数の型を宣言できます。これは、Juliaの<a href="../types/index.html#Type-Declarations">型宣言</a>における通常の方法です。例えば、次の関数は<a href="https://en.wikipedia.org/wiki/Fibonacci_number">フィボナッチ数</a>を再帰的に計算します：</span></p><pre><code class="nohighlight hljs">fib(n::Integer) = n ≤ 2 ? one(n) : fib(n-1) + fib(n-2)</code></pre><p data-translated="true"><span class="original-text">and the <code>::Integer</code> specification means that it will only be callable when <code>n</code> is a subtype of the <a href="../types/index.html#man-abstract-types">abstract</a> <code>Integer</code> type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そして<code>::Integer</code>の指定は、<code>n</code>が<a href="../types/index.html#man-abstract-types">抽象</a> <code>Integer</code>型のサブタイプであるときのみ呼び出し可能であることを意味します。</span></p><p data-translated="true"><span class="original-text">Argument-type declarations <strong>normally have no impact on performance</strong>: regardless of what argument types (if any) are declared, Julia compiles a specialized version of the function for the actual argument types passed by the caller. For example, calling <code>fib(1)</code> will trigger the compilation of specialized version of <code>fib</code> optimized specifically for <code>Int</code> arguments, which is then re-used if <code>fib(7)</code> or <code>fib(15)</code> are called.  (There are rare exceptions when an argument-type declaration can trigger additional compiler specializations; see: <a href="../performance-tips/index.html#Be-aware-of-when-Julia-avoids-specializing">Be aware of when Julia avoids specializing</a>.)  The most common reasons to declare argument types in Julia are, instead:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数型宣言は<strong>通常パフォーマンスに影響を与えません</strong>：宣言された引数型（もしあれば）に関係なく、Juliaは呼び出し元が渡した実際の引数型に対して関数の特化したバージョンをコンパイルします。例えば、<code>fib(1)</code>を呼び出すと、<code>Int</code>引数に特化した<code>fib</code>の特化バージョンのコンパイルがトリガーされ、<code>fib(7)</code>や<code>fib(15)</code>が呼び出されると再利用されます。（引数型宣言が追加のコンパイラ特化をトリガーする稀な例外があります。詳細は<a href="../performance-tips/index.html#Be-aware-of-when-Julia-avoids-specializing">Juliaが特化を避ける場合に注意してください</a>を参照してください。）Juliaで引数型を宣言する最も一般的な理由は、むしろ次の通りです：</span></p><ul><li data-translated="true"><span class="original-text"><strong>Dispatch:</strong> As explained in <a href="../methods/index.html#Methods">Methods</a>, you can have different versions ("methods") of a function for different argument types, in which case the argument types are used to determine which implementation is called for which arguments. For example, you might implement a completely different algorithm <code>fib(x::Number) = ...</code> that works for any <code>Number</code> type by using <a href="https://en.wikipedia.org/wiki/Fibonacci_number#Binet%27s_formula#Binet's_formula">Binet's formula</a> to extend it to non-integer values.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>ディスパッチ：</strong> <a href="../methods/index.html#Methods">メソッド</a>で説明されているように、異なる引数型に対して異なるバージョン（"メソッド"）の関数を持つことができ、その場合、引数型はどの実装がどの引数に対して呼び出されるかを決定するために使用されます。例えば、<code>fib(x::Number) = ...</code>のように、任意の<code>Number</code>型に対して機能する全く異なるアルゴリズムを実装することができます。</span></li><li data-translated="true"><span class="original-text"><strong>Correctness:</strong> Type declarations can be useful if your function only returns correct results for certain argument types. For example, if we omitted argument types and wrote <code>fib(n) = n ≤ 2 ? one(n) : fib(n-1) + fib(n-2)</code>, then <code>fib(1.5)</code> would silently give us the nonsensical answer <code>1.0</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>正確性:</strong> 型宣言は、関数が特定の引数の型に対してのみ正しい結果を返す場合に役立ちます。たとえば、引数の型を省略して <code>fib(n) = n ≤ 2 ? one(n) : fib(n-1) + fib(n-2)</code> と書いた場合、<code>fib(1.5)</code> は静かに意味のない答え <code>1.0</code> を返してしまいます。</span></li><li data-translated="true"><span class="original-text"><strong>Clarity:</strong> Type declarations can serve as a form of documentation about the expected arguments.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>明確さ:</strong> 型宣言は、期待される引数に関するドキュメントの一形態として機能します。</span></li></ul><p data-translated="true"><span class="original-text">However, it is a <strong>common mistake to overly restrict the argument types</strong>, which can unnecessarily limit the applicability of the function and prevent it from being re-used in circumstances you did not anticipate. For example, the <code>fib(n::Integer)</code> function above works equally well for <code>Int</code> arguments (machine integers) and <code>BigInt</code> arbitrary-precision integers (see <a href="../../base/numbers/index.html#BigFloats-and-BigInts">BigFloats and BigInts</a>), which is especially useful because Fibonacci numbers grow exponentially rapidly and will quickly overflow any fixed-precision type like <code>Int</code> (see <a href="../integers-and-floating-point-numbers/index.html#Overflow-behavior">Overflow behavior</a>). If we had declared our function as <code>fib(n::Int)</code>, however, the application to <code>BigInt</code> would have been prevented for no reason. In general, you should use the most general applicable abstract types for arguments, and <strong>when in doubt, omit the argument types</strong>. You can always add argument-type specifications later if they become necessary, and you don't sacrifice performance or functionality by omitting them.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、<strong>引数の型を過度に制限するのは一般的な間違いです</strong>。これは関数の適用可能性を不必要に制限し、予期しない状況で再利用できなくする可能性があります。たとえば、上記の <code>fib(n::Integer)</code> 関数は、<code>Int</code> 引数（機械整数）と <code>BigInt</code> 任意精度整数（<a href="../../base/numbers/index.html#BigFloats-and-BigInts">BigFloats と BigInts</a>を参照）に対して同様に機能します。これは特に便利です。なぜなら、フィボナッチ数は指数関数的に急速に増加し、<code>Int</code> のような固定精度型ではすぐにオーバーフローしてしまうからです（<a href="../integers-and-floating-point-numbers/index.html#Overflow-behavior">オーバーフローベハビア</a>を参照）。しかし、もし私たちが関数を <code>fib(n::Int)</code> と宣言していた場合、理由もなく <code>BigInt</code> への適用が妨げられてしまったでしょう。一般的に、引数には最も一般的な適用可能な抽象型を使用すべきであり、<strong>疑問がある場合は引数の型を省略するべきです</strong>。必要になった場合は、後で引数の型仕様を追加することができ、型を省略することでパフォーマンスや機能を犠牲にすることはありません。</span></p><h2 id="The-return-Keyword" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#The-return-Keyword">The <code>return</code> Keyword</a><a id="The-return-Keyword-1"></a><a class="docs-heading-anchor-permalink" href="#The-return-Keyword" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#The-return-Keyword"><code>return</code> キーワード</a><a id="The-return-Keyword-1"></a><a class="docs-heading-anchor-permalink" href="#The-return-Keyword" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition. In the example function, <code>f</code>, from the previous section this is the value of the expression <code>x + y</code>. As an alternative, as in many other languages, the <code>return</code> keyword causes a function to return immediately, providing an expression whose value is returned:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数が返す値は、評価された最後の式の値であり、デフォルトでは関数定義の本体の最後の式です。前のセクションの例の関数 <code>f</code> では、これは式 <code>x + y</code> の値です。代わりに、多くの他の言語のように、<code>return</code> キーワードを使用すると、関数は即座に戻り、戻される値を持つ式を提供します:</span></p><pre><code class="language-julia hljs">function g(x, y)
    return x * y
    x + y
end</code></pre><p data-translated="true"><span class="original-text">Since function definitions can be entered into interactive sessions, it is easy to compare these definitions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数定義はインタラクティブセッションに入力できるため、これらの定義を比較するのは簡単です:</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(x, y) = x + y
f (generic function with 1 method)

julia&gt; function g(x, y)
           return x * y
           x + y
       end
g (generic function with 1 method)

julia&gt; f(2, 3)
5

julia&gt; g(2, 3)
6</code></pre><p data-translated="true"><span class="original-text">Of course, in a purely linear function body like <code>g</code>, the usage of <code>return</code> is pointless since the expression <code>x + y</code> is never evaluated and we could simply make <code>x * y</code> the last expression in the function and omit the <code>return</code>. In conjunction with other control flow, however, <code>return</code> is of real use. Here, for example, is a function that computes the hypotenuse length of a right triangle with sides of length <code>x</code> and <code>y</code>, avoiding overflow:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もちろん、<code>g</code> のような純粋に線形の関数本体では、<code>return</code> の使用は無意味です。なぜなら、式 <code>x + y</code> は決して評価されず、単に <code>x * y</code> を関数の最後の式にして <code>return</code> を省略することができるからです。しかし、他の制御フローと組み合わせると、<code>return</code> は実際に役立ちます。ここでは、たとえば、長さ <code>x</code> と <code>y</code> の直角三角形の斜辺の長さを計算し、オーバーフローを避ける関数を示します:</span></p><pre><code class="language-julia-repl hljs">julia&gt; function hypot(x, y)
           x = abs(x)
           y = abs(y)
           if x &gt; y
               r = y/x
               return x*sqrt(1 + r*r)
           end
           if y == 0
               return x
           end
           r = x/y
           return y*sqrt(1 + r*r)
       end
hypot (generic function with 1 method)

julia&gt; hypot(3, 4)
5.0</code></pre><p data-translated="true"><span class="original-text">There are three possible points of return from this function, returning the values of three different expressions, depending on the values of <code>x</code> and <code>y</code>. The <code>return</code> on the last line could be omitted since it is the last expression.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この関数からは、<code>x</code> と <code>y</code> の値に応じて、3つの異なる式の値を返す3つの可能な戻りポイントがあります。最後の行の <code>return</code> は、最後の式であるため省略可能です。</span></p><h3 id="man-functions-return-type" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-functions-return-type">Return type</a><a id="man-functions-return-type-1"></a><a class="docs-heading-anchor-permalink" href="#man-functions-return-type" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-functions-return-type">戻り値の型</a><a id="man-functions-return-type-1"></a><a class="docs-heading-anchor-permalink" href="#man-functions-return-type" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">A return type can be specified in the function declaration using the <code>::</code> operator. This converts the return value to the specified type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">戻り値の型は、<code>::</code> 演算子を使用して関数宣言で指定できます。これにより、戻り値が指定された型に変換されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; function g(x, y)::Int8
           return x * y
       end;

julia&gt; typeof(g(1, 2))
Int8</code></pre><p data-translated="true"><span class="original-text">This function will always return an <code>Int8</code> regardless of the types of <code>x</code> and <code>y</code>. See <a href="../types/index.html#Type-Declarations">Type Declarations</a> for more on return types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この関数は、<code>x</code>と<code>y</code>の型に関係なく、常に<code>Int8</code>を返します。戻り値の型については、<a href="../types/index.html#Type-Declarations">型宣言</a>を参照してください。</span></p><p data-translated="true"><span class="original-text">Return type declarations are <strong>rarely used</strong> in Julia: in general, you should instead write "type-stable" functions in which Julia's compiler can automatically infer the return type. For more information, see the <a href="../performance-tips/index.html#man-performance-tips">Performance Tips</a> chapter.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">戻り値の型宣言は、Juliaでは<strong>ほとんど使用されません</strong>。一般的には、Juliaのコンパイラが自動的に戻り値の型を推論できる「型安定」な関数を書くべきです。詳細については、<a href="../performance-tips/index.html#man-performance-tips">パフォーマンスのヒント</a>の章を参照してください。</span></p><h3 id="Returning-nothing" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Returning-nothing">Returning nothing</a><a id="Returning-nothing-1"></a><a class="docs-heading-anchor-permalink" href="#Returning-nothing" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Returning-nothing">何も返さない</a><a id="Returning-nothing-1"></a><a class="docs-heading-anchor-permalink" href="#Returning-nothing" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">For functions that do not need to return a value (functions used only for some side effects), the Julia convention is to return the value <a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">値を返す必要のない関数（副作用のためだけに使用される関数）については、Juliaの慣習として、<a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a>という値を返すことになっています：</span></p><pre><code class="language-julia hljs">function printx(x)
    println("x = $x")
    return nothing
end</code></pre><p data-translated="true"><span class="original-text">This is a <em>convention</em> in the sense that <code>nothing</code> is not a Julia keyword but only a singleton object of type <code>Nothing</code>. Also, you may notice that the <code>printx</code> function example above is contrived, because <code>println</code> already returns <code>nothing</code>, so that the <code>return</code> line is redundant.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは<em>慣習</em>であり、<code>nothing</code>はJuliaのキーワードではなく、<code>Nothing</code>型の単一オブジェクトであることに注意してください。また、上記の<code>printx</code>関数の例は、<code>println</code>がすでに<code>nothing</code>を返すため、<code>return</code>行が冗長であるため、作り物であることに気付くかもしれません。</span></p><p data-translated="true"><span class="original-text">There are two possible shortened forms for the <code>return nothing</code> expression. On the one hand, the <code>return</code> keyword implicitly returns <code>nothing</code>, so it can be used alone. On the other hand, since functions implicitly return their last expression evaluated, <code>nothing</code> can be used alone when it's the last expression. The preference for the expression <code>return nothing</code> as opposed to <code>return</code> or <code>nothing</code> alone is a matter of coding style.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>return nothing</code>式には2つの短縮形があります。一方では、<code>return</code>キーワードは暗黙的に<code>nothing</code>を返すため、単独で使用できます。他方では、関数は暗黙的に最後に評価された式を返すため、<code>nothing</code>は最後の式である場合に単独で使用できます。<code>return nothing</code>という式を<code>return</code>や単独の<code>nothing</code>の代わりに好むのは、コーディングスタイルの問題です。</span></p><h2 id="Operators-Are-Functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Operators-Are-Functions">Operators Are Functions</a><a id="Operators-Are-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-Are-Functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Operators-Are-Functions">演算子は関数です</a><a id="Operators-Are-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-Are-Functions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like <code>&amp;&amp;</code> and <code>||</code>. These operators cannot be functions since <a href="../control-flow/index.html#Short-Circuit-Evaluation">Short-Circuit Evaluation</a> requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、ほとんどの演算子は特別な構文をサポートする関数です。（例外は、<code>&amp;&amp;</code>や<code>||</code>のような特別な評価セマンティクスを持つ演算子です。これらの演算子は、<a href="../control-flow/index.html#Short-Circuit-Evaluation">ショートサーキット評価</a>が演算子の評価前にオペランドが評価されないことを要求するため、関数にはできません。）したがって、他の関数と同様に、括弧付きの引数リストを使用して適用することもできます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; 1 + 2 + 3
6

julia&gt; +(1, 2, 3)
6</code></pre><p data-translated="true"><span class="original-text">The infix form is exactly equivalent to the function application form – in fact the former is parsed to produce the function call internally. This also means that you can assign and pass around operators such as <a href="../../base/math/#Base.:+#Base.:+"><code>+</code></a> and <a href="../../base/math/#Base.:*-Tuple{Any, Vararg{Any}}#Base.:*-Tuple{Any, Vararg{Any}}"><code>*</code></a> just like you would with other function values:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">中置形式は、関数適用形式と完全に同等です。実際、前者は内部的に関数呼び出しを生成するために解析されます。これにより、<a href="../../base/math/#Base.:+#Base.:+"><code>+</code></a>や<a href="../../base/math/#Base.:*-Tuple{Any, Vararg{Any}}#Base.:*-Tuple{Any, Vararg{Any}}"><code>*</code></a>のような演算子を他の関数値と同様に割り当てたり渡したりできることを意味します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; f = +;

julia&gt; f(1, 2, 3)
6</code></pre><p data-translated="true"><span class="original-text">Under the name <code>f</code>, the function does not support infix notation, however.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、<code>f</code>という名前の関数は中置記法をサポートしていません。</span></p><h2 id="Operators-With-Special-Names" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Operators-With-Special-Names">Operators With Special Names</a><a id="Operators-With-Special-Names-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-With-Special-Names" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Operators-With-Special-Names">特別な名前を持つ演算子</a><a id="Operators-With-Special-Names-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-With-Special-Names" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">A few special expressions correspond to calls to functions with non-obvious names. These are:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">いくつかの特別な式は、明示的でない名前の関数への呼び出しに対応しています。これらは次のとおりです：</span></p><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Expression</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">式</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Calls</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">呼び出し</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>[A B C ...]</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>[A B C ...]</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.hcat"><code>hcat</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.hcat"><code>hcat</code></a></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>[A; B; C; ...]</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>[A; B; C; ...]</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.vcat"><code>vcat</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.vcat"><code>vcat</code></a></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>[A B; C D; ...]</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>[A B; C D; ...]</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.hvcat"><code>hvcat</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.hvcat"><code>hvcat</code></a></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>[A; B;; C; D;; ...]</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>[A; B;; C; D;; ...]</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.hvncat"><code>hvncat</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.hvncat"><code>hvncat</code></a></span></td></tr><tr><td style="text-align: left"><code>A'</code></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../stdlib/LinearAlgebra/index.html#Base.adjoint"><code>adjoint</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/LinearAlgebra/index.html#Base.adjoint"><code>adjoint</code></a></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>A[i]</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A[i]</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>A[i] = x</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A[i] = x</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>A.n</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A.n</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/base/index.html#Base.getproperty"><code>getproperty</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Base.getproperty"><code>getproperty</code></a></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>A.n = x</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A.n = x</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/base/index.html#Base.setproperty!"><code>setproperty!</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Base.setproperty!"><code>setproperty!</code></a></span></td></tr></tbody></table><p data-translated="true"><span class="original-text">Note that expressions similar to <code>[A; B;; C; D;; ...]</code> but with more than two consecutive <code>;</code> also correspond to <code>hvncat</code> calls.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">二つ以上の連続した <code>;</code> を含む <code>[A; B;; C; D;; ...]</code> のような式も <code>hvncat</code> 呼び出しに対応することに注意してください。</span></p><h2 id="man-anonymous-functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-anonymous-functions">Anonymous Functions</a><a id="man-anonymous-functions-1"></a><a class="docs-heading-anchor-permalink" href="#man-anonymous-functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-anonymous-functions">匿名関数</a><a id="man-anonymous-functions-1"></a><a class="docs-heading-anchor-permalink" href="#man-anonymous-functions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Functions in Julia are <a href="https://en.wikipedia.org/wiki/First-class_citizen">first-class objects</a>: they can be assigned to variables, and called using the standard function call syntax from the variable they have been assigned to. They can be used as arguments, and they can be returned as values. They can also be created anonymously, without being given a name, using either of these syntaxes:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia の関数は <a href="https://en.wikipedia.org/wiki/First-class_citizen">ファーストクラスオブジェクト</a> です：変数に割り当てることができ、割り当てられた変数から標準の関数呼び出し構文を使用して呼び出すことができます。引数として使用でき、値として返すこともできます。また、名前を付けずに匿名で作成することもでき、次のいずれかの構文を使用します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x -&gt; x^2 + 2x - 1
#2 (generic function with 1 method)

julia&gt; function (x)
           x^2 + 2x - 1
       end
#5 (generic function with 1 method)</code></pre><p data-translated="true"><span class="original-text">Each statement creates a function taking one argument <code>x</code> and returning the value of the polynomial <code>x^2 + 2x - 1</code> at that value. Notice that the result is a generic function, but with a compiler-generated name based on consecutive numbering.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各ステートメントは、1つの引数 <code>x</code> を取り、その値における多項式 <code>x^2 + 2x - 1</code> の値を返す関数を作成します。結果は一般的な関数ですが、連続した番号に基づいてコンパイラが生成した名前を持っています。</span></p><p data-translated="true"><span class="original-text">The primary use for anonymous functions is passing them to functions which take other functions as arguments. A classic example is <a href="../../base/collections/index.html#Base.map"><code>map</code></a>, which applies a function to each value of an array and returns a new array containing the resulting values:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">匿名関数の主な用途は、他の関数を引数として受け取る関数に渡すことです。古典的な例は <a href="../../base/collections/index.html#Base.map"><code>map</code></a> で、これは配列の各値に関数を適用し、結果の値を含む新しい配列を返します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; map(round, [1.2, 3.5, 1.7])
3-element Vector{Float64}:
 1.0
 4.0
 2.0</code></pre><p data-translated="true"><span class="original-text">This is fine if a named function effecting the transform already exists to pass as the first argument to <a href="../../base/collections/index.html#Base.map"><code>map</code></a>. Often, however, a ready-to-use, named function does not exist. In these situations, the anonymous function construct allows easy creation of a single-use function object without needing a name:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もし変換を行う名前付き関数が既に存在する場合、これは <a href="../../base/collections/index.html#Base.map"><code>map</code></a> の最初の引数として渡すのに問題ありません。しかし、しばしば、すぐに使える名前付き関数は存在しません。このような状況では、匿名関数構文を使用することで、名前を必要とせずに単一使用の関数オブジェクトを簡単に作成できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; map(x -&gt; x^2 + 2x - 1, [1, 3, -1])
3-element Vector{Int64}:
  2
 14
 -2</code></pre><p data-translated="true"><span class="original-text">An anonymous function accepting multiple arguments can be written using the syntax <code>(x,y,z)-&gt;2x+y-z</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複数の引数を受け取る匿名関数は、<code>(x,y,z)-&gt;2x+y-z</code>という構文を使用して記述できます。</span></p><p data-translated="true"><span class="original-text">Argument-type declarations for anonymous functions work as for named functions, for example <code>x::Integer-&gt;2x</code>. The return type of an anonymous function cannot be specified.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">匿名関数の引数型宣言は、名前付き関数と同様に機能します。例えば、<code>x::Integer-&gt;2x</code>のように記述します。匿名関数の戻り値の型は指定できません。</span></p><p data-translated="true"><span class="original-text">A zero-argument anonymous function can be written as <code>()-&gt;2+2</code>. The idea of a function with no arguments may seem strange, but is useful in cases where a result cannot (or should not) be precomputed. For example, Julia has a zero-argument <a href="../../base/base/index.html#Base.Libc.time-Tuple{}"><code>time</code></a> function that returns the current time in seconds, and thus <code>seconds = ()-&gt;round(Int, time())</code> is an anonymous function that returns this time rounded to the nearest integer assigned to the variable <code>seconds</code>. Each time this anonymous function is called as <code>seconds()</code> the current time will be calculated and returned.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数がゼロの匿名関数は、<code>()-&gt;2+2</code>として記述できます。引数のない関数のアイデアは奇妙に思えるかもしれませんが、結果を事前に計算できない（またはすべきでない）場合に役立ちます。例えば、Juliaには現在の時間を秒単位で返すゼロ引数の<a href="../../base/base/index.html#Base.Libc.time-Tuple{}"><code>time</code></a>関数があり、したがって<code>seconds = ()-&gt;round(Int, time())</code>は、この時間を最も近い整数に丸めて変数<code>seconds</code>に割り当てる匿名関数です。この匿名関数が<code>seconds()</code>として呼び出されるたびに、現在の時間が計算されて返されます。</span></p><h2 id="Tuples" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Tuples">Tuples</a><a id="Tuples-1"></a><a class="docs-heading-anchor-permalink" href="#Tuples" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Tuples">タプル</a><a id="Tuples-1"></a><a class="docs-heading-anchor-permalink" href="#Tuples" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Julia has a built-in data structure called a <em>tuple</em> that is closely related to function arguments and return values. A tuple is a fixed-length container that can hold any values, but cannot be modified (it is <em>immutable</em>). Tuples are constructed with commas and parentheses, and can be accessed via indexing:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaには、関数の引数や戻り値に密接に関連する<em>タプル</em>という組み込みデータ構造があります。タプルは固定長のコンテナで、任意の値を保持できますが、変更することはできません（<em>不変</em>です）。タプルはカンマと括弧で構成され、インデックスを介してアクセスできます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; (1, 1+1)
(1, 2)

julia&gt; (1,)
(1,)

julia&gt; x = (0.0, "hello", 6*7)
(0.0, "hello", 42)

julia&gt; x[2]
"hello"</code></pre><p data-translated="true"><span class="original-text">Notice that a length-1 tuple must be written with a comma, <code>(1,)</code>, since <code>(1)</code> would just be a parenthesized value. <code>()</code> represents the empty (length-0) tuple.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">長さ1のタプルはカンマを付けて<code>(1,)</code>と書かなければなりません。<code>(1)</code>は単に括弧で囲まれた値になります。<code>()</code>は空の（長さ0の）タプルを表します。</span></p><h2 id="Named-Tuples" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Named-Tuples">Named Tuples</a><a id="Named-Tuples-1"></a><a class="docs-heading-anchor-permalink" href="#Named-Tuples" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Named-Tuples">名前付きタプル</a><a id="Named-Tuples-1"></a><a class="docs-heading-anchor-permalink" href="#Named-Tuples" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The components of tuples can optionally be named, in which case a <em>named tuple</em> is constructed:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">タプルの要素にはオプションで名前を付けることができ、その場合は<em>名前付きタプル</em>が構築されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = (a=2, b=1+2)
(a = 2, b = 3)

julia&gt; x[1]
2

julia&gt; x.a
2</code></pre><p data-translated="true"><span class="original-text">The fields of named tuples can be accessed by name using dot syntax (<code>x.a</code>) in addition to the regular indexing syntax (<code>x[1]</code> or <code>x[:a]</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">名前付きタプルのフィールドには、ドット構文（<code>x.a</code>）を使用してアクセスでき、通常のインデックス構文（<code>x[1]</code>または<code>x[:a]</code>）でもアクセスできます。</span></p><h2 id="destructuring-assignment" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#destructuring-assignment">Destructuring Assignment and Multiple Return Values</a><a id="destructuring-assignment-1"></a><a class="docs-heading-anchor-permalink" href="#destructuring-assignment" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#destructuring-assignment">分解代入と複数の戻り値</a><a id="destructuring-assignment-1"></a><a class="docs-heading-anchor-permalink" href="#destructuring-assignment" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">A comma-separated list of variables (optionally wrapped in parentheses) can appear on the left side of an assignment: the value on the right side is <em>destructured</em> by iterating over and assigning to each variable in turn:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">カンマ区切りの変数のリスト（オプションで括弧で囲むことができます）は、代入の左側に現れることができます：右側の値は、各変数に順番に代入することで<em>分解されます</em>。</span></p><pre><code class="language-julia-repl hljs">julia&gt; (a, b, c) = 1:3
1:3

julia&gt; b
2</code></pre><p data-translated="true"><span class="original-text">The value on the right should be an iterator (see <a href="../interfaces/index.html#man-interface-iteration">Iteration interface</a>) at least as long as the number of variables on the left (any excess elements of the iterator are ignored).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">右側の値はイテレータである必要があります（詳細は<a href="../interfaces/index.html#man-interface-iteration">イテレーションインターフェース</a>を参照）で、左側の変数の数と同じかそれ以上の長さでなければなりません（イテレータの余分な要素は無視されます）。</span></p><p data-translated="true"><span class="original-text">This can be used to return multiple values from functions by returning a tuple or other iterable value. For example, the following function returns two values:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、タプルや他のイテラブルな値を返すことで、関数から複数の値を返すために使用できます。例えば、次の関数は2つの値を返します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function foo(a, b)
           a+b, a*b
       end
foo (generic function with 1 method)</code></pre><p data-translated="true"><span class="original-text">If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">インタラクティブセッションで戻り値をどこにも代入せずに呼び出すと、返されたタプルが表示されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; foo(2, 3)
(5, 6)</code></pre><p data-translated="true"><span class="original-text">Destructuring assignment extracts each value into a variable:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">分解代入は各値を変数に抽出します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x, y = foo(2, 3)
(5, 6)

julia&gt; x
5

julia&gt; y
6</code></pre><p data-translated="true"><span class="original-text">Another common use is for swapping variables:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もう一つの一般的な使用法は、変数を入れ替えることです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; y, x = x, y
(5, 6)

julia&gt; x
6

julia&gt; y
5</code></pre><p data-translated="true"><span class="original-text">If only a subset of the elements of the iterator are required, a common convention is to assign ignored elements to a variable consisting of only underscores <code>_</code> (which is an otherwise invalid variable name, see <a href="../variables/index.html#man-allowed-variable-names">Allowed Variable Names</a>):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">イテレータの要素のサブセットのみが必要な場合、無視される要素をアンダースコアのみからなる変数<code>_</code>に代入するという一般的な慣習があります（これはそれ以外では無効な変数名です。詳細は<a href="../variables/index.html#man-allowed-variable-names">許可された変数名</a>を参照）：</span></p><pre><code class="language-julia-repl hljs">julia&gt; _, _, _, d = 1:10
1:10

julia&gt; d
4</code></pre><p data-translated="true"><span class="original-text">Other valid left-hand side expressions can be used as elements of the assignment list, which will call <a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a> or <a href="../../base/base/index.html#Base.setproperty!"><code>setproperty!</code></a>, or recursively destructure individual elements of the iterator:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">代入リストの要素として他の有効な左辺式を使用することができ、これにより<a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a>または<a href="../../base/base/index.html#Base.setproperty!"><code>setproperty!</code></a>が呼び出されるか、イテレータの個々の要素が再帰的に分解されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; X = zeros(3);

julia&gt; X[1], (a, b) = (1, (2, 3))
(1, (2, 3))

julia&gt; X
3-element Vector{Float64}:
 1.0
 0.0
 0.0

julia&gt; a
2

julia&gt; b
3</code></pre><div class="admonition is-compat" id="Julia-1.6-fb1e4553045f3a22"><header class="admonition-header">Julia 1.6<a class="admonition-anchor" href="#Julia-1.6-fb1e4553045f3a22" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text"><code>...</code> with assignment requires Julia 1.6</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>...</code>を伴う代入はJulia 1.6が必要です。</span></p></div></div><p data-translated="true"><span class="original-text">If the last symbol in the assignment list is suffixed by <code>...</code> (known as <em>slurping</em>), then it will be assigned a collection or lazy iterator of the remaining elements of the right-hand side iterator:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">代入リストの最後のシンボルが<code>...</code>（<em>スラーピング</em>として知られる）でサフィックスされている場合、右側のイテレータの残りの要素のコレクションまたは遅延イテレータが代入されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; a, b... = "hello"
"hello"

julia&gt; a
'h': ASCII/Unicode U+0068 (category Ll: Letter, lowercase)

julia&gt; b
"ello"

julia&gt; a, b... = Iterators.map(abs2, 1:4)
Base.Generator{UnitRange{Int64}, typeof(abs2)}(abs2, 1:4)

julia&gt; a
1

julia&gt; b
Base.Iterators.Rest{Base.Generator{UnitRange{Int64}, typeof(abs2)}, Int64}(Base.Generator{UnitRange{Int64}, typeof(abs2)}(abs2, 1:4), 1)</code></pre><p data-translated="true"><span class="original-text">See <a href="../../base/collections/index.html#Base.rest"><code>Base.rest</code></a> for details on the precise handling and customization for specific iterators.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">詳細については、<a href="../../base/collections/index.html#Base.rest"><code>Base.rest</code></a>を参照してください。特定のイテレータの正確な処理とカスタマイズについて説明しています。</span></p><div class="admonition is-compat" id="Julia-1.9-28eb827b6bacef02"><header class="admonition-header">Julia 1.9<a class="admonition-anchor" href="#Julia-1.9-28eb827b6bacef02" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text"><code>...</code> in non-final position of an assignment requires Julia 1.9</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>...</code> は、代入の非最終位置においてJulia 1.9を必要とします。</span></p></div></div><p data-translated="true"><span class="original-text">Slurping in assignments can also occur in any other position. As opposed to slurping the end of a collection however, this will always be eager.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">代入におけるスラーピングは、他の位置でも発生する可能性があります。ただし、コレクションの末尾をスラーピングするのとは異なり、これは常にイagerです。</span></p><pre><code class="language-julia-repl hljs">julia&gt; a, b..., c = 1:5
1:5

julia&gt; a
1

julia&gt; b
3-element Vector{Int64}:
 2
 3
 4

julia&gt; c
5

julia&gt; front..., tail = "Hi!"
"Hi!"

julia&gt; front
"Hi"

julia&gt; tail
'!': ASCII/Unicode U+0021 (category Po: Punctuation, other)</code></pre><p data-translated="true"><span class="original-text">This is implemented in terms of the function <a href="../../base/collections/index.html#Base.split_rest"><code>Base.split_rest</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、関数<a href="../../base/collections/index.html#Base.split_rest"><code>Base.split_rest</code></a>に基づいて実装されています。</span></p><p data-translated="true"><span class="original-text">Note that for variadic function definitions, slurping is still only allowed in final position. This does not apply to <a href="#man-argument-destructuring">single argument destructuring</a> though, as that does not affect method dispatch:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">可変引数関数の定義において、スラーピングは依然として最終位置でのみ許可されていることに注意してください。ただし、これは<a href="#man-argument-destructuring">単一引数のデストラクチャリング</a>には適用されません。なぜなら、それはメソッドディスパッチに影響を与えないからです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(x..., y) = x
ERROR: syntax: invalid "..." on non-final argument
Stacktrace:
[...]

julia&gt; f((x..., y)) = x
f (generic function with 1 method)

julia&gt; f((1, 2, 3))
(1, 2)</code></pre><h2 id="Property-destructuring" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Property-destructuring">Property destructuring</a><a id="Property-destructuring-1"></a><a class="docs-heading-anchor-permalink" href="#Property-destructuring" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Property-destructuring">プロパティデストラクチャリング</a><a id="Property-destructuring-1"></a><a class="docs-heading-anchor-permalink" href="#Property-destructuring" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Instead of destructuring based on iteration, the right side of assignments can also be destructured using property names. This follows the syntax for NamedTuples, and works by assigning to each variable on the left a property of the right side of the assignment with the same name using <code>getproperty</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">イテレーションに基づくデストラクチャリングの代わりに、代入の右側はプロパティ名を使用してデストラクチャリングすることもできます。これはNamedTuplesの構文に従い、左側の各変数に対して、代入の右側の同じ名前のプロパティを<code>getproperty</code>を使用して割り当てることによって機能します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; (; b, a) = (a=1, b=2, c=3)
(a = 1, b = 2, c = 3)

julia&gt; a
1

julia&gt; b
2</code></pre><h2 id="man-argument-destructuring" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-argument-destructuring">Argument destructuring</a><a id="man-argument-destructuring-1"></a><a class="docs-heading-anchor-permalink" href="#man-argument-destructuring" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-argument-destructuring">引数デストラクチャリング</a><a id="man-argument-destructuring-1"></a><a class="docs-heading-anchor-permalink" href="#man-argument-destructuring" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The destructuring feature can also be used within a function argument. If a function argument name is written as a tuple (e.g. <code>(x, y)</code>) instead of just a symbol, then an assignment <code>(x, y) = argument</code> will be inserted for you:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デストラクチャリング機能は、関数の引数内でも使用できます。関数引数名が単なるシンボルではなくタプル（例：<code>(x, y)</code>）として書かれている場合、代入<code>(x, y) = argument</code>が自動的に挿入されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; minmax(x, y) = (y &lt; x) ? (y, x) : (x, y)

julia&gt; gap((min, max)) = max - min

julia&gt; gap(minmax(10, 2))
8</code></pre><p data-translated="true"><span class="original-text">Notice the extra set of parentheses in the definition of <code>gap</code>. Without those, <code>gap</code> would be a two-argument function, and this example would not work.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>gap</code>の定義における追加の括弧に注意してください。それがなければ、<code>gap</code>は二引数関数となり、この例は機能しません。</span></p><p data-translated="true"><span class="original-text">Similarly, property destructuring can also be used for function arguments:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同様に、プロパティの分解代入は関数の引数にも使用できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; foo((; x, y)) = x + y
foo (generic function with 1 method)

julia&gt; foo((x=1, y=2))
3

julia&gt; struct A
           x
           y
       end

julia&gt; foo(A(3, 4))
7</code></pre><p data-translated="true"><span class="original-text">For anonymous functions, destructuring a single argument requires an extra comma:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">匿名関数の場合、単一の引数を分解代入するには追加のカンマが必要です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; map(((x, y),) -&gt; x + y, [(1, 2), (3, 4)])
2-element Vector{Int64}:
 3
 7</code></pre><h2 id="Varargs-Functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Varargs-Functions">Varargs Functions</a><a id="Varargs-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Varargs-Functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Varargs-Functions">可変引数関数</a><a id="Varargs-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Varargs-Functions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as "varargs" functions, which is short for "variable number of arguments". You can define a varargs function by following the last positional argument with an ellipsis:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">任意の数の引数を取る関数を書くことができると便利です。このような関数は伝統的に「varargs」関数として知られており、「可変数の引数」の略です。varargs関数は、最後の位置引数の後に省略記号を付けることで定義できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; bar(a, b, x...) = (a, b, x)
bar (generic function with 1 method)</code></pre><p data-translated="true"><span class="original-text">The variables <code>a</code> and <code>b</code> are bound to the first two argument values as usual, and the variable <code>x</code> is bound to an iterable collection of the zero or more values passed to <code>bar</code> after its first two arguments:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">変数 <code>a</code> と <code>b</code> は通常通り最初の2つの引数の値にバインドされ、変数 <code>x</code> は最初の2つの引数の後に <code>bar</code> に渡された0個以上の値のイテラブルコレクションにバインドされます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; bar(1, 2)
(1, 2, ())

julia&gt; bar(1, 2, 3)
(1, 2, (3,))

julia&gt; bar(1, 2, 3, 4)
(1, 2, (3, 4))

julia&gt; bar(1, 2, 3, 4, 5, 6)
(1, 2, (3, 4, 5, 6))</code></pre><p data-translated="true"><span class="original-text">In all these cases, <code>x</code> is bound to a tuple of the trailing values passed to <code>bar</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらすべての場合において、<code>x</code> は <code>bar</code> に渡された末尾の値のタプルにバインドされます。</span></p><p data-translated="true"><span class="original-text">It is possible to constrain the number of values passed as a variable argument; this will be discussed later in <a href="../methods/index.html#Parametrically-constrained-Varargs-methods">Parametrically-constrained Varargs methods</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">可変引数として渡される値の数を制約することも可能です。これは後で <a href="../methods/index.html#Parametrically-constrained-Varargs-methods">パラメトリックに制約されたVarargsメソッド</a>で説明します。</span></p><p data-translated="true"><span class="original-text">On the flip side, it is often handy to "splat" the values contained in an iterable collection into a function call as individual arguments. To do this, one also uses <code>...</code> but in the function call instead:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">逆に、イテラブルコレクションに含まれる値を関数呼び出しに個々の引数として「スプラット」することが便利な場合もあります。これを行うには、関数呼び出しの中で <code>...</code> を使用します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = (3, 4)
(3, 4)

julia&gt; bar(1, 2, x...)
(1, 2, (3, 4))</code></pre><p data-translated="true"><span class="original-text">In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments go. This need not be the case, however:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この場合、値のタプルが可変引数の呼び出しに正確に引数の数が入る場所にスプライスされます。ただし、必ずしもそうである必要はありません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = (2, 3, 4)
(2, 3, 4)

julia&gt; bar(1, x...)
(1, 2, (3, 4))

julia&gt; x = (1, 2, 3, 4)
(1, 2, 3, 4)

julia&gt; bar(x...)
(1, 2, (3, 4))</code></pre><p data-translated="true"><span class="original-text">Furthermore, the iterable object splatted into a function call need not be a tuple:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さらに、関数呼び出しにスプラットされたイテラブルオブジェクトはタプルである必要はありません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = [3, 4]
2-element Vector{Int64}:
 3
 4

julia&gt; bar(1, 2, x...)
(1, 2, (3, 4))

julia&gt; x = [1, 2, 3, 4]
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; bar(x...)
(1, 2, (3, 4))</code></pre><p data-translated="true"><span class="original-text">Also, the function that arguments are splatted into need not be a varargs function (although it often is):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、引数がスプラットされる関数は、可変引数関数である必要はありません（ただし、しばしばそうなります）：</span></p><pre><code class="language-julia-repl hljs">julia&gt; baz(a, b) = a + b;

julia&gt; args = [1, 2]
2-element Vector{Int64}:
 1
 2

julia&gt; baz(args...)
3

julia&gt; args = [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; baz(args...)
ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
The function `baz` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  baz(::Any, ::Any)
   @ Main none:1

Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">As you can see, if the wrong number of elements are in the splatted container, then the function call will fail, just as it would if too many arguments were given explicitly.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ご覧の通り、スプラットされたコンテナに要素の数が間違っている場合、関数呼び出しは失敗します。これは、引数が明示的に多すぎる場合と同様です。</span></p><h2 id="Optional-Arguments" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Optional-Arguments">Optional Arguments</a><a id="Optional-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-Arguments" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Optional-Arguments">オプショナル引数</a><a id="Optional-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-Arguments" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">It is often possible to provide sensible default values for function arguments. This can save users from having to pass every argument on every call. For example, the function <a href="../../stdlib/Dates/index.html#Dates.Date"><code>Date(y, [m, d])</code></a> from <code>Dates</code> module constructs a <code>Date</code> type for a given year <code>y</code>, month <code>m</code> and day <code>d</code>. However, <code>m</code> and <code>d</code> arguments are optional and their default value is <code>1</code>. This behavior can be expressed concisely as:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数の引数に対して合理的なデフォルト値を提供することがしばしば可能です。これにより、ユーザーは毎回すべての引数を渡す必要がなくなります。例えば、<code>Dates</code>モジュールの関数<a href="../../stdlib/Dates/index.html#Dates.Date"><code>Date(y, [m, d])</code></a>は、指定された年<code>y</code>、月<code>m</code>、日<code>d</code>の<code>Date</code>型を構築します。ただし、<code>m</code>と<code>d</code>の引数はオプショナルであり、そのデフォルト値は<code>1</code>です。この動作は簡潔に次のように表現できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; using Dates

julia&gt; function date(y::Int64, m::Int64=1, d::Int64=1)
           err = Dates.validargs(Date, y, m, d)
           err === nothing || throw(err)
           return Date(Dates.UTD(Dates.totaldays(y, m, d)))
       end
date (generic function with 3 methods)</code></pre><p data-translated="true"><span class="original-text">Observe, that this definition calls another method of the <code>Date</code> function that takes one argument of type <code>UTInstant{Day}</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この定義は、<code>Date</code>関数の別のメソッドを呼び出しており、そのメソッドは<code>UTInstant{Day}</code>型の引数を1つ取ります。</span></p><p data-translated="true"><span class="original-text">With this definition, the function can be called with either one, two or three arguments, and <code>1</code> is automatically passed when only one or two of the arguments are specified:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この定義により、関数は1つ、2つ、または3つの引数で呼び出すことができ、引数が1つまたは2つだけ指定された場合は<code>1</code>が自動的に渡されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; date(2000, 12, 12)
2000-12-12

julia&gt; date(2000, 12)
2000-12-01

julia&gt; date(2000)
2000-01-01</code></pre><p data-translated="true"><span class="original-text">Optional arguments are actually just a convenient syntax for writing multiple method definitions with different numbers of arguments (see <a href="../methods/index.html#Note-on-Optional-and-keyword-Arguments">Note on Optional and keyword Arguments</a>). This can be checked for our <code>date</code> function example by calling the <code>methods</code> function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">オプショナル引数は、実際には異なる数の引数を持つ複数のメソッド定義を書くための便利な構文です（<a href="../methods/index.html#Note-on-Optional-and-keyword-Arguments">オプショナルおよびキーワード引数に関する注意</a>を参照）。これは、<code>date</code>関数の例に対して<code>methods</code>関数を呼び出すことで確認できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; methods(date)
# 3 methods for generic function "date":
[1] date(y::Int64) in Main at REPL[1]:1
[2] date(y::Int64, m::Int64) in Main at REPL[1]:1
[3] date(y::Int64, m::Int64, d::Int64) in Main at REPL[1]:1</code></pre><h2 id="Keyword-Arguments" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Keyword-Arguments">Keyword Arguments</a><a id="Keyword-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-Arguments" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Keyword-Arguments">キーワード引数</a><a id="Keyword-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-Arguments" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Some functions need a large number of arguments, or have a large number of behaviors. Remembering how to call such functions can be difficult. Keyword arguments can make these complex interfaces easier to use and extend by allowing arguments to be identified by name instead of only by position.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一部の関数は多くの引数を必要としたり、多くの動作を持ったりします。そのような関数を呼び出す方法を覚えるのは難しいことがあります。キーワード引数は、引数を位置だけでなく名前で特定できるようにすることで、これらの複雑なインターフェースを使いやすくし、拡張しやすくします。</span></p><p data-translated="true"><span class="original-text">For example, consider a function <code>plot</code> that plots a line. This function might have many options, for controlling line style, width, color, and so on. If it accepts keyword arguments, a possible call might look like <code>plot(x, y, width=2)</code>, where we have chosen to specify only line width. Notice that this serves two purposes. The call is easier to read, since we can label an argument with its meaning. It also becomes possible to pass any subset of a large number of arguments, in any order.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、線をプロットする関数<code>plot</code>を考えてみましょう。この関数には、線のスタイル、幅、色などを制御するための多くのオプションがあるかもしれません。キーワード引数を受け入れる場合、呼び出しの例は<code>plot(x, y, width=2)</code>のようになります。ここでは、線の幅だけを指定することにしました。この呼び出しは2つの目的を果たします。呼び出しが読みやすくなり、引数に意味をラベル付けできます。また、多くの引数の任意の部分集合を、任意の順序で渡すことも可能になります。</span></p><p data-translated="true"><span class="original-text">Functions with keyword arguments are defined using a semicolon in the signature:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キーワード引数を持つ関数は、シグネチャでセミコロンを使用して定義されます。</span></p><pre><code class="language-julia hljs">function plot(x, y; style="solid", width=1, color="black")
    ###
end</code></pre><p data-translated="true"><span class="original-text">When the function is called, the semicolon is optional: one can either call <code>plot(x, y, width=2)</code> or <code>plot(x, y; width=2)</code>, but the former style is more common. An explicit semicolon is required only for passing varargs or computed keywords as described below.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数が呼び出されるとき、セミコロンはオプションです：<code>plot(x, y, width=2)</code>または<code>plot(x, y; width=2)</code>のいずれかを呼び出すことができますが、前者のスタイルが一般的です。明示的なセミコロンは、以下に説明するようにvarargsまたは計算されたキーワードを渡す場合にのみ必要です。</span></p><p data-translated="true"><span class="original-text">Keyword argument default values are evaluated only when necessary (when a corresponding keyword argument is not passed), and in left-to-right order. Therefore default expressions may refer to prior keyword arguments.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キーワード引数のデフォルト値は、必要なとき（対応するキーワード引数が渡されていないとき）のみ評価され、左から右の順序で評価されます。したがって、デフォルト式は以前のキーワード引数を参照することができます。</span></p><p data-translated="true"><span class="original-text">The types of keyword arguments can be made explicit as follows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キーワード引数の型を明示的にすることもできます。</span></p><pre><code class="language-julia hljs">function f(; x::Int=1)
    ###
end</code></pre><p data-translated="true"><span class="original-text">Keyword arguments can also be used in varargs functions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キーワード引数はvarargs関数でも使用できます：</span></p><pre><code class="language-julia hljs">function plot(x...; style="solid")
    ###
end</code></pre><p data-translated="true"><span class="original-text">Extra keyword arguments can be collected using <code>...</code>, as in varargs functions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">追加のキーワード引数は、varargs関数のように<code>...</code>を使用して収集できます：</span></p><pre><code class="language-julia hljs">function f(x; y=0, kwargs...)
    ###
end</code></pre><p data-translated="true"><span class="original-text">Inside <code>f</code>, <code>kwargs</code> will be an immutable key-value iterator over a named tuple. Named tuples (as well as dictionaries with keys of <code>Symbol</code>, and other iterators yielding two-value collections with symbol as first values) can be passed as keyword arguments using a semicolon in a call, e.g. <code>f(x, z=1; kwargs...)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>f</code>の内部では、<code>kwargs</code>は名前付きタプルに対する不変のキー-バリューイテレータになります。名前付きタプル（および<code>Symbol</code>のキーを持つ辞書、最初の値がシンボルである二値コレクションを生成する他のイテレータ）は、呼び出しでセミコロンを使用してキーワード引数として渡すことができます。例えば、<code>f(x, z=1; kwargs...)</code>のように。</span></p><p data-translated="true"><span class="original-text">If a keyword argument is not assigned a default value in the method definition, then it is <em>required</em>: an <a href="../../base/base/index.html#Core.UndefKeywordError"><code>UndefKeywordError</code></a> exception will be thrown if the caller does not assign it a value:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メソッド定義でキーワード引数にデフォルト値が割り当てられていない場合、それは<em>必須</em>です：呼び出し元が値を割り当てないと、<a href="../../base/base/index.html#Core.UndefKeywordError"><code>UndefKeywordError</code></a>例外がスローされます。</span></p><pre><code class="language-julia hljs">function f(x; y)
    ###
end
f(3, y=5) # ok, y is assigned
f(3)      # throws UndefKeywordError(:y)</code></pre><p data-translated="true"><span class="original-text">One can also pass <code>key =&gt; value</code> expressions after a semicolon. For example, <code>plot(x, y; :width =&gt; 2)</code> is equivalent to <code>plot(x, y, width=2)</code>. This is useful in situations where the keyword name is computed at runtime.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">セミコロンの後に<code>key =&gt; value</code>式を渡すこともできます。例えば、<code>plot(x, y; :width =&gt; 2)</code>は<code>plot(x, y, width=2)</code>と同等です。これは、キーワード名が実行時に計算される状況で便利です。</span></p><p data-translated="true"><span class="original-text">When a bare identifier or dot expression occurs after a semicolon, the keyword argument name is implied by the identifier or field name. For example <code>plot(x, y; width)</code> is equivalent to <code>plot(x, y; width=width)</code> and <code>plot(x, y; options.width)</code> is equivalent to <code>plot(x, y; width=options.width)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">セミコロンの後に裸の識別子またはドット式が現れると、キーワード引数名は識別子またはフィールド名によって暗示されます。例えば、<code>plot(x, y; width)</code>は<code>plot(x, y; width=width)</code>と同等であり、<code>plot(x, y; options.width)</code>は<code>plot(x, y; width=options.width)</code>と同等です。</span></p><p data-translated="true"><span class="original-text">The nature of keyword arguments makes it possible to specify the same argument more than once. For example, in the call <code>plot(x, y; options..., width=2)</code> it is possible that the <code>options</code> structure also contains a value for <code>width</code>. In such a case the rightmost occurrence takes precedence; in this example, <code>width</code> is certain to have the value <code>2</code>. However, explicitly specifying the same keyword argument multiple times, for example <code>plot(x, y, width=2, width=3)</code>, is not allowed and results in a syntax error.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キーワード引数の性質により、同じ引数を複数回指定することが可能です。例えば、呼び出し <code>plot(x, y; options..., width=2)</code> では、<code>options</code> 構造体にも <code>width</code> の値が含まれている可能性があります。この場合、最も右側の出現が優先されます。この例では、<code>width</code> は確実に値 <code>2</code> を持ちます。ただし、同じキーワード引数を複数回明示的に指定すること、例えば <code>plot(x, y, width=2, width=3)</code> は許可されておらず、構文エラーになります。</span></p><h2 id="Evaluation-Scope-of-Default-Values" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Evaluation-Scope-of-Default-Values">Evaluation Scope of Default Values</a><a id="Evaluation-Scope-of-Default-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-Scope-of-Default-Values" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Evaluation-Scope-of-Default-Values">デフォルト値の評価スコープ</a><a id="Evaluation-Scope-of-Default-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-Scope-of-Default-Values" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">When optional and keyword argument default expressions are evaluated, only <em>previous</em> arguments are in scope. For example, given this definition:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">オプションおよびキーワード引数のデフォルト式が評価されるとき、<em>前の</em> 引数のみがスコープ内にあります。例えば、この定義を考えてみてください：</span></p><pre><code class="language-julia hljs">function f(x, a=b, b=1)
    ###
end</code></pre><p data-translated="true"><span class="original-text">the <code>b</code> in <code>a=b</code> refers to a <code>b</code> in an outer scope, not the subsequent argument <code>b</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>a=b</code> の <code>b</code> は、後の引数 <code>b</code> ではなく、外側のスコープの <code>b</code> を参照します。</span></p><h2 id="Do-Block-Syntax-for-Function-Arguments" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Do-Block-Syntax-for-Function-Arguments">Do-Block Syntax for Function Arguments</a><a id="Do-Block-Syntax-for-Function-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Do-Block-Syntax-for-Function-Arguments" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Do-Block-Syntax-for-Function-Arguments">関数引数のための Do-ブロック構文</a><a id="Do-Block-Syntax-for-Function-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Do-Block-Syntax-for-Function-Arguments" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Passing functions as arguments to other functions is a powerful technique, but the syntax for it is not always convenient. Such calls are especially awkward to write when the function argument requires multiple lines. As an example, consider calling <a href="../../base/collections/index.html#Base.map"><code>map</code></a> on a function with several cases:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数を他の関数への引数として渡すことは強力な技術ですが、その構文は常に便利とは限りません。このような呼び出しは、関数引数が複数行を必要とする場合、特に書きにくくなります。例えば、複数のケースを持つ関数に対して <a href="../../base/collections/index.html#Base.map"><code>map</code></a> を呼び出すことを考えてみてください：</span></p><pre><code class="language-julia hljs">map(x-&gt;begin
           if x &lt; 0 &amp;&amp; iseven(x)
               return 0
           elseif x == 0
               return 1
           else
               return x
           end
       end,
    [A, B, C])</code></pre><p data-translated="true"><span class="original-text">Julia provides a reserved word <code>do</code> for rewriting this code more clearly:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia は、このコードをより明確に書き直すための予約語 <code>do</code> を提供しています：</span></p><pre><code class="language-julia hljs">map([A, B, C]) do x
    if x &lt; 0 &amp;&amp; iseven(x)
        return 0
    elseif x == 0
        return 1
    else
        return x
    end
end</code></pre><p data-translated="true"><span class="original-text">The <code>do x</code> syntax creates an anonymous function with argument <code>x</code> and passes the anonymous function as the first argument to the "outer" function - <a href="../../base/collections/index.html#Base.map"><code>map</code></a> in this example. Similarly, <code>do a,b</code> would create a two-argument anonymous function. Note that <code>do (a,b)</code> would create a one-argument anonymous function, whose argument is a tuple to be deconstructed. A plain <code>do</code> would declare that what follows is an anonymous function of the form <code>() -&gt; ...</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>do x</code> 構文は、引数 <code>x</code> を持つ匿名関数を作成し、その匿名関数を「外側」の関数 - この例では <a href="../../base/collections/index.html#Base.map"><code>map</code></a> に最初の引数として渡します。同様に、<code>do a,b</code> は二引数の匿名関数を作成します。<code>do (a,b)</code> は、引数が分解されるタプルである一引数の匿名関数を作成します。単純な <code>do</code> は、続くものが <code>() -&gt; ...</code> の形の匿名関数であることを宣言します。</span></p><p data-translated="true"><span class="original-text">How these arguments are initialized depends on the "outer" function; here, <a href="../../base/collections/index.html#Base.map"><code>map</code></a> will sequentially set <code>x</code> to <code>A</code>, <code>B</code>, <code>C</code>, calling the anonymous function on each, just as would happen in the syntax <code>map(func, [A, B, C])</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの引数がどのように初期化されるかは「外側」の関数に依存します。ここでは、<a href="../../base/collections/index.html#Base.map"><code>map</code></a> が順次 <code>x</code> を <code>A</code>、<code>B</code>、<code>C</code> に設定し、それぞれに対して匿名関数を呼び出します。これは、構文 <code>map(func, [A, B, C])</code> で起こることと同じです。</span></p><p data-translated="true"><span class="original-text">This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks. There are many possible uses quite different from <a href="../../base/collections/index.html#Base.map"><code>map</code></a>, such as managing system state. For example, there is a version of <a href="../../base/io-network/index.html#Base.open"><code>open</code></a> that runs code ensuring that the opened file is eventually closed:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この構文は、関数を使用して言語を効果的に拡張するのを容易にします。なぜなら、呼び出しが通常のコードブロックのように見えるからです。<a href="../../base/collections/index.html#Base.map"><code>map</code></a> とは異なる多くの可能な使用法があり、システム状態の管理などがあります。例えば、開いたファイルが最終的に閉じられることを保証するコードを実行する <a href="../../base/io-network/index.html#Base.open"><code>open</code></a> のバージョンがあります：</span></p><pre><code class="language-julia hljs">open("outfile", "w") do io
    write(io, data)
end</code></pre><p data-translated="true"><span class="original-text">This is accomplished by the following definition:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは次の定義によって実現されます：</span></p><pre><code class="language-julia hljs">function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end</code></pre><p data-translated="true"><span class="original-text">Here, <a href="../../base/io-network/index.html#Base.open"><code>open</code></a> first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the <code>do ... end</code> block. After your function exits, <a href="../../base/io-network/index.html#Base.open"><code>open</code></a> will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The <code>try/finally</code> construct will be described in <a href="../control-flow/index.html#Control-Flow">Control Flow</a>.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで、<a href="../../base/io-network/index.html#Base.open"><code>open</code></a>は最初にファイルをライティングのために開き、その後、<code>do ... end</code>ブロックで定義した匿名関数に結果の出力ストリームを渡します。あなたの関数が終了すると、<a href="../../base/io-network/index.html#Base.open"><code>open</code></a>は、あなたの関数が正常に終了したか、例外をスローしたかに関わらず、ストリームが適切に閉じられることを確認します。（<code>try/finally</code>構文については、<a href="../control-flow/index.html#Control-Flow">制御フロー</a>で説明されます。）</span></p><p data-translated="true"><span class="original-text">With the <code>do</code> block syntax, it helps to check the documentation or implementation to know how the arguments of the user function are initialized.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>do</code>ブロック構文では、ユーザー関数の引数がどのように初期化されるかを知るために、ドキュメントや実装を確認することが役立ちます。</span></p><p data-translated="true"><span class="original-text">A <code>do</code> block, like any other inner function, can "capture" variables from its enclosing scope. For example, the variable <code>data</code> in the above example of <code>open...do</code> is captured from the outer scope. Captured variables can create performance challenges as discussed in <a href="../performance-tips/index.html#man-performance-captured">performance tips</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>do</code>ブロックは、他の内部関数と同様に、囲むスコープから変数を「キャプチャ」することができます。例えば、<code>open...do</code>の上記の例における変数<code>data</code>は外部スコープからキャプチャされています。キャプチャされた変数は、<a href="../performance-tips/index.html#man-performance-captured">パフォーマンスのヒント</a>で議論されているように、パフォーマンス上の課題を引き起こす可能性があります。</span></p><h2 id="Function-composition-and-piping" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Function-composition-and-piping">Function composition and piping</a><a id="Function-composition-and-piping-1"></a><a class="docs-heading-anchor-permalink" href="#Function-composition-and-piping" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Function-composition-and-piping">関数の合成とパイピング</a><a id="Function-composition-and-piping-1"></a><a class="docs-heading-anchor-permalink" href="#Function-composition-and-piping" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Functions in Julia can be combined by composing or piping (chaining) them together.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの関数は、合成またはパイピング（チェイニング）によって組み合わせることができます。</span></p><p data-translated="true"><span class="original-text">Function composition is when you combine functions together and apply the resulting composition to arguments. You use the function composition operator (<code>∘</code>) to compose the functions, so <code>(f ∘ g)(args...; kw...)</code> is the same as <code>f(g(args...; kw...))</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数の合成とは、関数を組み合わせて、その結果の合成を引数に適用することです。関数合成演算子（<code>∘</code>）を使用して関数を合成しますので、<code>(f ∘ g)(args...; kw...)</code>は<code>f(g(args...; kw...))</code>と同じです。</span></p><p data-translated="true"><span class="original-text">You can type the composition operator at the REPL and suitably-configured editors using <code>\circ&lt;tab&gt;</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">合成演算子をREPLや適切に設定されたエディタで<code>\circ&lt;tab&gt;</code>を使用して入力できます。</span></p><p data-translated="true"><span class="original-text">For example, the <code>sqrt</code> and <code>+</code> functions can be composed like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、<code>sqrt</code>と<code>+</code>関数は次のように合成できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; (sqrt ∘ +)(3, 6)
3.0</code></pre><p data-translated="true"><span class="original-text">This adds the numbers first, then finds the square root of the result.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは最初に数を加算し、その後結果の平方根を求めます。</span></p><p data-translated="true"><span class="original-text">The next example composes three functions and maps the result over an array of strings:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次の例は、3つの関数を組み合わせて、その結果を文字列の配列にマッピングします：</span></p><pre><code class="language-julia-repl hljs">julia&gt; map(first ∘ reverse ∘ uppercase, split("you can compose functions like this"))
6-element Vector{Char}:
 'U': ASCII/Unicode U+0055 (category Lu: Letter, uppercase)
 'N': ASCII/Unicode U+004E (category Lu: Letter, uppercase)
 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)
 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)
 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)
 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)</code></pre><p data-translated="true"><span class="original-text">Function chaining (sometimes called "piping" or "using a pipe" to send data to a subsequent function) is when you apply a function to the previous function's output:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数のチェイニング（時には「パイピング」または「パイプを使用して」データを次の関数に送ることとも呼ばれます）は、前の関数の出力に関数を適用することです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; 1:10 |&gt; sum |&gt; sqrt
7.416198487095663</code></pre><p data-translated="true"><span class="original-text">Here, the total produced by <code>sum</code> is passed to the <code>sqrt</code> function. The equivalent composition would be:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、<code>sum</code>によって生成された合計が<code>sqrt</code>関数に渡されます。同等の合成は次のようになります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; (sqrt ∘ sum)(1:10)
7.416198487095663</code></pre><p data-translated="true"><span class="original-text">The pipe operator can also be used with broadcasting, as <code>.|&gt;</code>, to provide a useful combination of the chaining/piping and dot vectorization syntax (described below).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パイプ演算子は、<code>.|&gt;</code>のようにブロードキャスティングとともに使用することもでき、チェイニング/パイピングとドットベクトル化構文（以下に説明）を便利に組み合わせることができます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; ["a", "list", "of", "strings"] .|&gt; [uppercase, reverse, titlecase, length]
4-element Vector{Any}:
  "A"
  "tsil"
  "Of"
 7</code></pre><p data-translated="true"><span class="original-text">When combining pipes with anonymous functions, parentheses must be used if subsequent pipes are not to be parsed as part of the anonymous function's body. Compare:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パイプを匿名関数と組み合わせる場合、後続のパイプが匿名関数の本体の一部として解析されないようにするために、括弧を使用する必要があります。比較してください：</span></p><pre><code class="language-julia-repl hljs">julia&gt; 1:3 .|&gt; (x -&gt; x^2) |&gt; sum |&gt; sqrt
3.7416573867739413

julia&gt; 1:3 .|&gt; x -&gt; x^2 |&gt; sum |&gt; sqrt
3-element Vector{Float64}:
 1.0
 2.0
 3.0</code></pre><h2 id="man-vectorized" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-vectorized">Dot Syntax for Vectorizing Functions</a><a id="man-vectorized-1"></a><a class="docs-heading-anchor-permalink" href="#man-vectorized" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-vectorized">関数のベクトル化のためのドット構文</a><a id="man-vectorized-1"></a><a class="docs-heading-anchor-permalink" href="#man-vectorized" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">In technical-computing languages, it is common to have "vectorized" versions of functions, which simply apply a given function <code>f(x)</code> to each element of an array <code>A</code> to yield a new array via <code>f(A)</code>. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the "vectorized" version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are <em>not</em> required for performance, and indeed it is often beneficial to write your own loops (see <a href="../performance-tips/index.html#man-performance-tips">Performance Tips</a>), but they can still be convenient. Therefore, <em>any</em> Julia function <code>f</code> can be applied elementwise to any array (or other collection) with the syntax <code>f.(A)</code>. For example, <code>sin</code> can be applied to all elements in the vector <code>A</code> like so:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">技術計算言語では、関数の「ベクトル化」バージョンを持つことが一般的で、これは与えられた関数<code>f(x)</code>を配列<code>A</code>の各要素に適用して新しい配列を生成するものです<code>f(A)</code>。この種の構文はデータ処理に便利ですが、他の言語ではパフォーマンスのためにベクトル化が必要とされることもよくあります：ループが遅い場合、関数の「ベクトル化」バージョンは低レベル言語で書かれた高速ライブラリコードを呼び出すことができます。Juliaでは、ベクトル化関数はパフォーマンスに必要ではなく、実際には自分のループを書くことがしばしば有益です（<a href="../performance-tips/index.html#man-performance-tips">パフォーマンスのヒント</a>を参照）、しかしそれでも便利です。したがって、<em>任意の</em> Julia関数<code>f</code>は、構文<code>f.(A)</code>を使用して任意の配列（または他のコレクション）に要素ごとに適用できます。例えば、<code>sin</code>はベクトル<code>A</code>のすべての要素に次のように適用できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0, 2.0, 3.0]
3-element Vector{Float64}:
 1.0
 2.0
 3.0

julia&gt; sin.(A)
3-element Vector{Float64}:
 0.8414709848078965
 0.9092974268256817
 0.1411200080598672</code></pre><p data-translated="true"><span class="original-text">Of course, you can omit the dot if you write a specialized "vector" method of <code>f</code>, e.g. via <code>f(A::AbstractArray) = map(f, A)</code>, and this is just as efficient as <code>f.(A)</code>. The advantage of the <code>f.(A)</code> syntax is that which functions are vectorizable need not be decided upon in advance by the library writer.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もちろん、<code>f</code>の特化した「ベクトル」メソッドを記述する場合はドットを省略できます。例えば、<code>f(A::AbstractArray) = map(f, A)</code>のように書くことができ、これは<code>f.(A)</code>と同じくらい効率的です。<code>f.(A)</code>構文の利点は、どの関数がベクトル化可能であるかをライブラリ作成者が事前に決定する必要がないことです。</span></p><p data-translated="true"><span class="original-text">More generally, <code>f.(args...)</code> is actually equivalent to <code>broadcast(f, args...)</code>, which allows you to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars (see <a href="../arrays/index.html#Broadcasting">Broadcasting</a>). For example, if you have <code>f(x, y) = 3x + 4y</code>, then <code>f.(pi, A)</code> will return a new array consisting of <code>f(pi,a)</code> for each <code>a</code> in <code>A</code>, and <code>f.(vector1, vector2)</code> will return a new vector consisting of <code>f(vector1[i], vector2[i])</code> for each index <code>i</code> (throwing an exception if the vectors have different length).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より一般的には、<code>f.(args...)</code>は実際には<code>broadcast(f, args...)</code>と同等で、異なる形状の複数の配列や、配列とスカラーの混合に対して操作を行うことができます（<a href="../arrays/index.html#Broadcasting">ブロードキャスティング</a>を参照）。例えば、<code>f(x, y) = 3x + 4y</code>がある場合、<code>f.(pi, A)</code>は<code>f(pi,a)</code>の新しい配列を返し、<code>f.(vector1, vector2)</code>は各インデックス<code>i</code>に対して<code>f(vector1[i], vector2[i])</code>からなる新しいベクトルを返します（ベクトルの長さが異なる場合は例外をスローします）。</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(x, y) = 3x + 4y;

julia&gt; A = [1.0, 2.0, 3.0];

julia&gt; B = [4.0, 5.0, 6.0];

julia&gt; f.(pi, A)
3-element Vector{Float64}:
 13.42477796076938
 17.42477796076938
 21.42477796076938

julia&gt; f.(A, B)
3-element Vector{Float64}:
 19.0
 26.0
 33.0</code></pre><p data-translated="true"><span class="original-text">Keyword arguments are not broadcasted over, but are simply passed through to each call of the function. For example, <code>round.(x, digits=3)</code> is equivalent to <code>broadcast(x -&gt; round(x, digits=3), x)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キーワード引数はブロードキャストされませんが、単に関数の各呼び出しに渡されます。例えば、<code>round.(x, digits=3)</code>は<code>broadcast(x -&gt; round(x, digits=3), x)</code>と同等です。</span></p><p data-translated="true"><span class="original-text">Moreover, <em>nested</em> <code>f.(args...)</code> calls are <em>fused</em> into a single <code>broadcast</code> loop. For example, <code>sin.(cos.(X))</code> is equivalent to <code>broadcast(x -&gt; sin(cos(x)), X)</code>, similar to <code>[sin(cos(x)) for x in X]</code>: there is only a single loop over <code>X</code>, and a single array is allocated for the result. [In contrast, <code>sin(cos(X))</code> in a typical "vectorized" language would first allocate one temporary array for <code>tmp=cos(X)</code>, and then compute <code>sin(tmp)</code> in a separate loop, allocating a second array.] This loop fusion is not a compiler optimization that may or may not occur, it is a <em>syntactic guarantee</em> whenever nested <code>f.(args...)</code> calls are encountered. Technically, the fusion stops as soon as a "non-dot" function call is encountered; for example, in <code>sin.(sort(cos.(X)))</code> the <code>sin</code> and <code>cos</code> loops cannot be merged because of the intervening <code>sort</code> function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さらに、<em>ネストされた</em> <code>f.(args...)</code> 呼び出しは <em>融合</em> されて単一の <code>broadcast</code> ループにまとめられます。例えば、<code>sin.(cos.(X))</code> は <code>broadcast(x -&gt; sin(cos(x)), X)</code> と同等であり、<code>[sin(cos(x)) for x in X]</code> と似ています：<code>X</code> に対して単一のループがあり、結果のために単一の配列が割り当てられます。[対照的に、一般的な「ベクトル化」言語における <code>sin(cos(X))</code> は、最初に <code>tmp=cos(X)</code> のために一時的な配列を割り当て、その後別のループで <code>sin(tmp)</code> を計算し、二つ目の配列を割り当てます。] このループの融合は、発生するかどうかのコンパイラ最適化ではなく、ネストされた <code>f.(args...)</code> 呼び出しが遭遇するたびに <em>構文的保証</em> です。技術的には、融合は「ドットでない」関数呼び出しが遭遇するとすぐに停止します；例えば、<code>sin.(sort(cos.(X)))</code> では、介在する <code>sort</code> 関数のために <code>sin</code> と <code>cos</code> のループは統合できません。</span></p><p data-translated="true"><span class="original-text">Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is <em>pre-allocated</em>, so that repeated calls do not allocate new arrays over and over again for the results (see <a href="../../base/math/#Base.:--Tuple{Any, Any}#Base.:--Tuple{Any, Any}">Pre-allocating outputs</a>). A convenient syntax for this is <code>X .= ...</code>, which is equivalent to <code>broadcast!(identity, X, ...)</code> except that, as above, the <code>broadcast!</code> loop is fused with any nested "dot" calls. For example, <code>X .= sin.(Y)</code> is equivalent to <code>broadcast!(sin, X, Y)</code>, overwriting <code>X</code> with <code>sin.(Y)</code> in-place. If the left-hand side is an array-indexing expression, e.g. <code>X[begin+1:end] .= sin.(Y)</code>, then it translates to <code>broadcast!</code> on a <code>view</code>, e.g. <code>broadcast!(sin, view(X, firstindex(X)+1:lastindex(X)), Y)</code>, so that the left-hand side is updated in-place.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最後に、ベクトル化された操作の出力配列が <em>事前に割り当てられている</em> 場合、最大の効率が通常達成されます。これにより、繰り返し呼び出しが結果のために新しい配列を何度も割り当てることがなくなります（<a href="../../base/math/#Base.:--Tuple{Any, Any}#Base.:--Tuple{Any, Any}">出力の事前割り当て</a>を参照）。これに便利な構文は <code>X .= ...</code> であり、これは <code>broadcast!(identity, X, ...)</code> と同等ですが、上記のように <code>broadcast!</code> ループはネストされた「ドット」呼び出しと融合されます。例えば、<code>X .= sin.(Y)</code> は <code>broadcast!(sin, X, Y)</code> と同等で、<code>X</code> をインプレースで <code>sin.(Y)</code> で上書きします。左辺が配列インデックス式である場合、例えば <code>X[begin+1:end] .= sin.(Y)</code> は <code>view</code> に対する <code>broadcast!</code> に変換され、例えば <code>broadcast!(sin, view(X, firstindex(X)+1:lastindex(X)), Y)</code> となり、左辺がインプレースで更新されます。</span></p><p data-translated="true"><span class="original-text">Since adding dots to many operations and function calls in an expression can be tedious and lead to code that is difficult to read, the macro <a href="../../base/arrays/index.html#Base.Broadcast.@__dot__"><code>@.</code></a> is provided to convert <em>every</em> function call, operation, and assignment in an expression into the "dotted" version.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">式内の多くの操作や関数呼び出しにドットを追加することは面倒であり、読みづらいコードにつながる可能性があるため、マクロ <a href="../../base/arrays/index.html#Base.Broadcast.@__dot__"><code>@.</code></a> が提供されており、式内の<em>すべての</em>関数呼び出し、操作、および代入を「ドット」バージョンに変換します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; Y = [1.0, 2.0, 3.0, 4.0];

julia&gt; X = similar(Y); # pre-allocate output array

julia&gt; @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))
4-element Vector{Float64}:
  0.5143952585235492
 -0.4042391538522658
 -0.8360218615377305
 -0.6080830096407656</code></pre><p data-translated="true"><span class="original-text">Binary (or unary) operators like <code>.+</code> are handled with the same mechanism: they are equivalent to <code>broadcast</code> calls and are fused with other nested "dot" calls.  <code>X .+= Y</code> etcetera is equivalent to <code>X .= X .+ Y</code> and results in a fused in-place assignment;  see also <a href="../mathematical-operations/index.html#man-dot-operators">dot operators</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">二項（または単項）演算子の <code>.+</code> は同じメカニズムで処理されます：それらは <code>broadcast</code> 呼び出しと同等であり、他のネストされた「ドット」呼び出しと融合されます。<code>X .+= Y</code> などは <code>X .= X .+ Y</code> と同等で、融合されたインプレース代入を結果として得ます；<a href="../mathematical-operations/index.html#man-dot-operators">ドット演算子</a>も参照してください。</span></p><p data-translated="true"><span class="original-text">You can also combine dot operations with function chaining using <a href="../../base/base/#Base.:|&gt;#Base.:|&gt;"><code>|&gt;</code></a>, as in this example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、<a href="../../base/base/#Base.:|&gt;#Base.:|&gt;"><code>|&gt;</code></a> を使用して関数チェイニングとドット操作を組み合わせることもできます。以下の例のように：</span></p><pre><code class="language-julia-repl hljs">julia&gt; 1:5 .|&gt; [x-&gt;x^2, inv, x-&gt;2*x, -, isodd]
5-element Vector{Real}:
    1
    0.5
    6
   -4
 true</code></pre><p data-translated="true"><span class="original-text">All functions in the fused broadcast are always called for every element of the result. Thus <code>X .+ σ .* randn.()</code> will add a mask of independent and identically sampled random values to each element of the array <code>X</code>, but <code>X .+ σ .* randn()</code> will add the <em>same</em> random sample to each element. In cases where the fused computation is constant along one or more axes of the broadcast iteration, it may be possible to leverage a space-time tradeoff and allocate intermediate values to reduce the number of computations. See more at <a href="../performance-tips/index.html#man-performance-unfuse">performance tips</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">融合されたブロードキャスト内のすべての関数は、結果の各要素に対して常に呼び出されます。したがって、<code>X .+ σ .* randn.()</code> は配列 <code>X</code> の各要素に独立して同一にサンプリングされたランダム値のマスクを追加しますが、<code>X .+ σ .* randn()</code> は各要素に<em>同じ</em>ランダムサンプルを追加します。融合された計算がブロードキャスト反復の1つまたは複数の軸に沿って定数である場合、計算回数を減らすために中間値を割り当てて空間時間トレードオフを活用できる可能性があります。詳細は <a href="../performance-tips/index.html#man-performance-unfuse">パフォーマンスのヒント</a>を参照してください。</span></p><h2 id="Further-Reading" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Further-Reading">Further Reading</a><a id="Further-Reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Reading" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Further-Reading">さらなる読み物</a><a id="Further-Reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Reading" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">We should mention here that this is far from a complete picture of defining functions. Julia has a sophisticated type system and allows multiple dispatch on argument types. None of the examples given here provide any type annotations on their arguments, meaning that they are applicable to all types of arguments. The type system is described in <a href="../types/index.html#man-types">Types</a> and defining a function in terms of methods chosen by multiple dispatch on run-time argument types is described in <a href="../methods/index.html#Methods">Methods</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで言及すべきは、これは関数を定義する完全な図ではないということです。Julia には洗練された型システムがあり、引数の型に基づく複数のディスパッチを許可しています。ここで示された例は、引数に対する型注釈を提供していないため、すべての型の引数に適用可能です。型システムについては <a href="../types/index.html#man-types">型</a> を、実行時の引数型に基づくメソッドによって関数を定義することについては <a href="../methods/index.html#Methods">メソッド</a> を参照してください。</span></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../strings/index.html">« Strings</a><a class="docs-footer-nextpage" href="../control-flow/index.html">Control Flow »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>