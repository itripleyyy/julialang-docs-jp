<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Profiling · The Julia Language</title><meta name="title" content="Profiling · The Julia Language"><meta property="og:title" content="Profiling · The Julia Language"><meta property="twitter:title" content="Profiling · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/profile/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/profile/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bi1h1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li class="is-active"><a class="tocitem" href="">Profiling</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Basic-usage"><span>Basic usage</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Basic-usage"><span>基本的な使用法</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Accumulation-and-clearing"><span>Accumulation and clearing</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Accumulation-and-clearing"><span>蓄積とクリアリング</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Options-for-controlling-the-display-of-profile-results"><span>Options for controlling the display of profile results</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Options-for-controlling-the-display-of-profile-results"><span>プロファイル結果の表示を制御するためのオプション</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Configuration"><span>Configuration</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Configuration"><span>設定</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Wall-time-Profiler"><span>Wall-time Profiler</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Wall-time-Profiler"><span>ウォールタイムプロファイラ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Memory-allocation-analysis"><span>Memory allocation analysis</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Memory-allocation-analysis"><span>メモリ割り当て分析</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#External-Profiling"><span>External Profiling</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#External-Profiling"><span>外部プロファイリング</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">プロファイリング</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">プロファイリング</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/profile.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Profiling" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Profiling">Profiling</a><a id="Profiling-1"></a><a class="docs-heading-anchor-permalink" href="#Profiling" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Profiling">プロファイリング</a><a id="Profiling-1"></a><a class="docs-heading-anchor-permalink" href="#Profiling" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">The <code>Profile</code> module provides tools to help developers improve the performance of their code. When used, it takes measurements on running code, and produces output that helps you understand how much time is spent on individual line(s). The most common usage is to identify "bottlenecks" as targets for optimization.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この<code>Profile</code>モジュールは、開発者がコードのパフォーマンスを向上させるためのツールを提供します。使用すると、実行中のコードの測定を行い、個々の行にどれだけの時間が費やされているかを理解するのに役立つ出力を生成します。最も一般的な使用法は、最適化のターゲットとして「ボトルネック」を特定することです。</span></p><p data-translated="true"><span class="original-text"><code>Profile</code> implements what is known as a "sampling" or <a href="https://en.wikipedia.org/wiki/Profiling_(computer_programming)">statistical profiler</a>.  It works by periodically taking a backtrace during the execution of any task. Each backtrace captures the currently-running function and line number, plus the complete chain of function calls that led to this line, and hence is a "snapshot" of the current state of execution.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Profile</code>は「サンプリング」または<a href="https://en.wikipedia.org/wiki/Profiling_(computer_programming)">統計プロファイラ</a>として知られるものを実装しています。これは、任意のタスクの実行中に定期的にバックトレースを取得することによって機能します。各バックトレースは、現在実行中の関数と行番号、さらにこの行に至るまでの関数呼び出しの完全なチェーンをキャプチャし、したがって現在の実行状態の「スナップショット」となります。</span></p><p data-translated="true"><span class="original-text">If much of your run time is spent executing a particular line of code, this line will show up frequently in the set of all backtraces. In other words, the "cost" of a given line–or really, the cost of the sequence of function calls up to and including this line–is proportional to how often it appears in the set of all backtraces.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実行時間の多くが特定のコード行の実行に費やされている場合、この行はすべてのバックトレースのセットに頻繁に現れます。言い換えれば、特定の行の「コスト」—実際には、この行を含む関数呼び出しのシーケンスのコスト—は、すべてのバックトレースのセットにどれだけ頻繁に現れるかに比例します。</span></p><p data-translated="true"><span class="original-text">A sampling profiler does not provide complete line-by-line coverage, because the backtraces occur at intervals (by default, 1 ms on Unix systems and 10 ms on Windows, although the actual scheduling is subject to operating system load). Moreover, as discussed further below, because samples are collected at a sparse subset of all execution points, the data collected by a sampling profiler is subject to statistical noise.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">サンプリングプロファイラは、バックトレースが間隔で発生するため、完全な行ごとのカバレッジを提供しません（デフォルトでは、Unixシステムでは1ms、Windowsでは10msですが、実際のスケジューリングはオペレーティングシステムの負荷に依存します）。さらに、以下で詳しく説明するように、サンプルはすべての実行ポイントのスパースなサブセットで収集されるため、サンプリングプロファイラによって収集されたデータは統計的ノイズの影響を受けます。</span></p><p data-translated="true"><span class="original-text">Despite these limitations, sampling profilers have substantial strengths:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの制限にもかかわらず、サンプリングプロファイラには substantial strengthsがあります：</span></p><ul><li data-translated="true"><span class="original-text">You do not have to make any modifications to your code to take timing measurements.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">タイミング測定を行うためにコードを変更する必要はありません。</span></li><li data-translated="true"><span class="original-text">It can profile into Julia's core code and even (optionally) into C and Fortran libraries.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaのコアコードや、（オプションで）CおよびFortranライブラリのプロファイリングが可能です。</span></li><li data-translated="true"><span class="original-text">By running "infrequently" there is very little performance overhead; while profiling, your code can run at nearly native speed.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">「まれに」実行することで、パフォーマンスのオーバーヘッドは非常に少なく、プロファイリング中でもコードはほぼネイティブスピードで実行できます。</span></li></ul><p data-translated="true"><span class="original-text">For these reasons, it's recommended that you try using the built-in sampling profiler before considering any alternatives.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの理由から、代替手段を検討する前に、組み込みのサンプリングプロファイラを使用してみることをお勧めします。</span></p><h2 id="Basic-usage" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Basic-usage">基本的な使用法</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Let's work with a simple test case:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単なテストケースで作業しましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function myfunc()
           A = rand(200, 200, 400)
           maximum(A)
       end</code></pre><p data-translated="true"><span class="original-text">It's a good idea to first run the code you intend to profile at least once (unless you want to profile Julia's JIT-compiler):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロファイルを取得したいコードを少なくとも一度は実行するのが良いアイデアです（JuliaのJITコンパイラをプロファイルしたい場合を除いて）：</span></p><pre><code class="language-julia-repl hljs">julia&gt; myfunc() # run once to force compilation</code></pre><p data-translated="true"><span class="original-text">Now we're ready to profile this function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これでこの関数のプロファイルを取得する準備が整いました：</span></p><pre><code class="language-julia-repl hljs">julia&gt; using Profile

julia&gt; @profile myfunc()</code></pre><p data-translated="true"><span class="original-text">To see the profiling results, there are several graphical browsers. One "family" of visualizers is based on <a href="https://github.com/timholy/FlameGraphs.jl">FlameGraphs.jl</a>, with each family member providing a different user interface:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロファイリング結果を見るために、いくつかのグラフィカルブラウザがあります。一つの「ファミリー」のビジュアライザーは、<a href="https://github.com/timholy/FlameGraphs.jl">FlameGraphs.jl</a>に基づいており、各ファミリーメンバーが異なるユーザーインターフェースを提供します：</span></p><ul><li data-translated="true"><span class="original-text"><a href="https://www.julia-vscode.org/">VS Code</a> is a full IDE with built-in support for profile visualization</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://www.julia-vscode.org/">VS Code</a>は、プロファイルの視覚化をサポートする完全なIDEです</span></li><li data-translated="true"><span class="original-text"><a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a> is a stand-alone visualizer based on GTK</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a>は、GTKに基づいたスタンドアロンのビジュアライザーです</span></li><li data-translated="true"><span class="original-text"><a href="https://github.com/davidanthoff/ProfileVega.jl">ProfileVega.jl</a> uses VegaLight and integrates well with Jupyter notebooks</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/davidanthoff/ProfileVega.jl">ProfileVega.jl</a>はVegaLightを使用し、Jupyterノートブックと良く統合されます</span></li><li data-translated="true"><span class="original-text"><a href="https://github.com/tkluck/StatProfilerHTML.jl">StatProfilerHTML.jl</a> produces HTML and presents some additional summaries, and also integrates well with Jupyter notebooks</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/tkluck/StatProfilerHTML.jl">StatProfilerHTML.jl</a>はHTMLを生成し、いくつかの追加の要約を提示し、Jupyterノートブックとも良く統合されます</span></li><li data-translated="true"><span class="original-text"><a href="https://github.com/timholy/ProfileSVG.jl">ProfileSVG.jl</a> renders SVG</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/timholy/ProfileSVG.jl">ProfileSVG.jl</a>はSVGをレンダリングします</span></li><li data-translated="true"><span class="original-text"><a href="https://github.com/JuliaPerf/PProf.jl">PProf.jl</a> serves a local website for inspecting graphs, flamegraphs and more</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaPerf/PProf.jl">PProf.jl</a>は、グラフ、フレームグラフなどを検査するためのローカルウェブサイトを提供します</span></li><li data-translated="true"><span class="original-text"><a href="https://github.com/pfitzseb/ProfileCanvas.jl">ProfileCanvas.jl</a> is a HTML canvas based profile viewer UI, used by the <a href="https://www.julia-vscode.org/">Julia VS Code extension</a>, but can also generate interactive HTML files.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/pfitzseb/ProfileCanvas.jl">ProfileCanvas.jl</a> は、<a href="https://www.julia-vscode.org/">Julia VS Code extension</a> によって使用されるHTMLキャンバスベースのプロファイルビューアUIですが、インタラクティブなHTMLファイルも生成できます。</span></li></ul><p data-translated="true"><span class="original-text">An entirely independent approach to profile visualization is <a href="https://github.com/vchuravy/PProf.jl">PProf.jl</a>, which uses the external <code>pprof</code> tool.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロファイル可視化に対する完全に独立したアプローチは、<a href="https://github.com/vchuravy/PProf.jl">PProf.jl</a> であり、外部の <code>pprof</code> ツールを使用します。</span></p><p data-translated="true"><span class="original-text">Here, though, we'll use the text-based display that comes with the standard library:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、標準ライブラリに付属するテキストベースの表示を使用します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Profile.print()
80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
 80 ./REPL.jl:97; macro expansion
  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)
   80 ./boot.jl:235; eval(::Module, ::Any)
    80 ./&lt;missing&gt;:?; anonymous
     80 ./profile.jl:23; macro expansion
      52 ./REPL[1]:2; myfunc()
       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...
        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...
       14 ./random.jl:278; rand
        14 ./random.jl:277; rand
         14 ./random.jl:366; rand
          14 ./random.jl:369; rand
      28 ./REPL[1]:3; myfunc()
       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...
        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...
        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...</code></pre><p data-translated="true"><span class="original-text">Each line of this display represents a particular spot (line number) in the code. Indentation is used to indicate the nested sequence of function calls, with more-indented lines being deeper in the sequence of calls. In each line, the first "field" is the number of backtraces (samples) taken <em>at this line or in any functions executed by this line</em>. The second field is the file name and line number and the third field is the function name. Note that the specific line numbers may change as Julia's code changes; if you want to follow along, it's best to run this example yourself.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この表示の各行は、コード内の特定の場所（行番号）を表します。インデントは、関数呼び出しの入れ子の順序を示すために使用され、よりインデントされた行は呼び出しの順序の深い位置にあります。各行の最初の「フィールド」は、<em>この行またはこの行によって実行された関数内で取得されたバックトレース（サンプル）の数</em>です。2番目のフィールドはファイル名と行番号、3番目のフィールドは関数名です。特定の行番号はJuliaのコードが変更されると変わる可能性があるため、追跡したい場合はこの例を自分で実行するのが最良です。</span></p><p data-translated="true"><span class="original-text">In this example, we can see that the top level function called is in the file <code>event.jl</code>. This is the function that runs the REPL when you launch Julia. If you examine line 97 of <code>REPL.jl</code>, you'll see this is where the function <code>eval_user_input()</code> is called. This is the function that evaluates what you type at the REPL, and since we're working interactively these functions were invoked when we entered <code>@profile myfunc()</code>. The next line reflects actions taken in the <a href="../../stdlib/Profile/index.html#Profile.@profile"><code>@profile</code></a> macro.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例では、最上位の関数が <code>event.jl</code> ファイル内にあることがわかります。これは、Juliaを起動したときにREPLを実行する関数です。<code>REPL.jl</code> の97行目を調べると、ここで <code>eval_user_input()</code> 関数が呼び出されているのがわかります。これは、REPLで入力した内容を評価する関数であり、インタラクティブに作業しているため、<code>@profile myfunc()</code> を入力したときにこれらの関数が呼び出されました。次の行は、<a href="../../stdlib/Profile/index.html#Profile.@profile"><code>@profile</code></a> マクロで行われたアクションを反映しています。</span></p><p data-translated="true"><span class="original-text">The first line shows that 80 backtraces were taken at line 73 of <code>event.jl</code>, but it's not that this line was "expensive" on its own: the third line reveals that all 80 of these backtraces were actually triggered inside its call to <code>eval_user_input</code>, and so on. To find out which operations are actually taking the time, we need to look deeper in the call chain.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初の行は、<code>event.jl</code> の73行目で80のバックトレースが取得されたことを示していますが、この行が「高コスト」であったわけではありません。3行目は、これら80のバックトレースが実際には <code>eval_user_input</code> の呼び出し内でトリガーされたことを明らかにしています。どの操作が実際に時間を要しているのかを知るためには、呼び出しチェーンをさらに深く見る必要があります。</span></p><p data-translated="true"><span class="original-text">The first "important" line in this output is this one:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この出力の最初の「重要な」行はこれです：</span></p><pre><code class="nohighlight hljs">52 ./REPL[1]:2; myfunc()</code></pre><p data-translated="true"><span class="original-text"><code>REPL</code> refers to the fact that we defined <code>myfunc</code> in the REPL, rather than putting it in a file; if we had used a file, this would show the file name. The <code>[1]</code> shows that the function <code>myfunc</code> was the first expression evaluated in this REPL session. Line 2 of <code>myfunc()</code> contains the call to <code>rand</code>, and there were 52 (out of 80) backtraces that occurred at this line. Below that, you can see a call to <code>dsfmt_fill_array_close_open!</code> inside <code>dSFMT.jl</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>REPL</code> は、<code>myfunc</code> をREPLで定義したことを指しており、ファイルに入れなかった場合、ここにはファイル名が表示されます。<code>[1]</code> は、<code>myfunc</code> がこのREPLセッションで最初に評価された式であることを示しています。<code>myfunc()</code> の2行目には <code>rand</code> への呼び出しが含まれており、この行で52（80のうち）のバックトレースが発生しました。その下には、<code>dSFMT.jl</code> 内の <code>dsfmt_fill_array_close_open!</code> への呼び出しが見えます。</span></p><p data-translated="true"><span class="original-text">A little further down, you see:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もう少し下に行くと、次のようになります：</span></p><pre><code class="nohighlight hljs">28 ./REPL[1]:3; myfunc()</code></pre><p data-translated="true"><span class="original-text">Line 3 of <code>myfunc</code> contains the call to <code>maximum</code>, and there were 28 (out of 80) backtraces taken here. Below that, you can see the specific places in <code>base/reduce.jl</code> that carry out the time-consuming operations in the <code>maximum</code> function for this type of input data.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>myfunc</code> の3行目には <code>maximum</code> への呼び出しが含まれており、ここで28（80のうち）のバックトレースが取得されました。その下には、このタイプの入力データに対する <code>maximum</code> 関数内で時間を要する操作を実行する <code>base/reduce.jl</code> 内の特定の場所が見えます。</span></p><p data-translated="true"><span class="original-text">Overall, we can tentatively conclude that generating the random numbers is approximately twice as expensive as finding the maximum element. We could increase our confidence in this result by collecting more samples:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">全体として、ランダム数の生成は最大要素の検索の約2倍のコストがかかると暫定的に結論付けることができます。この結果に対する信頼性を高めるために、より多くのサンプルを収集することができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @profile (for i = 1:100; myfunc(); end)

julia&gt; Profile.print()
[....]
 3821 ./REPL[1]:2; myfunc()
  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...
   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...
  310  ./random.jl:278; rand
   [....]
 2893 ./REPL[1]:3; myfunc()
  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...
   [....]</code></pre><p data-translated="true"><span class="original-text">In general, if you have <code>N</code> samples collected at a line, you can expect an uncertainty on the order of <code>sqrt(N)</code> (barring other sources of noise, like how busy the computer is with other tasks). The major exception to this rule is garbage collection, which runs infrequently but tends to be quite expensive. (Since Julia's garbage collector is written in C, such events can be detected using the <code>C=true</code> output mode described below, or by using <a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a>.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般的に、あるラインで収集された<code>N</code>サンプルがある場合、他のノイズ源（コンピュータが他のタスクでどれだけ忙しいかなど）を除けば、<code>sqrt(N)</code>のオーダーの不確実性が期待できます。このルールの主な例外は、稀に実行されるが非常にコストがかかるガーベジコレクションです。（JuliaのガーベジコレクタはCで書かれているため、以下に説明する<code>C=true</code>出力モードを使用するか、<a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a>を使用することで、そのようなイベントを検出できます。）</span></p><p data-translated="true"><span class="original-text">This illustrates the default "tree" dump; an alternative is the "flat" dump, which accumulates counts independent of their nesting:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これはデフォルトの「ツリー」ダンプを示しています。代替として「フラット」ダンプがあり、ネストに依存せずにカウントを蓄積します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Profile.print(format=:flat)
 Count File          Line Function
  6714 ./&lt;missing&gt;     -1 anonymous
  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)
  6714 ./REPL.jl       97 macro expansion
  3821 ./REPL[1]        2 myfunc()
  2893 ./REPL[1]        3 myfunc()
  6714 ./REPL[7]        1 macro expansion
  6714 ./boot.jl      235 eval(::Module, ::Any)
  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...
  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
  6714 ./profile.jl    23 macro expansion
  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...
   310 ./random.jl    277 rand
   310 ./random.jl    278 rand
   310 ./random.jl    366 rand
   310 ./random.jl    369 rand
  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...
     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...</code></pre><p data-translated="true"><span class="original-text">If your code has recursion, one potentially-confusing point is that a line in a "child" function can accumulate more counts than there are total backtraces. Consider the following function definitions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コードに再帰がある場合、混乱を招く可能性のあるポイントは、「子」関数の行が総バックトレースよりも多くのカウントを蓄積できることです。以下の関数定義を考えてみてください：</span></p><pre><code class="language-julia hljs">dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)
dumbsum3() = dumbsum(3)</code></pre><p data-translated="true"><span class="original-text">If you were to profile <code>dumbsum3</code>, and a backtrace was taken while it was executing <code>dumbsum(1)</code>, the backtrace would look like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もし<code>dumbsum3</code>をプロファイルし、<code>dumbsum(1)</code>を実行中にバックトレースが取得された場合、バックトレースは次のようになります：</span></p><pre><code class="language-julia hljs">dumbsum3
    dumbsum(3)
        dumbsum(2)
            dumbsum(1)</code></pre><p data-translated="true"><span class="original-text">Consequently, this child function gets 3 counts, even though the parent only gets one. The "tree" representation makes this much clearer, and for this reason (among others) is probably the most useful way to view the results.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">その結果、この子関数は3つのカウントを取得しますが、親は1つしか取得しません。「ツリー」表現はこれをより明確にし、この理由（他にもいくつかの理由）から、結果を表示する最も有用な方法である可能性があります。</span></p><h2 id="Accumulation-and-clearing" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Accumulation-and-clearing">Accumulation and clearing</a><a id="Accumulation-and-clearing-1"></a><a class="docs-heading-anchor-permalink" href="#Accumulation-and-clearing" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Accumulation-and-clearing">蓄積とクリア</a><a id="Accumulation-and-clearing-1"></a><a class="docs-heading-anchor-permalink" href="#Accumulation-and-clearing" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Results from <a href="../../stdlib/Profile/index.html#Profile.@profile"><code>@profile</code></a> accumulate in a buffer; if you run multiple pieces of code under <a href="../../stdlib/Profile/index.html#Profile.@profile"><code>@profile</code></a>, then <a href="../../stdlib/Profile/index.html#Profile.print"><code>Profile.print()</code></a> will show you the combined results. This can be very useful, but sometimes you want to start fresh; you can do so with <a href="../../stdlib/Profile/index.html#Profile.clear"><code>Profile.clear()</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Profile/index.html#Profile.@profile"><code>@profile</code></a>からの結果はバッファに蓄積されます。<a href="../../stdlib/Profile/index.html#Profile.@profile"><code>@profile</code></a>の下で複数のコードを実行すると、<a href="../../stdlib/Profile/index.html#Profile.print"><code>Profile.print()</code></a>は結合された結果を表示します。これは非常に便利ですが、時には新たに始めたい場合があります。その場合は、<a href="../../stdlib/Profile/index.html#Profile.clear"><code>Profile.clear()</code></a>を使用できます。</span></p><h2 id="Options-for-controlling-the-display-of-profile-results" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a><a id="Options-for-controlling-the-display-of-profile-results-1"></a><a class="docs-heading-anchor-permalink" href="#Options-for-controlling-the-display-of-profile-results" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Options-for-controlling-the-display-of-profile-results">プロファイル結果の表示を制御するためのオプション</a><a id="Options-for-controlling-the-display-of-profile-results-1"></a><a class="docs-heading-anchor-permalink" href="#Options-for-controlling-the-display-of-profile-results" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text"><a href="../../stdlib/Profile/index.html#Profile.print"><code>Profile.print</code></a> has more options than we've described so far. Let's see the full declaration:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Profile/index.html#Profile.print"><code>Profile.print</code></a>には、これまでに説明したよりも多くのオプションがあります。完全な宣言を見てみましょう：</span></p><pre><code class="language-julia hljs">function print(io::IO = stdout, data = fetch(); kwargs...)</code></pre><p data-translated="true"><span class="original-text">Let's first discuss the two positional arguments, and later the keyword arguments:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">まず、2つの位置引数について説明し、その後にキーワード引数について説明します：</span></p><ul><li><p data-translated="true"><span class="original-text"><code>io</code> – Allows you to save the results to a buffer, e.g. a file, but the default is to print to <code>stdout</code> (the console).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>io</code> – 結果をバッファ（例：ファイル）に保存することを可能にしますが、デフォルトでは <code>stdout</code>（コンソール）に出力されます。</span></p></li><li><p data-translated="true"><span class="original-text"><code>data</code> – Contains the data you want to analyze; by default that is obtained from <a href="../../stdlib/Profile/index.html#Profile.fetch"><code>Profile.fetch()</code></a>, which pulls out the backtraces from a pre-allocated buffer. For example, if you want to profile the profiler, you could say:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>data</code> – 分析したいデータを含みます；デフォルトでは、<a href="../../stdlib/Profile/index.html#Profile.fetch"><code>Profile.fetch()</code></a> から取得され、事前に割り当てられたバッファからバックトレースを引き出します。たとえば、プロファイラをプロファイルしたい場合は、次のように言うことができます：</span></p><pre><code class="language-julia hljs">data = copy(Profile.fetch())
Profile.clear()
@profile Profile.print(stdout, data) # Prints the previous results
Profile.print()                      # Prints results from Profile.print()</code></pre></li></ul><p data-translated="true"><span class="original-text">The keyword arguments can be any combination of:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キーワード引数は、次の任意の組み合わせにすることができます：</span></p><ul><li data-translated="true"><span class="original-text"><code>format</code> – Introduced above, determines whether backtraces are printed  with (default, <code>:tree</code>) or without (<code>:flat</code>) indentation indicating tree  structure.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>format</code> – 上で紹介したもので、バックトレースがツリー構造を示すインデント付き（デフォルト、<code>:tree</code>）で印刷されるか、インデントなし（<code>:flat</code>）で印刷されるかを決定します。</span></li><li data-translated="true"><span class="original-text"><code>C</code> – If <code>true</code>, backtraces from C and Fortran code are shown (normally they are excluded). Try running the introductory example with <code>Profile.print(C = true)</code>. This can be extremely helpful in deciding whether it's Julia code or C code that is causing a bottleneck; setting <code>C = true</code> also improves the interpretability of the nesting, at the cost of longer profile dumps.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>C</code> – <code>true</code>の場合、CおよびFortranコードからのバックトレースが表示されます（通常は除外されます）。<code>Profile.print(C = true)</code>を使って導入例を実行してみてください。これは、ボトルネックを引き起こしているのがJuliaコードなのかCコードなのかを判断するのに非常に役立ちます；<code>C = true</code>を設定すると、ネストの解釈可能性も向上しますが、プロファイルダンプが長くなります。</span></li><li data-translated="true"><span class="original-text"><code>combine</code> – Some lines of code contain multiple operations; for example, <code>s += A[i]</code> contains both an array reference (<code>A[i]</code>) and a sum operation. These correspond to different lines in the generated machine code, and hence there may be two or more different addresses captured during backtraces on this line. <code>combine = true</code> lumps them together, and is probably what you typically want, but you can generate an output separately for each unique instruction pointer with <code>combine = false</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>combine</code> – 一部のコード行には複数の操作が含まれています；たとえば、<code>s += A[i]</code>は配列参照（<code>A[i]</code>）と合計操作の両方を含みます。これらは生成された機械コードの異なる行に対応し、そのためこの行のバックトレース中に2つ以上の異なるアドレスがキャプチャされる可能性があります。<code>combine = true</code>はそれらをまとめますが、通常はこれが望ましい設定ですが、<code>combine = false</code>を使用すると、各ユニークな命令ポインタごとに別々の出力を生成できます。</span></li><li data-translated="true"><span class="original-text"><code>maxdepth</code> – Limits frames at a depth higher than <code>maxdepth</code> in the <code>:tree</code> format.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>maxdepth</code> – <code>:tree</code>形式で<code>maxdepth</code>より深いフレームを制限します。</span></li><li data-translated="true"><span class="original-text"><code>sortedby</code> – Controls the order in <code>:flat</code> format. <code>:filefuncline</code> (default) sorts by the source line, whereas <code>:count</code> sorts in order of number of collected samples.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>sortedby</code> – <code>:flat</code>形式での順序を制御します。<code>:filefuncline</code>（デフォルト）はソース行でソートし、<code>:count</code>は収集されたサンプルの数の順にソートします。</span></li><li data-translated="true"><span class="original-text"><code>noisefloor</code> – Limits frames that are below the heuristic noise floor of the sample (only applies to format <code>:tree</code>). A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which <code>n &lt;= noisefloor * √N</code>, where <code>n</code> is the number of samples on this line, and <code>N</code> is the number of samples for the callee.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>noisefloor</code> – サンプルのヒューリスティックノイズフロア未満のフレームを制限します（<code>:tree</code>形式にのみ適用されます）。これに対して試すべき推奨値は2.0です（デフォルトは0です）。このパラメータは、<code>n &lt;= noisefloor * √N</code>のサンプルを隠します。ここで、<code>n</code>はこの行のサンプル数、<code>N</code>は呼び出し先のサンプル数です。</span></li><li data-translated="true"><span class="original-text"><code>mincount</code> – Limits frames with less than <code>mincount</code> occurrences.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>mincount</code> – <code>mincount</code> 回数未満のフレームを制限します。</span></li></ul><p data-translated="true"><span class="original-text">File/function names are sometimes truncated (with <code>...</code>), and indentation is truncated with a <code>+n</code> at the beginning, where <code>n</code> is the number of extra spaces that would have been inserted, had there been room. If you want a complete profile of deeply-nested code, often a good idea is to save to a file using a wide <code>displaysize</code> in an <a href="../../base/io-network/index.html#Base.IOContext"><code>IOContext</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ファイル/関数名は時々切り捨てられ（<code>...</code>で）、インデントは先頭に <code>+n</code> が付いて切り捨てられます。ここで <code>n</code> は、スペースが挿入される余地があった場合に挿入される追加のスペースの数です。深くネストされたコードの完全なプロファイルを取得したい場合は、広い <code>displaysize</code> を使用してファイルに保存するのが良いアイデアです。これは <a href="../../base/io-network/index.html#Base.IOContext"><code>IOContext</code></a> で行います：</span></p><pre><code class="language-julia hljs">open("/tmp/prof.txt", "w") do s
    Profile.print(IOContext(s, :displaysize =&gt; (24, 500)))
end</code></pre><h2 id="Configuration" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Configuration">Configuration</a><a id="Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Configuration">設定</a><a id="Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text"><a href="../../stdlib/Profile/index.html#Profile.@profile"><code>@profile</code></a> just accumulates backtraces, and the analysis happens when you call <a href="../../stdlib/Profile/index.html#Profile.print"><code>Profile.print()</code></a>. For a long-running computation, it's entirely possible that the pre-allocated buffer for storing backtraces will be filled. If that happens, the backtraces stop but your computation continues. As a consequence, you may miss some important profiling data (you will get a warning when that happens).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Profile/index.html#Profile.@profile"><code>@profile</code></a> はバックトレースを蓄積するだけで、分析は <a href="../../stdlib/Profile/index.html#Profile.print"><code>Profile.print()</code></a> を呼び出すときに行われます。長時間実行される計算では、バックトレースを保存するための事前に割り当てられたバッファが満杯になる可能性があります。その場合、バックトレースは停止しますが、計算は続行されます。その結果、重要なプロファイリングデータを見逃す可能性があります（その場合は警告が表示されます）。</span></p><p data-translated="true"><span class="original-text">You can obtain and configure the relevant parameters this way:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関連するパラメータをこのように取得して設定できます：</span></p><pre><code class="language-julia hljs">Profile.init() # returns the current settings
Profile.init(n = 10^7, delay = 0.01)</code></pre><p data-translated="true"><span class="original-text"><code>n</code> is the total number of instruction pointers you can store, with a default value of <code>10^6</code>. If your typical backtrace is 20 instruction pointers, then you can collect 50000 backtraces, which suggests a statistical uncertainty of less than 1%. This may be good enough for most applications.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>n</code> は保存できる命令ポインタの総数で、デフォルト値は <code>10^6</code> です。典型的なバックトレースが20の命令ポインタである場合、50000のバックトレースを収集できます。これは、統計的不確実性が1%未満であることを示唆しています。これはほとんどのアプリケーションには十分かもしれません。</span></p><p data-translated="true"><span class="original-text">Consequently, you are more likely to need to modify <code>delay</code>, expressed in seconds, which sets the amount of time that Julia gets between snapshots to perform the requested computations. A very long-running job might not need frequent backtraces. The default setting is <code>delay = 0.001</code>. Of course, you can decrease the delay as well as increase it; however, the overhead of profiling grows once the delay becomes similar to the amount of time needed to take a backtrace (~30 microseconds on the author's laptop).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、<code>delay</code> を変更する必要がある可能性が高く、これは秒単位で表現され、Juliaが要求された計算を実行するためのスナップショット間の時間を設定します。非常に長時間実行されるジョブでは、頻繁なバックトレースは必要ないかもしれません。デフォルト設定は <code>delay = 0.001</code> です。もちろん、遅延を減少させることも増加させることもできます。ただし、遅延がバックトレースを取得するのに必要な時間（著者のノートパソコンでは約30マイクロ秒）に近づくと、プロファイリングのオーバーヘッドが増加します。</span></p><h2 id="Wall-time-Profiler" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Wall-time-Profiler">Wall-time Profiler</a><a id="Wall-time-Profiler-1"></a><a class="docs-heading-anchor-permalink" href="#Wall-time-Profiler" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Wall-time-Profiler">ウォールタイムプロファイラ</a><a id="Wall-time-Profiler-1"></a><a class="docs-heading-anchor-permalink" href="#Wall-time-Profiler" title="Permalink"></a></span></h2><h3 id="Introduction-and-Problem-Motivation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Introduction-and-Problem-Motivation">Introduction &amp; Problem Motivation</a><a id="Introduction-and-Problem-Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-and-Problem-Motivation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Introduction-and-Problem-Motivation">はじめに &amp; 問題の動機</a><a id="Introduction-and-Problem-Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-and-Problem-Motivation" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The profiler described in the previous section is a sampling CPU profiler. At a high level, the profiler periodically stops all Julia compute threads to collect their backtraces and estimates the time spent in each function based on the number of backtrace samples that include a frame from that function. However, note that only tasks currently running on system threads just before the profiler stops them will have their backtraces collected.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">前のセクションで説明したプロファイラはサンプリングCPUプロファイラです。高レベルでは、プロファイラは定期的にすべてのJulia計算スレッドを停止してバックトレースを収集し、その関数からのバックトレースサンプルの数に基づいて各関数に費やされた時間を推定します。ただし、プロファイラがスレッドを停止する直前に実行中のタスクのみがバックトレースを収集されることに注意してください。</span></p><p data-translated="true"><span class="original-text">While this profiler is typically well-suited for workloads where the majority of tasks are compute-bound, it is less helpful for systems where most tasks are IO-heavy or for diagnosing contention on synchronization primitives in your code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このプロファイラは、タスクの大部分が計算に依存するワークロードに適していることが多いですが、ほとんどのタスクがIO重視であるシステムや、コード内の同期プリミティブにおける競合を診断するにはあまり役立ちません。</span></p><p data-translated="true"><span class="original-text">Let's consider this simple workload:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このシンプルなワークロードを考えてみましょう：</span></p><pre><code class="language-Julia hljs">using Base.Threads
using Profile
using PProf

ch = Channel(1)

const N_SPAWNED_TASKS = (1 &lt;&lt; 10)
const WAIT_TIME_NS = 10_000_000

function spawn_a_bunch_of_tasks_waiting_on_channel()
    for i in 1:N_SPAWNED_TASKS
        Threads.@spawn begin
            take!(ch)
        end
    end
end

function busywait()
    t0 = time_ns()
    while true
        if time_ns() - t0 &gt; WAIT_TIME_NS
            break
        end
    end
end

function main()
    spawn_a_bunch_of_tasks_waiting_on_channel()
    for i in 1:N_SPAWNED_TASKS
        put!(ch, i)
        busywait()
    end
end

Profile.@profile main()</code></pre><p data-translated="true"><span class="original-text">Our goal is to detect whether there is contention on the <code>ch</code> channel—i.e., whether the number of waiters is excessive given the rate at which work items are being produced in the channel.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">私たちの目標は、<code>ch</code> チャンネルで競合が発生しているかどうか、つまり、チャンネル内で作業項目が生成される速度に対して待機者の数が過剰であるかどうかを検出することです。</span></p><p data-translated="true"><span class="original-text">If we run this, we obtain the following <a href="https://github.com/JuliaPerf/PProf.jl">PProf</a> flame graph:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これを実行すると、次の<a href="https://github.com/JuliaPerf/PProf.jl">PProf</a> フレームグラフが得られます：</span></p><p><img src="../img/cpu-profile.png" alt="CPU Profile"></p><p data-translated="true"><span class="original-text">This profile provides no information to help determine where contention occurs in the system’s synchronization primitives. Waiters on a channel will be blocked and descheduled, meaning no system thread will be running the tasks assigned to those waiters, and as a result, they won't be sampled by the profiler.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このプロファイルは、システムの同期プリミティブで競合が発生している場所を特定するのに役立つ情報を提供しません。チャンネルの待機者はブロックされ、スケジュールから外されるため、システムスレッドはそれらの待機者に割り当てられたタスクを実行せず、その結果、プロファイラによってサンプリングされることはありません。</span></p><h3 id="Wall-time-Profiler-2" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Wall-time-Profiler-2">Wall-time Profiler</a><a class="docs-heading-anchor-permalink" href="#Wall-time-Profiler-2" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Wall-time-Profiler-2">ウォールタイムプロファイラ</a><a class="docs-heading-anchor-permalink" href="#Wall-time-Profiler-2" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Instead of sampling threads—and thus only sampling tasks that are running—a wall-time task profiler samples tasks independently of their scheduling state. For example, tasks that are sleeping on a synchronization primitive at the time the profiler is running will be sampled with the same probability as tasks that were actively running when the profiler attempted to capture backtraces.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">スレッドをサンプリングする代わりに、つまり実行中のタスクのみをサンプリングするのではなく、ウォールタイムタスクプロファイラはタスクをスケジューリング状態に関係なくサンプリングします。たとえば、プロファイラが実行中のときに同期プリミティブでスリープしているタスクは、プロファイラがバックトレースをキャプチャしようとしたときにアクティブに実行されていたタスクと同じ確率でサンプリングされます。</span></p><p data-translated="true"><span class="original-text">This approach allows us to construct a profile where backtraces from tasks blocked on the <code>ch</code> channel, as in the example above, are actually represented.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このアプローチにより、上記の例のように<code>ch</code> チャンネルでブロックされているタスクのバックトレースが実際に表現されたプロファイルを構築することができます。</span></p><p data-translated="true"><span class="original-text">Let's run the same example, but now with a wall-time profiler:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同じ例を実行しますが、今回はウォールタイムプロファイラを使用します：</span></p><pre><code class="language-Julia hljs">using Base.Threads
using Profile
using PProf

ch = Channel(1)

const N_SPAWNED_TASKS = (1 &lt;&lt; 10)
const WAIT_TIME_NS = 10_000_000

function spawn_a_bunch_of_tasks_waiting_on_channel()
    for i in 1:N_SPAWNED_TASKS
        Threads.@spawn begin
            take!(ch)
        end
    end
end

function busywait()
    t0 = time_ns()
    while true
        if time_ns() - t0 &gt; WAIT_TIME_NS
            break
        end
    end
end

function main()
    spawn_a_bunch_of_tasks_waiting_on_channel()
    for i in 1:N_SPAWNED_TASKS
        put!(ch, i)
        busywait()
    end
end

Profile.@profile_walltime main()</code></pre><p data-translated="true"><span class="original-text">We obtain the following flame graph:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のフレームグラフが得られます：</span></p><p><img src="../img/wall-time-profiler-channel-example.png" alt="Wall-time Profile Channel"></p><p data-translated="true"><span class="original-text">We see that a large number of samples come from channel-related <code>take!</code> functions, which allows us to determine that there is indeed an excessive number of waiters in <code>ch</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">多くのサンプルがチャネル関連の <code>take!</code> 関数から来ていることがわかります。これにより、<code>ch</code> に過剰な数の待機者がいることが確認できます。</span></p><h3 id="A-Compute-Bound-Workload" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#A-Compute-Bound-Workload">A Compute-Bound Workload</a><a id="A-Compute-Bound-Workload-1"></a><a class="docs-heading-anchor-permalink" href="#A-Compute-Bound-Workload" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#A-Compute-Bound-Workload">計算バウンドワークロード</a><a id="A-Compute-Bound-Workload-1"></a><a class="docs-heading-anchor-permalink" href="#A-Compute-Bound-Workload" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Despite the wall-time profiler sampling all live tasks in the system and not just the currently running ones, it can still be helpful for identifying performance hotspots, even if your code is compute-bound. Let’s consider a simple example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">壁時間プロファイラはシステム内のすべてのライブタスクをサンプリングし、現在実行中のものだけではありませんが、計算バウンドのコードであってもパフォーマンスホットスポットを特定するのに役立ちます。簡単な例を考えてみましょう：</span></p><pre><code class="language-Julia hljs">using Base.Threads
using Profile
using PProf

ch = Channel(1)

const MAX_ITERS = (1 &lt;&lt; 22)
const N_TASKS = (1 &lt;&lt; 12)

function spawn_a_task_waiting_on_channel()
    Threads.@spawn begin
        take!(ch)
    end
end

function sum_of_sqrt()
    sum_of_sqrt = 0.0
    for i in 1:MAX_ITERS
        sum_of_sqrt += sqrt(i)
    end
    return sum_of_sqrt
end

function spawn_a_bunch_of_compute_heavy_tasks()
    Threads.@sync begin
        for i in 1:N_TASKS
            Threads.@spawn begin
                sum_of_sqrt()
            end
        end
    end
end

function main()
    spawn_a_task_waiting_on_channel()
    spawn_a_bunch_of_compute_heavy_tasks()
end

Profile.@profile_walltime main()</code></pre><p data-translated="true"><span class="original-text">After collecting a wall-time profile, we get the following flame graph:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">壁時間プロファイルを収集した後、次のフレームグラフが得られます：</span></p><p><img src="../img/wall-time-profiler-compute-bound-example.png" alt="Wall-time Profile Compute-Bound"></p><p data-translated="true"><span class="original-text">Notice how many of the samples contain <code>sum_of_sqrt</code>, which is the expensive compute function in our example.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>sum_of_sqrt</code> が多くのサンプルに含まれていることに注意してください。これは私たちの例での高コストの計算関数です。</span></p><h3 id="Identifying-Task-Sampling-Failures-in-your-Profile" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Identifying-Task-Sampling-Failures-in-your-Profile">Identifying Task Sampling Failures in your Profile</a><a id="Identifying-Task-Sampling-Failures-in-your-Profile-1"></a><a class="docs-heading-anchor-permalink" href="#Identifying-Task-Sampling-Failures-in-your-Profile" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Identifying-Task-Sampling-Failures-in-your-Profile">プロファイルにおけるタスクサンプリングの失敗を特定する</a><a id="Identifying-Task-Sampling-Failures-in-your-Profile-1"></a><a class="docs-heading-anchor-permalink" href="#Identifying-Task-Sampling-Failures-in-your-Profile" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">In the current implementation, the wall-time profiler attempts to sample from tasks that have been alive since the last garbage collection, along with those created afterward. However, if most tasks are extremely short-lived, you may end up sampling tasks that have already completed, resulting in missed backtrace captures.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">現在の実装では、壁時間プロファイラは最後のガーベジコレクション以降に生存していたタスクと、その後に作成されたタスクからサンプリングしようとします。しかし、ほとんどのタスクが非常に短命である場合、すでに完了したタスクをサンプリングしてしまい、バックトレースのキャプチャを逃すことになります。</span></p><p data-translated="true"><span class="original-text">If you encounter samples containing <code>failed_to_sample_task_fun</code> or <code>failed_to_stop_thread_fun</code>, this likely indicates a high volume of short-lived tasks, which prevented their backtraces from being collected.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>failed_to_sample_task_fun</code> または <code>failed_to_stop_thread_fun</code> を含むサンプルに遭遇した場合、これは短命のタスクが大量に存在し、そのバックトレースの収集を妨げたことを示している可能性があります。</span></p><p data-translated="true"><span class="original-text">Let's consider this simple example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この簡単な例を考えてみましょう：</span></p><pre><code class="language-Julia hljs">using Base.Threads
using Profile
using PProf

const N_SPAWNED_TASKS = (1 &lt;&lt; 16)
const WAIT_TIME_NS = 100_000

function spawn_a_bunch_of_short_lived_tasks()
    for i in 1:N_SPAWNED_TASKS
        Threads.@spawn begin
            # Do nothing
        end
    end
end

function busywait()
    t0 = time_ns()
    while true
        if time_ns() - t0 &gt; WAIT_TIME_NS
            break
        end
    end
end

function main()
    GC.enable(false)
    spawn_a_bunch_of_short_lived_tasks()
    for i in 1:N_SPAWNED_TASKS
        busywait()
    end
    GC.enable(true)
end

Profile.@profile_walltime main()</code></pre><p data-translated="true"><span class="original-text">Notice that the tasks spawned in <code>spawn_a_bunch_of_short_lived_tasks</code> are extremely short-lived. Since these tasks constitute the majority in the system, we will likely miss capturing a backtrace for most sampled tasks.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>spawn_a_bunch_of_short_lived_tasks</code> で生成されたタスクは非常に短命であることに注意してください。これらのタスクがシステムの大多数を構成しているため、サンプリングされたタスクのほとんどのバックトレースをキャプチャできない可能性が高いです。</span></p><p data-translated="true"><span class="original-text">After collecting a wall-time profile, we obtain the following flame graph:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">壁時間プロファイルを収集した後、次のフレームグラフを取得します：</span></p><p><img src="../img/task-sampling-failure.png" alt="Task Sampling Failure"></p><p data-translated="true"><span class="original-text">The large number of samples from <code>failed_to_stop_thread_fun</code> confirms that we have a significant number of short-lived tasks in the system.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>failed_to_stop_thread_fun</code>からの多数のサンプルは、システム内に短命のタスクがかなり存在することを確認しています。</span></p><h2 id="Memory-allocation-analysis" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Memory-allocation-analysis">Memory allocation analysis</a><a id="Memory-allocation-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-allocation-analysis" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Memory-allocation-analysis">メモリ割り当て分析</a><a id="Memory-allocation-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-allocation-analysis" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">One of the most common techniques to improve performance is to reduce memory allocation. Julia provides several tools to measure this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パフォーマンスを向上させるための最も一般的な手法の1つは、メモリ割り当てを減らすことです。Juliaはこれを測定するためのいくつかのツールを提供しています：</span></p><h3 id="@time" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#@time"><code>@time</code></a><a id="@time-1"></a><a class="docs-heading-anchor-permalink" href="#@time" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#@time"><code>@time</code></a><a id="@time-1"></a><a class="docs-heading-anchor-permalink" href="#@time" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The total amount of allocation can be measured with <a href="#@time"><code>@time</code></a>, <a href="../../base/base/index.html#Base.@allocated"><code>@allocated</code></a> and <a href="../../base/base/index.html#Base.@allocations"><code>@allocations</code></a>, and specific lines triggering allocation can often be inferred from profiling via the cost of garbage collection that these lines incur. However, sometimes it is more efficient to directly measure the amount of memory allocated by each line of code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">割り当ての総量は、<a href="#@time"><code>@time</code></a>、<a href="../../base/base/index.html#Base.@allocated"><code>@allocated</code></a>、および<a href="../../base/base/index.html#Base.@allocations"><code>@allocations</code></a>を使用して測定でき、特定の行が割り当てを引き起こすことは、これらの行が引き起こすガーベジコレクションのコストから推測できます。しかし、時には各コード行によって割り当てられたメモリの量を直接測定する方が効率的です。</span></p><h3 id="GC-Logging" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#GC-Logging">GC Logging</a><a id="GC-Logging-1"></a><a class="docs-heading-anchor-permalink" href="#GC-Logging" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#GC-Logging">GCログ記録</a><a id="GC-Logging-1"></a><a class="docs-heading-anchor-permalink" href="#GC-Logging" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">While <a href="#@time"><code>@time</code></a> logs high-level stats about memory usage and garbage collection over the course of evaluating an expression, it can be useful to log each garbage collection event, to get an intuitive sense of how often the garbage collector is running, how long it's running each time, and how much garbage it collects each time. This can be enabled with <a href="../../base/base/index.html#Base.GC.enable_logging"><code>GC.enable_logging(true)</code></a>, which causes Julia to log to stderr every time a garbage collection happens.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#@time"><code>@time</code></a>は、式を評価する過程でのメモリ使用量とガーベジコレクションに関する高レベルの統計を記録しますが、ガーベジコレクションイベントをログに記録することも有用です。これにより、ガーベジコレクタがどのくらいの頻度で実行されているか、毎回どのくらいの時間実行されているか、毎回どのくらいのゴミを収集しているかを直感的に把握できます。これは、<a href="../../base/base/index.html#Base.GC.enable_logging"><code>GC.enable_logging(true)</code></a>を使用して有効にでき、これによりJuliaはガーベジコレクションが発生するたびにstderrにログを記録します。</span></p><h3 id="allocation-profiler" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#allocation-profiler">Allocation Profiler</a><a id="allocation-profiler-1"></a><a class="docs-heading-anchor-permalink" href="#allocation-profiler" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#allocation-profiler">アロケーションプロファイラ</a><a id="allocation-profiler-1"></a><a class="docs-heading-anchor-permalink" href="#allocation-profiler" title="Permalink"></a></span></h3><div class="admonition is-compat" id="Julia-1.8-9e816c1268df60c9"><header class="admonition-header">Julia 1.8<a class="admonition-anchor" href="#Julia-1.8-9e816c1268df60c9" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">This functionality requires at least Julia 1.8.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この機能は、少なくともJulia 1.8が必要です。</span></p></div></div><p data-translated="true"><span class="original-text">The allocation profiler records the stack trace, type, and size of each allocation while it is running. It can be invoked with <a href="../../stdlib/Profile/index.html#Profile.Allocs.@profile"><code>Profile.Allocs.@profile</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">アロケーションプロファイラは、実行中に各割り当てのスタックトレース、タイプ、およびサイズを記録します。これは、<a href="../../stdlib/Profile/index.html#Profile.Allocs.@profile"><code>Profile.Allocs.@profile</code></a>を使用して呼び出すことができます。</span></p><p data-translated="true"><span class="original-text">This information about the allocations is returned as an array of <code>Alloc</code> objects, wrapped in an <code>AllocResults</code> object. The best way to visualize these is currently with the <a href="https://github.com/JuliaPerf/PProf.jl">PProf.jl</a> and <a href="https://github.com/pfitzseb/ProfileCanvas.jl">ProfileCanvas.jl</a> packages, which can visualize the call stacks which are making the most allocations.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの割り当てに関する情報は、<code>Alloc</code>オブジェクトの配列として返され、<code>AllocResults</code>オブジェクトにラップされます。これらを視覚化する最良の方法は、現在、<a href="https://github.com/JuliaPerf/PProf.jl">PProf.jl</a>および<a href="https://github.com/pfitzseb/ProfileCanvas.jl">ProfileCanvas.jl</a>パッケージを使用することで、最も多くの割り当てを行っているコールスタックを視覚化できます。</span></p><p data-translated="true"><span class="original-text">The allocation profiler does have significant overhead, so a <code>sample_rate</code> argument can be passed to speed it up by making it skip some allocations. Passing <code>sample_rate=1.0</code> will make it record everything (which is slow); <code>sample_rate=0.1</code> will record only 10% of the allocations (faster), etc.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">アロケーションプロファイラにはかなりのオーバーヘッドがあるため、いくつかのアロケーションをスキップすることで速度を上げるために <code>sample_rate</code> 引数を渡すことができます。 <code>sample_rate=1.0</code> を渡すとすべてを記録します（これは遅いです）； <code>sample_rate=0.1</code> はアロケーションの10%のみを記録します（速い）、など。</span></p><div class="admonition is-compat" id="Julia-1.11-9b66f5b825954f3a"><header class="admonition-header">Julia 1.11<a class="admonition-anchor" href="#Julia-1.11-9b66f5b825954f3a" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Older versions of Julia could not capture types in all cases. In older versions of Julia, if you see an allocation of type <code>Profile.Allocs.UnknownType</code>, it means that the profiler doesn't know what type of object was allocated. This mainly happened when the allocation was coming from generated code produced by the compiler. See <a href="https://github.com/JuliaLang/julia/issues/43688">issue #43688</a> for more info.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">古いバージョンのJuliaでは、すべてのケースで型をキャプチャできませんでした。古いバージョンのJuliaでは、<code>Profile.Allocs.UnknownType</code> 型のアロケーションが見られる場合、それはプロファイラがどの型のオブジェクトがアロケートされたかを知らないことを意味します。これは主に、コンパイラによって生成されたコードからアロケーションが行われたときに発生しました。詳細については、<a href="https://github.com/JuliaLang/julia/issues/43688">issue #43688</a> を参照してください。</span></p><p data-translated="true"><span class="original-text">Since Julia 1.11, all allocations should have a type reported.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia 1.11以降、すべてのアロケーションには型が報告されるべきです。</span></p></div></div><p data-translated="true"><span class="original-text">For more details on how to use this tool, please see the following talk from JuliaCon 2022: https://www.youtube.com/watch?v=BFvpwC8hEWQ</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このツールの使用方法の詳細については、JuliaCon 2022の以下のトークをご覧ください: https://www.youtube.com/watch?v=BFvpwC8hEWQ</span></p><h5 id="Allocation-Profiler-Example" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Allocation-Profiler-Example">Allocation Profiler Example</a><a id="Allocation-Profiler-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation-Profiler-Example" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Allocation-Profiler-Example">アロケーションプロファイラの例</a><a id="Allocation-Profiler-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation-Profiler-Example" title="Permalink"></a></span></h5><p data-translated="true"><span class="original-text">In this simple example, we use PProf to visualize the alloc profile. You could use another visualization tool instead. We collect the profile (specifying a sample rate), then we visualize it.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このシンプルな例では、PProfを使用してアロケーションプロファイルを視覚化します。代わりに別の視覚化ツールを使用することもできます。プロファイルを収集し（サンプルレートを指定）、それを視覚化します。</span></p><pre><code class="language-julia hljs">using Profile, PProf
Profile.Allocs.clear()
Profile.Allocs.@profile sample_rate=0.0001 my_function()
PProf.Allocs.pprof()</code></pre><p data-translated="true"><span class="original-text">Here is a more in-depth example, showing how we can tune the sample rate. A good number of samples to aim for is around 1 - 10 thousand. Too many, and the profile visualizer can get overwhelmed, and profiling will be slow. Too few, and you don't have a representative sample.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、サンプルレートを調整する方法を示すより詳細な例を示します。目指すべき良いサンプル数は約1〜10千です。多すぎると、プロファイルビジュアライザが圧倒され、プロファイリングが遅くなります。少なすぎると、代表的なサンプルが得られません。</span></p><pre><code class="language-julia-repl hljs">julia&gt; import Profile

julia&gt; @time my_function()  # Estimate allocations from a (second-run) of the function
  0.110018 seconds (1.50 M allocations: 58.725 MiB, 17.17% gc time)
500000

julia&gt; Profile.Allocs.clear()

julia&gt; Profile.Allocs.@profile sample_rate=0.001 begin   # 1.5 M * 0.001 = ~1.5K allocs.
           my_function()
       end
500000

julia&gt; prof = Profile.Allocs.fetch();  # If you want, you can also manually inspect the results.

julia&gt; length(prof.allocs)  # Confirm we have expected number of allocations.
1515

julia&gt; using PProf  # Now, visualize with an external tool, like PProf or ProfileCanvas.

julia&gt; PProf.Allocs.pprof(prof; from_c=false)  # You can optionally pass in a previously fetched profile result.
Analyzing 1515 allocation samples... 100%|████████████████████████████████| Time: 0:00:00
Main binary filename not available.
Serving web UI on http://localhost:62261
"alloc-profile.pb.gz"</code></pre><p data-translated="true"><span class="original-text">Then you can view the profile by navigating to http://localhost:62261, and the profile is saved to disk. See PProf package for more options.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">その後、http://localhost:62261 に移動してプロファイルを表示でき、プロファイルはディスクに保存されます。詳細なオプションについてはPProfパッケージを参照してください。</span></p><h5 id="Allocation-Profiling-Tips" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Allocation-Profiling-Tips">Allocation Profiling Tips</a><a id="Allocation-Profiling-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation-Profiling-Tips" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Allocation-Profiling-Tips">アロケーションプロファイリングのヒント</a><a id="Allocation-Profiling-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation-Profiling-Tips" title="Permalink"></a></span></h5><p data-translated="true"><span class="original-text">As stated above, aim for around 1-10 thousand samples in your profile.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記のように、プロファイルには約1-10千のサンプルを目指してください。</span></p><p data-translated="true"><span class="original-text">Note that we are uniformly sampling in the space of <em>all allocations</em>, and are not weighting our samples by the size of the allocation. So a given allocation profile may not give a representative profile of where most bytes are allocated in your program, unless you had set <code>sample_rate=1</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべての<em>割り当て</em>の空間で均等にサンプリングしていることに注意してください。また、割り当てのサイズによってサンプルに重みを付けていません。したがって、特定の割り当てプロファイルは、<code>sample_rate=1</code>を設定していない限り、プログラム内でほとんどのバイトがどこに割り当てられているかの代表的なプロファイルを提供しない可能性があります。</span></p><p data-translated="true"><span class="original-text">Allocations can come from users directly constructing objects, but can also come from inside the runtime or be inserted into compiled code to handle type instability. Looking at the "source code" view can be helpful to isolate them, and then other external tools such as <a href="https://github.com/JuliaDebug/Cthulhu.jl"><code>Cthulhu.jl</code></a> can be useful for identifying the cause of the allocation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">割り当ては、ユーザーが直接オブジェクトを構築することから来る場合もありますが、ランタイム内部から来ることや、型の不安定性を処理するためにコンパイルされたコードに挿入されることもあります。「ソースコード」ビューを見ることで、それらを特定するのに役立ち、<a href="https://github.com/JuliaDebug/Cthulhu.jl"><code>Cthulhu.jl</code></a>のような他の外部ツールが割り当ての原因を特定するのに役立ちます。</span></p><h5 id="Allocation-Profile-Visualization-Tools" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Allocation-Profile-Visualization-Tools">Allocation Profile Visualization Tools</a><a id="Allocation-Profile-Visualization-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation-Profile-Visualization-Tools" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Allocation-Profile-Visualization-Tools">割り当てプロファイル可視化ツール</a><a id="Allocation-Profile-Visualization-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation-Profile-Visualization-Tools" title="Permalink"></a></span></h5><p data-translated="true"><span class="original-text">There are several profiling visualization tools now that can all display Allocation Profiles. Here is a small list of some of the main ones we know about:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">現在、割り当てプロファイルを表示できるプロファイリング可視化ツールがいくつかあります。ここに私たちが知っている主要なツールの小さなリストがあります：</span></p><ul><li data-translated="true"><span class="original-text"><a href="https://github.com/JuliaPerf/PProf.jl">PProf.jl</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaPerf/PProf.jl">PProf.jl</a></span></li><li data-translated="true"><span class="original-text"><a href="https://github.com/pfitzseb/ProfileCanvas.jl">ProfileCanvas.jl</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/pfitzseb/ProfileCanvas.jl">ProfileCanvas.jl</a></span></li><li data-translated="true"><span class="original-text">VSCode's built-in profile visualizer (<code>@profview_allocs</code>) [docs needed]</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">VSCodeの組み込みプロファイルビジュアライザー（<code>@profview_allocs</code>）[ドキュメントが必要]</span></li><li>Viewing the results directly in the REPL<ul><li data-translated="true"><span class="original-text">You can inspect the results in the REPL via <a href="../../stdlib/Profile/index.html#Profile.Allocs.fetch"><code>Profile.Allocs.fetch()</code></a>, to view the stacktrace and type of each allocation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">REPL内で結果を確認するには、<a href="../../stdlib/Profile/index.html#Profile.Allocs.fetch"><code>Profile.Allocs.fetch()</code></a>を使用して、各割り当てのスタックトレースとタイプを表示できます。</span></li></ul></li></ul><h4 id="Line-by-Line-Allocation-Tracking" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Line-by-Line-Allocation-Tracking">Line-by-Line Allocation Tracking</a><a id="Line-by-Line-Allocation-Tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Line-by-Line-Allocation-Tracking" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Line-by-Line-Allocation-Tracking">行ごとの割り当て追跡</a><a id="Line-by-Line-Allocation-Tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Line-by-Line-Allocation-Tracking" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">An alternative way to measure allocations is to start Julia with the <code>--track-allocation=&lt;setting&gt;</code> command-line option, for which you can choose <code>none</code> (the default, do not measure allocation), <code>user</code> (measure memory allocation everywhere except Julia's core code), or <code>all</code> (measure memory allocation at each line of Julia code). Allocation gets measured for each line of compiled code. When you quit Julia, the cumulative results are written to text files with <code>.mem</code> appended after the file name, residing in the same directory as the source file. Each line lists the total number of bytes allocated. The <a href="https://github.com/JuliaCI/Coverage.jl"><code>Coverage</code> package</a> contains some elementary analysis tools, for example to sort the lines in order of number of bytes allocated.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">割り当てを測定する別の方法は、<code>--track-allocation=&lt;setting&gt;</code>コマンドラインオプションを使用してJuliaを起動することです。このオプションでは、<code>none</code>（デフォルト、割り当てを測定しない）、<code>user</code>（Juliaのコアコードを除くすべての場所でメモリ割り当てを測定）、または<code>all</code>（各行のJuliaコードでメモリ割り当てを測定）を選択できます。コンパイルされたコードの各行で割り当てが測定されます。Juliaを終了すると、累積結果がファイル名の後に<code>.mem</code>が付加されたテキストファイルに書き込まれ、ソースファイルと同じディレクトリに保存されます。各行には、割り当てられたバイトの合計数がリストされます。<a href="https://github.com/JuliaCI/Coverage.jl"><code>Coverage</code>パッケージ</a>には、割り当てられたバイト数の順に行をソートするなどの基本的な分析ツールが含まれています。</span></p><p data-translated="true"><span class="original-text">In interpreting the results, there are a few important details. Under the <code>user</code> setting, the first line of any function directly called from the REPL will exhibit allocation due to events that happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation counts, because much of Julia's compiler is written in Julia (and compilation usually requires memory allocation). The recommended procedure is to force compilation by executing all the commands you want to analyze, then call <a href="../../stdlib/Profile/index.html#Profile.clear_malloc_data"><code>Profile.clear_malloc_data()</code></a> to reset all allocation counters.  Finally, execute the desired commands and quit Julia to trigger the generation of the <code>.mem</code> files.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">結果を解釈する際には、いくつかの重要な詳細があります。<code>user</code>設定の下では、REPLから直接呼び出された関数の最初の行は、REPLコード自体で発生するイベントによるメモリ割り当てを示します。さらに重要なことに、JITコンパイルもメモリ割り当て数に寄与します。なぜなら、Juliaのコンパイラの多くはJuliaで書かれており（コンパイルには通常メモリ割り当てが必要です）、推奨される手順は、分析したいすべてのコマンドを実行してコンパイルを強制し、その後<a href="../../stdlib/Profile/index.html#Profile.clear_malloc_data"><code>Profile.clear_malloc_data()</code></a>を呼び出してすべての割り当てカウンタをリセットすることです。最後に、目的のコマンドを実行し、Juliaを終了して<code>.mem</code>ファイルの生成をトリガーします。</span></p><div class="admonition is-info" id="Note-2728c0099792b27b"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2728c0099792b27b" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text"><code>--track-allocation</code> changes code generation to log the allocations, and so the allocations may be different than what happens without the option. We recommend using the <a href="#allocation-profiler">allocation profiler</a> instead.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>--track-allocation</code>はコード生成を変更して割り当てをログに記録するため、オプションなしで発生するものとは異なる割り当てが行われる場合があります。代わりに<a href="#allocation-profiler">割り当てプロファイラ</a>の使用をお勧めします。</span></p></div></div><h2 id="External-Profiling" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#External-Profiling">External Profiling</a><a id="External-Profiling-1"></a><a class="docs-heading-anchor-permalink" href="#External-Profiling" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#External-Profiling">外部プロファイリング</a><a id="External-Profiling-1"></a><a class="docs-heading-anchor-permalink" href="#External-Profiling" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Currently Julia supports <code>Intel VTune</code>, <code>OProfile</code> and <code>perf</code> as external profiling tools.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">現在、Juliaは<code>Intel VTune</code>、<code>OProfile</code>、および<code>perf</code>を外部プロファイリングツールとしてサポートしています。</span></p><p data-translated="true"><span class="original-text">Depending on the tool you choose, compile with <code>USE_INTEL_JITEVENTS</code>, <code>USE_OPROFILE_JITEVENTS</code> and <code>USE_PERF_JITEVENTS</code> set to 1 in <code>Make.user</code>. Multiple flags are supported.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">選択したツールに応じて、<code>Make.user</code>で<code>USE_INTEL_JITEVENTS</code>、<code>USE_OPROFILE_JITEVENTS</code>、および<code>USE_PERF_JITEVENTS</code>を1に設定してコンパイルします。複数のフラグがサポートされています。</span></p><p data-translated="true"><span class="original-text">Before running Julia set the environment variable <a href="../environment-variables/index.html#ENABLE_JITPROFILING"><code>ENABLE_JITPROFILING</code></a> to 1.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaを実行する前に、環境変数<a href="../environment-variables/index.html#ENABLE_JITPROFILING"><code>ENABLE_JITPROFILING</code></a>を1に設定します。</span></p><p data-translated="true"><span class="original-text">Now you have a multitude of ways to employ those tools! For example with <code>OProfile</code> you can try a simple recording :</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これで、これらのツールを使用する方法が多数あります！例えば、<code>OProfile</code>を使用してシンプルな記録を試すことができます：</span></p><pre><code class="nohighlight hljs">&gt;ENABLE_JITPROFILING=1 sudo operf -Vdebug ./julia test/fastmath.jl
&gt;opreport -l `which ./julia`</code></pre><p data-translated="true"><span class="original-text">Or similarly with <code>perf</code> :</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">または、同様に<code>perf</code>を使用して：</span></p><pre><code class="nohighlight hljs">$ ENABLE_JITPROFILING=1 perf record -o /tmp/perf.data --call-graph dwarf -k 1 ./julia /test/fastmath.jl
$ perf inject --jit --input /tmp/perf.data --output /tmp/perf-jit.data
$ perf report --call-graph -G -i /tmp/perf-jit.data</code></pre><p data-translated="true"><span class="original-text">There are many more interesting things that you can measure about your program, to get a comprehensive list please read the <a href="https://www.brendangregg.com/perf.html">Linux perf examples page</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プログラムに関して測定できる興味深いことが他にもたくさんあります。包括的なリストについては、<a href="https://www.brendangregg.com/perf.html">Linux perfの例ページ</a>をお読みください。</span></p><p data-translated="true"><span class="original-text">Remember that perf saves for each execution a <code>perf.data</code> file that, even for small programs, can get quite large. Also the perf LLVM module saves temporarily debug objects in <code>~/.debug/jit</code>, remember to clean that folder frequently.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">perfは各実行のために<code>perf.data</code>ファイルを保存しますが、小さなプログラムでもかなり大きくなる可能性があります。また、perf LLVMモジュールは一時的にデバッグオブジェクトを<code>~/.debug/jit</code>に保存しますので、そのフォルダを頻繁にクリーンアップすることを忘れないでください。</span></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../code-loading/index.html">« Code Loading</a><a class="docs-footer-nextpage" href="../stacktraces/index.html">Stack Traces »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>