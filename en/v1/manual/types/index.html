<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Types · The Julia Language</title><meta name="title" content="Types · The Julia Language"><meta property="og:title" content="Types · The Julia Language"><meta property="twitter:title" content="Types · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/types/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/types/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bi1h1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li class="is-active"><a class="tocitem" href="">Types</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Type-Declarations"><span>Type Declarations</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Type-Declarations"><span>型宣言</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-abstract-types"><span>Abstract Types</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-abstract-types"><span>抽象型</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Primitive-Types"><span>Primitive Types</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Primitive-Types"><span>基本型</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Composite-Types"><span>Composite Types</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Composite-Types"><span>複合型</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Mutable-Composite-Types"><span>Mutable Composite Types</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Mutable-Composite-Types"><span>可変複合型</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-declared-types"><span>Declared Types</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-declared-types"><span>宣言型</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Type-Unions"><span>Type Unions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Type-Unions"><span>型の合併</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Parametric-Types"><span>Parametric Types</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Parametric-Types"><span>パラメトリック型</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#UnionAll-Types"><span>UnionAll Types</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#UnionAll-Types"><span>UnionAll型</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-singleton-types"><span>Singleton types</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-singleton-types"><span>シングルトン型</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Types-of-functions"><span>Types of functions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Types-of-functions"><span>関数の種類</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-typet-type"><span><code>Type{T}</code> type selectors</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-typet-type"><span><code>Type{T}</code> 型セレクタ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Type-Aliases"><span>Type Aliases</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Type-Aliases"><span>型エイリアス</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Operations-on-Types"><span>Operations on Types</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Operations-on-Types"><span>型に対する操作</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-custom-pretty-printing"><span>Custom pretty-printing</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-custom-pretty-printing"><span>カスタム整形出力</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#&quot;Value-types&quot;"><span>"Value types"</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#&quot;Value-types&quot;"><span>「値型」</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">型</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">型</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/types.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-types">Types</a><a id="man-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-types">型</a><a id="man-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-types" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">Type systems have traditionally fallen into two quite different camps: static type systems, where every program expression must have a type computable before the execution of the program, and dynamic type systems, where nothing is known about types until run time, when the actual values manipulated by the program are available. Object orientation allows some flexibility in statically typed languages by letting code be written without the precise types of values being known at compile time. The ability to write code that can operate on different types is called polymorphism. All code in classic dynamically typed languages is polymorphic: only by explicitly checking types, or when objects fail to support operations at run-time, are the types of any values ever restricted.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型システムは伝統的に、プログラムの実行前にすべてのプログラム式が計算可能な型を持たなければならない静的型システムと、実行時まで型について何も知られていない動的型システムの二つの異なるキャンプに分かれてきました。オブジェクト指向は、コンパイル時に値の正確な型が知られていなくてもコードを書くことを可能にすることで、静的型付け言語においていくつかの柔軟性を提供します。異なる型で動作できるコードを書く能力はポリモーフィズムと呼ばれます。古典的な動的型付け言語のすべてのコードはポリモーフィックです。型を明示的にチェックするか、オブジェクトが実行時に操作をサポートしない場合にのみ、値の型が制限されます。</span></p><p data-translated="true"><span class="original-text">Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in <a href="../methods/index.html#Methods">Methods</a>, but is rooted in the type system presented here.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの型システムは動的ですが、特定の値が特定の型であることを示すことが可能であるため、静的型システムのいくつかの利点を得ることができます。これは効率的なコードを生成するのに大いに役立ちますが、さらに重要なのは、関数引数の型に基づくメソッドディスパッチが言語に深く統合されることです。メソッドディスパッチについては<a href="../methods/index.html#Methods">Methods</a>で詳しく探求されていますが、ここで提示されている型システムに根ざしています。</span></p><p data-translated="true"><span class="original-text">The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write many useful Julia functions without ever explicitly using types. When additional expressiveness is needed, however, it is easy to gradually introduce explicit type annotations into previously "untyped" code. Adding annotations serves three primary purposes: to take advantage of Julia's powerful multiple-dispatch mechanism,  to improve human readability, and to catch programmer errors.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型が省略された場合のJuliaのデフォルトの動作は、値が任意の型であることを許可することです。したがって、型を明示的に使用することなく、多くの有用なJulia関数を書くことができます。しかし、追加の表現力が必要な場合、以前の「型なし」コードに明示的な型注釈を徐々に導入するのは簡単です。注釈を追加することには主に3つの目的があります：Juliaの強力な多重ディスパッチメカニズムを活用すること、人間の可読性を向上させること、プログラマーのエラーを捕捉することです。</span></p><p data-translated="true"><span class="original-text">Describing Julia in the lingo of <a href="https://en.wikipedia.org/wiki/Type_system">type systems</a>, it is: dynamic, nominative and parametric. Generic types can be parameterized, and the hierarchical relationships between types are <a href="https://en.wikipedia.org/wiki/Nominal_type_system">explicitly declared</a>, rather than <a href="https://en.wikipedia.org/wiki/Structural_type_system">implied by compatible structure</a>. One particularly distinctive feature of Julia's type system is that concrete types may not subtype each other: all concrete types are final and may only have abstract types as their supertypes. While this might at first seem unduly restrictive, it has many beneficial consequences with surprisingly few drawbacks. It turns out that being able to inherit behavior is much more important than being able to inherit structure, and inheriting both causes significant difficulties in traditional object-oriented languages. Other high-level aspects of Julia's type system that should be mentioned up front are:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaを<a href="https://en.wikipedia.org/wiki/Type_system">型システム</a>の用語で説明すると、それは動的、名義的、かつパラメトリックです。ジェネリック型はパラメータ化でき、型間の階層関係は<a href="https://en.wikipedia.org/wiki/Nominal_type_system">明示的に宣言</a>されており、<a href="https://en.wikipedia.org/wiki/Structural_type_system">互換性のある構造によって暗示される</a>ものではありません。Juliaの型システムの特に特徴的な点は、具体的な型が互いにサブタイプになれないことです：すべての具体的な型は最終的であり、抽象型のみをスーパタイプとして持つことができます。これは最初は過度に制限的に思えるかもしれませんが、驚くほど少ない欠点で多くの有益な結果をもたらします。振る舞いを継承できることは、構造を継承できることよりもはるかに重要であり、両方を継承することは従来のオブジェクト指向言語で重大な困難を引き起こします。Juliaの型システムの他の高レベルの側面として、前もって言及すべきことは次のとおりです：</span></p><ul><li data-translated="true"><span class="original-text">There is no division between object and non-object values: all values in Julia are true objects having a type that belongs to a single, fully connected type graph, all nodes of which are equally first-class as types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">オブジェクト値と非オブジェクト値の間に区別はありません：Juliaのすべての値は真のオブジェクトであり、単一の完全に接続された型グラフに属する型を持ち、そのすべてのノードは型として同等にファーストクラスです。</span></li><li data-translated="true"><span class="original-text">There is no meaningful concept of a "compile-time type": the only type a value has is its actual type when the program is running. This is called a "run-time type" in object-oriented languages where the combination of static compilation with polymorphism makes this distinction significant.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">「コンパイル時型」という意味のある概念はありません：値が持つ唯一の型は、プログラムが実行されているときの実際の型です。これは、静的コンパイルと多態性の組み合わせがこの区別を重要にするオブジェクト指向言語では「ランタイム型」と呼ばれます。</span></li><li data-translated="true"><span class="original-text">Only values, not variables, have types – variables are simply names bound to values, although for simplicity we may say "type of a variable" as shorthand for "type of the value to which a variable refers".</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型を持つのは値のみであり、変数ではありません – 変数は単に値にバインドされた名前であり、簡単のために「変数の型」と言うことがありますが、これは「変数が参照する値の型」の略語です。</span></li><li data-translated="true"><span class="original-text">Both abstract and concrete types can be parameterized by other types. They can also be parameterized by symbols, by values of any type for which <a href="../../base/base/index.html#Base.isbits"><code>isbits</code></a> returns true (essentially, things like numbers and bools that are stored like C types or <code>struct</code>s with no pointers to other objects), and also by tuples thereof. Type parameters may be omitted when they do not need to be referenced or restricted.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">抽象型と具体型の両方は、他の型によってパラメータ化できます。また、<a href="../../base/base/index.html#Base.isbits"><code>isbits</code></a>がtrueを返す任意の型の値（本質的には、C型や他のオブジェクトへのポインタを持たない<code>struct</code>のような数値やboolなど）や、それらのタプルによってもパラメータ化できます。型パラメータは、参照または制限する必要がない場合は省略できます。</span></li></ul><p data-translated="true"><span class="original-text">Julia's type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive. Many Julia programmers may never feel the need to write code that explicitly uses types. Some kinds of programming, however, become clearer, simpler, faster and more robust with declared types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの型システムは強力で表現力豊かであるように設計されていますが、同時に明確で直感的で目立たないものでもあります。多くのJuliaプログラマーは、型を明示的に使用するコードを書く必要を感じないかもしれません。しかし、特定の種類のプログラミングは、宣言された型を持つことでより明確でシンプル、迅速かつ堅牢になります。</span></p><h2 id="Type-Declarations" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Type-Declarations">Type Declarations</a><a id="Type-Declarations-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Declarations" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Type-Declarations">型宣言</a><a id="Type-Declarations-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Declarations" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The <code>::</code> operator can be used to attach type annotations to expressions and variables in programs. There are two primary reasons to do this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>::</code>演算子は、プログラム内の式や変数に型注釈を付けるために使用できます。これを行う主な理由は2つあります：</span></p><ol><li data-translated="true"><span class="original-text">As an assertion to help confirm that your program works the way you expect, and</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プログラムが期待通りに動作することを確認するためのアサーションとして、</span></li><li data-translated="true"><span class="original-text">To provide extra type information to the compiler, which can then improve performance in some cases.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コンパイラに追加の型情報を提供し、場合によってはパフォーマンスを向上させることができます。</span></li></ol><p data-translated="true"><span class="original-text">When appended to an expression computing a value, the <code>::</code> operator is read as "is an instance of". It can be used anywhere to assert that the value of the expression on the left is an instance of the type on the right. When the type on the right is concrete, the value on the left must have that type as its implementation – recall that all concrete types are final, so no implementation is a subtype of any other. When the type is abstract, it suffices for the value to be implemented by a concrete type that is a subtype of the abstract type. If the type assertion is not true, an exception is thrown, otherwise, the left-hand value is returned:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">値を計算する式に追加されると、<code>::</code>演算子は「はインスタンスである」と読み取られます。これは、左側の式の値が右側の型のインスタンスであることを主張するためにどこでも使用できます。右側の型が具体的な場合、左側の値はその型を実装している必要があります - すべての具体的な型は最終的なものであるため、どの実装も他の型のサブタイプではありません。型が抽象的な場合、値は抽象型のサブタイプである具体的な型によって実装されているだけで十分です。型アサーションが真でない場合、例外がスローされ、それ以外の場合は左側の値が返されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; (1+2)::AbstractFloat
ERROR: TypeError: in typeassert, expected AbstractFloat, got a value of type Int64

julia&gt; (1+2)::Int
3</code></pre><p data-translated="true"><span class="original-text">This allows a type assertion to be attached to any expression in-place.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これにより、型アサーションを任意の式にその場で追加することができます。</span></p><p data-translated="true"><span class="original-text">When appended to a variable on the left-hand side of an assignment, or as part of a <code>local</code> declaration, the <code>::</code> operator means something a bit different: it declares the variable to always have the specified type, like a type declaration in a statically-typed language such as C. Every value assigned to the variable will be converted to the declared type using <a href="../../base/base/index.html#Base.convert"><code>convert</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">代入の左側にある変数に追加されたり、<code>local</code>宣言の一部として使用されると、<code>::</code>演算子は少し異なる意味を持ちます：これは、変数が常に指定された型を持つことを宣言します。これは、Cのような静的型付け言語における型宣言のようなものです。変数に割り当てられるすべての値は、<a href="../../base/base/index.html#Base.convert"><code>convert</code></a>を使用して宣言された型に変換されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function foo()
           x::Int8 = 100
           x
       end
foo (generic function with 1 method)

julia&gt; x = foo()
100

julia&gt; typeof(x)
Int8</code></pre><p data-translated="true"><span class="original-text">This feature is useful for avoiding performance "gotchas" that could occur if one of the assignments to a variable changed its type unexpectedly.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この機能は、変数への代入のいずれかが予期せずその型を変更した場合に発生する可能性のあるパフォーマンスの「落とし穴」を避けるのに役立ちます。</span></p><p data-translated="true"><span class="original-text">This "declaration" behavior only occurs in specific contexts:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この「宣言」動作は特定のコンテキストでのみ発生します：</span></p><pre><code class="language-julia hljs">local x::Int8  # in a local declaration
x::Int8 = 10   # as the left-hand side of an assignment</code></pre><p data-translated="true"><span class="original-text">and applies to the whole current scope, even before the declaration.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そして、宣言の前でも現在のスコープ全体に適用されます。</span></p><p data-translated="true"><span class="original-text">As of Julia 1.8, type declarations can now be used in global scope i.e. type annotations can be added to global variables to make accessing them type stable.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia 1.8以降、型宣言はグローバルスコープでも使用できるようになりました。つまり、型アノテーションをグローバル変数に追加して、それらに型安定性を持たせることができます。</span></p><pre><code class="language-julia hljs">julia&gt; x::Int = 10
10

julia&gt; x = 3.5
ERROR: InexactError: Int64(3.5)

julia&gt; function foo(y)
           global x = 15.8    # throws an error when foo is called
           return x + y
       end
foo (generic function with 1 method)

julia&gt; foo(10)
ERROR: InexactError: Int64(15.8)</code></pre><p data-translated="true"><span class="original-text">Declarations can also be attached to function definitions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">宣言は関数定義にも付けることができます：</span></p><pre><code class="language-julia hljs">function sinc(x)::Float64
    if x == 0
        return 1
    end
    return sin(pi*x)/(pi*x)
end</code></pre><p data-translated="true"><span class="original-text">Returning from this function behaves just like an assignment to a variable with a declared type: the value is always converted to <code>Float64</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この関数からの戻り値は、宣言された型の変数への代入と同様に動作します: 値は常に <code>Float64</code> に変換されます。</span></p><h2 id="man-abstract-types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-abstract-types">Abstract Types</a><a id="man-abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-abstract-types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-abstract-types">抽象型</a><a id="man-abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-abstract-types" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. We begin with abstract types even though they have no instantiation because they are the backbone of the type system: they form the conceptual hierarchy which makes Julia's type system more than just a collection of object implementations.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">抽象型はインスタンス化できず、型グラフのノードとしてのみ機能し、関連する具体的な型の集合を記述します: それらの具体的な型は、抽象型の子孫です。抽象型はインスタンス化されないにもかかわらず、型システムの基盤であるため、最初に扱います: それらは、Juliaの型システムを単なるオブジェクト実装の集合以上のものにする概念的な階層を形成します。</span></p><p data-translated="true"><span class="original-text">Recall that in <a href="../integers-and-floating-point-numbers/index.html#Integers-and-Floating-Point-Numbers">Integers and Floating-Point Numbers</a>, we introduced a variety of concrete types of numeric values: <a href="../../base/numbers/index.html#Core.Int8"><code>Int8</code></a>, <a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a>, <a href="../../base/numbers/index.html#Core.Int16"><code>Int16</code></a>, <a href="../../base/numbers/index.html#Core.UInt16"><code>UInt16</code></a>, <a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a>, <a href="../../base/numbers/index.html#Core.UInt32"><code>UInt32</code></a>, <a href="../../base/numbers/index.html#Core.Int64"><code>Int64</code></a>, <a href="../../base/numbers/index.html#Core.UInt64"><code>UInt64</code></a>, <a href="../../base/numbers/index.html#Core.Int128"><code>Int128</code></a>, <a href="../../base/numbers/index.html#Core.UInt128"><code>UInt128</code></a>, <a href="../../base/numbers/index.html#Core.Float16"><code>Float16</code></a>, <a href="../../base/numbers/index.html#Core.Float32"><code>Float32</code></a>, and <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>. Although they have different representation sizes, <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code> and <code>Int128</code> all have in common that they are signed integer types. Likewise <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>, <code>UInt64</code> and <code>UInt128</code> are all unsigned integer types, while <code>Float16</code>, <code>Float32</code> and <code>Float64</code> are distinct in being floating-point types rather than integers. It is common for a piece of code to make sense, for example, only if its arguments are some kind of integer, but not really depend on what particular <em>kind</em> of integer. For example, the greatest common denominator algorithm works for all kinds of integers, but will not work for floating-point numbers. Abstract types allow the construction of a hierarchy of types, providing a context into which concrete types can fit. This allows you, for example, to easily program to any type that is an integer, without restricting an algorithm to a specific type of integer.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../integers-and-floating-point-numbers/index.html#Integers-and-Floating-Point-Numbers">整数と浮動小数点数</a>で、さまざまな具体的な数値型を紹介しました: <a href="../../base/numbers/index.html#Core.Int8"><code>Int8</code></a>、<a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a>、<a href="../../base/numbers/index.html#Core.Int16"><code>Int16</code></a>、<a href="../../base/numbers/index.html#Core.UInt16"><code>UInt16</code></a>、<a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a>、<a href="../../base/numbers/index.html#Core.UInt32"><code>UInt32</code></a>、<a href="../../base/numbers/index.html#Core.Int64"><code>Int64</code></a>、<a href="../../base/numbers/index.html#Core.UInt64"><code>UInt64</code></a>、<a href="../../base/numbers/index.html#Core.Int128"><code>Int128</code></a>、<a href="../../base/numbers/index.html#Core.UInt128"><code>UInt128</code></a>、<a href="../../base/numbers/index.html#Core.Float16"><code>Float16</code></a>、<a href="../../base/numbers/index.html#Core.Float32"><code>Float32</code></a>、および <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>。それらは異なる表現サイズを持っていますが、<code>Int8</code>、<code>Int16</code>、<code>Int32</code>、<code>Int64</code>、および <code>Int128</code> はすべて符号付き整数型であるという共通点があります。同様に、<code>UInt8</code>、<code>UInt16</code>、<code>UInt32</code>、<code>UInt64</code>、および <code>UInt128</code> はすべて符号なし整数型であり、<code>Float16</code>、<code>Float32</code>、および <code>Float64</code> は整数ではなく浮動小数点型であるという点で異なります。コードの一部は、たとえば、その引数が何らかの整数型である場合にのみ意味を持つことが一般的ですが、特定の<em>種類</em>の整数に依存するわけではありません。たとえば、最大公約数アルゴリズムはすべての種類の整数に対して機能しますが、浮動小数点数には機能しません。抽象型は、型の階層を構築することを可能にし、具体的な型が適合できるコンテキストを提供します。これにより、たとえば、特定の整数型に制限することなく、整数型の任意の型に対して簡単にプログラムを作成できます。</span></p><p data-translated="true"><span class="original-text">Abstract types are declared using the <a href="../../base/base/index.html#abstract type"><code>abstract type</code></a> keyword. The general syntaxes for declaring an abstract type are:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">抽象型は <a href="../../base/base/index.html#abstract type"><code>abstract type</code></a> キーワードを使用して宣言されます。抽象型を宣言するための一般的な構文は次のとおりです:</span></p><pre><code class="nohighlight hljs">abstract type «name» end
abstract type «name» &lt;: «supertype» end</code></pre><p data-translated="true"><span class="original-text">The <code>abstract type</code> keyword introduces a new abstract type, whose name is given by <code>«name»</code>. This name can be optionally followed by <a href="../../base/base/#Core.:&lt;:#Core.:&lt;:"><code>&lt;:</code></a> and an already-existing type, indicating that the newly declared abstract type is a subtype of this "parent" type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>abstract type</code> キーワードは、新しい抽象型を導入し、その名前は <code>«name»</code> で指定されます。この名前は、オプションで <a href="../../base/base/#Core.:&lt;:#Core.:&lt;:"><code>&lt;:</code></a> と既存の型を続けることができ、新しく宣言された抽象型がこの「親」型のサブタイプであることを示します。</span></p><p data-translated="true"><span class="original-text">When no supertype is given, the default supertype is <code>Any</code> – a predefined abstract type that all objects are instances of and all types are subtypes of. In type theory, <code>Any</code> is commonly called "top" because it is at the apex of the type graph. Julia also has a predefined abstract "bottom" type, at the nadir of the type graph, which is written as <code>Union{}</code>. It is the exact opposite of <code>Any</code>: no object is an instance of <code>Union{}</code> and all types are supertypes of <code>Union{}</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">スーパタイプが指定されていない場合、デフォルトのスーパタイプは <code>Any</code> です - すべてのオブジェクトがインスタンスであり、すべての型がサブタイプである事前定義された抽象型です。型理論では、<code>Any</code> は「トップ」と呼ばれることが一般的で、型グラフの頂点に位置します。Julia には、型グラフの底辺に位置する事前定義された抽象「ボトム」型もあり、<code>Union{}</code> と書かれます。これは <code>Any</code> の正反対です: どのオブジェクトも <code>Union{}</code> のインスタンスではなく、すべての型が <code>Union{}</code> のスーパタイプです。</span></p><p data-translated="true"><span class="original-text">Let's consider some of the abstract types that make up Julia's numerical hierarchy:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia の数値階層を構成するいくつかの抽象型を考えてみましょう:</span></p><pre><code class="language-julia hljs">abstract type Number end
abstract type Real          &lt;: Number end
abstract type AbstractFloat &lt;: Real end
abstract type Integer       &lt;: Real end
abstract type Signed        &lt;: Integer end
abstract type Unsigned      &lt;: Integer end</code></pre><p data-translated="true"><span class="original-text">The <a href="../../base/numbers/index.html#Core.Number"><code>Number</code></a> type is a direct child type of <code>Any</code>, and <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> is its child. In turn, <code>Real</code> has two children (it has more, but only two are shown here; we'll get to the others later): <a href="../../base/numbers/index.html#Core.Integer"><code>Integer</code></a> and <a href="../../base/numbers/index.html#Core.AbstractFloat"><code>AbstractFloat</code></a>, separating the world into representations of integers and representations of real numbers. Representations of real numbers include floating-point types, but also include other types, such as rationals. <code>AbstractFloat</code> includes only floating-point representations of real numbers. Integers are further subdivided into <a href="../../base/numbers/index.html#Core.Signed"><code>Signed</code></a> and <a href="../../base/numbers/index.html#Core.Unsigned"><code>Unsigned</code></a> varieties.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/numbers/index.html#Core.Number"><code>Number</code></a> 型は <code>Any</code> の直接の子型であり、<a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> はその子です。さらに、<code>Real</code> には2つの子があります（他にもありますが、ここでは2つだけが表示されています; 他のものについては後で説明します）: <a href="../../base/numbers/index.html#Core.Integer"><code>Integer</code></a> と <a href="../../base/numbers/index.html#Core.AbstractFloat"><code>AbstractFloat</code></a> で、整数の表現と実数の表現に分かれています。実数の表現には浮動小数点型が含まれますが、有理数などの他の型も含まれます。<code>AbstractFloat</code> には実数の浮動小数点表現のみが含まれます。整数はさらに <a href="../../base/numbers/index.html#Core.Signed"><code>Signed</code></a> と <a href="../../base/numbers/index.html#Core.Unsigned"><code>Unsigned</code></a> の種類に細分化されます。</span></p><p data-translated="true"><span class="original-text">The <code>&lt;:</code> operator in general means "is a subtype of", and, used in declarations like those above, declares the right-hand type to be an immediate supertype of the newly declared type. It can also be used in expressions as a subtype operator which returns <code>true</code> when its left operand is a subtype of its right operand:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>&lt;:</code> 演算子は一般に「サブタイプである」を意味し、上記のような宣言で使用されると、右側の型を新しく宣言された型の即時スーパタイプとして宣言します。また、式の中でサブタイプ演算子として使用され、左オペランドが右オペランドのサブタイプである場合に <code>true</code> を返します:</span></p><pre><code class="language-julia-repl hljs">julia&gt; Integer &lt;: Number
true

julia&gt; Integer &lt;: AbstractFloat
false</code></pre><p data-translated="true"><span class="original-text">An important use of abstract types is to provide default implementations for concrete types. To give a simple example, consider:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">抽象型の重要な使用法は、具体型のデフォルト実装を提供することです。簡単な例を考えてみましょう：</span></p><pre><code class="language-julia hljs">function myplus(x,y)
    x+y
end</code></pre><p data-translated="true"><span class="original-text">The first thing to note is that the above argument declarations are equivalent to <code>x::Any</code> and <code>y::Any</code>. When this function is invoked, say as <code>myplus(2,5)</code>, the dispatcher chooses the most specific method named <code>myplus</code> that matches the given arguments. (See <a href="../methods/index.html#Methods">Methods</a> for more information on multiple dispatch.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初に注目すべき点は、上記の引数宣言が<code>x::Any</code>および<code>y::Any</code>と同等であるということです。この関数が<code>myplus(2,5)</code>のように呼び出されると、ディスパッチャは与えられた引数に一致する最も特定的な<code>myplus</code>という名前のメソッドを選択します。（複数のディスパッチに関する詳細は<a href="../methods/index.html#Methods">Methods</a>を参照してください。）</span></p><p data-translated="true"><span class="original-text">Assuming no method more specific than the above is found, Julia next internally defines and compiles a method called <code>myplus</code> specifically for two <code>Int</code> arguments based on the generic function given above, i.e., it implicitly defines and compiles:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記よりも特定的なメソッドが見つからない場合、Juliaは次に、上記の汎用関数に基づいて2つの<code>Int</code>引数専用の<code>myplus</code>というメソッドを内部的に定義し、コンパイルします。つまり、暗黙的に定義され、コンパイルされるのです：</span></p><pre><code class="language-julia hljs">function myplus(x::Int,y::Int)
    x+y
end</code></pre><p data-translated="true"><span class="original-text">and finally, it invokes this specific method.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そして最後に、この特定のメソッドが呼び出されます。</span></p><p data-translated="true"><span class="original-text">Thus, abstract types allow programmers to write generic functions that can later be used as the default method by many combinations of concrete types. Thanks to multiple dispatch, the programmer has full control over whether the default or more specific method is used.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、抽象型はプログラマーが汎用関数を書くことを可能にし、それが後に多くの具体型の組み合わせによってデフォルトメソッドとして使用されることができます。複数のディスパッチのおかげで、プログラマーはデフォルトメソッドまたはより特定的なメソッドが使用されるかどうかを完全に制御できます。</span></p><p data-translated="true"><span class="original-text">An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of concrete argument types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see <a href="../performance-tips/index.html#man-performance-abstract-container">Performance Tips</a>.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プログラマーが引数が抽象型の関数に依存してもパフォーマンスの損失はないという重要な点は、呼び出される具体的な引数型のタプルごとに再コンパイルされるからです。（ただし、抽象型のコンテナである関数引数の場合にはパフォーマンスの問題があるかもしれません；詳細は<a href="../performance-tips/index.html#man-performance-abstract-container">Performance Tips</a>を参照してください。）</span></p><h2 id="Primitive-Types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Primitive-Types">Primitive Types</a><a id="Primitive-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-Types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Primitive-Types">プリミティブ型</a><a id="Primitive-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-Types" title="Permalink"></a></span></h2><div class="admonition is-warning" id="Warning-e7b3b4c029e7fd12"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-e7b3b4c029e7fd12" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">It is almost always preferable to wrap an existing primitive type in a new composite type than to define your own primitive type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">独自のプリミティブ型を定義するよりも、既存のプリミティブ型を新しい複合型でラップする方がほとんどの場合望ましいです。</span></p><p data-translated="true"><span class="original-text">This functionality exists to allow Julia to bootstrap the standard primitive types that LLVM supports. Once they are defined, there is very little reason to define more.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この機能は、JuliaがLLVMがサポートする標準のプリミティブ型をブートストラップすることを可能にするために存在します。一度定義されると、さらに多くを定義する理由はほとんどありません。</span></p></div></div><p data-translated="true"><span class="original-text">A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プリミティブ型とは、データが単純なビットから成る具体型のことです。プリミティブ型の古典的な例は整数や浮動小数点値です。ほとんどの言語とは異なり、Juliaでは固定された組み込み型のセットだけを提供するのではなく、独自のプリミティブ型を宣言することができます。実際、標準のプリミティブ型はすべて言語自体で定義されています：</span></p><pre><code class="language-julia hljs">primitive type Float16 &lt;: AbstractFloat 16 end
primitive type Float32 &lt;: AbstractFloat 32 end
primitive type Float64 &lt;: AbstractFloat 64 end

primitive type Bool &lt;: Integer 8 end
primitive type Char &lt;: AbstractChar 32 end

primitive type Int8    &lt;: Signed   8 end
primitive type UInt8   &lt;: Unsigned 8 end
primitive type Int16   &lt;: Signed   16 end
primitive type UInt16  &lt;: Unsigned 16 end
primitive type Int32   &lt;: Signed   32 end
primitive type UInt32  &lt;: Unsigned 32 end
primitive type Int64   &lt;: Signed   64 end
primitive type UInt64  &lt;: Unsigned 64 end
primitive type Int128  &lt;: Signed   128 end
primitive type UInt128 &lt;: Unsigned 128 end</code></pre><p data-translated="true"><span class="original-text">The general syntaxes for declaring a primitive type are:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プリミティブ型を宣言するための一般的な構文は次のとおりです。</span></p><pre><code class="nohighlight hljs">primitive type «name» «bits» end
primitive type «name» &lt;: «supertype» «bits» end</code></pre><p data-translated="true"><span class="original-text">The number of bits indicates how much storage the type requires and the name gives the new type a name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having <code>Any</code> as its immediate supertype. The declaration of <a href="../../base/numbers/index.html#Core.Bool"><code>Bool</code></a> above therefore means that a boolean value takes eight bits to store, and has <a href="../../base/numbers/index.html#Core.Integer"><code>Integer</code></a> as its immediate supertype. Currently, only sizes that are multiples of 8 bits are supported and you are likely to experience LLVM bugs with sizes other than those used above. Therefore, boolean values, although they really need just a single bit, cannot be declared to be any smaller than eight bits.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ビット数は、その型が必要とするストレージの量を示し、名前は新しい型に名前を付けます。プリミティブ型は、オプションであるスーパタイプのサブタイプとして宣言できます。スーパタイプが省略された場合、その型は即時スーパタイプとして<code>Any</code>を持つことになります。したがって、上記の<a href="../../base/numbers/index.html#Core.Bool"><code>Bool</code></a>の宣言は、ブール値がストレージに8ビットを必要とし、即時スーパタイプとして<a href="../../base/numbers/index.html#Core.Integer"><code>Integer</code></a>を持つことを意味します。現在、サポートされているのは8ビットの倍数のみであり、上記以外のサイズではLLVMのバグが発生する可能性があります。したがって、ブール値は実際には1ビットだけで済むにもかかわらず、8ビット未満に宣言することはできません。</span></p><p data-translated="true"><span class="original-text">The types <a href="../../base/numbers/index.html#Core.Bool"><code>Bool</code></a>, <a href="../../base/numbers/index.html#Core.Int8"><code>Int8</code></a> and <a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a> all have identical representations: they are eight-bit chunks of memory. Since Julia's type system is nominative, however, they are not interchangeable despite having identical structure. A fundamental difference between them is that they have different supertypes: <a href="../../base/numbers/index.html#Core.Bool"><code>Bool</code></a>'s direct supertype is <a href="../../base/numbers/index.html#Core.Integer"><code>Integer</code></a>, <a href="../../base/numbers/index.html#Core.Int8"><code>Int8</code></a>'s is <a href="../../base/numbers/index.html#Core.Signed"><code>Signed</code></a>, and <a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a>'s is <a href="../../base/numbers/index.html#Core.Unsigned"><code>Unsigned</code></a>. All other differences between <a href="../../base/numbers/index.html#Core.Bool"><code>Bool</code></a>, <a href="../../base/numbers/index.html#Core.Int8"><code>Int8</code></a>, and <a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a> are matters of behavior – the way functions are defined to act when given objects of these types as arguments. This is why a nominative type system is necessary: if structure determined type, which in turn dictates behavior, then it would be impossible to make <a href="../../base/numbers/index.html#Core.Bool"><code>Bool</code></a> behave any differently than <a href="../../base/numbers/index.html#Core.Int8"><code>Int8</code></a> or <a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型<a href="../../base/numbers/index.html#Core.Bool"><code>Bool</code></a>、<a href="../../base/numbers/index.html#Core.Int8"><code>Int8</code></a>、および<a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a>はすべて同一の表現を持っています：それらは8ビットのメモリチャンクです。しかし、Juliaの型システムは名義型であるため、同一の構造を持っていても相互に交換可能ではありません。これらの間の根本的な違いは、異なるスーパタイプを持つことです：<a href="../../base/numbers/index.html#Core.Bool"><code>Bool</code></a>の直接スーパタイプは<a href="../../base/numbers/index.html#Core.Integer"><code>Integer</code></a>、<a href="../../base/numbers/index.html#Core.Int8"><code>Int8</code></a>のそれは<a href="../../base/numbers/index.html#Core.Signed"><code>Signed</code></a>、および<a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a>のそれは<a href="../../base/numbers/index.html#Core.Unsigned"><code>Unsigned</code></a>です。<a href="../../base/numbers/index.html#Core.Bool"><code>Bool</code></a>、<a href="../../base/numbers/index.html#Core.Int8"><code>Int8</code></a>、および<a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a>の間の他のすべての違いは、これらの型のオブジェクトを引数として与えたときに関数がどのように動作するかという振る舞いの問題です。これが名義型システムが必要な理由です：構造が型を決定し、それが振る舞いを決定する場合、<a href="../../base/numbers/index.html#Core.Bool"><code>Bool</code></a>が<a href="../../base/numbers/index.html#Core.Int8"><code>Int8</code></a>や<a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a>とは異なる振る舞いをすることは不可能になります。</span></p><h2 id="Composite-Types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Composite-Types">Composite Types</a><a id="Composite-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Composite-Types">複合型</a><a id="Composite-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Types" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text"><a href="https://en.wikipedia.org/wiki/Composite_data_type">Composite types</a> are called records, structs, or objects in various languages. A composite type is a collection of named fields, an instance of which can be treated as a single value. In many languages, composite types are the only kind of user-definable type, and they are by far the most commonly used user-defined type in Julia as well.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://en.wikipedia.org/wiki/Composite_data_type">複合型</a>は、さまざまな言語でレコード、構造体、またはオブジェクトと呼ばれます。複合型は、名前付きフィールドのコレクションであり、そのインスタンスは単一の値として扱うことができます。多くの言語では、複合型はユーザー定義型の唯一の種類であり、Juliaでも最も一般的に使用されるユーザー定義型です。</span></p><p data-translated="true"><span class="original-text">In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an "object". In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of <em>all</em> of a function's arguments are considered when selecting a method, rather than just the first one (see <a href="../methods/index.html#Methods">Methods</a> for more information on methods and dispatch). Thus, it would be inappropriate for functions to "belong" to only their first argument. Organizing methods into function objects rather than having named bags of methods "inside" each object ends up being a highly beneficial aspect of the language design.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C++、Java、Python、Rubyなどの主流のオブジェクト指向言語では、複合型には名前付き関数が関連付けられており、その組み合わせは「オブジェクト」と呼ばれます。RubyやSmalltalkのような純粋なオブジェクト指向言語では、すべての値は複合型であろうとなかろうとオブジェクトです。C++やJavaなどの純粋でないオブジェクト指向言語では、整数や浮動小数点値などの一部の値はオブジェクトではなく、ユーザー定義の複合型のインスタンスは関連するメソッドを持つ真のオブジェクトです。Juliaでは、すべての値はオブジェクトですが、関数はそれらが操作するオブジェクトにバンドルされていません。これは、Juliaが関数のメソッドを選択する際に複数のディスパッチを選ぶために必要です。つまり、メソッドを選択する際には、関数のすべての引数の型が考慮され、最初の引数だけではありません（メソッドとディスパッチに関する詳細は<a href="../methods/index.html#Methods">メソッド</a>を参照してください）。したがって、関数が最初の引数だけに「属する」ことは不適切です。メソッドを関数オブジェクトに整理することは、各オブジェクトの「内部」に名前付きメソッドのバグを持つよりも、言語設計の非常に有益な側面となります。</span></p><p data-translated="true"><span class="original-text">Composite types are introduced with the <a href="../../base/base/index.html#struct"><code>struct</code></a> keyword followed by a block of field names, optionally annotated with types using the <code>::</code> operator:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複合型は、<a href="../../base/base/index.html#struct"><code>struct</code></a>キーワードで導入され、その後にフィールド名のブロックが続き、オプションで<code>::</code>演算子を使用して型が注釈されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct Foo
           bar
           baz::Int
           qux::Float64
       end</code></pre><p data-translated="true"><span class="original-text">Fields with no type annotation default to <code>Any</code>, and can accordingly hold any type of value.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型注釈のないフィールドはデフォルトで<code>Any</code>となり、したがって任意の型の値を保持できます。</span></p><p data-translated="true"><span class="original-text">New objects of type <code>Foo</code> are created by applying the <code>Foo</code> type object like a function to values for its fields:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型<code>Foo</code>の新しいオブジェクトは、そのフィールドの値に対して関数のように<code>Foo</code>型オブジェクトを適用することによって作成されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; foo = Foo("Hello, world.", 23, 1.5)
Foo("Hello, world.", 23, 1.5)

julia&gt; typeof(foo)
Foo</code></pre><p data-translated="true"><span class="original-text">When a type is applied like a function it is called a <em>constructor</em>. Two constructors are generated automatically (these are called <em>default constructors</em>). One accepts any arguments and calls <a href="../../base/base/index.html#Base.convert"><code>convert</code></a> to convert them to the types of the fields, and the other accepts arguments that match the field types exactly. The reason both of these are generated is that this makes it easier to add new definitions without inadvertently replacing a default constructor.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型が関数のように適用されると、それは<em>コンストラクタ</em>と呼ばれます。2つのコンストラクタが自動的に生成されます（これらは<em>デフォルトコンストラクタ</em>と呼ばれます）。1つは任意の引数を受け入れ、<a href="../../base/base/index.html#Base.convert"><code>convert</code></a>を呼び出してそれらをフィールドの型に変換し、もう1つはフィールド型と正確に一致する引数を受け入れます。これらの両方が生成される理由は、新しい定義を追加する際にデフォルトコンストラクタを誤って置き換えることなく、より簡単にするためです。</span></p><p data-translated="true"><span class="original-text">Since the <code>bar</code> field is unconstrained in type, any value will do. However, the value for <code>baz</code> must be convertible to <code>Int</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>bar</code>フィールドは型に制約がないため、任意の値を使用できます。ただし、<code>baz</code>の値は<code>Int</code>に変換可能でなければなりません:</span></p><pre><code class="language-julia-repl hljs">julia&gt; Foo((), 23.5, 1)
ERROR: InexactError: Int64(23.5)
Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">You may find a list of field names using the <a href="../../base/base/index.html#Base.fieldnames"><code>fieldnames</code></a> function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Base.fieldnames"><code>fieldnames</code></a>関数を使用してフィールド名のリストを見つけることができます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; fieldnames(Foo)
(:bar, :baz, :qux)</code></pre><p data-translated="true"><span class="original-text">You can access the field values of a composite object using the traditional <code>foo.bar</code> notation:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">従来の<code>foo.bar</code>表記を使用して、複合オブジェクトのフィールド値にアクセスできます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; foo.bar
"Hello, world."

julia&gt; foo.baz
23

julia&gt; foo.qux
1.5</code></pre><p data-translated="true"><span class="original-text">Composite objects declared with <code>struct</code> are <em>immutable</em>; they cannot be modified after construction. This may seem odd at first, but it has several advantages:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>struct</code>で宣言された複合オブジェクトは<em>不変</em>です; 構築後に変更することはできません。最初は奇妙に思えるかもしれませんが、いくつかの利点があります:</span></p><ul><li data-translated="true"><span class="original-text">It can be more efficient. Some structs can be packed efficiently into arrays, and in some cases the compiler is able to avoid allocating immutable objects entirely.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より効率的である可能性があります。一部の構造体は配列に効率的にパックでき、場合によってはコンパイラが不変オブジェクトの割り当てを完全に回避できることがあります。</span></li><li data-translated="true"><span class="original-text">It is not possible to violate the invariants provided by the type's constructors.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型のコンストラクタによって提供される不変条件を侵害することはできません。</span></li><li data-translated="true"><span class="original-text">Code using immutable objects can be easier to reason about.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">不変オブジェクトを使用するコードは、より論理的に考えやすい場合があります。</span></li></ul><p data-translated="true"><span class="original-text">An immutable object might contain mutable objects, such as arrays, as fields. Those contained objects will remain mutable; only the fields of the immutable object itself cannot be changed to point to different objects.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">不変オブジェクトは、配列などの可変オブジェクトをフィールドとして含むことがあります。それらの含まれるオブジェクトは可変のままであり、不変オブジェクト自体のフィールドだけが異なるオブジェクトを指すように変更することはできません。</span></p><p data-translated="true"><span class="original-text">Where required, mutable composite objects can be declared with the keyword <a href="../../base/base/index.html#mutable struct"><code>mutable struct</code></a>, to be discussed in the next section.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">必要に応じて、可変の複合オブジェクトは<a href="../../base/base/index.html#mutable struct"><code>mutable struct</code></a>キーワードで宣言できます。これは次のセクションで説明します。</span></p><p data-translated="true"><span class="original-text">If all the fields of an immutable structure are indistinguishable (<code>===</code>) then two immutable values containing those fields are also indistinguishable:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">不変構造体のすべてのフィールドが区別できない場合（<code>===</code>）、それらのフィールドを含む2つの不変値も区別できません:</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct X
           a::Int
           b::Float64
       end

julia&gt; X(1, 2) === X(1, 2)
true</code></pre><p data-translated="true"><span class="original-text">There is much more to say about how instances of composite types are created, but that discussion depends on both <a href="#Parametric-Types">Parametric Types</a> and on <a href="../methods/index.html#Methods">Methods</a>, and is sufficiently important to be addressed in its own section: <a href="../constructors/index.html#man-constructors">Constructors</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複合型のインスタンスがどのように作成されるかについては、さらに多くのことを言うことができますが、その議論は両方の<a href="#Parametric-Types">パラメトリック型</a>と<a href="../methods/index.html#Methods">メソッド</a>に依存しており、独自のセクションで扱うに値する重要な内容です：<a href="../constructors/index.html#man-constructors">コンストラクタ</a>。</span></p><p data-translated="true"><span class="original-text">For many user-defined types <code>X</code>, you may want to define a method <a href="../interfaces/index.html#man-interfaces-broadcasting"><code>Base.broadcastable(x::X) = Ref(x)</code></a> so that instances of that type act as 0-dimensional "scalars" for <a href="../arrays/index.html#Broadcasting">broadcasting</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">多くのユーザー定義型<code>X</code>に対して、<a href="../interfaces/index.html#man-interfaces-broadcasting"><code>Base.broadcastable(x::X) = Ref(x)</code></a>というメソッドを定義したい場合があります。これにより、その型のインスタンスは<a href="../arrays/index.html#Broadcasting">ブロードキャスティング</a>のための0次元の「スカラー」として機能します。</span></p><h2 id="Mutable-Composite-Types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Mutable-Composite-Types">Mutable Composite Types</a><a id="Mutable-Composite-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Mutable-Composite-Types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Mutable-Composite-Types">可変複合型</a><a id="Mutable-Composite-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Mutable-Composite-Types" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">If a composite type is declared with <code>mutable struct</code> instead of <code>struct</code>, then instances of it can be modified:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複合型が<code>struct</code>の代わりに<code>mutable struct</code>として宣言されると、そのインスタンスは変更可能になります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Bar
           baz
           qux::Float64
       end

julia&gt; bar = Bar("Hello", 1.5);

julia&gt; bar.qux = 2.0
2.0

julia&gt; bar.baz = 1//2
1//2</code></pre><p data-translated="true"><span class="original-text">An extra interface between the fields and the user can be provided through <a href="../interfaces/index.html#man-instance-properties">Instance Properties</a>. This grants more control on what can be accessed and modified using the <code>bar.baz</code> notation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">フィールドとユーザーの間に追加のインターフェースを<a href="../interfaces/index.html#man-instance-properties">インスタンスプロパティ</a>を通じて提供できます。これにより、<code>bar.baz</code>表記を使用してアクセスおよび変更できる内容に対するより多くの制御が可能になります。</span></p><p data-translated="true"><span class="original-text">In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses. A mutable object is like a little container that might hold different values over time, and so can only be reliably identified with its address. In contrast, an instance of an immutable type is associated with specific field values –- the field values alone tell you everything about the object. In deciding whether to make a type mutable, ask whether two instances with the same field values would be considered identical, or if they might need to change independently over time. If they would be considered identical, the type should probably be immutable.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">変更をサポートするために、そのようなオブジェクトは一般的にヒープに割り当てられ、安定したメモリアドレスを持ちます。可変オブジェクトは、時間の経過とともに異なる値を保持する可能性のある小さなコンテナのようなものであり、そのため、アドレスでのみ信頼性を持って識別できます。対照的に、不変型のインスタンスは特定のフィールド値に関連付けられています。フィールド値だけがオブジェクトに関するすべてを教えてくれます。型を可変にするかどうかを決定する際には、同じフィールド値を持つ2つのインスタンスが同一と見なされるか、時間の経過とともに独立して変更される必要があるかを尋ねてください。同一と見なされる場合、その型はおそらく不変であるべきです。</span></p><p data-translated="true"><span class="original-text">To recap, two essential properties define immutability in Julia:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">要約すると、Juliaにおける不変性を定義する2つの重要な特性があります：</span></p><ul><li>It is not permitted to modify the value of an immutable type.<ul><li data-translated="true"><span class="original-text">For bits types this means that the bit pattern of a value once set will never change and that value is the identity of a bits type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ビット型の場合、これは一度設定された値のビットパターンは決して変わらず、その値がビット型のアイデンティティであることを意味します。</span></li><li data-translated="true"><span class="original-text">For composite  types, this means that the identity of the values of its fields will never change. When the fields are bits types, that means their bits will never change, for fields whose values are mutable types like arrays, that means the fields will always refer to the same mutable value even though that mutable value's content may itself be modified.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複合型の場合、これはフィールドの値のアイデンティティが決して変わらないことを意味します。フィールドがビット型である場合、それはそのビットが決して変わらないことを意味し、配列のような可変型の値を持つフィールドの場合、それはフィールドが常に同じ可変値を参照し続けることを意味しますが、その可変値の内容自体は変更される可能性があります。</span></li></ul></li><li>An object with an immutable type may be copied freely by the compiler since its immutability makes it impossible to programmatically distinguish between the original object and a copy.<ul><li data-translated="true"><span class="original-text">In particular, this means that small enough immutable values like integers and floats are typically passed to functions in registers (or stack allocated).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特に、これは整数や浮動小数点数のような十分に小さな不変値が通常、レジスタ内で関数に渡される（またはスタックに割り当てられる）ことを意味します。</span></li><li data-translated="true"><span class="original-text">Mutable values, on the other hand are heap-allocated and passed to functions as pointers to heap-allocated values except in cases where the compiler is sure that there's no way to tell that this is not what is happening.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一方で、可変値はヒープに割り当てられ、関数にはヒープに割り当てられた値へのポインタとして渡されます。ただし、コンパイラがこれが発生していないことを確信している場合を除きます。</span></li></ul></li></ul><p data-translated="true"><span class="original-text">In cases where one or more fields of an otherwise mutable struct is known to be immutable, one can declare these fields as such using <code>const</code> as shown below. This enables some, but not all of the optimizations of immutable structs, and can be used to enforce invariants on the particular fields marked as <code>const</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">可変構造体の一部のフィールドが不変であることが知られている場合、これらのフィールドを<code>const</code>を使用して宣言することができます。これは不変構造体の最適化の一部を可能にし、<code>const</code>としてマークされた特定のフィールドに対して不変条件を強制するために使用できます。</span></p><div class="admonition is-compat" id="Julia-1.8-62f5fb6ca596e100"><header class="admonition-header">Julia 1.8<a class="admonition-anchor" href="#Julia-1.8-62f5fb6ca596e100" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text"><code>const</code> annotating fields of mutable structs requires at least Julia 1.8.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>const</code>を使用して可変構造体のフィールドを注釈するには、少なくともJulia 1.8が必要です。</span></p></div></div><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Baz
           a::Int
           const b::Float64
       end

julia&gt; baz = Baz(1, 1.5);

julia&gt; baz.a = 2
2

julia&gt; baz.b = 2.0
ERROR: setfield!: const field .b of type Baz cannot be changed
[...]</code></pre><h2 id="man-declared-types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-declared-types">Declared Types</a><a id="man-declared-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-declared-types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-declared-types">宣言された型</a><a id="man-declared-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-declared-types" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The three kinds of types (abstract, primitive, composite) discussed in the previous sections are actually all closely related. They share the same key properties:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">前のセクションで議論された三種類の型（抽象型、プリミティブ型、複合型）は、実際にはすべて密接に関連しています。これらは同じ重要な特性を共有しています：</span></p><ul><li data-translated="true"><span class="original-text">They are explicitly declared.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">明示的に宣言されています。</span></li><li data-translated="true"><span class="original-text">They have names.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">名前があります。</span></li><li data-translated="true"><span class="original-text">They have explicitly declared supertypes.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">明示的に宣言されたスーパタイプがあります。</span></li><li data-translated="true"><span class="original-text">They may have parameters.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パラメータを持つことがあります。</span></li></ul><p data-translated="true"><span class="original-text">Because of these shared properties, these types are internally represented as instances of the same concept, <code>DataType</code>, which is the type of any of these types:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの共有特性のため、これらの型は内部的に同じ概念のインスタンスとして表現されます。<code>DataType</code>は、これらの型のいずれかの型です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; typeof(Real)
DataType

julia&gt; typeof(Int)
DataType</code></pre><p data-translated="true"><span class="original-text">A <code>DataType</code> may be abstract or concrete. If it is concrete, it has a specified size, storage layout, and (optionally) field names. Thus a primitive type is a <code>DataType</code> with nonzero size, but no field names. A composite type is a <code>DataType</code> that has field names or is empty (zero size).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">データ型は抽象型または具体型のいずれかです。具体型の場合、指定されたサイズ、ストレージレイアウト、および（オプションで）フィールド名があります。したがって、プリミティブ型はサイズがゼロでないデータ型ですが、フィールド名はありません。複合型はフィールド名を持つか、空（サイズゼロ）であるデータ型です。</span></p><p data-translated="true"><span class="original-text">Every concrete value in the system is an instance of some <code>DataType</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">システム内のすべての具体的な値は、何らかのデータ型のインスタンスです。</span></p><h2 id="Type-Unions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Type-Unions">Type Unions</a><a id="Type-Unions-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Unions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Type-Unions">型のユニオン</a><a id="Type-Unions-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Unions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">A type union is a special abstract type which includes as objects all instances of any of its argument types, constructed using the special <a href="../../base/base/index.html#Core.Union"><code>Union</code></a> keyword:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型のユニオンは、引数型のいずれかのインスタンスをすべてオブジェクトとして含む特別な抽象型であり、特別な<a href="../../base/base/index.html#Core.Union"><code>Union</code></a>キーワードを使用して構築されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia&gt; 1 :: IntOrString
1

julia&gt; "Hello!" :: IntOrString
"Hello!"

julia&gt; 1.0 :: IntOrString
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got a value of type Float64</code></pre><p data-translated="true"><span class="original-text">The compilers for many languages have an internal union construct for reasoning about types; Julia simply exposes it to the programmer. The Julia compiler is able to generate efficient code in the presence of <code>Union</code> types with a small number of types <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup>, by generating specialized code in separate branches for each possible type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">多くの言語のコンパイラには、型について推論するための内部ユニオン構造があります。Juliaはそれをプログラマに単純に公開します。Juliaコンパイラは、少数の型を持つ<code>Union</code>型が存在する場合に効率的なコードを生成することができ、各可能な型のために別の分岐で特化したコードを生成します。</span></p><p data-translated="true"><span class="original-text">A particularly useful case of a <code>Union</code> type is <code>Union{T, Nothing}</code>, where <code>T</code> can be any type and <a href="../../base/base/index.html#Core.Nothing"><code>Nothing</code></a> is the singleton type whose only instance is the object <a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a>. This pattern is the Julia equivalent of <a href="https://en.wikipedia.org/wiki/Nullable_type"><code>Nullable</code>, <code>Option</code> or <code>Maybe</code></a> types in other languages. Declaring a function argument or a field as <code>Union{T, Nothing}</code> allows setting it either to a value of type <code>T</code>, or to <code>nothing</code> to indicate that there is no value. See <a href="../faq/index.html#faq-nothing">this FAQ entry</a> for more information.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Union</code>型の特に便利なケースは<code>Union{T, Nothing}</code>であり、ここで<code>T</code>は任意の型であり、<a href="../../base/base/index.html#Core.Nothing"><code>Nothing</code></a>は唯一のインスタンスがオブジェクト<a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a>であるシングルトン型です。このパターンは、他の言語における<a href="https://en.wikipedia.org/wiki/Nullable_type"><code>Nullable</code>、<code>Option</code>または<code>Maybe</code></a>型のJuliaの同等物です。関数引数またはフィールドを<code>Union{T, Nothing}</code>として宣言することで、型<code>T</code>の値に設定するか、値がないことを示すために<code>nothing</code>に設定することができます。詳細については<a href="../faq/index.html#faq-nothing">このFAQエントリ</a>を参照してください。</span></p><h2 id="Parametric-Types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Parametric-Types">Parametric Types</a><a id="Parametric-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Parametric-Types">パラメトリック型</a><a id="Parametric-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Types" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">An important and powerful feature of Julia's type system is that it is parametric: types can take parameters, so that type declarations actually introduce a whole family of new types – one for each possible combination of parameter values. There are many languages that support some version of <a href="https://en.wikipedia.org/wiki/Generic_programming">generic programming</a>, wherein data structures and algorithms to manipulate them may be specified without specifying the exact types involved. For example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#, F#, and Scala, just to name a few. Some of these languages support true parametric polymorphism (e.g. ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming (e.g. C++, Java). With so many different varieties of generic programming and parametric types in various languages, we won't even attempt to compare Julia's parametric types to other languages, but will instead focus on explaining Julia's system in its own right. We will note, however, that because Julia is a dynamically typed language and doesn't need to make all type decisions at compile time, many traditional difficulties encountered in static parametric type systems can be relatively easily handled.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの型システムの重要で強力な特徴は、それがパラメトリックであることです：型はパラメータを取ることができ、型宣言は実際に新しい型のファミリーを導入します - 各パラメータ値の可能な組み合わせごとに1つずつです。データ構造とそれを操作するアルゴリズムを、関与する正確な型を指定せずに指定できるようにする、いくつかのバージョンの<a href="https://en.wikipedia.org/wiki/Generic_programming">ジェネリックプログラミング</a>をサポートする言語が多数あります。たとえば、ML、Haskell、Ada、Eiffel、C++、Java、C#、F#、Scalaなど、いくつかの言語において何らかの形のジェネリックプログラミングが存在します。これらの言語のいくつかは真のパラメトリック多態性をサポートしています（例：ML、Haskell、Scala）、他の言語はアドホックでテンプレートベースのスタイルのジェネリックプログラミングをサポートしています（例：C++、Java）。さまざまな言語におけるさまざまな種類のジェネリックプログラミングとパラメトリック型があるため、Juliaのパラメトリック型を他の言語と比較することは試みませんが、代わりにJuliaのシステムを独自に説明することに焦点を当てます。ただし、Juliaは動的型付け言語であり、すべての型決定をコンパイル時に行う必要がないため、静的パラメトリック型システムで遭遇する多くの従来の困難は比較的簡単に処理できることに注意します。</span></p><p data-translated="true"><span class="original-text">All declared types (the <code>DataType</code> variety) can be parameterized, with the same syntax in each case. We will discuss them in the following order: first, parametric composite types, then parametric abstract types, and finally parametric primitive types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべての宣言された型（<code>DataType</code>のバリエーション）は、各ケースで同じ構文でパラメータ化できます。次の順序でそれらについて説明します：最初に、パラメトリック複合型、次にパラメトリック抽象型、最後にパラメトリックプリミティブ型です。</span></p><h3 id="man-parametric-composite-types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-parametric-composite-types">Parametric Composite Types</a><a id="man-parametric-composite-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-parametric-composite-types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-parametric-composite-types">パラメトリック複合型</a><a id="man-parametric-composite-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-parametric-composite-types" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Type parameters are introduced immediately after the type name, surrounded by curly braces:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型パラメータは、型名の直後に波括弧で囲まれて導入されます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct Point{T}
           x::T
           y::T
       end</code></pre><p data-translated="true"><span class="original-text">This declaration defines a new parametric type, <code>Point{T}</code>, holding two "coordinates" of type <code>T</code>. What, one may ask, is <code>T</code>? Well, that's precisely the point of parametric types: it can be any type at all (or a value of any bits type, actually, although here it's clearly used as a type). <code>Point{Float64}</code> is a concrete type equivalent to the type defined by replacing <code>T</code> in the definition of <code>Point</code> with <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>. Thus, this single declaration actually declares an unlimited number of types: <code>Point{Float64}</code>, <code>Point{AbstractString}</code>, <code>Point{Int64}</code>, etc. Each of these is now a usable concrete type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この宣言は、新しいパラメトリック型 <code>Point{T}</code> を定義し、型 <code>T</code> の2つの「座標」を保持します。では、<code>T</code> とは何でしょうか？それこそがパラメトリック型のポイントです: それは全く任意の型である可能性があります（実際には任意のビット型の値でも構いませんが、ここでは明らかに型として使用されています）。<code>Point{Float64}</code> は、<code>Point</code> の定義における <code>T</code> を <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> に置き換えた型に相当する具体的な型です。したがって、この単一の宣言は実際には無限の数の型を宣言します: <code>Point{Float64}</code>、<code>Point{AbstractString}</code>、<code>Point{Int64}</code> などです。これらの各型は、現在使用可能な具体的な型です:</span></p><pre><code class="language-julia-repl hljs">julia&gt; Point{Float64}
Point{Float64}

julia&gt; Point{AbstractString}
Point{AbstractString}</code></pre><p data-translated="true"><span class="original-text">The type <code>Point{Float64}</code> is a point whose coordinates are 64-bit floating-point values, while the type <code>Point{AbstractString}</code> is a "point" whose "coordinates" are string objects (see <a href="../../devdocs/ast/index.html#Strings">Strings</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型 <code>Point{Float64}</code> は、座標が64ビット浮動小数点値である点であり、型 <code>Point{AbstractString}</code> は、「座標」が文字列オブジェクトである「点」です（<a href="../../devdocs/ast/index.html#Strings">Strings</a> を参照）。</span></p><p data-translated="true"><span class="original-text"><code>Point</code> itself is also a valid type object, containing all instances <code>Point{Float64}</code>, <code>Point{AbstractString}</code>, etc. as subtypes:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Point</code> 自体も有効な型オブジェクトであり、すべてのインスタンス <code>Point{Float64}</code>、<code>Point{AbstractString}</code> などをサブタイプとして含んでいます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; Point{Float64} &lt;: Point
true

julia&gt; Point{AbstractString} &lt;: Point
true</code></pre><p data-translated="true"><span class="original-text">Other types, of course, are not subtypes of it:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もちろん、他の型はそれのサブタイプではありません:</span></p><pre><code class="language-julia-repl hljs">julia&gt; Float64 &lt;: Point
false

julia&gt; AbstractString &lt;: Point
false</code></pre><p data-translated="true"><span class="original-text">Concrete <code>Point</code> types with different values of <code>T</code> are never subtypes of each other:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">異なる <code>T</code> の値を持つ具体的な <code>Point</code> 型は、互いにサブタイプにはなりません:</span></p><pre><code class="language-julia-repl hljs">julia&gt; Point{Float64} &lt;: Point{Int64}
false

julia&gt; Point{Float64} &lt;: Point{Real}
false</code></pre><div class="admonition is-warning" id="Warning-1b7f080e812a3d9c"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-1b7f080e812a3d9c" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">This last point is <em>very</em> important: even though <code>Float64 &lt;: Real</code> we <strong>DO NOT</strong> have <code>Point{Float64} &lt;: Point{Real}</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この最後のポイントは <em>非常に</em> 重要です: <code>Float64 &lt;: Real</code> であるにもかかわらず、<strong>私たちは</strong> <code>Point{Float64} &lt;: Point{Real}</code> を持っていません。</span></p></div></div><p data-translated="true"><span class="original-text">In other words, in the parlance of type theory, Julia's type parameters are <em>invariant</em>, rather than being <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29">covariant (or even contravariant)</a>. This is for practical reasons: while any instance of <code>Point{Float64}</code> may conceptually be like an instance of <code>Point{Real}</code> as well, the two types have different representations in memory:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">言い換えれば、型理論の用語で言えば、Juliaの型パラメータは <em>不変</em> であり、<a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29">共変（または逆変）</a> ではありません。これは実用的な理由によるものです: <code>Point{Float64}</code> の任意のインスタンスは、概念的には <code>Point{Real}</code> のインスタンスのようであるかもしれませんが、2つの型はメモリ内で異なる表現を持っています:</span></p><ul><li data-translated="true"><span class="original-text">An instance of <code>Point{Float64}</code> can be represented compactly and efficiently as an immediate pair of 64-bit values;</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Point{Float64}</code> のインスタンスは、64ビット値の即時ペアとしてコンパクトかつ効率的に表現できます;</span></li><li data-translated="true"><span class="original-text">An instance of <code>Point{Real}</code> must be able to hold any pair of instances of <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a>. Since objects that are instances of <code>Real</code> can be of arbitrary size and structure, in practice an instance of <code>Point{Real}</code> must be represented as a pair of pointers to individually allocated <code>Real</code> objects.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Point{Real}</code> のインスタンスは、<a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> の任意のインスタンスのペアを保持できる必要があります。<code>Real</code> のインスタンスは任意のサイズと構造を持つ可能性があるため、実際には <code>Point{Real}</code> のインスタンスは、個別に割り当てられた <code>Real</code> オブジェクトへのポインタのペアとして表現されなければなりません。</span></li></ul><p data-translated="true"><span class="original-text">The efficiency gained by being able to store <code>Point{Float64}</code> objects with immediate values is magnified enormously in the case of arrays: an <code>Array{Float64}</code> can be stored as a contiguous memory block of 64-bit floating-point values, whereas an <code>Array{Real}</code> must be an array of pointers to individually allocated <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> objects – which may well be <a href="https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing#Boxing">boxed</a> 64-bit floating-point values, but also might be arbitrarily large, complex objects, which are declared to be implementations of the <code>Real</code> abstract type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">即値を持つ <code>Point{Float64}</code> オブジェクトを格納できることによって得られる効率は、配列の場合において非常に大きくなります：<code>Array{Float64}</code> は 64 ビット浮動小数点値の連続メモリブロックとして格納できるのに対し、<code>Array{Real}</code> は個別に割り当てられた <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> オブジェクトへのポインタの配列でなければなりません – これは <a href="https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing#Boxing">ボックス化された</a> 64 ビット浮動小数点値である可能性もありますが、任意に大きく、複雑なオブジェクトである可能性もあり、これらは <code>Real</code> 抽象型の実装として宣言されています。</span></p><p data-translated="true"><span class="original-text">Since <code>Point{Float64}</code> is not a subtype of <code>Point{Real}</code>, the following method can't be applied to arguments of type <code>Point{Float64}</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Point{Float64}</code> は <code>Point{Real}</code> のサブタイプではないため、次のメソッドは <code>Point{Float64}</code> 型の引数には適用できません：</span></p><pre><code class="language-julia hljs">function norm(p::Point{Real})
    sqrt(p.x^2 + p.y^2)
end</code></pre><p data-translated="true"><span class="original-text">A correct way to define a method that accepts all arguments of type <code>Point{T}</code> where <code>T</code> is a subtype of <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> is:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>T</code> が <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> のサブタイプである <code>Point{T}</code> 型のすべての引数を受け入れるメソッドを定義する正しい方法は次の通りです：</span></p><pre><code class="language-julia hljs">function norm(p::Point{&lt;:Real})
    sqrt(p.x^2 + p.y^2)
end</code></pre><p data-translated="true"><span class="original-text">(Equivalently, one could define <code>function norm(p::Point{T} where T&lt;:Real)</code> or <code>function norm(p::Point{T}) where T&lt;:Real</code>; see <a href="#UnionAll-Types">UnionAll Types</a>.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(同等に、<code>function norm(p::Point{T} where T&lt;:Real)</code> または <code>function norm(p::Point{T}) where T&lt;:Real</code> を定義することもできます；詳細は <a href="#UnionAll-Types">UnionAll Types</a> を参照してください。)</span></p><p data-translated="true"><span class="original-text">More examples will be discussed later in <a href="../methods/index.html#Methods">Methods</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さらなる例については、後で <a href="../methods/index.html#Methods">Methods</a> で議論します。</span></p><p data-translated="true"><span class="original-text">How does one construct a <code>Point</code> object? It is possible to define custom constructors for composite types, which will be discussed in detail in <a href="../constructors/index.html#man-constructors">Constructors</a>, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Point</code> オブジェクトはどのように構築しますか？複合型のカスタムコンストラクタを定義することが可能であり、これは <a href="../constructors/index.html#man-constructors">Constructors</a> で詳細に説明されますが、特別なコンストラクタ宣言がない場合、新しい複合オブジェクトを作成するための 2 つのデフォルトの方法があります。一つは型パラメータが明示的に与えられる方法で、もう一つはオブジェクトコンストラクタへの引数によって暗示される方法です。</span></p><p data-translated="true"><span class="original-text">Since the type <code>Point{Float64}</code> is a concrete type equivalent to <code>Point</code> declared with <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> in place of <code>T</code>, it can be applied as a constructor accordingly:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Point{Float64}</code> 型は <code>T</code> の代わりに <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> で宣言された <code>Point</code> と同等の具体的な型であるため、それに応じてコンストラクタとして適用できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; p = Point{Float64}(1.0, 2.0)
Point{Float64}(1.0, 2.0)

julia&gt; typeof(p)
Point{Float64}</code></pre><p data-translated="true"><span class="original-text">For the default constructor, exactly one argument must be supplied for each field:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトコンストラクタの場合、各フィールドに対して正確に 1 つの引数を提供する必要があります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Point{Float64}(1.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64)
The type `Point{Float64}` exists, but no method is defined for this combination of argument types when trying to construct it.
[...]

julia&gt; Point{Float64}(1.0, 2.0, 3.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)
The type `Point{Float64}` exists, but no method is defined for this combination of argument types when trying to construct it.
[...]</code></pre><p data-translated="true"><span class="original-text">Only one default constructor is generated for parametric types, since overriding it is not possible. This constructor accepts any arguments and converts them to the field types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パラメトリック型に対しては、デフォルトコンストラクタが 1 つだけ生成されます。これはオーバーライドすることができないためです。このコンストラクタは任意の引数を受け入れ、それらをフィールド型に変換します。</span></p><p data-translated="true"><span class="original-text">In many cases, it is redundant to provide the type of <code>Point</code> object one wants to construct, since the types of arguments to the constructor call already implicitly provide type information. For that reason, you can also apply <code>Point</code> itself as a constructor, provided that the implied value of the parameter type <code>T</code> is unambiguous:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">多くの場合、構築したい <code>Point</code> オブジェクトの型を提供することは冗長です。なぜなら、コンストラクタ呼び出しの引数の型がすでに暗黙的に型情報を提供しているからです。そのため、引数の型 <code>T</code> の暗示された値があいまいでない限り、<code>Point</code> 自体をコンストラクタとして適用することもできます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; p1 = Point(1.0,2.0)
Point{Float64}(1.0, 2.0)

julia&gt; typeof(p1)
Point{Float64}

julia&gt; p2 = Point(1,2)
Point{Int64}(1, 2)

julia&gt; typeof(p2)
Point{Int64}</code></pre><p data-translated="true"><span class="original-text">In the case of <code>Point</code>, the type of <code>T</code> is unambiguously implied if and only if the two arguments to <code>Point</code> have the same type. When this isn't the case, the constructor will fail with a <a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Point</code>の場合、<code>T</code>の型は、<code>Point</code>への2つの引数が同じ型である場合に限り、明確に暗示されます。これが当てはまらない場合、コンストラクタは<a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a>で失敗します:</span></p><pre><code class="language-julia-repl hljs">julia&gt; Point(1,2.5)
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
The type `Point` exists, but no method is defined for this combination of argument types when trying to construct it.

Closest candidates are:
  Point(::T, !Matched::T) where T
   @ Main none:2

Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">Constructor methods to appropriately handle such mixed cases can be defined, but that will not be discussed until later on in <a href="../constructors/index.html#man-constructors">Constructors</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そのような混合ケースを適切に処理するコンストラクタメソッドを定義することは可能ですが、それについては<a href="../constructors/index.html#man-constructors">Constructors</a>で後ほど説明します。</span></p><h3 id="Parametric-Abstract-Types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Parametric-Abstract-Types">Parametric Abstract Types</a><a id="Parametric-Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Abstract-Types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Parametric-Abstract-Types">パラメトリック抽象型</a><a id="Parametric-Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Abstract-Types" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Parametric abstract type declarations declare a collection of abstract types, in much the same way:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パラメトリック抽象型の宣言は、ほぼ同じ方法で抽象型のコレクションを宣言します:</span></p><pre><code class="language-julia-repl hljs">julia&gt; abstract type Pointy{T} end</code></pre><p data-translated="true"><span class="original-text">With this declaration, <code>Pointy{T}</code> is a distinct abstract type for each type or integer value of <code>T</code>. As with parametric composite types, each such instance is a subtype of <code>Pointy</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この宣言により、<code>Pointy{T}</code>は<code>T</code>の各型または整数値に対して異なる抽象型になります。パラメトリック合成型と同様に、各インスタンスは<code>Pointy</code>のサブタイプです:</span></p><pre><code class="language-julia-repl hljs">julia&gt; Pointy{Int64} &lt;: Pointy
true

julia&gt; Pointy{1} &lt;: Pointy
true</code></pre><p data-translated="true"><span class="original-text">Parametric abstract types are invariant, much as parametric composite types are:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パラメトリック抽象型は不変であり、パラメトリック合成型と同様です:</span></p><pre><code class="language-julia-repl hljs">julia&gt; Pointy{Float64} &lt;: Pointy{Real}
false

julia&gt; Pointy{Real} &lt;: Pointy{Float64}
false</code></pre><p data-translated="true"><span class="original-text">The notation <code>Pointy{&lt;:Real}</code> can be used to express the Julia analogue of a <em>covariant</em> type, while <code>Pointy{&gt;:Int}</code> the analogue of a <em>contravariant</em> type, but technically these represent <em>sets</em> of types (see <a href="#UnionAll-Types">UnionAll Types</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Pointy{&lt;:Real}</code>という表記は、Juliaにおける<em>共変</em>型のアナロジーを表現するために使用でき、<code>Pointy{&gt;:Int}</code>は<em>反変</em>型のアナロジーを表しますが、技術的にはこれらは型の<em>集合</em>を表します（<a href="#UnionAll-Types">UnionAll Types</a>を参照）。</span></p><pre><code class="language-julia-repl hljs">julia&gt; Pointy{Float64} &lt;: Pointy{&lt;:Real}
true

julia&gt; Pointy{Real} &lt;: Pointy{&gt;:Int}
true</code></pre><p data-translated="true"><span class="original-text">Much as plain old abstract types serve to create a useful hierarchy of types over concrete types, parametric abstract types serve the same purpose with respect to parametric composite types. We could, for example, have declared <code>Point{T}</code> to be a subtype of <code>Pointy{T}</code> as follows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">従来の抽象型が具体的な型に対して有用な型の階層を作成するのと同様に、パラメトリック抽象型もパラメトリック合成型に関して同じ目的を果たします。例えば、<code>Point{T}</code>を<code>Pointy{T}</code>のサブタイプとして次のように宣言することができます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct Point{T} &lt;: Pointy{T}
           x::T
           y::T
       end</code></pre><p data-translated="true"><span class="original-text">Given such a declaration, for each choice of <code>T</code>, we have <code>Point{T}</code> as a subtype of <code>Pointy{T}</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このような宣言があると、<code>T</code>の各選択に対して、<code>Point{T}</code>は<code>Pointy{T}</code>のサブタイプになります:</span></p><pre><code class="language-julia-repl hljs">julia&gt; Point{Float64} &lt;: Pointy{Float64}
true

julia&gt; Point{Real} &lt;: Pointy{Real}
true

julia&gt; Point{AbstractString} &lt;: Pointy{AbstractString}
true</code></pre><p data-translated="true"><span class="original-text">This relationship is also invariant:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この関係も不変です:</span></p><pre><code class="language-julia-repl hljs">julia&gt; Point{Float64} &lt;: Pointy{Real}
false

julia&gt; Point{Float64} &lt;: Pointy{&lt;:Real}
true</code></pre><p data-translated="true"><span class="original-text">What purpose do parametric abstract types like <code>Pointy</code> serve? Consider if we create a point-like implementation that only requires a single coordinate because the point is on the diagonal line <em>x = y</em>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Pointy</code>のようなパラメトリック抽象型はどのような目的を持つのでしょうか？点が対角線<em>x = y</em>上にあるため、単一の座標のみを必要とする点のような実装を作成することを考えてみてください：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct DiagPoint{T} &lt;: Pointy{T}
           x::T
       end</code></pre><p data-translated="true"><span class="original-text">Now both <code>Point{Float64}</code> and <code>DiagPoint{Float64}</code> are implementations of the <code>Pointy{Float64}</code> abstraction, and similarly for every other possible choice of type <code>T</code>. This allows programming to a common interface shared by all <code>Pointy</code> objects, implemented for both <code>Point</code> and <code>DiagPoint</code>. This cannot be fully demonstrated, however, until we have introduced methods and dispatch in the next section, <a href="../methods/index.html#Methods">Methods</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">今、<code>Point{Float64}</code>と<code>DiagPoint{Float64}</code>は<code>Pointy{Float64}</code>抽象の実装であり、他のすべての可能な型<code>T</code>の選択に対しても同様です。これにより、<code>Point</code>と<code>DiagPoint</code>の両方に実装されたすべての<code>Pointy</code>オブジェクトが共有する共通のインターフェースにプログラミングすることができます。ただし、次のセクションでメソッドとディスパッチを導入するまで、これを完全に示すことはできません。<a href="../methods/index.html#Methods">メソッド</a>。</span></p><p data-translated="true"><span class="original-text">There are situations where it may not make sense for type parameters to range freely over all possible types. In such situations, one can constrain the range of <code>T</code> like so:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型パラメータがすべての可能な型に自由に範囲を持つことが意味をなさない状況があります。そのような状況では、<code>T</code>の範囲を次のように制約することができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; abstract type Pointy{T&lt;:Real} end</code></pre><p data-translated="true"><span class="original-text">With such a declaration, it is acceptable to use any type that is a subtype of <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> in place of <code>T</code>, but not types that are not subtypes of <code>Real</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このような宣言を行うことで、<code>T</code>の代わりに<a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a>のサブタイプである任意の型を使用することが許可されますが、<code>Real</code>のサブタイプでない型は使用できません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Pointy{Float64}
Pointy{Float64}

julia&gt; Pointy{Real}
Pointy{Real}

julia&gt; Pointy{AbstractString}
ERROR: TypeError: in Pointy, in T, expected T&lt;:Real, got Type{AbstractString}

julia&gt; Pointy{1}
ERROR: TypeError: in Pointy, in T, expected T&lt;:Real, got a value of type Int64</code></pre><p data-translated="true"><span class="original-text">Type parameters for parametric composite types can be restricted in the same manner:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パラメトリックコンポジット型の型パラメータも同様に制限できます：</span></p><pre><code class="language-julia hljs">struct Point{T&lt;:Real} &lt;: Pointy{T}
    x::T
    y::T
end</code></pre><p data-translated="true"><span class="original-text">To give a real-world example of how all this parametric type machinery can be useful, here is the actual definition of Julia's <a href="../../base/numbers/index.html#Base.Rational"><code>Rational</code></a> immutable type (except that we omit the constructor here for simplicity), representing an exact ratio of integers:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このすべてのパラメトリック型の仕組みがどのように役立つかの実世界の例として、整数の正確な比率を表すJuliaの<a href="../../base/numbers/index.html#Base.Rational"><code>Rational</code></a>不変型の実際の定義を示します（簡潔さのためにコンストラクタは省略します）：</span></p><pre><code class="language-julia hljs">struct Rational{T&lt;:Integer} &lt;: Real
    num::T
    den::T
end</code></pre><p data-translated="true"><span class="original-text">It only makes sense to take ratios of integer values, so the parameter type <code>T</code> is restricted to being a subtype of <a href="../../base/numbers/index.html#Core.Integer"><code>Integer</code></a>, and a ratio of integers represents a value on the real number line, so any <a href="../../base/numbers/index.html#Base.Rational"><code>Rational</code></a> is an instance of the <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> abstraction.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">整数値の比率を取ることは意味があるため、パラメータ型<code>T</code>は<a href="../../base/numbers/index.html#Core.Integer"><code>Integer</code></a>のサブタイプであることに制限され、整数の比率は実数直線上の値を表すため、任意の<a href="../../base/numbers/index.html#Base.Rational"><code>Rational</code></a>は<a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a>抽象のインスタンスです。</span></p><h3 id="Tuple-Types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Tuple-Types">Tuple Types</a><a id="Tuple-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Tuple-Types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Tuple-Types">タプル型</a><a id="Tuple-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Tuple-Types" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Tuples are an abstraction of the arguments of a function – without the function itself. The salient aspects of a function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. For example, a 2-element tuple type resembles the following immutable type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">タプルは関数の引数の抽象であり、関数自体は含まれていません。関数の引数の重要な側面は、その順序と型です。したがって、タプル型は各パラメータが1つのフィールドの型であるパラメータ化された不変型に似ています。たとえば、2要素のタプル型は次の不変型に似ています：</span></p><pre><code class="language-julia hljs">struct Tuple2{A,B}
    a::A
    b::B
end</code></pre><p data-translated="true"><span class="original-text">However, there are three key differences:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、3つの重要な違いがあります：</span></p><ul><li data-translated="true"><span class="original-text">Tuple types may have any number of parameters.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">タプル型は任意の数のパラメータを持つことができます。</span></li><li data-translated="true"><span class="original-text">Tuple types are <em>covariant</em> in their parameters: <code>Tuple{Int}</code> is a subtype of <code>Tuple{Any}</code>. Therefore <code>Tuple{Any}</code> is considered an abstract type, and tuple types are only concrete if their parameters are.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">タプル型はそのパラメータに対して<em>共変</em>です：<code>Tuple{Int}</code>は<code>Tuple{Any}</code>のサブタイプです。したがって、<code>Tuple{Any}</code>は抽象型と見なされ、タプル型はそのパラメータが具体的である場合にのみ具体的です。</span></li><li data-translated="true"><span class="original-text">Tuples do not have field names; fields are only accessed by index.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">タプルにはフィールド名がなく、フィールドはインデックスによってのみアクセスされます。</span></li></ul><p data-translated="true"><span class="original-text">Tuple values are written with parentheses and commas. When a tuple is constructed, an appropriate tuple type is generated on demand:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">タプル値は括弧とカンマで書かれます。タプルが構築されると、適切なタプル型が必要に応じて生成されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; typeof((1,"foo",2.5))
Tuple{Int64, String, Float64}</code></pre><p data-translated="true"><span class="original-text">Note the implications of covariance:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">共変の影響に注意してください：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,Any}
true

julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,Real}
false

julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,}
false</code></pre><p data-translated="true"><span class="original-text">Intuitively, this corresponds to the type of a function's arguments being a subtype of the function's signature (when the signature matches).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">直感的には、これは関数の引数の型が関数のシグネチャのサブタイプであることに対応します（シグネチャが一致する場合）。</span></p><h3 id="Vararg-Tuple-Types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Vararg-Tuple-Types">Vararg Tuple Types</a><a id="Vararg-Tuple-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Vararg-Tuple-Types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Vararg-Tuple-Types">可変引数タプル型</a><a id="Vararg-Tuple-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Vararg-Tuple-Types" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The last parameter of a tuple type can be the special value <a href="../../base/base/index.html#Core.Vararg"><code>Vararg</code></a>, which denotes any number of trailing elements:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">タプル型の最後のパラメータは特別な値<a href="../../base/base/index.html#Core.Vararg"><code>Vararg</code></a>であり、任意の数の末尾要素を示します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; mytupletype = Tuple{AbstractString,Vararg{Int}}
Tuple{AbstractString, Vararg{Int64}}

julia&gt; isa(("1",), mytupletype)
true

julia&gt; isa(("1",1), mytupletype)
true

julia&gt; isa(("1",1,2), mytupletype)
true

julia&gt; isa(("1",1,2,3.0), mytupletype)
false</code></pre><p data-translated="true"><span class="original-text">Moreover <code>Vararg{T}</code> corresponds to zero or more elements of type <code>T</code>. Vararg tuple types are used to represent the arguments accepted by varargs methods (see <a href="../functions/index.html#Varargs-Functions">Varargs Functions</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さらに、<code>Vararg{T}</code>は型<code>T</code>のゼロ個以上の要素に対応します。可変引数タプル型は、可変引数メソッドが受け入れる引数を表すために使用されます（<a href="../functions/index.html#Varargs-Functions">可変引数関数</a>を参照）。</span></p><p data-translated="true"><span class="original-text">The special value <code>Vararg{T,N}</code> (when used as the last parameter of a tuple type) corresponds to exactly <code>N</code> elements of type <code>T</code>.  <code>NTuple{N,T}</code> is a convenient alias for <code>Tuple{Vararg{T,N}}</code>, i.e. a tuple type containing exactly <code>N</code> elements of type <code>T</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特別な値<code>Vararg{T,N}</code>（タプル型の最後のパラメータとして使用される場合）は、正確に<code>N</code>個の型<code>T</code>の要素に対応します。<code>NTuple{N,T}</code>は<code>Tuple{Vararg{T,N}}</code>の便利なエイリアスであり、すなわち型<code>T</code>の要素が正確に<code>N</code>個含まれるタプル型です。</span></p><h3 id="Named-Tuple-Types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Named-Tuple-Types">Named Tuple Types</a><a id="Named-Tuple-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Named-Tuple-Types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Named-Tuple-Types">名前付きタプル型</a><a id="Named-Tuple-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Named-Tuple-Types" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Named tuples are instances of the <a href="../../base/base/index.html#Core.NamedTuple"><code>NamedTuple</code></a> type, which has two parameters: a tuple of symbols giving the field names, and a tuple type giving the field types. For convenience, <code>NamedTuple</code> types are printed using the <a href="../../base/base/index.html#Base.@NamedTuple"><code>@NamedTuple</code></a> macro which provides a convenient <code>struct</code>-like syntax for declaring these types via <code>key::Type</code> declarations, where an omitted <code>::Type</code> corresponds to <code>::Any</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">名前付きタプルは、フィールド名を与えるシンボルのタプルと、フィールド型を与えるタプル型の2つのパラメータを持つ<a href="../../base/base/index.html#Core.NamedTuple"><code>NamedTuple</code></a>型のインスタンスです。便利さのために、<code>NamedTuple</code>型は、<a href="../../base/base/index.html#Base.@NamedTuple"><code>@NamedTuple</code></a>マクロを使用して印刷され、<code>key::Type</code>宣言を介してこれらの型を宣言するための便利な<code>struct</code>のような構文を提供します。省略された<code>::Type</code>は<code>::Any</code>に対応します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; typeof((a=1,b="hello")) # prints in macro form
@NamedTuple{a::Int64, b::String}

julia&gt; NamedTuple{(:a, :b), Tuple{Int64, String}} # long form of the type
@NamedTuple{a::Int64, b::String}</code></pre><p data-translated="true"><span class="original-text">The <code>begin ... end</code> form of the <code>@NamedTuple</code> macro allows the declarations to be split across multiple lines (similar to a struct declaration), but is otherwise equivalent:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>begin ... end</code>形式の<code>@NamedTuple</code>マクロは、宣言を複数行に分割することを許可します（構造体宣言に似ています）が、それ以外は同等です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @NamedTuple begin
           a::Int
           b::String
       end
@NamedTuple{a::Int64, b::String}</code></pre><p data-translated="true"><span class="original-text">A <code>NamedTuple</code> type can be used as a constructor, accepting a single tuple argument. The constructed <code>NamedTuple</code> type can be either a concrete type, with both parameters specified, or a type that specifies only field names:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>NamedTuple</code>型は、単一のタプル引数を受け取るコンストラクタとして使用できます。構築された<code>NamedTuple</code>型は、両方のパラメータが指定された具体的な型であるか、フィールド名のみを指定する型である可能性があります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @NamedTuple{a::Float32,b::String}((1, ""))
(a = 1.0f0, b = "")

julia&gt; NamedTuple{(:a, :b)}((1, ""))
(a = 1, b = "")</code></pre><p data-translated="true"><span class="original-text">If field types are specified, the arguments are converted. Otherwise the types of the arguments are used directly.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">フィールド型が指定されている場合、引数は変換されます。そうでない場合、引数の型が直接使用されます。</span></p><h3 id="Parametric-Primitive-Types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Parametric-Primitive-Types">Parametric Primitive Types</a><a id="Parametric-Primitive-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Primitive-Types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Parametric-Primitive-Types">パラメトリックプリミティブ型</a><a id="Parametric-Primitive-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Primitive-Types" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Primitive types can also be declared parametrically. For example, pointers are represented as primitive types which would be declared in Julia like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プリミティブ型は、パラメトリックに宣言することもできます。たとえば、ポインタは、次のようにJuliaで宣言されるプリミティブ型として表されます：</span></p><pre><code class="language-julia hljs"># 32-bit system:
primitive type Ptr{T} 32 end

# 64-bit system:
primitive type Ptr{T} 64 end</code></pre><p data-translated="true"><span class="original-text">The slightly odd feature of these declarations as compared to typical parametric composite types, is that the type parameter <code>T</code> is not used in the definition of the type itself – it is just an abstract tag, essentially defining an entire family of types with identical structure, differentiated only by their type parameter. Thus, <code>Ptr{Float64}</code> and <code>Ptr{Int64}</code> are distinct types, even though they have identical representations. And of course, all specific pointer types are subtypes of the umbrella <a href="../../base/c/index.html#Core.Ptr"><code>Ptr</code></a> type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの宣言の少し奇妙な特徴は、典型的なパラメトリック合成型と比較して、型パラメータ<code>T</code>が型自体の定義に使用されないことです。これは単なる抽象的なタグであり、基本的に同一の構造を持つ型のファミリー全体を定義し、型パラメータによってのみ区別されます。したがって、<code>Ptr{Float64}</code>と<code>Ptr{Int64}</code>は、同一の表現を持っていても異なる型です。そしてもちろん、すべての特定のポインタ型は、傘型<a href="../../base/c/index.html#Core.Ptr"><code>Ptr</code></a>型のサブタイプです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Ptr{Float64} &lt;: Ptr
true

julia&gt; Ptr{Int64} &lt;: Ptr
true</code></pre><h2 id="UnionAll-Types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#UnionAll-Types">UnionAll Types</a><a id="UnionAll-Types-1"></a><a class="docs-heading-anchor-permalink" href="#UnionAll-Types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#UnionAll-Types">UnionAll型</a><a id="UnionAll-Types-1"></a><a class="docs-heading-anchor-permalink" href="#UnionAll-Types" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">We have said that a parametric type like <code>Ptr</code> acts as a supertype of all its instances (<code>Ptr{Int64}</code> etc.). How does this work? <code>Ptr</code> itself cannot be a normal data type, since without knowing the type of the referenced data the type clearly cannot be used for memory operations. The answer is that <code>Ptr</code> (or other parametric types like <code>Array</code>) is a different kind of type called a <a href="../../base/base/index.html#Core.UnionAll"><code>UnionAll</code></a> type. Such a type expresses the <em>iterated union</em> of types for all values of some parameter.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">私たちは、<code>Ptr</code>のようなパラメトリック型がそのすべてのインスタンス（<code>Ptr{Int64}</code>など）のスーパタイプとして機能することを述べました。これはどのように機能するのでしょうか？<code>Ptr</code>自体は通常のデータ型にはなれません。参照されるデータの型を知らなければ、その型は明らかにメモリ操作に使用できないからです。答えは、<code>Ptr</code>（または<code>Array</code>のような他のパラメトリック型）は、<a href="../../base/base/index.html#Core.UnionAll"><code>UnionAll</code></a>型と呼ばれる異なる種類の型であるということです。このような型は、あるパラメータのすべての値に対する型の<em>反復和</em>を表現します。</span></p><p data-translated="true"><span class="original-text"><code>UnionAll</code> types are usually written using the keyword <code>where</code>. For example <code>Ptr</code> could be more accurately written as <code>Ptr{T} where T</code>, meaning all values whose type is <code>Ptr{T}</code> for some value of <code>T</code>. In this context, the parameter <code>T</code> is also often called a "type variable" since it is like a variable that ranges over types. Each <code>where</code> introduces a single type variable, so these expressions are nested for types with multiple parameters, for example <code>Array{T,N} where N where T</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>UnionAll</code> 型は通常、キーワード <code>where</code> を使用して記述されます。例えば、<code>Ptr</code> はより正確には <code>Ptr{T} where T</code> と書くことができ、これはある値の <code>T</code> に対して型が <code>Ptr{T}</code> であるすべての値を意味します。この文脈では、パラメータ <code>T</code> は「型変数」とも呼ばれ、型の範囲を持つ変数のようなものです。各 <code>where</code> は単一の型変数を導入するため、これらの式は複数のパラメータを持つ型に対してネストされます。例えば、<code>Array{T,N} where N where T</code> のようになります。</span></p><p data-translated="true"><span class="original-text">The type application syntax <code>A{B,C}</code> requires <code>A</code> to be a <code>UnionAll</code> type, and first substitutes <code>B</code> for the outermost type variable in <code>A</code>. The result is expected to be another <code>UnionAll</code> type, into which <code>C</code> is then substituted. So <code>A{B,C}</code> is equivalent to <code>A{B}{C}</code>. This explains why it is possible to partially instantiate a type, as in <code>Array{Float64}</code>: the first parameter value has been fixed, but the second still ranges over all possible values. Using explicit <code>where</code> syntax, any subset of parameters can be fixed. For example, the type of all 1-dimensional arrays can be written as <code>Array{T,1} where T</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型適用構文 <code>A{B,C}</code> は <code>A</code> が <code>UnionAll</code> 型であることを要求し、最初に <code>A</code> の最外部の型変数に <code>B</code> を代入します。その結果は別の <code>UnionAll</code> 型であることが期待され、次に <code>C</code> が代入されます。したがって、<code>A{B,C}</code> は <code>A{B}{C}</code> と同等です。これにより、<code>Array{Float64}</code> のように型を部分的にインスタンス化することが可能である理由が説明されます。最初のパラメータ値は固定されていますが、2番目はまだすべての可能な値の範囲を持っています。明示的な <code>where</code> 構文を使用すると、パラメータの任意の部分集合を固定できます。例えば、すべての1次元配列の型は <code>Array{T,1} where T</code> と書くことができます。</span></p><p data-translated="true"><span class="original-text">Type variables can be restricted with subtype relations. <code>Array{T} where T&lt;:Integer</code> refers to all arrays whose element type is some kind of <a href="../../base/numbers/index.html#Core.Integer"><code>Integer</code></a>. The syntax <code>Array{&lt;:Integer}</code> is a convenient shorthand for <code>Array{T} where T&lt;:Integer</code>. Type variables can have both lower and upper bounds. <code>Array{T} where Int&lt;:T&lt;:Number</code> refers to all arrays of <a href="../../base/numbers/index.html#Core.Number"><code>Number</code></a>s that are able to contain <code>Int</code>s (since <code>T</code> must be at least as big as <code>Int</code>). The syntax <code>where T&gt;:Int</code> also works to specify only the lower bound of a type variable, and <code>Array{&gt;:Int}</code> is equivalent to <code>Array{T} where T&gt;:Int</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型変数はサブタイプ関係で制限できます。<code>Array{T} where T&lt;:Integer</code> は、要素型がある種の <a href="../../base/numbers/index.html#Core.Integer"><code>Integer</code></a> であるすべての配列を指します。構文 <code>Array{&lt;:Integer}</code> は <code>Array{T} where T&lt;:Integer</code> の便利な省略形です。型変数には下限と上限の両方を持たせることができます。<code>Array{T} where Int&lt;:T&lt;:Number</code> は、<a href="../../base/numbers/index.html#Core.Number"><code>Number</code></a> の配列で、<code>Int</code> を含むことができるすべての配列を指します（<code>T</code> は少なくとも <code>Int</code> と同じ大きさでなければなりません）。構文 <code>where T&gt;:Int</code> は型変数の下限のみを指定するためにも機能し、<code>Array{&gt;:Int}</code> は <code>Array{T} where T&gt;:Int</code> と同等です。</span></p><p data-translated="true"><span class="original-text">Since <code>where</code> expressions nest, type variable bounds can refer to outer type variables. For example <code>Tuple{T,Array{S}} where S&lt;:AbstractArray{T} where T&lt;:Real</code> refers to 2-tuples whose first element is some <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a>, and whose second element is an <code>Array</code> of any kind of array whose element type contains the type of the first tuple element.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>where</code> 式はネストされるため、型変数の境界は外部の型変数を参照することができます。例えば、<code>Tuple{T,Array{S}} where S&lt;:AbstractArray{T} where T&lt;:Real</code> は、最初の要素がある <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> であり、2番目の要素が最初のタプル要素の型を含む任意の型の配列の <code>Array</code> である2タプルを指します。</span></p><p data-translated="true"><span class="original-text">The <code>where</code> keyword itself can be nested inside a more complex declaration. For example, consider the two types created by the following declarations:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>where</code> キーワード自体は、より複雑な宣言の中にネストすることができます。例えば、次の宣言によって作成される2つの型を考えてみましょう。</span></p><pre><code class="language-julia-repl hljs">julia&gt; const T1 = Array{Array{T, 1} where T, 1}
Vector{Vector} (alias for Array{Array{T, 1} where T, 1})

julia&gt; const T2 = Array{Array{T, 1}, 1} where T
Array{Vector{T}, 1} where T</code></pre><p data-translated="true"><span class="original-text">Type <code>T1</code> defines a 1-dimensional array of 1-dimensional arrays; each of the inner arrays consists of objects of the same type, but this type may vary from one inner array to the next. On the other hand, type <code>T2</code> defines a 1-dimensional array of 1-dimensional arrays all of whose inner arrays must have the same type. Note that <code>T2</code> is an abstract type, e.g., <code>Array{Array{Int,1},1} &lt;: T2</code>, whereas <code>T1</code> is a concrete type. As a consequence, <code>T1</code> can be constructed with a zero-argument constructor <code>a=T1()</code> but <code>T2</code> cannot.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型 <code>T1</code> は1次元配列の1次元配列を定義します。各内部配列は同じ型のオブジェクトで構成されますが、この型は内部配列ごとに異なる場合があります。一方、型 <code>T2</code> は、すべての内部配列が同じ型でなければならない1次元配列の1次元配列を定義します。<code>T2</code> は抽象型であることに注意してください。例えば、<code>Array{Array{Int,1},1} &lt;: T2</code> ですが、<code>T1</code> は具体的な型です。その結果、<code>T1</code> は引数なしのコンストラクタ <code>a=T1()</code> で構築できますが、<code>T2</code> はできません。</span></p><p data-translated="true"><span class="original-text">There is a convenient syntax for naming such types, similar to the short form of function definition syntax:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そのような型に名前を付けるための便利な構文があります。これは関数定義構文の短縮形に似ています。</span></p><pre><code class="language-julia hljs">Vector{T} = Array{T, 1}</code></pre><p data-translated="true"><span class="original-text">This is equivalent to <code>const Vector = Array{T,1} where T</code>. Writing <code>Vector{Float64}</code> is equivalent to writing <code>Array{Float64,1}</code>, and the umbrella type <code>Vector</code> has as instances all <code>Array</code> objects where the second parameter – the number of array dimensions – is 1, regardless of what the element type is. In languages where parametric types must always be specified in full, this is not especially helpful, but in Julia, this allows one to write just <code>Vector</code> for the abstract type including all one-dimensional dense arrays of any element type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは <code>const Vector = Array{T,1} where T</code> と同等です。<code>Vector{Float64}</code> と書くことは <code>Array{Float64,1}</code> と書くことと同等であり、傘型 <code>Vector</code> は、要素型が何であれ、配列の次元数が1であるすべての <code>Array</code> オブジェクトをインスタンスとして持ちます。パラメトリック型が常に完全に指定されなければならない言語では、これは特に役立ちませんが、Julia では、任意の要素型のすべての1次元密な配列を含む抽象型として <code>Vector</code> だけを書くことができます。</span></p><h2 id="man-singleton-types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-singleton-types">Singleton types</a><a id="man-singleton-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-singleton-types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-singleton-types">シングルトン型</a><a id="man-singleton-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-singleton-types" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Immutable composite types with no fields are called <em>singletons</em>. Formally, if</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">フィールドを持たない不変の複合型は <em>シングルトン</em> と呼ばれます。形式的には、もし</span></p><ol><li data-translated="true"><span class="original-text"><code>T</code> is an immutable composite type (i.e. defined with <code>struct</code>),</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>T</code> は不変の複合型（すなわち、<code>struct</code>で定義された）です。</span></li><li data-translated="true"><span class="original-text"><code>a isa T &amp;&amp; b isa T</code> implies <code>a === b</code>,</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>a isa T &amp;&amp; b isa T</code> は <code>a === b</code> を意味します。</span></li></ol><p data-translated="true"><span class="original-text">then <code>T</code> is a singleton type.<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2" class="footnote-ref">[2]</a><span class="footnote-preview" id="fn-2"></span></sup> <a href="../../base/base/index.html#Base.issingletontype"><code>Base.issingletontype</code></a> can be used to check if a type is a singleton type. <a href="#man-abstract-types">Abstract types</a> cannot be singleton types by construction.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この場合、<code>T</code> はシングルトン型です。<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2" class="footnote-ref">[2]</a><span class="footnote-preview" id="fn-2"></span></sup> <a href="../../base/base/index.html#Base.issingletontype"><code>Base.issingletontype</code></a> を使用して、型がシングルトン型であるかどうかを確認できます。<a href="#man-abstract-types">抽象型</a> は構造上シングルトン型にはなりません。</span></p><p data-translated="true"><span class="original-text">From the definition, it follows that there can be only one instance of such types:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">定義から、こうした型のインスタンスは1つだけ存在できることがわかります。</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct NoFields
       end

julia&gt; NoFields() === NoFields()
true

julia&gt; Base.issingletontype(NoFields)
true</code></pre><p data-translated="true"><span class="original-text">The <a href="../../base/base/#Core.:===#Core.:==="><code>===</code></a> function confirms that the constructed instances of <code>NoFields</code> are actually one and the same.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/#Core.:===#Core.:==="><code>===</code></a> 関数は、<code>NoFields</code> の構築されたインスタンスが実際に同一であることを確認します。</span></p><p data-translated="true"><span class="original-text">Parametric types can be singleton types when the above condition holds. For example,</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記の条件が満たされると、パラメトリック型もシングルトン型になり得ます。例えば、</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct NoFieldsParam{T}
       end

julia&gt; Base.issingletontype(NoFieldsParam) # Can't be a singleton type ...
false

julia&gt; NoFieldsParam{Int}() isa NoFieldsParam # ... because it has ...
true

julia&gt; NoFieldsParam{Bool}() isa NoFieldsParam # ... multiple instances.
true

julia&gt; Base.issingletontype(NoFieldsParam{Int}) # Parametrized, it is a singleton.
true

julia&gt; NoFieldsParam{Int}() === NoFieldsParam{Int}()
true</code></pre><h2 id="Types-of-functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Types-of-functions">Types of functions</a><a id="Types-of-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Types-of-functions">関数の型</a><a id="Types-of-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-functions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Each function has its own type, which is a subtype of <code>Function</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各関数は独自の型を持ち、それは <code>Function</code> のサブタイプです。</span></p><pre><code class="language-julia-repl hljs">julia&gt; foo41(x) = x + 1
foo41 (generic function with 1 method)

julia&gt; typeof(foo41)
typeof(foo41) (singleton type of function foo41, subtype of Function)</code></pre><p data-translated="true"><span class="original-text">Note how <code>typeof(foo41)</code> prints as itself. This is merely a convention for printing, as it is a first-class object that can be used like any other value:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>typeof(foo41)</code> がそのまま印刷されることに注意してください。これは単なる印刷のための慣習であり、他の値と同様に使用できる第一級オブジェクトです。</span></p><pre><code class="language-julia-repl hljs">julia&gt; T = typeof(foo41)
typeof(foo41) (singleton type of function foo41, subtype of Function)

julia&gt; T &lt;: Function
true</code></pre><p data-translated="true"><span class="original-text">Types of functions defined at top-level are singletons. When necessary, you can compare them with <a href="../../base/base/#Core.:===#Core.:==="><code>===</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">トップレベルで定義された関数の型はシングルトンです。必要に応じて、<a href="../../base/base/#Core.:===#Core.:==="><code>===</code></a> で比較できます。</span></p><p data-translated="true"><span class="original-text"><a href="../functions/index.html#man-anonymous-functions">Closures</a> also have their own type, which is usually printed with names that end in <code>#&lt;number&gt;</code>. Names and types for functions defined at different locations are distinct, but not guaranteed to be printed the same way across sessions.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../functions/index.html#man-anonymous-functions">クロージャ</a>には独自の型があり、通常は<code>#&lt;number&gt;</code>で終わる名前で表示されます。異なる場所で定義された関数の名前と型は異なりますが、セッション間で同じように表示されることは保証されていません。</span></p><pre><code class="language-julia-repl hljs">julia&gt; typeof(x -&gt; x + 1)
var"#9#10"</code></pre><p data-translated="true"><span class="original-text">Types of closures are not necessarily singletons.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">クロージャの型は必ずしもシングルトンではありません。</span></p><pre><code class="language-julia-repl hljs">julia&gt; addy(y) = x -&gt; x + y
addy (generic function with 1 method)

julia&gt; typeof(addy(1)) === typeof(addy(2))
true

julia&gt; addy(1) === addy(2)
false

julia&gt; Base.issingletontype(typeof(addy(1)))
false</code></pre><h2 id="man-typet-type" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-typet-type"><code>Type{T}</code> type selectors</a><a id="man-typet-type-1"></a><a class="docs-heading-anchor-permalink" href="#man-typet-type" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-typet-type"><code>Type{T}</code> 型セレクタ</a><a id="man-typet-type-1"></a><a class="docs-heading-anchor-permalink" href="#man-typet-type" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">For each type <code>T</code>, <code>Type{T}</code> is an abstract parametric type whose only instance is the object <code>T</code>. Until we discuss <a href="../methods/index.html#Parametric-Methods">Parametric Methods</a> and <a href="../conversion-and-promotion/index.html#conversion-and-promotion">conversions</a>, it is difficult to explain the utility of this construct, but in short, it allows one to specialize function behavior on specific types as <em>values</em>. This is useful for writing methods (especially parametric ones) whose behavior depends on a type that is given as an explicit argument rather than implied by the type of one of its arguments.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各型<code>T</code>に対して、<code>Type{T}</code>は抽象的なパラメトリック型で、その唯一のインスタンスはオブジェクト<code>T</code>です。<a href="../methods/index.html#Parametric-Methods">パラメトリックメソッド</a>と<a href="../conversion-and-promotion/index.html#conversion-and-promotion">変換</a>について議論するまで、この構造の有用性を説明するのは難しいですが、簡単に言うと、特定の型に基づいて関数の動作を<em>値</em>として特化することを可能にします。これは、引数の型によって暗黙的に決定されるのではなく、明示的な引数として与えられる型に依存するメソッド（特にパラメトリックなもの）を書くのに役立ちます。</span></p><p data-translated="true"><span class="original-text">Since the definition is a little difficult to parse, let's look at some examples:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">定義が少し難解なので、いくつかの例を見てみましょう。</span></p><pre><code class="language-julia-repl hljs">julia&gt; isa(Float64, Type{Float64})
true

julia&gt; isa(Real, Type{Float64})
false

julia&gt; isa(Real, Type{Real})
true

julia&gt; isa(Float64, Type{Real})
false</code></pre><p data-translated="true"><span class="original-text">In other words, <a href="../../base/base/index.html#Core.isa"><code>isa(A, Type{B})</code></a> is true if and only if <code>A</code> and <code>B</code> are the same object and that object is a type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">言い換えれば、<a href="../../base/base/index.html#Core.isa"><code>isa(A, Type{B})</code></a>は、<code>A</code>と<code>B</code>が同じオブジェクトであり、そのオブジェクトが型である場合にのみ真です。</span></p><p data-translated="true"><span class="original-text">In particular, since parametric types are <a href="#man-parametric-composite-types">invariant</a>, we have</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特に、パラメトリック型は<a href="#man-parametric-composite-types">不変</a>であるため、私たちは</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct TypeParamExample{T}
           x::T
       end

julia&gt; TypeParamExample isa Type{TypeParamExample}
true

julia&gt; TypeParamExample{Int} isa Type{TypeParamExample}
false

julia&gt; TypeParamExample{Int} isa Type{TypeParamExample{Int}}
true</code></pre><p data-translated="true"><span class="original-text">Without the parameter, <code>Type</code> is simply an abstract type which has all type objects as its instances:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パラメータなしでは、<code>Type</code>はすべての型オブジェクトをインスタンスとして持つ単なる抽象型です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; isa(Type{Float64}, Type)
true

julia&gt; isa(Float64, Type)
true

julia&gt; isa(Real, Type)
true</code></pre><p data-translated="true"><span class="original-text">Any object that is not a type is not an instance of <code>Type</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型でない任意のオブジェクトは<code>Type</code>のインスタンスではありません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; isa(1, Type)
false

julia&gt; isa("foo", Type)
false</code></pre><p data-translated="true"><span class="original-text">While <code>Type</code> is part of Julia's type hierarchy like any other abstract parametric type, it is not commonly used outside method signatures except in some special cases. Another important use case for <code>Type</code> is sharpening field types which would otherwise be captured less precisely, e.g. as <a href="#man-declared-types"><code>DataType</code></a> in the example below where the default constructor could lead to performance problems in code relying on the precise wrapped type (similarly to <a href="../performance-tips/index.html#man-performance-abstract-container">abstract type parameters</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Type</code>は他の抽象的なパラメトリック型と同様にJuliaの型階層の一部ですが、特別な場合を除いてメソッドシグネチャの外では一般的には使用されません。<code>Type</code>のもう一つの重要な使用例は、そうでなければあまり正確に捉えられないフィールド型を鋭くすることです。例えば、以下の例のようにデフォルトコンストラクタが正確なラップ型に依存するコードでパフォーマンスの問題を引き起こす可能性がある<a href="#man-declared-types"><code>DataType</code></a>としてです（<a href="../performance-tips/index.html#man-performance-abstract-container">抽象型パラメータ</a>と同様に）。</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct WrapType{T}
       value::T
       end

julia&gt; WrapType(Float64) # default constructor, note DataType
WrapType{DataType}(Float64)

julia&gt; WrapType(::Type{T}) where T = WrapType{Type{T}}(T)
WrapType

julia&gt; WrapType(Float64) # sharpened constructor, note more precise Type{Float64}
WrapType{Type{Float64}}(Float64)</code></pre><h2 id="Type-Aliases" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Type-Aliases">Type Aliases</a><a id="Type-Aliases-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Aliases" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Type-Aliases">型エイリアス</a><a id="Type-Aliases-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Aliases" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Sometimes it is convenient to introduce a new name for an already expressible type. This can be done with a simple assignment statement. For example, <code>UInt</code> is aliased to either <a href="../../base/numbers/index.html#Core.UInt32"><code>UInt32</code></a> or <a href="../../base/numbers/index.html#Core.UInt64"><code>UInt64</code></a> as is appropriate for the size of pointers on the system:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すでに表現可能な型に新しい名前を導入することは便利な場合があります。これは単純な代入文で行うことができます。例えば、<code>UInt</code>はシステムのポインタのサイズに応じて、<a href="../../base/numbers/index.html#Core.UInt32"><code>UInt32</code></a>または<a href="../../base/numbers/index.html#Core.UInt64"><code>UInt64</code></a>にエイリアスされています。</span></p><pre><code class="language-julia-repl hljs"># 32-bit system:
julia&gt; UInt
UInt32

# 64-bit system:
julia&gt; UInt
UInt64</code></pre><p data-translated="true"><span class="original-text">This is accomplished via the following code in <code>base/boot.jl</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは<code>base/boot.jl</code>内の以下のコードを通じて実現されます:</span></p><pre><code class="language-julia hljs">if Int === Int64
    const UInt = UInt64
else
    const UInt = UInt32
end</code></pre><p data-translated="true"><span class="original-text">Of course, this depends on what <code>Int</code> is aliased to – but that is predefined to be the correct type – either <a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a> or <a href="../../base/numbers/index.html#Core.Int64"><code>Int64</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もちろん、これは<code>Int</code>が何にエイリアスされているかに依存しますが、それは正しい型に事前定義されています – すなわち<a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a>または<a href="../../base/numbers/index.html#Core.Int64"><code>Int64</code></a>です。</span></p><p data-translated="true"><span class="original-text">(Note that unlike <code>Int</code>, <code>Float</code> does not exist as a type alias for a specific sized <a href="../../base/numbers/index.html#Core.AbstractFloat"><code>AbstractFloat</code></a>. Unlike with integer registers, where the size of <code>Int</code> reflects the size of a native pointer on that machine, the floating point register sizes are specified by the IEEE-754 standard.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(<code>Int</code>とは異なり、<code>Float</code>は特定のサイズの<a href="../../base/numbers/index.html#Core.AbstractFloat"><code>AbstractFloat</code></a>の型エイリアスとして存在しないことに注意してください。整数レジスタの場合、<code>Int</code>のサイズはそのマシン上のネイティブポインタのサイズを反映しますが、浮動小数点レジスタのサイズはIEEE-754標準によって指定されています。)</span></p><p data-translated="true"><span class="original-text">Type aliases may be parametrized:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型エイリアスはパラメータ化することができます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; const Family{T} = Set{T}
Set

julia&gt; Family{Char} === Set{Char}
true</code></pre><h2 id="Operations-on-Types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Operations-on-Types">Operations on Types</a><a id="Operations-on-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-Types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Operations-on-Types">型に対する操作</a><a id="Operations-on-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-Types" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Since types in Julia are themselves objects, ordinary functions can operate on them. Some functions that are particularly useful for working with or exploring types have already been introduced, such as the <code>&lt;:</code> operator, which indicates whether its left hand operand is a subtype of its right hand operand.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの型はそれ自体がオブジェクトであるため、通常の関数がそれらに対して操作を行うことができます。型を扱ったり探索したりするために特に便利な関数がいくつか既に紹介されています。例えば、<code>&lt;:</code>演算子は、その左側のオペランドが右側のオペランドのサブタイプであるかどうかを示します。</span></p><p data-translated="true"><span class="original-text">The <a href="../../base/base/index.html#Core.isa"><code>isa</code></a> function tests if an object is of a given type and returns true or false:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Core.isa"><code>isa</code></a>関数は、オブジェクトが特定の型であるかどうかをテストし、真または偽を返します:</span></p><pre><code class="language-julia-repl hljs">julia&gt; isa(1, Int)
true

julia&gt; isa(1, AbstractFloat)
false</code></pre><p data-translated="true"><span class="original-text">The <a href="../../base/base/index.html#Core.typeof"><code>typeof</code></a> function, already used throughout the manual in examples, returns the type of its argument. Since, as noted above, types are objects, they also have types, and we can ask what their types are:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Core.typeof"><code>typeof</code></a>関数は、マニュアル全体で例として使用されているように、引数の型を返します。上記のように、型はオブジェクトであるため、それらにも型があり、私たちはそれらの型が何であるかを尋ねることができます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; typeof(Rational{Int})
DataType

julia&gt; typeof(Union{Real,String})
Union</code></pre><p data-translated="true"><span class="original-text">What if we repeat the process? What is the type of a type of a type? As it happens, types are all composite values and thus all have a type of <code>DataType</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロセスを繰り返したらどうなるでしょうか？型の型の型とは何でしょうか？実際、型はすべて複合値であり、したがってすべての型は <code>DataType</code> の型を持っています：</span></p><pre><code class="language-julia-repl hljs">julia&gt; typeof(DataType)
DataType

julia&gt; typeof(Union)
DataType</code></pre><p data-translated="true"><span class="original-text"><code>DataType</code> is its own type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>DataType</code> は自分自身の型です。</span></p><p data-translated="true"><span class="original-text">Another operation that applies to some types is <a href="../../base/base/index.html#Base.supertype"><code>supertype</code></a>, which reveals a type's supertype. Only declared types (<code>DataType</code>) have unambiguous supertypes:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">いくつかの型に適用される別の操作は、<a href="../../base/base/index.html#Base.supertype"><code>supertype</code></a> であり、型のスーパタイプを明らかにします。宣言された型（<code>DataType</code>）のみが明確なスーパタイプを持っています：</span></p><pre><code class="language-julia-repl hljs">julia&gt; supertype(Float64)
AbstractFloat

julia&gt; supertype(Number)
Any

julia&gt; supertype(AbstractString)
Any

julia&gt; supertype(Any)
Any</code></pre><p data-translated="true"><span class="original-text">If you apply <a href="../../base/base/index.html#Base.supertype"><code>supertype</code></a> to other type objects (or non-type objects), a <a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a> is raised:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">他の型オブジェクト（または非型オブジェクト）に <a href="../../base/base/index.html#Base.supertype"><code>supertype</code></a> を適用すると、<a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a> が発生します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; supertype(Union{Float64,Int64})
ERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})
The function `supertype` exists, but no method is defined for this combination of argument types.

Closest candidates are:
[...]</code></pre><h2 id="man-custom-pretty-printing" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-custom-pretty-printing">Custom pretty-printing</a><a id="man-custom-pretty-printing-1"></a><a class="docs-heading-anchor-permalink" href="#man-custom-pretty-printing" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-custom-pretty-printing">カスタム整形表示</a><a id="man-custom-pretty-printing-1"></a><a class="docs-heading-anchor-permalink" href="#man-custom-pretty-printing" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Often, one wants to customize how instances of a type are displayed. This is accomplished by overloading the <a href="../../base/io-network/index.html#Base.show-Tuple{IO, Any}"><code>show</code></a> function. For example, suppose we define a type to represent complex numbers in polar form:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しばしば、型のインスタンスがどのように表示されるかをカスタマイズしたいと思います。これは、<a href="../../base/io-network/index.html#Base.show-Tuple{IO, Any}"><code>show</code></a> 関数をオーバーロードすることで実現されます。例えば、極形式の複素数を表す型を定義するとします：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct Polar{T&lt;:Real} &lt;: Number
           r::T
           Θ::T
       end

julia&gt; Polar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)
Polar</code></pre><p data-translated="true"><span class="original-text">Here, we've added a custom constructor function so that it can take arguments of different <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> types and promote them to a common type (see <a href="../constructors/index.html#man-constructors">Constructors</a> and <a href="../conversion-and-promotion/index.html#conversion-and-promotion">Conversion and Promotion</a>). (Of course, we would have to define lots of other methods, too, to make it act like a <a href="../../base/numbers/index.html#Core.Number"><code>Number</code></a>, e.g. <code>+</code>, <code>*</code>, <code>one</code>, <code>zero</code>, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. <code>Polar{Float64}(3.0,4.0)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、異なる <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> 型の引数を受け取り、それらを共通の型に昇格させるカスタムコンストラクタ関数を追加しました（<a href="../constructors/index.html#man-constructors">コンストラクタ</a>や<a href="../conversion-and-promotion/index.html#conversion-and-promotion">変換と昇格</a>を参照）。（もちろん、<code>+</code>、<code>*</code>、<code>one</code>、<code>zero</code>、昇格ルールなど、<a href="../../base/numbers/index.html#Core.Number"><code>Number</code></a> のように動作させるために、他の多くのメソッドも定義する必要があります。）デフォルトでは、この型のインスタンスは型名とフィールド値に関する情報を持って比較的シンプルに表示されます。例えば、<code>Polar{Float64}(3.0,4.0)</code> のように表示されます。</span></p><p data-translated="true"><span class="original-text">If we want it to display instead as <code>3.0 * exp(4.0im)</code>, we would define the following method to print the object to a given output object <code>io</code> (representing a file, terminal, buffer, etcetera; see <a href="../networking-and-streams/index.html#Networking-and-Streams">Networking and Streams</a>):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もしこれを <code>3.0 * exp(4.0im)</code> のように表示したい場合は、指定された出力オブジェクト <code>io</code> にオブジェクトを印刷するための以下のメソッドを定義します（ファイル、端末、バッファなどを表します；<a href="../networking-and-streams/index.html#Networking-and-Streams">ネットワーキングとストリーム</a>を参照）：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Base.show(io::IO, z::Polar) = print(io, z.r, " * exp(", z.Θ, "im)")</code></pre><p data-translated="true"><span class="original-text">More fine-grained control over display of <code>Polar</code> objects is possible. In particular, sometimes one wants both a verbose multi-line printing format, used for displaying a single object in the REPL and other interactive environments, and also a more compact single-line format used for <a href="../../base/io-network/index.html#Base.print"><code>print</code></a> or for displaying the object as part of another object (e.g. in an array). Although by default the <code>show(io, z)</code> function is called in both cases, you can define a <em>different</em> multi-line format for displaying an object by overloading a three-argument form of <code>show</code> that takes the <code>text/plain</code> MIME type as its second argument (see <a href="../../base/io-network/index.html#Multimedia-I/O">Multimedia I/O</a>), for example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Polar</code> オブジェクトの表示をより細かく制御することが可能です。特に、時にはREPLや他のインタラクティブ環境で単一のオブジェクトを表示するために使用される冗長なマルチライン印刷形式と、<a href="../../base/io-network/index.html#Base.print"><code>print</code></a> や他のオブジェクトの一部としてオブジェクトを表示するために使用されるよりコンパクトなシングルライン形式の両方を望むことがあります。デフォルトでは、<code>show(io, z)</code> 関数が両方のケースで呼び出されますが、<code>text/plain</code> MIMEタイプを第2引数として受け取る <code>show</code> の3引数形式をオーバーロードすることで、オブジェクトを表示するための<em>異なる</em>マルチライン形式を定義できます（<a href="../../base/io-network/index.html#Multimedia-I/O">マルチメディアI/O</a>を参照）。例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Base.show(io::IO, ::MIME"text/plain", z::Polar{T}) where{T} =
           print(io, "Polar{$T} complex number:\n   ", z)</code></pre><p data-translated="true"><span class="original-text">(Note that <code>print(..., z)</code> here will call the 2-argument <code>show(io, z)</code> method.) This results in:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(ここで <code>print(..., z)</code> は2引数の <code>show(io, z)</code> メソッドを呼び出します。）これにより、次のようになります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia&gt; [Polar(3, 4.0), Polar(4.0,5.3)]
2-element Vector{Polar{Float64}}:
 3.0 * exp(4.0im)
 4.0 * exp(5.3im)</code></pre><p data-translated="true"><span class="original-text">where the single-line <code>show(io, z)</code> form is still used for an array of <code>Polar</code> values. Technically, the REPL calls <code>display(z)</code> to display the result <code>z</code> of executing a line, which defaults to <code>show(io, MIME("text/plain"), z)</code> (where <code>io</code> is an <a href="../../base/io-network/index.html#Base.IOContext"><code>IOContext</code></a> wrapper around <a href="../../base/io-network/index.html#Base.stdout"><code>stdout</code></a>), which in turn defaults to <code>show(io, z)</code>, but you should <em>not</em> define new <a href="../../base/io-network/index.html#Base.Multimedia.display"><code>display</code></a> methods unless you are defining a new multimedia display handler (see <a href="../../base/io-network/index.html#Multimedia-I/O">Multimedia I/O</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、単一行の <code>show(io, z)</code> 形式が <code>Polar</code> 値の配列に対してまだ使用されています。技術的には、REPLは行を実行した結果 <code>z</code> を表示するために <code>display(z)</code> を呼び出し、これはデフォルトで <code>show(io, MIME("text/plain"), z)</code> に設定されています（ここで <code>io</code> は <a href="../../base/io-network/index.html#Base.IOContext"><code>IOContext</code></a> のラッパーで <a href="../../base/io-network/index.html#Base.stdout"><code>stdout</code></a> を囲んでいます）。これにより、デフォルトで <code>show(io, z)</code> に戻りますが、新しい <a href="../../base/io-network/index.html#Base.Multimedia.display"><code>display</code></a> メソッドを定義するべきではありません。新しいマルチメディア表示ハンドラーを定義する場合を除いて（詳細は <a href="../../base/io-network/index.html#Multimedia-I/O">Multimedia I/O</a> を参照）。</span></p><p data-translated="true"><span class="original-text">Moreover, you can also define <code>show</code> methods for other MIME types in order to enable richer display (HTML, images, etcetera) of objects in environments that support this (e.g. IJulia). For example, we can define formatted HTML display of <code>Polar</code> objects, with superscripts and italics, via:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さらに、他のMIMEタイプのために <code>show</code> メソッドを定義することもでき、これにより、これをサポートする環境（例：IJulia）でオブジェクトのリッチな表示（HTML、画像など）が可能になります。例えば、<code>Polar</code> オブジェクトのフォーマットされたHTML表示を、上付き文字やイタリック体を使って定義できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; Base.show(io::IO, ::MIME"text/html", z::Polar{T}) where {T} =
           println(io, "&lt;code&gt;Polar{$T}&lt;/code&gt; complex number: ",
                   z.r, " &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;", z.Θ, " &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;")</code></pre><p data-translated="true"><span class="original-text">A <code>Polar</code> object will then display automatically using HTML in an environment that supports HTML display, but you can call <code>show</code> manually to get HTML output if you want:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Polar</code> オブジェクトは、HTML表示をサポートする環境で自動的にHTMLを使用して表示されますが、必要に応じて手動で <code>show</code> を呼び出してHTML出力を得ることもできます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; show(stdout, "text/html", Polar(3.0,4.0))
&lt;code&gt;Polar{Float64}&lt;/code&gt; complex number: 3.0 &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;4.0 &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;</code></pre><p data-translated="true"><span class="original-text">An HTML renderer would display this as: <code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">HTMLレンダラーはこれを次のように表示します： <code>Polar{Float64}</code> 複素数： 3.0 <i>e</i><sup>4.0 <i>i</i></sup></span></p><p data-translated="true"><span class="original-text">As a rule of thumb, the single-line <code>show</code> method should print a valid Julia expression for creating the shown object. When this <code>show</code> method contains infix operators, such as the multiplication operator (<code>*</code>) in our single-line <code>show</code> method for <code>Polar</code> above, it may not parse correctly when printed as part of another object. To see this, consider the expression object (see <a href="../metaprogramming/index.html#Program-representation">Program representation</a>) which takes the square of a specific instance of our <code>Polar</code> type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般的なルールとして、単一行の <code>show</code> メソッドは、表示されるオブジェクトを作成するための有効なJulia式を印刷するべきです。この <code>show</code> メソッドに中置演算子（上記の <code>Polar</code> の単一行 <code>show</code> メソッドにある乗算演算子 <code>*</code> など）が含まれている場合、他のオブジェクトの一部として印刷されたときに正しく解析されない可能性があります。これを確認するために、特定の <code>Polar</code> 型のインスタンスの平方を取る式オブジェクト（詳細は <a href="../metaprogramming/index.html#Program-representation">Program representation</a> を参照）を考えてみましょう。</span></p><pre><code class="language-julia-repl hljs">julia&gt; a = Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia&gt; print(:($a^2))
3.0 * exp(4.0im) ^ 2</code></pre><p data-translated="true"><span class="original-text">Because the operator <code>^</code> has higher precedence than <code>*</code> (see <a href="../mathematical-operations/index.html#Operator-Precedence-and-Associativity">Operator Precedence and Associativity</a>), this output does not faithfully represent the expression <code>a ^ 2</code> which should be equal to <code>(3.0 * exp(4.0im)) ^ 2</code>. To solve this issue, we must make a custom method for <code>Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)</code>, which is called internally by the expression object when printing:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">演算子 <code>^</code> は <code>*</code> よりも優先順位が高いため（詳細は <a href="../mathematical-operations/index.html#Operator-Precedence-and-Associativity">Operator Precedence and Associativity</a> を参照）、この出力は <code>a ^ 2</code> の式を忠実に表現しておらず、<code>(3.0 * exp(4.0im)) ^ 2</code> と等しいはずです。この問題を解決するために、<code>Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)</code> のカスタムメソッドを作成する必要があります。これは印刷時に式オブジェクトによって内部的に呼び出されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; function Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)
           if Base.operator_precedence(:*) &lt;= precedence
               print(io, "(")
               show(io, z)
               print(io, ")")
           else
               show(io, z)
           end
       end

julia&gt; :($a^2)
:((3.0 * exp(4.0im)) ^ 2)</code></pre><p data-translated="true"><span class="original-text">The method defined above adds parentheses around the call to <code>show</code> when the precedence of the calling operator is higher than or equal to the precedence of multiplication. This check allows expressions which parse correctly without the parentheses (such as <code>:($a + 2)</code> and <code>:($a == 2)</code>) to omit them when printing:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記で定義されたメソッドは、呼び出し演算子の優先順位が乗算の優先順位以上である場合に <code>show</code> の呼び出しの周りに括弧を追加します。このチェックにより、括弧なしで正しく解析される式（<code>:($a + 2)</code> や <code>:($a == 2)</code> など）は、印刷時に省略されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; :($a + 2)
:(3.0 * exp(4.0im) + 2)

julia&gt; :($a == 2)
:(3.0 * exp(4.0im) == 2)</code></pre><p data-translated="true"><span class="original-text">In some cases, it is useful to adjust the behavior of <code>show</code> methods depending on the context. This can be achieved via the <a href="../../base/io-network/index.html#Base.IOContext"><code>IOContext</code></a> type, which allows passing contextual properties together with a wrapped IO stream. For example, we can build a shorter representation in our <code>show</code> method when the <code>:compact</code> property is set to <code>true</code>, falling back to the long representation if the property is <code>false</code> or absent:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">場合によっては、コンテキストに応じて <code>show</code> メソッドの動作を調整することが有用です。これは、ラップされたIOストリームと共にコンテキストプロパティを渡すことを可能にする <a href="../../base/io-network/index.html#Base.IOContext"><code>IOContext</code></a> 型を介して実現できます。例えば、<code>:compact</code> プロパティが <code>true</code> に設定されている場合、<code>show</code> メソッドで短い表現を構築し、プロパティが <code>false</code> または存在しない場合は長い表現にフォールバックできます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; function Base.show(io::IO, z::Polar)
           if get(io, :compact, false)::Bool
               print(io, z.r, "ℯ", z.Θ, "im")
           else
               print(io, z.r, " * exp(", z.Θ, "im)")
           end
       end</code></pre><p data-translated="true"><span class="original-text">This new compact representation will be used when the passed IO stream is an <code>IOContext</code> object with the <code>:compact</code> property set. In particular, this is the case when printing arrays with multiple columns (where horizontal space is limited):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この新しいコンパクトな表現は、渡されたIOストリームが <code>IOContext</code> オブジェクトで <code>:compact</code> プロパティが設定されている場合に使用されます。特に、これは複数の列を持つ配列を印刷する場合（水平スペースが限られている場合）に該当します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; show(IOContext(stdout, :compact=&gt;true), Polar(3, 4.0))
3.0ℯ4.0im

julia&gt; [Polar(3, 4.0) Polar(4.0,5.3)]
1×2 Matrix{Polar{Float64}}:
 3.0ℯ4.0im  4.0ℯ5.3im</code></pre><p data-translated="true"><span class="original-text">See the <a href="../../base/io-network/index.html#Base.IOContext"><code>IOContext</code></a> documentation for a list of common properties which can be used to adjust printing.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/io-network/index.html#Base.IOContext"><code>IOContext</code></a> ドキュメントを参照して、印刷を調整するために使用できる一般的なプロパティのリストを確認してください。</span></p><h3 id="Output-function-summary" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Output-function-summary">Output-function summary</a><a id="Output-function-summary-1"></a><a class="docs-heading-anchor-permalink" href="#Output-function-summary" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Output-function-summary">出力関数の概要</a><a id="Output-function-summary-1"></a><a class="docs-heading-anchor-permalink" href="#Output-function-summary" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Here is a brief summary of the different output functions in Julia and how they are related. Most new types should only need to define <code>show</code> methods, if anything.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、Juliaのさまざまな出力関数の簡単な概要と、それらの関連性について説明します。ほとんどの新しい型は、何かを定義する必要がある場合、<code>show</code>メソッドのみを定義すれば十分です。</span></p><ul><li data-translated="true"><span class="original-text"><a href="../../base/io-network/index.html#Base.Multimedia.display"><code>display(x)</code></a> tells the current environment to display <code>x</code> in whatever way it thinks best. (This might even be a graphical display in something like a Jupyter or Pluto notebook.) By default (e.g. in scripts or in the text REPL), it calls <code>show(io, "text/plain", x)</code>, or equivalently <code>show(io, MIME"text/plain"(), x)</code>, for an appropriate <code>io</code> stream. (In the REPL, <code>io</code> is an <a href="../../base/io-network/index.html#Base.IOContext"><code>IOContext</code></a> wrapper around <a href="../../base/io-network/index.html#Base.stdout"><code>stdout</code></a>.) The REPL uses <code>display</code> to output the result of an evaluated expression.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/io-network/index.html#Base.Multimedia.display"><code>display(x)</code></a>は、現在の環境に対して<code>x</code>を最適な方法で表示するよう指示します。（これは、JupyterやPlutoノートブックのようなものにおけるグラフィカルな表示である可能性もあります。）デフォルトでは（例えば、スクリプトやテキストREPLでは）、適切な<code>io</code>ストリームに対して<code>show(io, "text/plain", x)</code>、または同等の<code>show(io, MIME"text/plain"(), x)</code>を呼び出します。（REPLでは、<code>io</code>は<a href="../../base/io-network/index.html#Base.IOContext"><code>IOContext</code></a>ラッパーであり、<a href="../../base/io-network/index.html#Base.stdout"><code>stdout</code></a>の周りにあります。）REPLは、評価された式の結果を出力するために<code>display</code>を使用します。</span></li><li data-translated="true"><span class="original-text">The 3-argument <a href="../../base/io-network/index.html#Base.show-Tuple{IO, Any}"><code>show(io, ::MIME"text/plain", x)</code></a> method performs verbose pretty-printing of <code>x</code>. By default (if no 3-argument method is defined for <code>typeof(x)</code>), it calls the 2-argument <code>show(io, x)</code>. It is called by the 2-argument <code>repr("text/plain", x)</code>. Other 3-argument <code>show</code> methods can be defined for additional MIME types as discussed above, to enable richer display of <code>x</code> in some interactive environments.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">3引数の<a href="../../base/io-network/index.html#Base.show-Tuple{IO, Any}"><code>show(io, ::MIME"text/plain", x)</code></a>メソッドは、<code>x</code>の冗長な整形表示を行います。デフォルトでは（<code>typeof(x)</code>に対して3引数のメソッドが定義されていない場合）、2引数の<code>show(io, x)</code>を呼び出します。これは、2引数の<code>repr("text/plain", x)</code>によって呼び出されます。上記で説明したように、追加のMIMEタイプに対して他の3引数の<code>show</code>メソッドを定義することで、いくつかのインタラクティブな環境での<code>x</code>のよりリッチな表示を可能にします。</span></li><li data-translated="true"><span class="original-text">The 2-argument <a href="../../base/io-network/index.html#Base.show-Tuple{IO, Any}"><code>show(io, x)</code></a> is the default simple text representation of <code>x</code>. It is called by the 1-argument <a href="../../base/strings/index.html#Base.repr-Tuple{Any}"><code>repr(x)</code></a>, and is typically the format you might employ to input <code>x</code> into Julia. The 1-argument <code>show(x)</code> calls <code>show(stdout, x)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">2引数の<a href="../../base/io-network/index.html#Base.show-Tuple{IO, Any}"><code>show(io, x)</code></a>は、<code>x</code>のデフォルトの単純なテキスト表現です。これは、1引数の<a href="../../base/strings/index.html#Base.repr-Tuple{Any}"><code>repr(x)</code></a>によって呼び出され、通常は<code>x</code>をJuliaに入力するために使用する形式です。1引数の<code>show(x)</code>は<code>show(stdout, x)</code>を呼び出します。</span></li><li data-translated="true"><span class="original-text"><a href="../../base/io-network/index.html#Base.print"><code>print(io, x)</code></a> by default calls <code>show(io, x)</code>, but a few types have a distinct <code>print</code> format — most notably, when <code>x</code> is a string, <code>print</code> outputs the raw text whereas <code>show</code> outputs an escaped string enclosed in quotation marks. The 1-argument <code>print(x)</code> calls <code>print(stdout, x)</code>. <code>print</code> is also called by <a href="../../base/strings/index.html#Base.string"><code>string(x)</code></a>.  See also <a href="../../base/io-network/index.html#Base.println"><code>println</code></a> (to append a newline) and <a href="../../base/io-network/index.html#Base.printstyled"><code>printstyled</code></a> (to add colors etc.), both of which call <code>print</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/io-network/index.html#Base.print"><code>print(io, x)</code></a>はデフォルトで<code>show(io, x)</code>を呼び出しますが、いくつかの型は異なる<code>print</code>形式を持っています。特に、<code>x</code>が文字列の場合、<code>print</code>は生のテキストを出力し、<code>show</code>は引用符で囲まれたエスケープされた文字列を出力します。1引数の<code>print(x)</code>は<code>print(stdout, x)</code>を呼び出します。<code>print</code>は<a href="../../base/strings/index.html#Base.string"><code>string(x)</code></a>によっても呼び出されます。<code>println</code>（改行を追加するため）や<a href="../../base/io-network/index.html#Base.printstyled"><code>printstyled</code></a>（色などを追加するため）も<code>print</code>を呼び出します。</span></li><li data-translated="true"><span class="original-text"><a href="../../base/file/index.html#Base.write-Tuple{String, Any}"><code>write(io, x)</code></a>, if it is defined (it generally has <em>no</em> default definition for new types), writes a "raw" binary representation of <code>x</code> to <code>io</code>, e.g. an <code>x::Int32</code> will be written as 4 bytes.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/file/index.html#Base.write-Tuple{String, Any}"><code>write(io, x)</code></a>は、定義されている場合（新しい型には一般的に<em>デフォルト定義がない</em>）、<code>io</code>に<code>x</code>の「生」バイナリ表現を書き込みます。例えば、<code>x::Int32</code>は4バイトとして書き込まれます。</span></li></ul><p data-translated="true"><span class="original-text">It is also helpful to be familiar with the metadata that can be attached to an <code>io</code> stream by an <a href="../../base/io-network/index.html#Base.IOContext"><code>IOContext</code></a> wrapper. For example, the REPL sets the <code>:limit =&gt; true</code> flag from <code>display</code> for an evaluated expression, in order to limit the output to fit in the terminal; you can query this flag with <code>get(io, :limit, false)</code>. And when displaying an object contained within, for example, a multi-column matrix, the <code>:compact =&gt; true</code> flag could be set, which you can query with <code>get(io, :compact, false)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、<code>io</code>ストリームに<a href="../../base/io-network/index.html#Base.IOContext"><code>IOContext</code></a>ラッパーによって添付できるメタデータに慣れておくことも役立ちます。例えば、REPLは評価された式の<code>display</code>から<code>:limit =&gt; true</code>フラグを設定し、出力を端末に収まるように制限します。このフラグは<code>get(io, :limit, false)</code>で照会できます。また、例えばマルチカラム行列内のオブジェクトを表示する際には、<code>:compact =&gt; true</code>フラグが設定されることがあり、これは<code>get(io, :compact, false)</code>で照会できます。</span></p><h2 id="&quot;Value-types&quot;" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#&quot;Value-types&quot;">"Value types"</a><a id="&quot;Value-types&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;Value-types&quot;" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#&quot;Value-types&quot;">"値型"</a><a id="&quot;Value-types&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;Value-types&quot;" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">In Julia, you can't dispatch on a <em>value</em> such as <code>true</code> or <code>false</code>. However, you can dispatch on parametric types, and Julia allows you to include "plain bits" values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters. A common example is the dimensionality parameter in <code>Array{T,N}</code>, where <code>T</code> is a type (e.g., <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>) but <code>N</code> is just an <code>Int</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<em>値</em>（例えば<code>true</code>や<code>false</code>）に対してディスパッチすることはできません。しかし、パラメトリック型に対してディスパッチすることはでき、Juliaは「プレーンビット」値（型、シンボル、整数、浮動小数点数、タプルなど）を型パラメータとして含めることを許可します。一般的な例は、<code>Array{T,N}</code>の次元パラメータであり、ここで<code>T</code>は型（例えば<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>）ですが、<code>N</code>は単なる<code>Int</code>です。</span></p><p data-translated="true"><span class="original-text">You can create your own custom types that take values as parameters, and use them to control dispatch of custom types. By way of illustration of this idea, let's introduce the parametric type <code>Val{x}</code>, and its constructor <code>Val(x) = Val{x}()</code>, which serves as a customary way to exploit this technique for cases where you don't need a more elaborate hierarchy.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">値をパラメータとして受け取る独自のカスタム型を作成し、それを使用してカスタム型のディスパッチを制御できます。このアイデアを説明するために、パラメトリック型<code>Val{x}</code>とそのコンストラクタ<code>Val(x) = Val{x}()</code>を紹介します。これは、より複雑な階層が必要ない場合にこの技術を利用するための一般的な方法です。</span></p><p data-translated="true"><span class="original-text"><a href="../../base/base/index.html#Base.Val"><code>Val</code></a> is defined as:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Base.Val"><code>Val</code></a>は次のように定義されています：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct Val{x}
       end

julia&gt; Val(x) = Val{x}()
Val</code></pre><p data-translated="true"><span class="original-text">There is no more to the implementation of <code>Val</code> than this. Some functions in Julia's standard library accept <code>Val</code> instances as arguments, and you can also use it to write your own functions.  For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Val</code>の実装はこれ以上のものではありません。Juliaの標準ライブラリのいくつかの関数は<code>Val</code>インスタンスを引数として受け入れ、独自の関数を書くためにも使用できます。例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; firstlast(::Val{true}) = "First"
firstlast (generic function with 1 method)

julia&gt; firstlast(::Val{false}) = "Last"
firstlast (generic function with 2 methods)

julia&gt; firstlast(Val(true))
"First"

julia&gt; firstlast(Val(false))
"Last"</code></pre><p data-translated="true"><span class="original-text">For consistency across Julia, the call site should always pass a <code>Val</code> <em>instance</em> rather than using a <em>type</em>, i.e., use <code>foo(Val(:bar))</code> rather than <code>foo(Val{:bar})</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia全体での一貫性のために、呼び出し元は常に<code>Val</code>の<em>インスタンス</em>を渡すべきであり、<em>型</em>を使用すべきではありません。つまり、<code>foo(Val(:bar))</code>を使用するべきであり、<code>foo(Val{:bar})</code>は使用すべきではありません。</span></p><p data-translated="true"><span class="original-text">It's worth noting that it's extremely easy to mis-use parametric "value" types, including <code>Val</code>; in unfavorable cases, you can easily end up making the performance of your code much <em>worse</em>.  In particular, you would never want to write actual code as illustrated above. For more information about the proper (and improper) uses of <code>Val</code>, please read <a href="../performance-tips/index.html#man-performance-value-type">the more extensive discussion in the performance tips</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パラメトリックな「値」型、特に<code>Val</code>を誤って使用するのは非常に簡単であることに注意する価値があります。好ましくない場合、コードのパフォーマンスが非常に<em>悪化</em>することがあります。特に、上記のように実際のコードを書くことは決して望ましくありません。<code>Val</code>の適切（および不適切）な使用についての詳細は、<a href="../performance-tips/index.html#man-performance-value-type">パフォーマンスのヒントにおけるより詳細な議論をお読みください</a>。</span></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1" data-translated="true"><span class="original-text"><a class="tag is-link" href="#citeref-1">1</a>"Small" is defined by the <code>max_union_splitting</code> configuration, which currently defaults to 4.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tag is-link" href="#citeref-1">1</a>「Small」は<code>max_union_splitting</code>設定によって定義されており、現在のデフォルトは4です。</span></li><li class="footnote" id="footnote-2" data-translated="true"><span class="original-text"><a class="tag is-link" href="#citeref-2">2</a>A few popular languages have singleton types, including Haskell, Scala and Ruby.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tag is-link" href="#citeref-2">2</a>いくつかの人気のある言語にはシングルトン型があり、Haskell、Scala、Rubyが含まれます。</span></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variables-and-scoping/index.html">« Scope of Variables</a><a class="docs-footer-nextpage" href="../methods/index.html">Methods »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>