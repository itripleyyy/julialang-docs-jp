<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Modules · The Julia Language</title><meta name="title" content="Modules · The Julia Language"><meta property="og:title" content="Modules · The Julia Language"><meta property="twitter:title" content="Modules · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/modules/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/modules/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bi1h1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li class="is-active"><a class="tocitem" href="">Modules</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#namespace-management"><span>Namespace management</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#namespace-management"><span>名前空間管理</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Submodules-and-relative-paths"><span>Submodules and relative paths</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Submodules-and-relative-paths"><span>サブモジュールと相対パス</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Module-initialization-and-precompilation"><span>Module initialization and precompilation</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Module-initialization-and-precompilation"><span>モジュールの初期化と事前コンパイル</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">モジュール</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">モジュール</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/modules.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="modules" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#modules">Modules</a><a id="modules-1"></a><a class="docs-heading-anchor-permalink" href="#modules" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#modules">モジュール</a><a id="modules-1"></a><a class="docs-heading-anchor-permalink" href="#modules" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">Modules in Julia help organize code into coherent units. They are delimited syntactically inside <code>module NameOfModule ... end</code>, and have the following features:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaのモジュールは、コードを一貫した単位に整理するのに役立ちます。モジュールは<code>module NameOfModule ... end</code>の中で構文的に区切られ、以下の特徴があります：</span></p><ol><li><p data-translated="true"><span class="original-text">Modules are separate namespaces, each introducing a new global scope. This is useful, because it allows the same name to be used for different functions or global variables without conflict, as long as they are in separate modules.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュールは別々の名前空間であり、それぞれが新しいグローバルスコープを導入します。これは便利で、異なるモジュール内であれば、同じ名前を異なる関数やグローバル変数に使用することができ、衝突を避けることができます。</span></p></li><li><p data-translated="true"><span class="original-text">Modules have facilities for detailed namespace management: each defines a set of names it <code>export</code>s and marks as <code>public</code>, and can import names from other modules with <code>using</code> and <code>import</code> (we explain these below).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュールには詳細な名前空間管理のための機能があります：各モジュールは<code>export</code>で公開する名前のセットを定義し、他のモジュールから<code>using</code>や<code>import</code>で名前をインポートすることができます（これについては以下で説明します）。</span></p></li><li><p data-translated="true"><span class="original-text">Modules can be precompiled for faster loading, and may contain code for runtime initialization.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュールは高速な読み込みのために事前コンパイルすることができ、ランタイム初期化のためのコードを含むことがあります。</span></p></li></ol><p data-translated="true"><span class="original-text">Typically, in larger Julia packages you will see module code organized into files, eg</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">通常、大きなJuliaパッケージでは、モジュールコードがファイルに整理されているのが見られます。例えば、</span></p><pre><code class="language-julia hljs">module SomeModule

# export, public, using, import statements are usually here; we discuss these below

include("file1.jl")
include("file2.jl")

end</code></pre><p data-translated="true"><span class="original-text">Files and file names are mostly unrelated to modules; modules are associated only with module expressions. One can have multiple files per module, and multiple modules per file. <code>include</code> behaves as if the contents of the source file were evaluated in the global scope of the including module. In this chapter, we use short and simplified examples, so we won't use <code>include</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ファイルとファイル名はモジュールとはほとんど無関係です。モジュールはモジュール式にのみ関連付けられます。モジュールごとに複数のファイルを持つことができ、ファイルごとに複数のモジュールを持つことができます。<code>include</code>は、ソースファイルの内容が含まれるモジュールのグローバルスコープで評価されたかのように振る舞います。この章では、短く簡略化された例を使用するため、<code>include</code>は使用しません。</span></p><p data-translated="true"><span class="original-text">The recommended style is not to indent the body of the module, since that would typically lead to whole files being indented. Also, it is common to use <code>UpperCamelCase</code> for module names (just like types), and use the plural form if applicable, especially if the module contains a similarly named identifier, to avoid name clashes. For example,</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">推奨されるスタイルは、モジュールの本体をインデントしないことです。そうしないと、通常はファイル全体がインデントされることになります。また、モジュール名には<code>UpperCamelCase</code>を使用するのが一般的であり（型と同様）、特にモジュールに同様の名前の識別子が含まれている場合は、名前の衝突を避けるために複数形を使用することが推奨されます。例えば、</span></p><pre><code class="language-julia hljs">module FastThings

struct FastThing
    ...
end

end</code></pre><h2 id="namespace-management" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#namespace-management">Namespace management</a><a id="namespace-management-1"></a><a class="docs-heading-anchor-permalink" href="#namespace-management" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#namespace-management">名前空間管理</a><a id="namespace-management-1"></a><a class="docs-heading-anchor-permalink" href="#namespace-management" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Namespace management refers to the facilities the language offers for making names in a module available in other modules. We discuss the related concepts and functionality below in detail.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">名前空間管理とは、モジュール内の名前を他のモジュールで利用可能にするために言語が提供する機能を指します。関連する概念と機能については、以下で詳しく説明します。</span></p><h3 id="Qualified-names" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Qualified-names">Qualified names</a><a id="Qualified-names-1"></a><a class="docs-heading-anchor-permalink" href="#Qualified-names" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Qualified-names">修飾名</a><a id="Qualified-names-1"></a><a class="docs-heading-anchor-permalink" href="#Qualified-names" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Names for functions, variables and types in the global scope like <code>sin</code>, <code>ARGS</code>, and <code>UnitRange</code> always belong to a module, called the <em>parent module</em>, which can be found interactively with <a href="../../base/base/index.html#Base.parentmodule"><code>parentmodule</code></a>, for example</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバルスコープ内の関数、変数、型の名前（例えば<code>sin</code>、<code>ARGS</code>、<code>UnitRange</code>）は常にモジュールに属し、そのモジュールは<em>親モジュール</em>と呼ばれます。これは、<a href="../../base/base/index.html#Base.parentmodule"><code>parentmodule</code></a>を使用して対話的に見つけることができます。例えば、</span></p><pre><code class="language-julia-repl hljs">julia&gt; parentmodule(UnitRange)
Base</code></pre><p data-translated="true"><span class="original-text">One can also refer to these names outside their parent module by prefixing them with their module, eg <code>Base.UnitRange</code>. This is called a <em>qualified name</em>. The parent module may be accessible using a chain of submodules like <code>Base.Math.sin</code>, where <code>Base.Math</code> is called the <em>module path</em>. Due to syntactic ambiguities, qualifying a name that contains only symbols, such as an operator, requires inserting a colon, e.g. <code>Base.:+</code>. A small number of operators additionally require parentheses, e.g. <code>Base.:(==)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの名前は、モジュール名を接頭辞として付けることで、親モジュールの外部からも参照できます。例えば、<code>Base.UnitRange</code>のように。これは<em>修飾名</em>と呼ばれます。親モジュールは、<code>Base.Math.sin</code>のようにサブモジュールのチェーンを使用してアクセスできる場合があります。ここで、<code>Base.Math</code>は<em>モジュールパス</em>と呼ばれます。構文の曖昧さのために、演算子のような記号のみを含む名前を修飾するにはコロンを挿入する必要があります。例えば、<code>Base.:+</code>のように。少数の演算子は、さらに括弧を必要とします。例えば、<code>Base.:(==)</code>のように。</span></p><p data-translated="true"><span class="original-text">If a name is qualified, then it is always <em>accessible</em>, and in case of a function, it can also have methods added to it by using the qualified name as the function name.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">名前が修飾されている場合、それは常に<em>アクセス可能</em>であり、関数の場合は、修飾名を関数名として使用することでメソッドを追加することもできます。</span></p><p data-translated="true"><span class="original-text">Within a module, a variable name can be “reserved” without assigning to it by declaring it as <code>global x</code>. This prevents name conflicts for globals initialized after load time. The syntax <code>M.x = y</code> does not work to assign a global in another module; global assignment is always module-local.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュール内では、変数名を<code>global x</code>として宣言することで「予約」することができます。これにより、ロード時以降に初期化されたグローバルの名前の衝突を防ぐことができます。<code>M.x = y</code>という構文は、他のモジュールでグローバルを割り当てるためには機能しません。グローバルの割り当ては常にモジュールローカルです。</span></p><h3 id="Export-lists" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Export-lists">Export lists</a><a id="Export-lists-1"></a><a class="docs-heading-anchor-permalink" href="#Export-lists" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Export-lists">リストのエクスポート</a><a id="Export-lists-1"></a><a class="docs-heading-anchor-permalink" href="#Export-lists" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Names (referring to functions, types, global variables, and constants) can be added to the <em>export list</em> of a module with <code>export</code>: these are the symbols that are imported when <code>using</code> the module. Typically, they are at or near the top of the module definition so that readers of the source code can find them easily, as in</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">名前（関数、型、グローバル変数、および定数を指す）は、<em>エクスポートリスト</em>に<code>export</code>を使って追加できます。これらは、<code>using</code>を使ってモジュールをインポートする際にインポートされるシンボルです。通常、これらはモジュール定義の最上部またはその近くに配置され、ソースコードの読者が簡単に見つけられるようになっています。例えば、</span></p><pre><code class="language-julia-repl hljs">julia&gt; module NiceStuff
       export nice, DOG
       struct Dog end      # singleton type, not exported
       const DOG = Dog()   # named instance, exported
       nice(x) = "nice $x" # function, exported
       end;
</code></pre><p data-translated="true"><span class="original-text">but this is just a style suggestion — a module can have multiple <code>export</code> statements in arbitrary locations.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、これは単なるスタイルの提案です — モジュールは任意の場所に複数の<code>export</code>ステートメントを持つことができます。</span></p><p data-translated="true"><span class="original-text">It is common to export names which form part of the API (application programming interface). In the above code, the export list suggests that users should use <code>nice</code> and <code>DOG</code>. However, since qualified names always make identifiers accessible, this is just an option for organizing APIs: unlike other languages, Julia has no facilities for truly hiding module internals.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">API（アプリケーションプログラミングインターフェース）の一部を形成する名前をエクスポートすることは一般的です。上記のコードでは、エクスポートリストはユーザーが<code>nice</code>と<code>DOG</code>を使用すべきであることを示唆しています。しかし、修飾された名前は常に識別子をアクセス可能にするため、これはAPIを整理するためのオプションに過ぎません。他の言語とは異なり、Juliaにはモジュール内部を真に隠すための機能はありません。</span></p><p data-translated="true"><span class="original-text">Also, some modules don't export names at all. This is usually done if they use common words, such as <code>derivative</code>, in their API, which could easily clash with the export lists of other modules. We will see how to manage name clashes below.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、一部のモジュールは名前を全くエクスポートしません。これは通常、<code>derivative</code>のような一般的な単語をAPIで使用する場合に行われ、他のモジュールのエクスポートリストと衝突する可能性があるためです。名前の衝突を管理する方法については、以下で説明します。</span></p><p data-translated="true"><span class="original-text">To mark a name as public without exporting it into the namespace of folks who call <code>using NiceStuff</code>, one can use <code>public</code> instead of <code>export</code>. This marks the public name(s) as part of the public API, but does not have any namespace implications. The <code>public</code> keyword is only available in Julia 1.11 and above. To maintain compatibility with Julia 1.10 and below, use the <code>@compat</code> macro from the <a href="https://github.com/JuliaLang/Compat.jl">Compat</a> package, or the version-aware construct</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">名前を公開としてマークし、<code>using NiceStuff</code>を呼び出す人々の名前空間にエクスポートしないようにするには、<code>export</code>の代わりに<code>public</code>を使用できます。これにより、公開名が公開APIの一部としてマークされますが、名前空間には影響を与えません。<code>public</code>キーワードはJulia 1.11以降でのみ利用可能です。Julia 1.10以前との互換性を維持するためには、<a href="https://github.com/JuliaLang/Compat.jl">Compat</a>パッケージの<code>@compat</code>マクロを使用するか、バージョン対応の構文を使用してください。</span></p><pre><code class="language-julia hljs">VERSION &gt;= v"1.11.0-DEV.469" &amp;&amp; eval(Meta.parse("public a, b, c"))</code></pre><h3 id="Standalone-using-and-import" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Standalone-using-and-import">Standalone <code>using</code> and <code>import</code></a><a id="Standalone-using-and-import-1"></a><a class="docs-heading-anchor-permalink" href="#Standalone-using-and-import" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Standalone-using-and-import">スタンドアロン<code>using</code>および<code>import</code></a><a id="Standalone-using-and-import-1"></a><a class="docs-heading-anchor-permalink" href="#Standalone-using-and-import" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">For interactive use, the most common way of loading a module is <code>using ModuleName</code>. This <a href="../code-loading/index.html#code-loading">loads</a> the code associated with <code>ModuleName</code>, and brings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">対話的に使用する場合、モジュールをロードする最も一般的な方法は<code>using ModuleName</code>です。これにより、<a href="../code-loading/index.html#code-loading">コードがロードされ</a>、<code>ModuleName</code>に関連付けられたコードが読み込まれます。</span></p><ol><li><p data-translated="true"><span class="original-text">the module name</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュール名</span></p></li><li><p data-translated="true"><span class="original-text">and the elements of the export list into the surrounding global namespace.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">およびエクスポートリストの要素が周囲のグローバル名前空間に取り込まれます。</span></p></li></ol><p data-translated="true"><span class="original-text">Technically, the statement <code>using ModuleName</code> means that a module called <code>ModuleName</code> will be available for resolving names as needed. When a global variable is encountered that has no definition in the current module, the system will search for it among variables exported by <code>ModuleName</code> and use it if it is found there. This means that all uses of that global within the current module will resolve to the definition of that variable in <code>ModuleName</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">技術的には、<code>using ModuleName</code>という文は、<code>ModuleName</code>という名前のモジュールが必要に応じて名前を解決するために利用可能であることを意味します。現在のモジュールに定義がないグローバル変数が見つかった場合、システムはそれを<code>ModuleName</code>によってエクスポートされた変数の中から探し、見つかった場合はそれを使用します。これは、現在のモジュール内でそのグローバル変数のすべての使用が<code>ModuleName</code>内のその変数の定義に解決されることを意味します。</span></p><p data-translated="true"><span class="original-text">To load a module from a package, the statement <code>using ModuleName</code> can be used. To load a module from a locally defined module, a dot needs to be added before the module name like <code>using .ModuleName</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パッケージからモジュールをロードするには、<code>using ModuleName</code>という文を使用できます。ローカルに定義されたモジュールからモジュールをロードするには、モジュール名の前にドットを追加する必要があります。例えば、<code>using .ModuleName</code>のようにします。</span></p><p data-translated="true"><span class="original-text">To continue with our example,</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例を続けると、</span></p><pre><code class="language-julia-repl hljs">julia&gt; using .NiceStuff</code></pre><p data-translated="true"><span class="original-text">would load the above code, making <code>NiceStuff</code> (the module name), <code>DOG</code> and <code>nice</code> available. <code>Dog</code> is not on the export list, but it can be accessed if the name is qualified with the module path (which here is just the module name) as <code>NiceStuff.Dog</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記のコードをロードし、<code>NiceStuff</code>（モジュール名）、<code>DOG</code>および<code>nice</code>を利用可能にします。<code>Dog</code>はエクスポートリストにはありませんが、モジュールパス（ここではモジュール名のみ）で名前を修飾すれば、<code>NiceStuff.Dog</code>としてアクセスできます。</span></p><p data-translated="true"><span class="original-text">Importantly, <strong><code>using ModuleName</code> is the only form for which export lists matter at all</strong>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">重要なことに、<strong><code>using ModuleName</code>はエクスポートリストが重要になる唯一の形式です</strong>。</span></p><p data-translated="true"><span class="original-text">In contrast,</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">対照的に、</span></p><pre><code class="language-julia-repl hljs">julia&gt; import .NiceStuff</code></pre><p data-translated="true"><span class="original-text">brings <em>only</em> the module name into scope. Users would need to use <code>NiceStuff.DOG</code>, <code>NiceStuff.Dog</code>, and <code>NiceStuff.nice</code> to access its contents. Usually, <code>import ModuleName</code> is used in contexts when the user wants to keep the namespace clean. As we will see in the next section <code>import .NiceStuff</code> is equivalent to <code>using .NiceStuff: NiceStuff</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><em>のみ</em>モジュール名をスコープに持ち込みます。ユーザーはその内容にアクセスするために<code>NiceStuff.DOG</code>、<code>NiceStuff.Dog</code>、および<code>NiceStuff.nice</code>を使用する必要があります。通常、<code>import ModuleName</code>は、ユーザーが名前空間をクリーンに保ちたいときに使用されます。次のセクションで見るように、<code>import .NiceStuff</code>は<code>using .NiceStuff: NiceStuff</code>と同等です。</span></p><p data-translated="true"><span class="original-text">You can combine multiple <code>using</code> and <code>import</code> statements of the same kind in a comma-separated expression, e.g.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複数の<code>using</code>および<code>import</code>文を同じ種類でカンマ区切りの式で組み合わせることができます。例えば、</span></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra, Random</code></pre><h3 id="using-and-import-with-specific-identifiers,-and-adding-methods" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#using-and-import-with-specific-identifiers,-and-adding-methods"><code>using</code> and <code>import</code> with specific identifiers, and adding methods</a><a id="using-and-import-with-specific-identifiers,-and-adding-methods-1"></a><a class="docs-heading-anchor-permalink" href="#using-and-import-with-specific-identifiers,-and-adding-methods" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#using-and-import-with-specific-identifiers,-and-adding-methods"><code>using</code>と<code>import</code>を特定の識別子で使用し、メソッドを追加する</a><a id="using-and-import-with-specific-identifiers,-and-adding-methods-1"></a><a class="docs-heading-anchor-permalink" href="#using-and-import-with-specific-identifiers,-and-adding-methods" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">When <code>using ModuleName:</code> or <code>import ModuleName:</code> is followed by a comma-separated list of names, the module is loaded, but <em>only those specific names are brought into the namespace</em> by the statement. For example,</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>using ModuleName:</code>または<code>import ModuleName:</code>の後にカンマ区切りの名前のリストが続くと、モジュールがロードされますが、<em>その特定の名前のみが名前空間に持ち込まれます</em>。例えば、</span></p><pre><code class="language-julia-repl hljs">julia&gt; using .NiceStuff: nice, DOG</code></pre><p data-translated="true"><span class="original-text">will import the names <code>nice</code> and <code>DOG</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">名前 <code>nice</code> と <code>DOG</code> をインポートします。</span></p><p data-translated="true"><span class="original-text">Importantly, the module name <code>NiceStuff</code> will <em>not</em> be in the namespace. If you want to make it accessible, you have to list it explicitly, as</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">重要なことに、モジュール名 <code>NiceStuff</code> は名前空間に <em>含まれません</em>。アクセス可能にしたい場合は、明示的にリストする必要があります。</span></p><pre><code class="language-julia-repl hljs">julia&gt; using .NiceStuff: nice, DOG, NiceStuff</code></pre><p data-translated="true"><span class="original-text">When two or more packages/modules export a name and that name does not refer to the same thing in each of the packages, and the packages are loaded via <code>using</code> without an explicit list of names, it is an error to reference that name without qualification. It is thus recommended that code intended to be forward-compatible with future versions of its dependencies and of Julia, e.g., code in released packages, list the names it uses from each loaded package, e.g., <code>using Foo: Foo, f</code> rather than <code>using Foo</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">2つ以上のパッケージ/モジュールが同じ名前をエクスポートし、その名前が各パッケージで同じものを指さない場合、明示的な名前のリストなしに <code>using</code> を介してパッケージがロードされると、その名前を修飾なしで参照することはエラーになります。したがって、依存関係やJuliaの将来のバージョンと互換性を持たせることを意図したコード、例えばリリースされたパッケージのコードは、各ロードされたパッケージから使用する名前をリストすることが推奨されます。例えば、<code>using Foo: Foo, f</code> のように、<code>using Foo</code> よりも。</span></p><p data-translated="true"><span class="original-text">Julia has two forms for seemingly the same thing because only <code>import ModuleName: f</code> allows adding methods to <code>f</code> <em>without a module path</em>. That is to say, the following example will give an error:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaには一見同じことのための2つの形式があります。なぜなら、<code>import ModuleName: f</code> のみが <code>f</code> に <em>モジュールパスなしで</em> メソッドを追加することを許可するからです。つまり、以下の例はエラーになります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; using .NiceStuff: nice

julia&gt; struct Cat end

julia&gt; nice(::Cat) = "nice 😸"
ERROR: invalid method definition in Main: function NiceStuff.nice must be explicitly imported to be extended
Stacktrace:
 [1] top-level scope
   @ none:1</code></pre><p data-translated="true"><span class="original-text">This error prevents accidentally adding methods to functions in other modules that you only intended to use.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このエラーは、他のモジュールの関数に意図せずメソッドを追加するのを防ぎます。</span></p><p data-translated="true"><span class="original-text">There are two ways to deal with this. You can always qualify function names with a module path:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これに対処する方法は2つあります。関数名を常にモジュールパスで修飾することができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; using .NiceStuff

julia&gt; struct Cat end

julia&gt; NiceStuff.nice(::Cat) = "nice 😸"</code></pre><p data-translated="true"><span class="original-text">Alternatively, you can <code>import</code> the specific function name:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">または、特定の関数名を <code>import</code> することができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; import .NiceStuff: nice

julia&gt; struct Mouse end

julia&gt; nice(::Mouse) = "nice 🐭"
nice (generic function with 3 methods)</code></pre><p data-translated="true"><span class="original-text">Which one you choose is a matter of style. The first form makes it clear that you are adding a method to a function in another module (remember, that the imports and the method definition may be in separate files), while the second one is shorter, which is especially convenient if you are defining multiple methods.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">どちらを選ぶかはスタイルの問題です。最初の形式は、他のモジュールの関数にメソッドを追加していることを明確に示します（インポートとメソッド定義が別のファイルにある可能性があることを忘れないでください）。一方、2番目の形式は短く、特に複数のメソッドを定義する場合に便利です。</span></p><p data-translated="true"><span class="original-text">Once a variable is made visible via <code>using</code> or <code>import</code>, a module may not create its own variable with the same name. Imported variables are read-only; assigning to a global variable always affects a variable owned by the current module, or else raises an error.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">変数が <code>using</code> または <code>import</code> を介して可視化されると、モジュールは同じ名前の独自の変数を作成できません。インポートされた変数は読み取り専用です；グローバル変数に代入すると、常に現在のモジュールが所有する変数に影響を与えるか、エラーが発生します。</span></p><h3 id="Renaming-with-as" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Renaming-with-as">Renaming with <code>as</code></a><a id="Renaming-with-as-1"></a><a class="docs-heading-anchor-permalink" href="#Renaming-with-as" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Renaming-with-as"><code>as</code> を使った名前の変更</a><a id="Renaming-with-as-1"></a><a class="docs-heading-anchor-permalink" href="#Renaming-with-as" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">An identifier brought into scope by <code>import</code> or <code>using</code> can be renamed with the keyword <code>as</code>. This is useful for working around name conflicts as well as for shortening names. For example, <code>Base</code> exports the function name <code>read</code>, but the CSV.jl package also provides <code>CSV.read</code>. If we are going to invoke CSV reading many times, it would be convenient to drop the <code>CSV.</code> qualifier. But then it is ambiguous whether we are referring to <code>Base.read</code> or <code>CSV.read</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>import</code> または <code>using</code> によってスコープに持ち込まれた識別子は、キーワード <code>as</code> を使って名前を変更できます。これは、名前の衝突を回避するためや、名前を短縮するために便利です。例えば、<code>Base</code> は関数名 <code>read</code> をエクスポートしますが、CSV.jl パッケージも <code>CSV.read</code> を提供しています。CSV 読み込みを何度も呼び出す場合、<code>CSV.</code> 修飾子を省略できると便利です。しかし、その場合、<code>Base.read</code> を指しているのか <code>CSV.read</code> を指しているのかが曖昧になります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; read;

julia&gt; import CSV: read
WARNING: ignoring conflicting import of CSV.read into Main</code></pre><p data-translated="true"><span class="original-text">Renaming provides a solution:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">名前変更は解決策を提供します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; import CSV: read as rd</code></pre><p data-translated="true"><span class="original-text">Imported packages themselves can also be renamed:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">インポートされたパッケージ自体も名前を変更できます：</span></p><pre><code class="language-julia hljs">import BenchmarkTools as BT</code></pre><p data-translated="true"><span class="original-text"><code>as</code> works with <code>using</code> only when a single identifier is brought into scope. For example <code>using CSV: read as rd</code> works, but <code>using CSV as C</code> does not, since it operates on all of the exported names in <code>CSV</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>as</code> は、スコープに持ち込まれるのが単一の識別子の場合にのみ <code>using</code> と共に機能します。例えば <code>using CSV: read as rd</code> は機能しますが、<code>using CSV as C</code> は機能しません。なぜなら、これは <code>CSV</code> のすべてのエクスポートされた名前に対して操作を行うからです。</span></p><h3 id="Mixing-multiple-using-and-import-statements" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Mixing-multiple-using-and-import-statements">Mixing multiple <code>using</code> and <code>import</code> statements</a><a id="Mixing-multiple-using-and-import-statements-1"></a><a class="docs-heading-anchor-permalink" href="#Mixing-multiple-using-and-import-statements" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Mixing-multiple-using-and-import-statements">複数の <code>using</code> と <code>import</code> ステートメントの混合</a><a id="Mixing-multiple-using-and-import-statements-1"></a><a class="docs-heading-anchor-permalink" href="#Mixing-multiple-using-and-import-statements" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">When multiple <code>using</code> or <code>import</code> statements of any of the forms above are used, their effect is combined in the order they appear. For example,</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記のいずれかの形式の複数の <code>using</code> または <code>import</code> ステートメントが使用されると、その効果は出現する順序で組み合わされます。例えば、</span></p><pre><code class="language-julia-repl hljs">julia&gt; using .NiceStuff         # exported names and the module name

julia&gt; import .NiceStuff: nice  # allows adding methods to unqualified functions
</code></pre><p data-translated="true"><span class="original-text">would bring all the exported names of <code>NiceStuff</code> and the module name itself into scope, and also allow adding methods to <code>nice</code> without prefixing it with a module name.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>using .NiceStuff</code> は <code>NiceStuff</code> のすべてのエクスポートされた名前とモジュール名自体をスコープに持ち込み、モジュール名を前置きせずに <code>nice</code> にメソッドを追加することを可能にします。</span></p><h3 id="Handling-name-conflicts" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Handling-name-conflicts">Handling name conflicts</a><a id="Handling-name-conflicts-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-name-conflicts" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Handling-name-conflicts">名前の衝突の処理</a><a id="Handling-name-conflicts-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-name-conflicts" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Consider the situation where two (or more) packages export the same name, as in</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">2つ（またはそれ以上）のパッケージが同じ名前をエクスポートする状況を考えてみましょう。例えば、</span></p><pre><code class="language-julia-repl hljs">julia&gt; module A
       export f
       f() = 1
       end
A
julia&gt; module B
       export f
       f() = 2
       end
B</code></pre><p data-translated="true"><span class="original-text">The statement <code>using .A, .B</code> works, but when you try to call <code>f</code>, you get an error with a hint</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>using .A, .B</code> ステートメントは機能しますが、<code>f</code> を呼び出そうとすると、エラーが発生し、ヒントが表示されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; using .A, .B

julia&gt; f
ERROR: UndefVarError: `f` not defined in `Main`
Hint: It looks like two or more modules export different bindings with this name, resulting in ambiguity. Try explicitly importing it from a particular module, or qualifying the name with the module it should come from.</code></pre><p data-translated="true"><span class="original-text">Here, Julia cannot decide which <code>f</code> you are referring to, so you have to make a choice. The following solutions are commonly used:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで、Juliaはどの<code>f</code>を指しているのか決められないので、選択をする必要があります。以下の解決策が一般的に使用されます：</span></p><ol><li><p data-translated="true"><span class="original-text">Simply proceed with qualified names like <code>A.f</code> and <code>B.f</code>. This makes the context clear to the reader of your code, especially if <code>f</code> just happens to coincide but has different meaning in various packages. For example, <code>degree</code> has various uses in mathematics, the natural sciences, and in everyday life, and these meanings should be kept separate.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">単に<code>A.f</code>や<code>B.f</code>のような修飾名を使って進めます。これにより、あなたのコードの読者にとって文脈が明確になります。特に、<code>f</code>がたまたま一致していても、さまざまなパッケージで異なる意味を持つ場合です。例えば、<code>degree</code>は数学、自然科学、日常生活でさまざまな使い方があり、これらの意味は分けておくべきです。</span></p></li><li><p data-translated="true"><span class="original-text">Use the <code>as</code> keyword above to rename one or both identifiers, eg</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>as</code>キーワードを上記のように使用して、一方または両方の識別子の名前を変更します。例えば、</span></p><pre><code class="language-julia-repl hljs">julia&gt; using .A: f as f

julia&gt; using .B: f as g
</code></pre><p data-translated="true"><span class="original-text">would make <code>B.f</code> available as <code>g</code>. Here, we are assuming that you did not use <code>using A</code> before, which would have brought <code>f</code> into the namespace.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>B.f</code>を<code>g</code>として利用可能にします。ここでは、<code>using A</code>を以前に使用していないと仮定しています。そうであれば、<code>f</code>が名前空間に取り込まれてしまいます。</span></p></li><li><p data-translated="true"><span class="original-text">When the names in question <em>do</em> share a meaning, it is common for one module to import it from another, or have a lightweight “base” package with the sole function of defining an interface like this, which can be used by other packages. It is conventional to have such package names end in <code>...Base</code> (which has nothing to do with Julia's <code>Base</code> module).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">問題の名前が<em>意味を共有する</em>場合、一般的には一つのモジュールが別のモジュールからそれをインポートするか、他のパッケージが使用できるようにこのようなインターフェースを定義するためだけの軽量な「ベース」パッケージを持つことがよくあります。このようなパッケージ名は<code>...Base</code>で終わるのが慣例です（これはJuliaの<code>Base</code>モジュールとは関係ありません）。</span></p></li></ol><h3 id="Precedence-order-of-definitions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Precedence-order-of-definitions">Precedence order of definitions</a><a id="Precedence-order-of-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Precedence-order-of-definitions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Precedence-order-of-definitions">定義の優先順位</a><a id="Precedence-order-of-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Precedence-order-of-definitions" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">There are in general four kinds of binding definitions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般的に、バインディング定義には4種類があります：</span></p><ol><li data-translated="true"><span class="original-text">Those provided via implicit import through <code>using M</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>using M</code>を通じて暗黙的に提供されるもの</span></li><li data-translated="true"><span class="original-text">Those provided via explicit import (e.g. <code>using M: x</code>, <code>import M: x</code>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">明示的なインポートを通じて提供されるもの（例：<code>using M: x</code>、<code>import M: x</code>）</span></li><li data-translated="true"><span class="original-text">Those declared implicitly as global (via <code>global x</code> without type specification)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型指定なしで<code>global x</code>として暗黙的に宣言されたもの</span></li><li data-translated="true"><span class="original-text">Those declared explicitly using definition syntax (<code>const</code>, <code>global x::T</code>, <code>struct</code>, etc.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">定義構文（<code>const</code>、<code>global x::T</code>、<code>struct</code>など）を使用して明示的に宣言されたもの</span></li></ol><p data-translated="true"><span class="original-text">Syntactically, we divide these into three precedence levels (from weakest to strongest)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文法的には、これらを三つの優先度レベル（弱いものから強いものへ）に分けます</span></p><ol><li data-translated="true"><span class="original-text">Implicit imports</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">暗黙のインポート</span></li><li data-translated="true"><span class="original-text">Implicit declarations</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">暗黙の宣言</span></li><li data-translated="true"><span class="original-text">Explicit declarations and imports</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">明示的な宣言とインポート</span></li></ol><p data-translated="true"><span class="original-text">In general, we permit replacement of weaker bindings by stronger ones:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般的に、弱いバインディングを強いものに置き換えることを許可します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; module M1; const x = 1; export x; end
Main.M1

julia&gt; using .M1

julia&gt; x # Implicit import from M1
1

julia&gt; begin; f() = (global x; x = 1) end

julia&gt; x # Implicit declaration
ERROR: UndefVarError: `x` not defined in `Main`
Suggestion: add an appropriate import or assignment. This global was declared but not assigned.

julia&gt; const x = 2 # Explicit declaration
2</code></pre><p data-translated="true"><span class="original-text">However, within the explicit precedence level, replacement is syntactically disallowed:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、明示的な優先度レベル内では、置き換えは文法的に許可されていません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; module M1; const x = 1; export x; end
Main.M1

julia&gt; import .M1: x

julia&gt; const x = 2
ERROR: cannot declare Main.x constant; it was already declared as an import
Stacktrace:
 [1] top-level scope
   @ REPL[3]:1</code></pre><p data-translated="true"><span class="original-text">or ignored:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">または無視されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; const y = 2
2

julia&gt; import .M1: x as y
WARNING: import of M1.x into Main conflicts with an existing identifier; ignored.</code></pre><p data-translated="true"><span class="original-text">The resolution of an implicit binding depends on the set of all <code>using</code>'d modules visible in the current world age. See <a href="../../base/math/#Base.:--Tuple{Any, Any}#Base.:--Tuple{Any, Any}">the manual chapter on world age</a> for more details.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">暗黙のバインディングの解決は、現在のワールドエイジで可視なすべての<code>using</code>されたモジュールのセットに依存します。詳細については、<a href="../../base/math/#Base.:--Tuple{Any, Any}#Base.:--Tuple{Any, Any}">ワールドエイジに関するマニュアルの章</a>を参照してください。</span></p><h3 id="Default-top-level-definitions-and-bare-modules" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Default-top-level-definitions-and-bare-modules">Default top-level definitions and bare modules</a><a id="Default-top-level-definitions-and-bare-modules-1"></a><a class="docs-heading-anchor-permalink" href="#Default-top-level-definitions-and-bare-modules" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Default-top-level-definitions-and-bare-modules">デフォルトのトップレベル定義とベアモジュール</a><a id="Default-top-level-definitions-and-bare-modules-1"></a><a class="docs-heading-anchor-permalink" href="#Default-top-level-definitions-and-bare-modules" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Modules automatically contain <code>using Core</code>, <code>using Base</code>, and definitions of the <a href="../../base/base/index.html#eval"><code>eval</code></a> and <a href="../../base/base/index.html#include"><code>include</code></a> functions, which evaluate expressions/files within the global scope of that module.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュールは自動的に <code>using Core</code>、<code>using Base</code>、および <a href="../../base/base/index.html#eval"><code>eval</code></a> と <a href="../../base/base/index.html#include"><code>include</code></a> 関数の定義を含み、これらはそのモジュールのグローバルスコープ内で式/ファイルを評価します。</span></p><p data-translated="true"><span class="original-text">If these default definitions are not wanted, modules can be defined using the keyword <a href="../../base/base/index.html#baremodule"><code>baremodule</code></a> instead (note: <code>Core</code> is still imported). In terms of <code>baremodule</code>, a standard <code>module</code> looks like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらのデフォルトの定義が不要な場合は、キーワード <a href="../../base/base/index.html#baremodule"><code>baremodule</code></a> を使用してモジュールを定義できます（注意：<code>Core</code> はまだインポートされます）。<code>baremodule</code> の観点から、標準の <code>module</code> は次のようになります：</span></p><pre><code class="nohighlight hljs">baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
include(p) = Base.include(Mod, p)

...

end</code></pre><p data-translated="true"><span class="original-text">If even <code>Core</code> is not wanted, a module that imports nothing and defines no names at all can be defined with <code>Module(:YourNameHere, false, false)</code> and code can be evaluated into it with <a href="../../base/base/index.html#Base.@eval"><code>@eval</code></a> or <a href="../../devdocs/init/index.html#Core.eval"><code>Core.eval</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もし <code>Core</code> さえ不要な場合は、何もインポートせず、名前を全く定義しないモジュールを <code>Module(:YourNameHere, false, false)</code> で定義でき、コードは <a href="../../base/base/index.html#Base.@eval"><code>@eval</code></a> または <a href="../../devdocs/init/index.html#Core.eval"><code>Core.eval</code></a> を使って評価できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; arithmetic = Module(:arithmetic, false, false)
Main.arithmetic

julia&gt; @eval arithmetic add(x, y) = $(+)(x, y)
add (generic function with 1 method)

julia&gt; arithmetic.add(12, 13)
25</code></pre><h3 id="Standard-modules" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Standard-modules">Standard modules</a><a id="Standard-modules-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-modules" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Standard-modules">標準モジュール</a><a id="Standard-modules-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-modules" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">There are three important standard modules:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">重要な標準モジュールは3つあります：</span></p><ul><li data-translated="true"><span class="original-text"><a href="../../base/base/index.html#Core"><code>Core</code></a> contains all functionality "built into" the language.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Core"><code>Core</code></a> は言語に「組み込まれた」すべての機能を含みます。</span></li><li data-translated="true"><span class="original-text"><a href="../../base/base/index.html#Base"><code>Base</code></a> contains basic functionality that is useful in almost all cases.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Base"><code>Base</code></a> はほぼすべてのケースで便利な基本機能を含みます。</span></li><li data-translated="true"><span class="original-text"><a href="../../base/base/index.html#Main"><code>Main</code></a> is the top-level module and the current module, when Julia is started.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Main"><code>Main</code></a> はトップレベルのモジュールであり、Juliaが起動したときの現在のモジュールです。</span></li></ul><div class="admonition is-info" id="Standard-library-modules-2859e1c45d193878"><header class="admonition-header">Standard library modules<a class="admonition-anchor" href="#Standard-library-modules-2859e1c45d193878" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">By default Julia ships with some standard library modules. These behave like regular Julia packages except that you don't need to install them explicitly. For example, if you wanted to perform some unit testing, you could load the <code>Test</code> standard library as follows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトでは、Juliaは標準ライブラリモジュールをいくつか同梱しています。これらは通常のJuliaパッケージのように振る舞いますが、明示的にインストールする必要はありません。たとえば、単体テストを実行したい場合は、次のように <code>Test</code> 標準ライブラリをロードできます：</span></p><pre><code class="language-julia hljs">using Test</code></pre></div></div><h2 id="Submodules-and-relative-paths" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Submodules-and-relative-paths">Submodules and relative paths</a><a id="Submodules-and-relative-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Submodules-and-relative-paths" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Submodules-and-relative-paths">サブモジュールと相対パス</a><a id="Submodules-and-relative-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Submodules-and-relative-paths" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Modules can contain <em>submodules</em>, nesting the same syntax <code>module ... end</code>. They can be used to introduce separate namespaces, which can be helpful for organizing complex codebases. Note that each <code>module</code> introduces its own <a href="../variables-and-scoping/index.html#scope-of-variables">scope</a>, so submodules do not automatically “inherit” names from their parent.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュールは<em>サブモジュール</em>を含むことができ、同じ構文<code>module ... end</code>をネストすることができます。これにより、複雑なコードベースを整理するために役立つ別々の名前空間を導入できます。各<code>module</code>は独自の<a href="../variables-and-scoping/index.html#scope-of-variables">スコープ</a>を導入するため、サブモジュールは親から名前を自動的に「継承」することはありません。</span></p><p data-translated="true"><span class="original-text">It is recommended that submodules refer to other modules within the enclosing parent module (including the latter) using <em>relative module qualifiers</em> in <code>using</code> and <code>import</code> statements. A relative module qualifier starts with a period (<code>.</code>), which corresponds to the current module, and each successive <code>.</code> leads to the parent of the current module. This should be followed by modules if necessary, and eventually the actual name to access, all separated by <code>.</code>s. As a special case, however, referring to the module root can be written without <code>.</code>, avoiding the need to count the depth to reach that module.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">サブモジュールは、<em>相対モジュール修飾子</em>を使用して、囲む親モジュール内の他のモジュール（親モジュールを含む）を参照することが推奨されます。相対モジュール修飾子は、現在のモジュールに対応するピリオド（<code>.</code>）で始まり、各連続する<code>.</code>は現在のモジュールの親を指します。必要に応じてモジュールが続き、最終的にアクセスする実際の名前が<code>.</code>で区切られて続きます。ただし、特別なケースとして、モジュールのルートを参照する場合は<code>.</code>なしで書くことができ、そのモジュールに到達するための深さを数える必要がありません。</span></p><p data-translated="true"><span class="original-text">Consider the following example, where the submodule <code>SubA</code> defines a function, which is then extended in its “sibling” module:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">以下の例を考えてみてください。ここで、サブモジュール<code>SubA</code>は関数を定義し、それが「兄弟」モジュールで拡張されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; module ParentModule
       module SubA
       export add_D  # exported interface
       const D = 3
       add_D(x) = x + D
       end
       using .SubA  # brings `add_D` into the namespace
       export add_D # export it from ParentModule too
       module SubB
       import ..SubA: add_D # relative path for a “sibling” module
       # import ParentModule.SubA: add_D # when in a package, such as when this is loaded by using or import, this would be equivalent to the previous import, but not at the REPL
       struct Infinity end
       add_D(x::Infinity) = x
       end
       end;
</code></pre><p data-translated="true"><span class="original-text">You may see code in packages, which, in a similar situation, uses import without the <code>.</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パッケージ内のコードでは、同様の状況で<code>.</code>なしでimportを使用しているのを見かけるかもしれません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; import ParentModule.SubA: add_D
ERROR: ArgumentError: Package ParentModule not found in current path.</code></pre><p data-translated="true"><span class="original-text">However, since this operates through <a href="../code-loading/index.html#code-loading">code loading</a>, it only works if <code>ParentModule</code> is in a package in a file. If <code>ParentModule</code> was defined at the REPL, it is necessary to use use relative paths:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、これは<a href="../code-loading/index.html#code-loading">コードの読み込み</a>を通じて動作するため、<code>ParentModule</code>がファイル内のパッケージにある場合にのみ機能します。<code>ParentModule</code>がREPLで定義されている場合は、相対パスを使用する必要があります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; import .ParentModule.SubA: add_D
</code></pre><p data-translated="true"><span class="original-text">Note that the order of definitions also matters if you are evaluating values. Consider</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">値を評価する場合、定義の順序も重要であることに注意してください。考えてみてください</span></p><pre><code class="language-julia hljs">module TestPackage

export x, y

x = 0

module Sub
using ..TestPackage
z = y # ERROR: UndefVarError: `y` not defined in `Main`
end

y = 1

end</code></pre><p data-translated="true"><span class="original-text">where <code>Sub</code> is trying to use <code>TestPackage.y</code> before it was defined, so it does not have a value.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで<code>Sub</code>は定義される前に<code>TestPackage.y</code>を使用しようとしているため、値を持っていません。</span></p><p data-translated="true"><span class="original-text">For similar reasons, you cannot use a cyclic ordering:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同様の理由から、循環的な順序を使用することはできません：</span></p><pre><code class="language-julia hljs">module A

module B
using ..C # ERROR: UndefVarError: `C` not defined in `Main.A`
end

module C
using ..B
end

end</code></pre><h2 id="Module-initialization-and-precompilation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Module-initialization-and-precompilation">Module initialization and precompilation</a><a id="Module-initialization-and-precompilation-1"></a><a class="docs-heading-anchor-permalink" href="#Module-initialization-and-precompilation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Module-initialization-and-precompilation">モジュールの初期化と事前コンパイル</a><a id="Module-initialization-and-precompilation-1"></a><a class="docs-heading-anchor-permalink" href="#Module-initialization-and-precompilation" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Large modules can take several seconds to load because executing all of the statements in a module often involves compiling a large amount of code. Julia creates precompiled caches of the module to reduce this time.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">大きなモジュールは、モジュール内のすべてのステートメントを実行することが多く、大量のコードをコンパイルする必要があるため、読み込むのに数秒かかることがあります。Juliaは、この時間を短縮するためにモジュールの事前コンパイルキャッシュを作成します。</span></p><p data-translated="true"><span class="original-text">Precompiled module files (sometimes called "cache files") are created and used automatically when <code>import</code> or <code>using</code> loads a module. If the cache file(s) do not yet exist, the module will be compiled and saved for future reuse. You can also manually call <a href="../../base/base/index.html#Base.compilecache"><code>Base.compilecache(Base.identify_package("modulename"))</code></a> to create these files without loading the module. The resulting cache files will be stored in the <code>compiled</code> subfolder of <code>DEPOT_PATH[1]</code>. If nothing about your system changes, such cache files will be used when you load the module with <code>import</code> or <code>using</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プリコンパイルされたモジュールファイル（時には「キャッシュファイル」と呼ばれる）は、<code>import</code>または<code>using</code>がモジュールをロードする際に自動的に作成され、使用されます。キャッシュファイルがまだ存在しない場合、モジュールはコンパイルされ、将来の再利用のために保存されます。また、モジュールをロードせずにこれらのファイルを作成するために、<a href="../../base/base/index.html#Base.compilecache"><code>Base.compilecache(Base.identify_package("modulename"))</code></a>を手動で呼び出すこともできます。生成されたキャッシュファイルは、<code>DEPOT_PATH[1]</code>の<code>compiled</code>サブフォルダーに保存されます。システムに変更がない限り、そのようなキャッシュファイルは<code>import</code>または<code>using</code>でモジュールをロードする際に使用されます。</span></p><p data-translated="true"><span class="original-text">Precompilation cache files store definitions of modules, types, methods, and constants. They may also store method specializations and the code generated for them, but this typically requires that the developer add explicit <a href="../../base/base/index.html#Base.precompile"><code>precompile</code></a> directives or execute workloads that force compilation during the package build.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プリコンパイルキャッシュファイルは、モジュール、型、メソッド、および定数の定義を保存します。また、メソッドの特化やそれに対して生成されたコードも保存する場合がありますが、これは通常、開発者が明示的な<a href="../../base/base/index.html#Base.precompile"><code>precompile</code></a>ディレクティブを追加するか、パッケージビルド中にコンパイルを強制するワークロードを実行する必要があります。</span></p><p data-translated="true"><span class="original-text">However, if you update the module's dependencies or change its source code, the module is automatically recompiled upon <code>using</code> or <code>import</code>. Dependencies are modules it imports, the Julia build, files it includes, or explicit dependencies declared by <a href="../../base/base/index.html#Base.include_dependency"><code>include_dependency(path)</code></a> in the module file(s).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、モジュールの依存関係を更新したり、ソースコードを変更したりすると、<code>using</code>または<code>import</code>時にモジュールが自動的に再コンパイルされます。依存関係とは、モジュールがインポートするモジュール、Juliaビルド、含まれるファイル、またはモジュールファイル内で<a href="../../base/base/index.html#Base.include_dependency"><code>include_dependency(path)</code></a>によって宣言された明示的な依存関係です。</span></p><p data-translated="true"><span class="original-text">For file dependencies loaded by <code>include</code>, a change is determined by examining whether the file size (<code>fsize</code>) or content (condensed into a hash) is unchanged. For file dependencies loaded by <code>include_dependency</code> a change is determined by examining whether the modification time (<code>mtime</code>) is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can't copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in <code>require</code> matches the path that had created the precompile file. It also takes into account the set of dependencies already loaded into the current process and won't recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache. Finally, it takes account of changes in any <a href="../code-loading/index.html#preferences">compile-time preferences</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ファイル依存関係が<code>include</code>によってロードされる場合、変更はファイルサイズ（<code>fsize</code>）または内容（ハッシュに圧縮されたもの）が変更されていないかどうかを調べることによって判断されます。<code>include_dependency</code>によってロードされるファイル依存関係の場合、変更は修正時間（<code>mtime</code>）が変更されていないか、最も近い秒に切り捨てられた修正時間と等しいかどうかを調べることによって判断されます（サブ秒精度でmtimeをコピーできないシステムに対応するため）。また、<code>require</code>の検索ロジックによって選択されたファイルへのパスがプリコンパイルファイルを作成したパスと一致するかどうかも考慮されます。さらに、現在のプロセスにすでにロードされている依存関係のセットも考慮され、ファイルが変更されたり消えたりしても、それらのモジュールは再コンパイルされず、実行中のシステムとプリコンパイルキャッシュとの間に互換性のない状態を作成しないようにします。最後に、任意の<a href="../code-loading/index.html#preferences">コンパイル時の設定</a>の変更も考慮されます。</span></p><p data-translated="true"><span class="original-text">If you know that a module is <em>not</em> safe to precompile (for example, for one of the reasons described below), you should put <code>__precompile__(false)</code> in the module file (typically placed at the top). This will cause <code>Base.compilecache</code> to throw an error, and will cause <code>using</code> / <code>import</code> to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュールが<em>安全でない</em>ことがわかっている場合（例えば、以下に説明されている理由の1つのため）、モジュールファイルに<code>__precompile__(false)</code>を記述する必要があります（通常はファイルの先頭に配置します）。これにより、<code>Base.compilecache</code>がエラーをスローし、<code>using</code> / <code>import</code>がそれを現在のプロセスに直接ロードし、プリコンパイルとキャッシュをスキップします。これにより、他のプリコンパイルされたモジュールによってモジュールがインポートされるのを防ぎます。</span></p><p data-translated="true"><span class="original-text">You may need to be aware of certain behaviors inherent in the creation of incremental shared libraries which may require care when writing your module. For example, external state is not preserved. To accommodate this, explicitly separate any initialization steps that must occur at <em>runtime</em> from steps that can occur at <em>compile time</em>. For this purpose, Julia allows you to define an <code>__init__()</code> function in your module that executes any initialization steps that must occur at runtime. This function will not be called during compilation (<code>--output-*</code>). Effectively, you can assume it will be run exactly once in the lifetime of the code. You may, of course, call it manually if necessary, but the default is to assume this function deals with computing state for the local machine, which does not need to be – or even should not be – captured in the compiled image. It will be called after the module is loaded into a process, including if it is being loaded into an incremental compile (<code>--output-incremental=yes</code>), but not if it is being loaded into a full-compilation process.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">インクリメンタル共有ライブラリの作成に固有の特定の動作に注意する必要があるかもしれません。これは、モジュールを書く際に注意が必要です。例えば、外部状態は保持されません。これに対応するために、<em>ランタイム</em>で発生する必要がある初期化ステップと<em>コンパイル時</em>に発生できるステップを明示的に分離してください。この目的のために、Juliaはモジュール内に<code>__init__()</code>関数を定義することを許可し、ランタイムで発生する必要がある初期化ステップを実行します。この関数はコンパイル中（<code>--output-*</code>）には呼び出されません。実際には、コードのライフサイクルの中で正確に1回実行されると仮定できます。もちろん、必要に応じて手動で呼び出すこともできますが、デフォルトではこの関数がローカルマシンの状態を計算することを扱うものであると仮定され、コンパイルされたイメージにキャプチャする必要はありませんし、キャプチャすべきではありません。モジュールがプロセスにロードされた後、<code>--output-incremental=yes</code>でインクリメンタルコンパイルにロードされる場合も含めて呼び出されますが、フルコンパイルプロセスにロードされる場合は呼び出されません。</span></p><p data-translated="true"><span class="original-text">In particular, if you define a <code>function __init__()</code> in a module, then Julia will call <code>__init__()</code> immediately <em>after</em> the module is loaded (e.g., by <code>import</code>, <code>using</code>, or <code>require</code>) at runtime for the <em>first</em> time (i.e., <code>__init__</code> is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their <code>__init__</code> functions called <em>before</em> the <code>__init__</code> of the enclosing module. This is also synchronized across threads, so that code can safely rely upon this ordering of effects, such that all <code>__init__</code> will have run, in dependency ordering, before the <code>using</code> result is completed. They may run concurrently with other <code>__init__</code> methods which are not dependencies however, so be careful when accessing any shared state outside the current module to use locks when needed.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特に、モジュール内に<code>function __init__()</code>を定義すると、Juliaはモジュールがロードされた直後（例えば、<code>import</code>、<code>using</code>、または<code>require</code>によって）に<code>__init__()</code>を実行時に<em>最初に</em>呼び出します（つまり、<code>__init__</code>は1回だけ呼び出され、モジュール内のすべてのステートメントが実行された後にのみ呼び出されます）。モジュールが完全にインポートされた後に呼び出されるため、すべてのサブモジュールや他のインポートされたモジュールの<code>__init__</code>関数は、外側のモジュールの<code>__init__</code>の<em>前に</em>呼び出されます。これはスレッド間で同期されているため、コードはこの効果の順序に安全に依存でき、すべての<code>__init__</code>が依存関係の順序で実行されることが保証されます。ただし、依存関係ではない他の<code>__init__</code>メソッドと同時に実行される可能性があるため、現在のモジュールの外部で共有状態にアクセスする際には、必要に応じてロックを使用することに注意してください。</span></p><p data-translated="true"><span class="original-text">Two typical uses of <code>__init__</code> are calling runtime initialization functions of external C libraries and initializing global constants that involve pointers returned by external libraries. For example, suppose that we are calling a C library <code>libfoo</code> that requires us to call a <code>foo_init()</code> initialization function at runtime. Suppose that we also want to define a global constant <code>foo_data_ptr</code> that holds the return value of a <code>void *foo_data()</code> function defined by <code>libfoo</code> – this constant must be initialized at runtime (not at compile time) because the pointer address will change from run to run. You could accomplish this by defining the following <code>__init__</code> function in your module:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>__init__</code>の2つの典型的な使用法は、外部Cライブラリのランタイム初期化関数を呼び出すことと、外部ライブラリによって返されるポインタを含むグローバル定数を初期化することです。例えば、ランタイムで<code>foo_init()</code>初期化関数を呼び出す必要があるCライブラリ<code>libfoo</code>を呼び出すとします。また、<code>libfoo</code>によって定義された<code>void *foo_data()</code>関数の戻り値を保持するグローバル定数<code>foo_data_ptr</code>を定義したいとします。この定数は、ポインタアドレスが実行ごとに変わるため、ランタイムで初期化する必要があります（コンパイル時ではありません）。これを達成するために、モジュール内に次の<code>__init__</code>関数を定義できます。</span></p><pre><code class="language-julia hljs">const foo_data_ptr = Ref{Ptr{Cvoid}}(0)
function __init__()
    ccall((:foo_init, :libfoo), Cvoid, ())
    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())
    nothing
end</code></pre><p data-translated="true"><span class="original-text">Notice that it is perfectly possible to define a global inside a function like <code>__init__</code>; this is one of the advantages of using a dynamic language. But by making it a constant at global scope, we can ensure that the type is known to the compiler and allow it to generate better optimized code. Obviously, any other globals in your module that depends on <code>foo_data_ptr</code> would also have to be initialized in <code>__init__</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>__init__</code>のような関数内でグローバルを定義することは完全に可能であり、これは動的言語を使用する利点の1つです。しかし、グローバルスコープで定数にすることで、型がコンパイラに知られ、より最適化されたコードを生成できるようになります。もちろん、<code>foo_data_ptr</code>に依存するモジュール内の他のグローバルも<code>__init__</code>で初期化する必要があります。</span></p><p data-translated="true"><span class="original-text">Constants involving most Julia objects that are not produced by <a href="../../base/c/index.html#ccall"><code>ccall</code></a> do not need to be placed in <code>__init__</code>: their definitions can be precompiled and loaded from the cached module image. This includes complicated heap-allocated objects like arrays. However, any routine that returns a raw pointer value must be called at runtime for precompilation to work (<a href="../../base/c/index.html#Core.Ptr"><code>Ptr</code></a> objects will turn into null pointers unless they are hidden inside an <a href="../../base/base/index.html#Base.isbits"><code>isbits</code></a> object). This includes the return values of the Julia functions <a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a> and <a href="../../base/c/index.html#Base.pointer"><code>pointer</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/c/index.html#ccall"><code>ccall</code></a>によって生成されないほとんどのJuliaオブジェクトに関する定数は<code>__init__</code>に配置する必要はありません：その定義はプリコンパイルされ、キャッシュされたモジュールイメージからロードできます。これには、配列のような複雑なヒープ割り当てオブジェクトが含まれます。ただし、生のポインタ値を返すルーチンは、プリコンパイルが機能するためにランタイムで呼び出す必要があります（<a href="../../base/c/index.html#Core.Ptr"><code>Ptr</code></a>オブジェクトは、<a href="../../base/base/index.html#Base.isbits"><code>isbits</code></a>オブジェクトの内部に隠されていない限り、ヌルポインタに変わります）。これには、Julia関数<a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a>および<a href="../../base/c/index.html#Base.pointer"><code>pointer</code></a>の戻り値が含まれます。</span></p><p data-translated="true"><span class="original-text">When using precompilation, it is important to keep a clear sense of the distinction between the compilation phase and the execution phase. In this mode, it will often be much more clearly apparent that Julia is a compiler which allows execution of arbitrary Julia code, not a standalone interpreter that also generates compiled code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プリコンパイルを使用する際には、コンパイルフェーズと実行フェーズの違いを明確に理解しておくことが重要です。このモードでは、Juliaが任意のJuliaコードを実行できるコンパイラであり、コンパイルされたコードも生成するスタンドアロンのインタプリタではないことが、より明確に示されることがよくあります。</span></p><p data-translated="true"><span class="original-text">Other known potential failure scenarios include:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">他に知られている潜在的な失敗シナリオには、</span></p><ol><li><p data-translated="true"><span class="original-text">Global counters (for example, for attempting to uniquely identify objects). Consider the following code snippet:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバルカウンタ（例えば、オブジェクトを一意に識別するためのもの）があります。次のコードスニペットを考えてみてください：</span></p><pre><code class="language-julia hljs">mutable struct UniquedById
    myid::Int
    let counter = 0
        UniquedById() = new(counter += 1)
    end
end</code></pre><p data-translated="true"><span class="original-text">while the intent of this code was to give every instance a unique id, the counter value is recorded at the end of compilation. All subsequent usages of this incrementally compiled module will start from that same counter value.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このコードの意図は、すべてのインスタンスに一意のIDを与えることでしたが、カウンタの値はコンパイルの最後に記録されます。このインクリメンタルにコンパイルされたモジュールのその後のすべての使用は、同じカウンタ値から始まります。</span></p><p data-translated="true"><span class="original-text">Note that <code>objectid</code> (which works by hashing the memory pointer) has similar issues (see notes on <code>Dict</code> usage below).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メモリポインタをハッシュ化することで動作する <code>objectid</code> も同様の問題があります（以下の <code>Dict</code> 使用に関するノートを参照してください）。</span></p><p data-translated="true"><span class="original-text">One alternative is to use a macro to capture <a href="../../base/base/index.html#Base.@__MODULE__"><code>@__MODULE__</code></a> and store it alone with the current <code>counter</code> value, however, it may be better to redesign the code to not depend on this global state.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">代替案の一つは、<a href="../../base/base/index.html#Base.@__MODULE__"><code>@__MODULE__</code></a> をキャプチャして現在の <code>counter</code> 値と一緒に保存するマクロを使用することですが、このグローバル状態に依存しないようにコードを再設計する方が良いかもしれません。</span></p></li><li><p data-translated="true"><span class="original-text">Associative collections (such as <code>Dict</code> and <code>Set</code>) need to be re-hashed in <code>__init__</code>. (In the future, a mechanism may be provided to register an initializer function.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">連想コレクション（<code>Dict</code> や <code>Set</code> など）は、<code>__init__</code> で再ハッシュする必要があります。（将来的には、初期化関数を登録するメカニズムが提供されるかもしれません。）</span></p></li><li><p data-translated="true"><span class="original-text">Depending on compile-time side-effects persisting through load-time. Example include: modifying arrays or other variables in other Julia modules; maintaining handles to open files or devices; storing pointers to other system resources (including memory);</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ロード時に持続するコンパイル時の副作用に依存すること。例としては、他のJuliaモジュール内の配列や他の変数を変更すること、オープンファイルやデバイスへのハンドルを維持すること、他のシステムリソース（メモリを含む）へのポインタを保存することが含まれます。</span></p></li><li><p data-translated="true"><span class="original-text">Creating accidental "copies" of global state from another module, by referencing it directly instead of via its lookup path. For example, (in global scope):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">他のモジュールから直接参照することによって、グローバル状態の偶発的な「コピー」を作成すること。例えば、（グローバルスコープ内で）：</span></p><pre><code class="language-julia hljs">#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#
# instead use accessor functions:
getstdout() = Base.stdout #= best option =#
# or move the assignment into the runtime:
__init__() = global mystdout = Base.stdout #= also works =#</code></pre></li></ol><p data-translated="true"><span class="original-text">Several additional restrictions are placed on the operations that can be done while precompiling code to help the user avoid other wrong-behavior situations:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コードをプリコンパイルする際に行える操作には、他の誤った動作の状況を避けるためにいくつかの追加の制限が課されています：</span></p><ol><li data-translated="true"><span class="original-text">Calling <a href="../../base/base/index.html#eval"><code>eval</code></a> to cause a side-effect in another module. This will also cause a warning to be emitted when the incremental precompile flag is set.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#eval"><code>eval</code></a>を呼び出して、別のモジュールに副作用を引き起こします。これは、インクリメンタルプリコンパイルフラグが設定されているときに警告が発生する原因にもなります。</span></li><li data-translated="true"><span class="original-text"><code>global const</code> statements from local scope after <code>__init__()</code> has been started (see issue #12010 for plans to add an error for this)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>global const</code>文は、<code>__init__()</code>が開始された後のローカルスコープから（これに関するエラーを追加する計画については、問題#12010を参照）</span></li><li data-translated="true"><span class="original-text">Replacing a module is a runtime error while doing an incremental precompile.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュールを置き換えることは、インクリメンタルプリコンパイル中のランタイムエラーです。</span></li></ol><p data-translated="true"><span class="original-text">A few other points to be aware of:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">注意すべき他のいくつかのポイント：</span></p><ol><li data-translated="true"><span class="original-text">No code reload / cache invalidation is performed after changes are made to the source files themselves, (including by <code>Pkg.update</code>), and no cleanup is done after <code>Pkg.rm</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ソースファイル自体に変更が加えられた後（<code>Pkg.update</code>による変更を含む）、コードの再読み込みやキャッシュの無効化は行われず、<code>Pkg.rm</code>の後にクリーンアップも行われません。</span></li><li data-translated="true"><span class="original-text">The memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets its own copy)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">再形成された配列のメモリ共有の動作はプリコンパイルによって無視されます（各ビューは独自のコピーを取得します）。</span></li><li data-translated="true"><span class="original-text">Expecting the filesystem to be unchanged between compile-time and runtime e.g. <a href="../../base/base/index.html#Base.@__FILE__"><code>@__FILE__</code></a>/<code>source_path()</code> to find resources at runtime, or the BinDeps <code>@checked_lib</code> macro. Sometimes this is unavoidable. However, when possible, it can be good practice to copy resources into the module at compile-time so they won't need to be found at runtime.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コンパイル時とランタイムの間でファイルシステムが変更されないことを期待しています。例えば、<a href="../../base/base/index.html#Base.@__FILE__"><code>@__FILE__</code></a>/<code>source_path()</code>を使用してランタイムでリソースを見つけるか、BinDepsの<code>@checked_lib</code>マクロを使用します。これは時には避けられません。しかし、可能な場合は、リソースをコンパイル時にモジュールにコピーして、ランタイムで見つける必要がないようにすることが良いプラクティスです。</span></li><li data-translated="true"><span class="original-text"><code>WeakRef</code> objects and finalizers are not currently handled properly by the serializer (this will be fixed in an upcoming release).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>WeakRef</code>オブジェクトとファイナライザは、現在シリアライザによって適切に処理されていません（これは今後のリリースで修正される予定です）。</span></li><li data-translated="true"><span class="original-text">It is usually best to avoid capturing references to instances of internal metadata objects such as <code>Method</code>, <code>MethodInstance</code>, <code>MethodTable</code>, <code>TypeMapLevel</code>, <code>TypeMapEntry</code> and fields of those objects, as this can confuse the serializer and may not lead to the outcome you desire. It is not necessarily an error to do this, but you simply need to be prepared that the system will try to copy some of these and to create a single unique instance of others.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Method</code>、<code>MethodInstance</code>、<code>MethodTable</code>、<code>TypeMapLevel</code>、<code>TypeMapEntry</code>などの内部メタデータオブジェクトのインスタンスへの参照をキャプチャすることは通常避けるのが最良です。これはシリアライザを混乱させる可能性があり、望む結果を得られないかもしれません。これを行うことは必ずしもエラーではありませんが、システムがこれらの一部をコピーし、他のもののユニークなインスタンスを作成しようとすることに備えておく必要があります。</span></li></ol><p data-translated="true"><span class="original-text">It is sometimes helpful during module development to turn off incremental precompilation. The command line flag <code>--compiled-modules={yes|no|existing}</code> enables you to toggle module precompilation on and off. When Julia is started with <code>--compiled-modules=no</code> the serialized modules in the compile cache are ignored when loading modules and module dependencies. In some cases, you may want to load existing precompiled modules, but not create new ones. This can be done by starting Julia with <code>--compiled-modules=existing</code>. More fine-grained control is available with <code>--pkgimages={yes|no|existing}</code>, which only affects native-code storage during precompilation. <code>Base.compilecache</code> can still be called manually. The state of this command line flag is passed to <code>Pkg.build</code> to disable automatic precompilation triggering when installing, updating, and explicitly building packages.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュール開発中にインクリメンタルプリコンパイルをオフにすることが時には役立ちます。コマンドラインフラグ<code>--compiled-modules={yes|no|existing}</code>を使用すると、モジュールのプリコンパイルをオンとオフに切り替えることができます。<code>--compiled-modules=no</code>でJuliaを起動すると、コンパイルキャッシュ内のシリアライズされたモジュールは、モジュールとモジュール依存関係の読み込み時に無視されます。場合によっては、既存のプリコンパイルされたモジュールを読み込みたいが、新しいものを作成したくないことがあります。これは、<code>--compiled-modules=existing</code>でJuliaを起動することで実行できます。<code>--pkgimages={yes|no|existing}</code>を使用すると、プリコンパイル中のネイティブコードストレージにのみ影響を与えるより詳細な制御が可能です。<code>Base.compilecache</code>は手動で呼び出すことができます。このコマンドラインフラグの状態は、<code>Pkg.build</code>に渡され、パッケージのインストール、更新、および明示的なビルド時に自動プリコンパイルトリガーを無効にします。</span></p><p data-translated="true"><span class="original-text">You can also debug some precompilation failures with environment variables. Setting <code>JULIA_VERBOSE_LINKING=true</code> may help resolve failures in linking shared libraries of compiled native code. See the <strong>Developer Documentation</strong> part of the Julia manual, where you will find further details in the section documenting Julia's internals under "Package Images".</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">環境変数を使用して、いくつかのプリコンパイルの失敗をデバッグすることもできます。<code>JULIA_VERBOSE_LINKING=true</code>を設定すると、コンパイルされたネイティブコードの共有ライブラリのリンクに関する失敗を解決するのに役立つ場合があります。詳細については、Juliaマニュアルの<strong>開発者ドキュメント</strong>の部分を参照してください。そこでは、「パッケージイメージ」に関するJuliaの内部を文書化したセクションでさらに詳しい情報が見つかります。</span></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interfaces/index.html">« Interfaces</a><a class="docs-footer-nextpage" href="../documentation/index.html">Documentation »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>