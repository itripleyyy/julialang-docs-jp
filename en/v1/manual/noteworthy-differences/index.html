<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Noteworthy Differences from other Languages · The Julia Language</title><meta name="title" content="Noteworthy Differences from other Languages · The Julia Language"><meta property="og:title" content="Noteworthy Differences from other Languages · The Julia Language"><meta property="twitter:title" content="Noteworthy Differences from other Languages · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/noteworthy-differences/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/noteworthy-differences/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bi1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li class="is-active"><a class="tocitem" href="">Noteworthy Differences from other Languages</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Noteworthy-differences-from-MATLAB"><span>Noteworthy differences from MATLAB</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Noteworthy-differences-from-MATLAB"><span>MATLABとの注目すべき違い</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Noteworthy-differences-from-R"><span>Noteworthy differences from R</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Noteworthy-differences-from-R"><span>Rとの注目すべき違い</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Noteworthy-differences-from-Python"><span>Noteworthy differences from Python</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Noteworthy-differences-from-Python"><span>Pythonとの注目すべき違い</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Noteworthy-differences-from-C/C"><span>Noteworthy differences from C/C++</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Noteworthy-differences-from-C/C"><span>C/C++との注目すべき違い</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Noteworthy-differences-from-Common-Lisp"><span>Noteworthy differences from Common Lisp</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Noteworthy-differences-from-Common-Lisp"><span>Common Lispとの注目すべき違い</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">他の言語との注目すべき違い</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">他の言語との注目すべき違い</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/noteworthy-differences.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Noteworthy-Differences-from-other-Languages" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Noteworthy-Differences-from-other-Languages">Noteworthy Differences from other Languages</a><a id="Noteworthy-Differences-from-other-Languages-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-Differences-from-other-Languages" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Noteworthy-Differences-from-other-Languages">他の言語との注目すべき違い</a><a id="Noteworthy-Differences-from-other-Languages-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-Differences-from-other-Languages" title="Permalink"></a></span></h1><h2 id="Noteworthy-differences-from-MATLAB" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-MATLAB">Noteworthy differences from MATLAB</a><a id="Noteworthy-differences-from-MATLAB-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-MATLAB" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-MATLAB">MATLABとの注目すべき違い</a><a id="Noteworthy-differences-from-MATLAB-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-MATLAB" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Although MATLAB users may find Julia's syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. The following are some noteworthy differences that may trip up Julia users accustomed to MATLAB:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">MATLABユーザーはJuliaの構文に親しみを感じるかもしれませんが、JuliaはMATLABのクローンではありません。構文的および機能的な違いが大きくあります。以下は、MATLABに慣れたJuliaユーザーを混乱させる可能性のある注目すべき違いです:</span></p><ul><li data-translated="true"><span class="original-text">Julia arrays are indexed with square brackets, <code>A[i,j]</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの配列は角括弧でインデックス指定されます、<code>A[i,j]</code>。</span></li><li data-translated="true"><span class="original-text">Julia arrays are not copied when assigned to another variable. After <code>A = B</code>, changing elements of <code>B</code> will modify <code>A</code> as well. To avoid this, use <code>A = copy(B)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの配列は別の変数に代入されるときにコピーされません。<code>A = B</code>の後、<code>B</code>の要素を変更すると、<code>A</code>も変更されます。これを避けるためには、<code>A = copy(B)</code>を使用します。</span></li><li data-translated="true"><span class="original-text">Julia values are not copied when passed to a function. If a function modifies an array, the changes will be visible in the caller.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの値は関数に渡されるときにコピーされません。関数が配列を変更すると、その変更は呼び出し元で見えるようになります。</span></li><li data-translated="true"><span class="original-text">Julia does not automatically grow arrays in an assignment statement. Whereas in MATLAB <code>a(4) = 3.2</code> can create the array <code>a = [0 0 0 3.2]</code> and <code>a(5) = 7</code> can grow it into <code>a = [0 0 0 3.2 7]</code>, the corresponding Julia statement <code>a[5] = 7</code> throws an error if the length of <code>a</code> is less than 5 or if this statement is the first use of the identifier <code>a</code>. Julia has <a href="../../base/collections/index.html#Base.push!"><code>push!</code></a> and <a href="../../base/collections/index.html#Base.append!"><code>append!</code></a>, which grow <code>Vector</code>s much more efficiently than MATLAB's <code>a(end+1) = val</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは代入文で配列を自動的に成長させません。MATLABでは<code>a(4) = 3.2</code>が配列<code>a = [0 0 0 3.2]</code>を作成し、<code>a(5) = 7</code>がそれを<code>a = [0 0 0 3.2 7]</code>に成長させることができますが、対応するJuliaの文<code>a[5] = 7</code>は、<code>a</code>の長さが5未満であるか、この文が<code>a</code>の識別子の最初の使用である場合にエラーを投げます。Juliaには、<a href="../../base/collections/index.html#Base.push!"><code>push!</code></a>や<a href="../../base/collections/index.html#Base.append!"><code>append!</code></a>があり、これらはMATLABの<code>a(end+1) = val</code>よりもはるかに効率的に<code>Vector</code>を成長させます。</span></li><li data-translated="true"><span class="original-text">The imaginary unit <code>sqrt(-1)</code> is represented in Julia as <a href="../../base/numbers/index.html#Base.im"><code>im</code></a>, not <code>i</code> or <code>j</code> as in MATLAB.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">虚数単位<code>sqrt(-1)</code>は、Juliaでは<a href="../../base/numbers/index.html#Base.im"><code>im</code></a>として表され、MATLABのように<code>i</code>や<code>j</code>ではありません。</span></li><li data-translated="true"><span class="original-text">In Julia, literal numbers without a decimal point (such as <code>42</code>) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, <code>julia&gt; a = -1; 2^a</code> throws a domain error, as the result is not an integer (see <a href="../faq/index.html#faq-domain-errors">the FAQ entry on domain errors</a> for details).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、小数点のないリテラル数（例えば<code>42</code>）は浮動小数点数ではなく整数を生成します。その結果、いくつかの操作は浮動小数点数を期待する場合にドメインエラーを投げることがあります。例えば、<code>julia&gt; a = -1; 2^a</code>はドメインエラーを投げます。結果が整数ではないためです（詳細については<a href="../faq/index.html#faq-domain-errors">ドメインエラーに関するFAQの項目</a>を参照してください）。</span></li><li data-translated="true"><span class="original-text">In Julia, multiple values are returned and assigned as tuples, e.g. <code>(a, b) = (1, 2)</code> or <code>a, b = 1, 2</code>. MATLAB's <code>nargout</code>, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、複数の値がタプルとして返され、代入されます。例えば、<code>(a, b) = (1, 2)</code>や<code>a, b = 1, 2</code>のように。MATLABの<code>nargout</code>は、返される値の数に基づいてオプションの作業を行うためにMATLABでよく使用されますが、Juliaには存在しません。代わりに、ユーザーはオプション引数やキーワード引数を使用して同様の機能を実現できます。</span></li><li data-translated="true"><span class="original-text">Julia has true one-dimensional arrays. Column vectors are of size <code>N</code>, not <code>Nx1</code>. For example, <a href="../../stdlib/Random/index.html#Base.rand"><code>rand(N)</code></a> makes a 1-dimensional array.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaには真の1次元配列があります。列ベクトルはサイズ<code>N</code>であり、<code>Nx1</code>ではありません。例えば、<a href="../../stdlib/Random/index.html#Base.rand"><code>rand(N)</code></a>は1次元配列を作成します。</span></li><li>In Julia, <code>[x,y,z]</code> will always construct a 3-element array containing <code>x</code>, <code>y</code> and <code>z</code>.<ul><li data-translated="true"><span class="original-text">To concatenate in the first ("vertical") dimension use either <a href="../../base/arrays/index.html#Base.vcat"><code>vcat(x,y,z)</code></a> or separate with semicolons (<code>[x; y; z]</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初の（"垂直"）次元で連結するには、<a href="../../base/arrays/index.html#Base.vcat"><code>vcat(x,y,z)</code></a>を使用するか、セミコロンで区切ります（<code>[x; y; z]</code>）。</span></li><li data-translated="true"><span class="original-text">To concatenate in the second ("horizontal") dimension use either <a href="../../base/arrays/index.html#Base.hcat"><code>hcat(x,y,z)</code></a> or separate with spaces (<code>[x y z]</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">2番目の（"水平"）次元で連結するには、<a href="../../base/arrays/index.html#Base.hcat"><code>hcat(x,y,z)</code></a>を使用するか、スペースで区切ります（<code>[x y z]</code>）。</span></li><li data-translated="true"><span class="original-text">To construct block matrices (concatenating in the first two dimensions), use either <a href="../../base/arrays/index.html#Base.hvcat"><code>hvcat</code></a> or combine spaces and semicolons (<code>[a b; c d]</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ブロック行列を構築するには（最初の2次元で連結する）、<a href="../../base/arrays/index.html#Base.hvcat"><code>hvcat</code></a>を使用するか、スペースとセミコロンを組み合わせて使用します（<code>[a b; c d]</code>）。</span></li></ul></li><li data-translated="true"><span class="original-text">In Julia, <code>a:b</code> and <code>a:b:c</code> construct <code>AbstractRange</code> objects. To construct a full vector like in MATLAB, use <a href="../../base/collections/index.html#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a>. Generally, there is no need to call <code>collect</code> though. An <code>AbstractRange</code> object will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as <a href="../../base/math/index.html#Base.range"><code>range</code></a>, or with iterators such as <code>enumerate</code>, and <code>zip</code>. The special objects can mostly be used as if they were normal arrays.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>a:b</code>および<code>a:b:c</code>は<code>AbstractRange</code>オブジェクトを構築します。MATLABのように完全なベクトルを構築するには、<a href="../../base/collections/index.html#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a>を使用します。ただし、一般的には<code>collect</code>を呼び出す必要はありません。<code>AbstractRange</code>オブジェクトはほとんどの場合、通常の配列のように動作しますが、遅延評価により効率的です。このように完全な配列の代わりに特化したオブジェクトを作成するパターンは頻繁に使用され、<a href="../../base/math/index.html#Base.range"><code>range</code></a>のような関数や、<code>enumerate</code>、<code>zip</code>のようなイテレータでも見られます。特別なオブジェクトは、通常の配列のように使用できます。</span></li><li data-translated="true"><span class="original-text">Functions in Julia return values from their last expression or the <code>return</code> keyword instead of listing the names of variables to return in the function definition (see <a href="../functions/index.html#The-return-Keyword">The return Keyword</a> for details).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの関数は、関数定義内で返す変数の名前を列挙するのではなく、最後の式または<code>return</code>キーワードから値を返します（詳細は<a href="../functions/index.html#The-return-Keyword">returnキーワード</a>を参照してください）。</span></li><li data-translated="true"><span class="original-text">A Julia script may contain any number of functions, and all definitions will be externally visible when the file is loaded. Function definitions can be loaded from files outside the current working directory.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaスクリプトには任意の数の関数を含めることができ、ファイルが読み込まれるとすべての定義が外部から見えるようになります。関数定義は、現在の作業ディレクトリの外部のファイルから読み込むことができます。</span></li><li data-translated="true"><span class="original-text">In Julia, reductions such as <a href="../../base/collections/index.html#Base.sum"><code>sum</code></a>, <a href="../../base/collections/index.html#Base.prod"><code>prod</code></a>, and <a href="../../base/collections/index.html#Base.maximum"><code>maximum</code></a> are performed over every element of an array when called with a single argument, as in <code>sum(A)</code>, even if <code>A</code> has more than one dimension.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<a href="../../base/collections/index.html#Base.sum"><code>sum</code></a>、<a href="../../base/collections/index.html#Base.prod"><code>prod</code></a>、および<a href="../../base/collections/index.html#Base.maximum"><code>maximum</code></a>のような還元は、単一の引数で呼び出されたときに配列のすべての要素に対して実行されます。たとえば、<code>sum(A)</code>のように、<code>A</code>が複数の次元を持っていても同様です。</span></li><li data-translated="true"><span class="original-text">In Julia, parentheses must be used to call a function with zero arguments, like in <a href="../../stdlib/Random/index.html#Base.rand"><code>rand()</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、引数がゼロの関数を呼び出すには、<a href="../../stdlib/Random/index.html#Base.rand"><code>rand()</code></a>のように括弧を使用する必要があります。</span></li><li data-translated="true"><span class="original-text">Julia discourages the use of semicolons to end statements. The results of statements are not automatically printed (except at the interactive prompt), and lines of code do not need to end with semicolons. <a href="../../base/io-network/index.html#Base.println"><code>println</code></a> or <a href="../../stdlib/Printf/index.html#Printf.@printf"><code>@printf</code></a> can be used to print specific output.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、文の終了にセミコロンを使用することは推奨されません。文の結果は自動的に印刷されず（対話型プロンプトを除く）、コードの行はセミコロンで終わる必要はありません。特定の出力を印刷するには、<a href="../../base/io-network/index.html#Base.println"><code>println</code></a>や<a href="../../stdlib/Printf/index.html#Printf.@printf"><code>@printf</code></a>を使用できます。</span></li><li data-translated="true"><span class="original-text">In Julia, if <code>A</code> and <code>B</code> are arrays, logical comparison operations like <code>A == B</code> do not return an array of booleans. Instead, use <code>A .== B</code>, and similarly for the other boolean operators like <a href="../../base/math/#Base.:&lt;#Base.:&lt;"><code>&lt;</code></a>, <a href="../../base/math/#Base.:&gt;#Base.:&gt;"><code>&gt;</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>A</code>と<code>B</code>が配列である場合、<code>A == B</code>のような論理比較演算はブール値の配列を返しません。代わりに、<code>A .== B</code>を使用し、他のブール演算子（<a href="../../base/math/#Base.:&lt;#Base.:&lt;"><code>&lt;</code></a>、<a href="../../base/math/#Base.:&gt;#Base.:&gt;"><code>&gt;</code></a>など）についても同様です。</span></li><li data-translated="true"><span class="original-text">In Julia, when you want to apply a scalar-valued function elementwise to an array, use broadcasting syntax: <code>f.(A)</code> instead of <code>f(A)</code>. In some cases, both operations are defined but mean different things: in MATLAB <code>exp(A)</code> applies elementwise and <code>expm(A)</code> is the <a href="https://en.wikipedia.org/wiki/Matrix_exponential">matrix exponential</a>, but in Julia <code>exp.(A)</code> applies elementwise and <code>exp(A)</code> is the matrix exponential.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、スカラー値の関数を配列に要素ごとに適用したい場合、ブロードキャスティング構文を使用します：<code>f.(A)</code>の代わりに<code>f(A)</code>を使用します。場合によっては、両方の操作が定義されていますが、意味が異なります：MATLABでは<code>exp(A)</code>は要素ごとに適用され、<code>expm(A)</code>は<a href="https://en.wikipedia.org/wiki/Matrix_exponential">行列指数関数</a>ですが、Juliaでは<code>exp.(A)</code>が要素ごとに適用され、<code>exp(A)</code>は行列指数関数です。</span></li><li data-translated="true"><span class="original-text">In Julia, the operators <a href="../../base/math/#Base.:&amp;#Base.:&amp;"><code>&amp;</code></a>, <a href="../../base/math/#Base.:|#Base.:|"><code>|</code></a>, and <a href="../../base/math/index.html#Base.xor"><code>⊻</code></a> (<a href="../../base/math/index.html#Base.xor"><code>xor</code></a>) perform the bitwise operations equivalent to <code>and</code>, <code>or</code>, and <code>xor</code> respectively in MATLAB, and have precedence similar to Python's bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of <code>A</code> equal to 1 or 2 use <code>(A .== 1) .| (A .== 2)</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、演算子<a href="../../base/math/#Base.:&amp;#Base.:&amp;"><code>&amp;</code></a>、<a href="../../base/math/#Base.:|#Base.:|"><code>|</code></a>、および<a href="../../base/math/index.html#Base.xor"><code>⊻</code></a>（<a href="../../base/math/index.html#Base.xor"><code>xor</code></a>）は、MATLABの<code>and</code>、<code>or</code>、<code>xor</code>に相当するビット単位の演算を行い、Cとは異なりPythonのビット単位演算子と同様の優先順位を持ちます。これらはスカラーまたは配列に対して要素ごとに操作でき、論理配列を組み合わせるために使用できますが、演算の順序に注意が必要です：括弧が必要な場合があります（例：<code>A</code>の要素が1または2に等しいものを選択するには、<code>(A .== 1) .| (A .== 2)</code>を使用します）。</span></li><li data-translated="true"><span class="original-text">In Julia, the elements of a collection can be passed as arguments to a function using the splat operator <code>...</code>, as in <code>xs=[1,2]; f(xs...)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、コレクションの要素をスプラット演算子<code>...</code>を使用して関数に引数として渡すことができます。例えば、<code>xs=[1,2]; f(xs...)</code>のように。</span></li><li data-translated="true"><span class="original-text">Julia's <a href="../../stdlib/LinearAlgebra/index.html#LinearAlgebra.svd"><code>svd</code></a> returns singular values as a vector instead of as a dense diagonal matrix.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの<a href="../../stdlib/LinearAlgebra/index.html#LinearAlgebra.svd"><code>svd</code></a>は、特異値を密な対角行列ではなくベクトルとして返します。</span></li><li data-translated="true"><span class="original-text">In Julia, <code>...</code> is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>...</code>はコードの行を続けるためには使用されません。代わりに、不完全な式は自動的に次の行に続きます。</span></li><li data-translated="true"><span class="original-text">In both Julia and MATLAB, the variable <code>ans</code> is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, <code>ans</code> is not set when Julia code is run in non-interactive mode.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">JuliaとMATLABの両方で、変数<code>ans</code>はインタラクティブセッションで発行された最後の式の値に設定されます。Juliaでは、MATLABとは異なり、非インタラクティブモードでJuliaコードが実行されるときには<code>ans</code>は設定されません。</span></li><li data-translated="true"><span class="original-text">Julia's <code>struct</code>s do not support dynamically adding fields at runtime, unlike MATLAB's <code>class</code>es. Instead, use a <a href="../../base/collections/index.html#Base.Dict"><code>Dict</code></a>. Dict in Julia isn't ordered.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの<code>struct</code>は、MATLABの<code>class</code>のように実行時にフィールドを動的に追加することをサポートしていません。代わりに、<a href="../../base/collections/index.html#Base.Dict"><code>Dict</code></a>を使用してください。JuliaのDictは順序付けされていません。</span></li><li data-translated="true"><span class="original-text">In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは各モジュールが独自のグローバルスコープ/名前空間を持っていますが、MATLABには1つのグローバルスコープしかありません。</span></li><li data-translated="true"><span class="original-text">In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression <code>x(x&gt;3)</code> or in the statement <code>x(x&gt;3) = []</code> to modify <code>x</code> in-place. In contrast, Julia provides the higher order functions <a href="../../base/collections/index.html#Base.filter"><code>filter</code></a> and <a href="../../base/collections/index.html#Base.filter!"><code>filter!</code></a>, allowing users to write <code>filter(z-&gt;z&gt;3, x)</code> and <code>filter!(z-&gt;z&gt;3, x)</code> as alternatives to the corresponding transliterations <code>x[x.&gt;3]</code> and <code>x = x[x.&gt;3]</code>. Using <a href="../../base/collections/index.html#Base.filter!"><code>filter!</code></a> reduces the use of temporary arrays.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">MATLABでは、不要な値を削除するための慣用的な方法は論理インデクシングを使用することです。例えば、<code>x(x&gt;3)</code>のような式や、<code>x(x&gt;3) = []</code>のような文を使用して<code>x</code>をその場で修正します。対照的に、Juliaは高階関数<a href="../../base/collections/index.html#Base.filter"><code>filter</code></a>と<a href="../../base/collections/index.html#Base.filter!"><code>filter!</code></a>を提供しており、ユーザーは<code>filter(z-&gt;z&gt;3, x)</code>や<code>filter!(z-&gt;z&gt;3, x)</code>を対応する翻訳<code>x[x.&gt;3]</code>や<code>x = x[x.&gt;3]</code>の代替として書くことができます。<a href="../../base/collections/index.html#Base.filter!"><code>filter!</code></a>を使用することで、一時配列の使用を減らすことができます。</span></li><li data-translated="true"><span class="original-text">Following on from the previous point, to replace values that meet specific criteria, for example a thresholding operation on all elements in a matrix, could be achieved in Matlab as follows <code>A(A &lt; threshold) = 0</code>. The Julia equivalent would be <code>A[A .&lt; threshold] .= 0</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">前のポイントに続いて、特定の条件を満たす値を置き換えるため、例えば行列内のすべての要素に対するしきい値操作は、MATLABでは次のように実現できます。<code>A(A &lt; threshold) = 0</code>。Juliaの同等のものは<code>A[A .&lt; threshold] .= 0</code>です。</span></li><li data-translated="true"><span class="original-text">The analogue of extracting (or "dereferencing") all elements of a cell array, e.g. in <code>vertcat(A{:})</code> in MATLAB, is written using the splat operator in Julia, e.g. as <code>vcat(A...)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">MATLABの<code>vertcat(A{:})</code>のようにセル配列のすべての要素を抽出（または「デリファレンス」）するアナログは、Juliaではスプラット演算子を使用して書かれます。例えば、<code>vcat(A...)</code>のように。</span></li><li data-translated="true"><span class="original-text">In Julia, the <code>adjoint</code> function performs conjugate transposition; in MATLAB, <code>adjoint</code> provides the "adjugate" or classical adjoint, which is the transpose of the matrix of cofactors.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>adjoint</code>関数が共役転置を実行します。MATLABでは、<code>adjoint</code>は「随伴」または古典的な随伴を提供し、これは余因子行列の転置です。</span></li><li data-translated="true"><span class="original-text">In Julia, a^b^c is evaluated a^(b^c) while in MATLAB it's (a^b)^c.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、a^b^cはa^(b^c)として評価されますが、MATLABでは(a^b)^cです。</span></li></ul><h2 id="Noteworthy-differences-from-R" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-R">Noteworthy differences from R</a><a id="Noteworthy-differences-from-R-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-R" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-R">Rとの注目すべき違い</a><a id="Noteworthy-differences-from-R-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-R" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">One of Julia's goals is to provide an effective language for data analysis and statistical programming. For users coming to Julia from R, these are some noteworthy differences:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの目標の一つは、データ分析と統計プログラミングのための効果的な言語を提供することです。RからJuliaに移行するユーザーにとって、注目すべき違いは以下の通りです：</span></p><ul><li><p data-translated="true"><span class="original-text">Julia's single quotes enclose characters, not strings.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaのシングルクォートは文字を囲み、文字列ではありません。</span></p></li><li><p data-translated="true"><span class="original-text">Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、文字列にインデックスを付けることで部分文字列を作成できます。Rでは、部分文字列を作成する前に文字列を文字ベクトルに変換する必要があります。</span></p></li><li><p data-translated="true"><span class="original-text">In Julia, like Python but unlike R, strings can be created with triple quotes <code>""" ... """</code>. This syntax is convenient for constructing strings that contain line breaks.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、Pythonと同様に、Rとは異なり、トリプルクォート<code>""" ... """</code>を使用して文字列を作成できます。この構文は、改行を含む文字列を構築するのに便利です。</span></p></li><li><p data-translated="true"><span class="original-text">In Julia, varargs are specified using the splat operator <code>...</code>, which always follows the name of a specific variable, unlike R, for which <code>...</code> can occur in isolation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、可変引数はスプラット演算子<code>...</code>を使用して指定され、特定の変数の名前の後に常に続きます。Rでは、<code>...</code>は孤立して出現することがあります。</span></p></li><li><p data-translated="true"><span class="original-text">In Julia, modulus is <code>mod(a, b)</code>, not <code>a %% b</code>. <code>%</code> in Julia is the remainder operator.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、剰余は<code>mod(a, b)</code>であり、<code>a %% b</code>ではありません。<code>%</code>はJuliaでは余り演算子です。</span></p></li><li><p data-translated="true"><span class="original-text">Julia constructs vectors using brackets. Julia's <code>[1, 2, 3]</code> is the equivalent of R's <code>c(1, 2, 3)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaはブラケットを使用してベクトルを構築します。Juliaの<code>[1, 2, 3]</code>はRの<code>c(1, 2, 3)</code>に相当します。</span></p></li><li><p data-translated="true"><span class="original-text">In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、すべてのデータ構造が論理インデックスをサポートしているわけではありません。さらに、Juliaの論理インデックスは、インデックスを付けられるオブジェクトと同じ長さのベクトルでのみサポートされています。例えば：</span></p><ul><li data-translated="true"><span class="original-text">In R, <code>c(1, 2, 3, 4)[c(TRUE, FALSE)]</code> is equivalent to <code>c(1, 3)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Rでは、<code>c(1, 2, 3, 4)[c(TRUE, FALSE)]</code>は<code>c(1, 3)</code>と同等です。</span></li><li data-translated="true"><span class="original-text">In R, <code>c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]</code> is equivalent to <code>c(1, 3)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Rでは、<code>c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]</code>は<code>c(1, 3)</code>と同等です。</span></li><li data-translated="true"><span class="original-text">In Julia, <code>[1, 2, 3, 4][[true, false]]</code> throws a <a href="../../base/base/index.html#Core.BoundsError"><code>BoundsError</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>[1, 2, 3, 4][[true, false]]</code>は<a href="../../base/base/index.html#Core.BoundsError"><code>BoundsError</code></a>をスローします。</span></li><li data-translated="true"><span class="original-text">In Julia, <code>[1, 2, 3, 4][[true, false, true, false]]</code> produces <code>[1, 3]</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>[1, 2, 3, 4][[true, false, true, false]]</code>は<code>[1, 3]</code>を生成します。</span></li></ul></li><li><p data-translated="true"><span class="original-text">Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range. For example, <code>c(1, 2, 3, 4) + c(1, 2)</code> is valid R but the equivalent <code>[1, 2, 3, 4] + [1, 2]</code> will throw an error in Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">多くの言語と同様に、Juliaは異なる長さのベクトルに対する操作を常に許可しませんが、Rではベクトルは共通のインデックス範囲を共有する必要があるだけです。例えば、<code>c(1, 2, 3, 4) + c(1, 2)</code>は有効なRですが、同等の<code>[1, 2, 3, 4] + [1, 2]</code>はJuliaではエラーをスローします。</span></p></li><li><p data-translated="true"><span class="original-text">Julia allows an optional trailing comma when that comma does not change the meaning of code. This can cause confusion among R users when indexing into arrays. For example, <code>x[1,]</code> in R would return the first row of a matrix; in Julia, however, the comma is ignored, so <code>x[1,] == x[1]</code>, and will return the first element. To extract a row, be sure to use <code>:</code>, as in <code>x[1,:]</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、カンマがコードの意味を変えない場合にオプショナルな末尾のカンマを許可します。これは、配列にインデックスを付ける際にRユーザーの間で混乱を引き起こす可能性があります。例えば、Rの<code>x[1,]</code>は行列の最初の行を返しますが、Juliaではカンマが無視されるため、<code>x[1,] == x[1]</code>となり、最初の要素を返します。行を抽出するには、<code>:</code>を使用することを確認してください。例えば、<code>x[1,:]</code>のように。</span></p></li><li><p data-translated="true"><span class="original-text">Julia's <a href="../../base/collections/index.html#Base.map"><code>map</code></a> takes the function first, then its arguments, unlike <code>lapply(&lt;structure&gt;, function, ...)</code> in R. Similarly Julia's equivalent of <code>apply(X, MARGIN, FUN, ...)</code> in R is <a href="../../base/arrays/index.html#Base.mapslices"><code>mapslices</code></a> where the function is the first argument.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの<a href="../../base/collections/index.html#Base.map"><code>map</code></a>は、Rの<code>lapply(&lt;structure&gt;, function, ...)</code>とは異なり、最初に関数を取り、その後に引数を取ります。同様に、Rの<code>apply(X, MARGIN, FUN, ...)</code>に相当するJuliaのものは、<a href="../../base/arrays/index.html#Base.mapslices"><code>mapslices</code></a>で、関数が最初の引数です。</span></p></li><li><p data-translated="true"><span class="original-text">Multivariate apply in R, e.g. <code>mapply(choose, 11:13, 1:3)</code>, can be written as <code>broadcast(binomial, 11:13, 1:3)</code> in Julia. Equivalently Julia offers a shorter dot syntax for vectorizing functions <code>binomial.(11:13, 1:3)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Rの多変量適用、例えば<code>mapply(choose, 11:13, 1:3)</code>は、Juliaでは<code>broadcast(binomial, 11:13, 1:3)</code>として書くことができます。同様に、Juliaは関数をベクトル化するための短いドット構文<code>binomial.(11:13, 1:3)</code>を提供します。</span></p></li><li><p data-translated="true"><span class="original-text">Julia uses <code>end</code> to denote the end of conditional blocks, like <code>if</code>, loop blocks, like <code>while</code>/ <code>for</code>, and functions. In lieu of the one-line <code>if ( cond ) statement</code>, Julia allows statements of the form <code>if cond; statement; end</code>, <code>cond &amp;&amp; statement</code> and <code>!cond || statement</code>. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. <code>cond &amp;&amp; (x = value)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは、<code>end</code>を条件ブロックの終わりを示すために使用します。これは<code>if</code>、ループブロック（<code>while</code>/<code>for</code>）、および関数に適用されます。1行の<code>if ( cond ) statement</code>の代わりに、Juliaは<code>if cond; statement; end</code>、<code>cond &amp;&amp; statement</code>、および<code>!cond || statement</code>の形式の文を許可します。後者の2つの構文の代入文は、明示的に括弧で囲む必要があります。例えば、<code>cond &amp;&amp; (x = value)</code>のように。</span></p></li><li><p data-translated="true"><span class="original-text">In Julia, <code>&lt;-</code>, <code>&lt;&lt;-</code> and <code>-&gt;</code> are not assignment operators.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>&lt;-</code>、<code>&lt;&lt;-</code>および<code>-&gt;</code>は代入演算子ではありません。</span></p></li><li><p data-translated="true"><span class="original-text">Julia's <code>-&gt;</code> creates an anonymous function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの <code>-&gt;</code> は無名関数を作成します。</span></p></li><li><p data-translated="true"><span class="original-text">Julia's <a href="../../base/math/#Base.:*-Tuple{Any, Vararg{Any}}#Base.:*-Tuple{Any, Vararg{Any}}"><code>*</code></a> operator can perform matrix multiplication, unlike in R. If <code>A</code> and <code>B</code> are matrices, then <code>A * B</code> denotes a matrix multiplication in Julia, equivalent to R's <code>A %*% B</code>. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write <code>A .* B</code> in Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの <a href="../../base/math/#Base.:*-Tuple{Any, Vararg{Any}}#Base.:*-Tuple{Any, Vararg{Any}}"><code>*</code></a> 演算子は行列の乗算を行うことができ、Rとは異なります。もし <code>A</code> と <code>B</code> が行列であれば、<code>A * B</code> はJuliaにおける行列の乗算を示し、Rの <code>A %*% B</code> に相当します。Rでは、この同じ表記は要素ごとの（アダマール）積を行います。要素ごとの乗算操作を得るには、Juliaで <code>A .* B</code> と書く必要があります。</span></p></li><li><p data-translated="true"><span class="original-text">Julia performs matrix transposition using the <code>transpose</code> function and conjugated transposition using the <code>'</code> operator or the <code>adjoint</code> function. Julia's <code>transpose(A)</code> is therefore equivalent to R's <code>t(A)</code>. Additionally a non-recursive transpose in Julia is provided by the <code>permutedims</code> function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは <code>transpose</code> 関数を使用して行列の転置を行い、<code>'</code> 演算子または <code>adjoint</code> 関数を使用して共役転置を行います。したがって、Juliaの <code>transpose(A)</code> はRの <code>t(A)</code> に相当します。さらに、Juliaでは非再帰的な転置が <code>permutedims</code> 関数によって提供されています。</span></p></li><li><p data-translated="true"><span class="original-text">Julia does not require parentheses when writing <code>if</code> statements or <code>for</code>/<code>while</code> loops: use <code>for i in [1, 2, 3]</code> instead of <code>for (i in c(1, 2, 3))</code> and <code>if i == 1</code> instead of <code>if (i == 1)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは <code>if</code> 文や <code>for</code>/<code>while</code> ループを書く際に括弧を必要としません： <code>for i in [1, 2, 3]</code> と書き、 <code>for (i in c(1, 2, 3))</code> の代わりに使用し、 <code>if i == 1</code> と書き、 <code>if (i == 1)</code> の代わりに使用します。</span></p></li><li><p data-translated="true"><span class="original-text">Julia does not treat the numbers <code>0</code> and <code>1</code> as Booleans. You cannot write <code>if (1)</code> in Julia, because <code>if</code> statements accept only booleans. Instead, you can write <code>if true</code>, <code>if Bool(1)</code>, or <code>if 1==1</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは、数値<code>0</code>と<code>1</code>をブール値として扱いません。<code>if (1)</code>と書くことはできません。なぜなら、<code>if</code>文はブール値のみを受け入れるからです。代わりに、<code>if true</code>、<code>if Bool(1)</code>、または<code>if 1==1</code>と書くことができます。</span></p></li><li><p data-translated="true"><span class="original-text">Julia does not provide <code>nrow</code> and <code>ncol</code>. Instead, use <code>size(M, 1)</code> for <code>nrow(M)</code> and <code>size(M, 2)</code> for <code>ncol(M)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは <code>nrow</code> と <code>ncol</code> を提供していません。代わりに、 <code>size(M, 1)</code> を <code>nrow(M)</code> のために、 <code>size(M, 2)</code> を <code>ncol(M)</code> のために使用します。</span></p></li><li><p data-translated="true"><span class="original-text">Julia is careful to distinguish scalars, vectors and matrices. In R, <code>1</code> and <code>c(1)</code> are the same. In Julia, they cannot be used interchangeably.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaはスカラー、ベクトル、行列を区別することに注意しています。Rでは、 <code>1</code> と <code>c(1)</code> は同じですが、Juliaでは互換的に使用することはできません。</span></p></li><li><p data-translated="true"><span class="original-text">Julia's <a href="../../stdlib/LinearAlgebra/index.html#LinearAlgebra.diag"><code>diag</code></a> and <a href="../../stdlib/LinearAlgebra/index.html#LinearAlgebra.diagm"><code>diagm</code></a> are not like R's.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの <a href="../../stdlib/LinearAlgebra/index.html#LinearAlgebra.diag"><code>diag</code></a> と <a href="../../stdlib/LinearAlgebra/index.html#LinearAlgebra.diagm"><code>diagm</code></a> はRのものとは異なります。</span></p></li><li><p data-translated="true"><span class="original-text">Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write <code>diag(M) = fill(1, n)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、代入操作の左辺に関数呼び出しの結果を代入することはできません： <code>diag(M) = fill(1, n)</code> と書くことはできません。</span></p></li><li><p data-translated="true"><span class="original-text">Julia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in <a href="https://pkg.julialang.org/">packages</a> under the <a href="https://github.com/JuliaStats">JuliaStats organization</a>. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaはメイン名前空間に関数を追加することを推奨しません。Juliaのほとんどの統計機能は、 <a href="https://pkg.julialang.org/">パッケージ</a> に見つかり、 <a href="https://github.com/JuliaStats">JuliaStats組織</a> の下にあります。例えば：</span></p><ul><li data-translated="true"><span class="original-text">Functions pertaining to probability distributions are provided by the <a href="https://github.com/JuliaStats/Distributions.jl">Distributions package</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">確率分布に関連する関数は、<a href="https://github.com/JuliaStats/Distributions.jl">Distributionsパッケージ</a>によって提供されています。</span></li><li data-translated="true"><span class="original-text">The <a href="https://github.com/JuliaData/DataFrames.jl">DataFrames package</a> provides data frames.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaData/DataFrames.jl">DataFramesパッケージ</a>はデータフレームを提供します。</span></li><li data-translated="true"><span class="original-text">Generalized linear models are provided by the <a href="https://github.com/JuliaStats/GLM.jl">GLM package</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般化線形モデルは、<a href="https://github.com/JuliaStats/GLM.jl">GLMパッケージ</a>によって提供されています。</span></li></ul></li><li><p data-translated="true"><span class="original-text">Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple or a named tuple: instead of <code>list(a = 1, b = 2)</code>, use <code>(1, 2)</code> or <code>(a=1, b=2)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaはタプルと実際のハッシュテーブルを提供しますが、Rスタイルのリストは提供していません。複数のアイテムを返す場合は、通常タプルまたは名前付きタプルを使用するべきです：<code>list(a = 1, b = 2)</code>の代わりに、<code>(1, 2)</code>または<code>(a=1, b=2)</code>を使用してください。</span></p></li><li><p data-translated="true"><span class="original-text">Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia's multiple dispatch system means that <code>table(x::TypeA)</code> and <code>table(x::TypeB)</code> act like R's <code>table.TypeA(x)</code> and <code>table.TypeB(x)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaはユーザーが独自の型を作成することを奨励しており、これはRのS3やS4オブジェクトよりも使いやすいです。Juliaの多重ディスパッチシステムにより、<code>table(x::TypeA)</code>と<code>table(x::TypeB)</code>はRの<code>table.TypeA(x)</code>と<code>table.TypeB(x)</code>のように動作します。</span></p></li><li><p data-translated="true"><span class="original-text">In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、値は関数に割り当てられたり渡されたりする際にコピーされません。関数が配列を変更すると、その変更は呼び出し元に反映されます。これはRとは大きく異なり、新しい関数が大きなデータ構造に対してより効率的に動作することを可能にします。</span></p></li><li><p data-translated="true"><span class="original-text">In Julia, vectors and matrices are concatenated using <a href="../../base/arrays/index.html#Base.hcat"><code>hcat</code></a>, <a href="../../base/arrays/index.html#Base.vcat"><code>vcat</code></a> and <a href="../../base/arrays/index.html#Base.hvcat"><code>hvcat</code></a>, not <code>c</code>, <code>rbind</code> and <code>cbind</code> like in R.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、ベクトルと行列は<a href="../../base/arrays/index.html#Base.hcat"><code>hcat</code></a>、<a href="../../base/arrays/index.html#Base.vcat"><code>vcat</code></a>、および<a href="../../base/arrays/index.html#Base.hvcat"><code>hvcat</code></a>を使用して連結され、Rのように<code>c</code>、<code>rbind</code>、および<code>cbind</code>は使用しません。</span></p></li><li><p data-translated="true"><span class="original-text">In Julia, a range like <code>a:b</code> is not shorthand for a vector like in R, but is a specialized <code>AbstractRange</code> object that is used for iteration. To convert a range into a vector, use <a href="../../base/collections/index.html#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>a:b</code>のような範囲はRのベクトルの省略形ではなく、反復処理に使用される特化した<code>AbstractRange</code>オブジェクトです。範囲をベクトルに変換するには、<a href="../../base/collections/index.html#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a>を使用します。</span></p></li><li><p data-translated="true"><span class="original-text">The <code>:</code> operator has a different precedence in R and Julia. In particular, in Julia arithmetic operators have higher precedence than the <code>:</code> operator, whereas the reverse is true in R. For example, <code>1:n-1</code> in Julia is equivalent to <code>1:(n-1)</code> in R.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>:</code>演算子はRとJuliaで異なる優先順位を持っています。特に、Juliaでは算術演算子の優先順位が<code>:</code>演算子よりも高く、Rではその逆です。例えば、Juliaの<code>1:n-1</code>はRの<code>1:(n-1)</code>に相当します。</span></p></li><li><p data-translated="true"><span class="original-text">Julia's <a href="../../base/math/index.html#Base.max"><code>max</code></a> and <a href="../../base/math/index.html#Base.min"><code>min</code></a> are the equivalent of <code>pmax</code> and <code>pmin</code> respectively in R, but both arguments need to have the same dimensions. While <a href="../../base/collections/index.html#Base.maximum"><code>maximum</code></a> and <a href="../../base/collections/index.html#Base.minimum"><code>minimum</code></a> replace <code>max</code> and <code>min</code> in R, there are important differences.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの<a href="../../base/math/index.html#Base.max"><code>max</code></a>と<a href="../../base/math/index.html#Base.min"><code>min</code></a>は、Rの<code>pmax</code>と<code>pmin</code>に相当しますが、両方の引数は同じ次元である必要があります。一方、<a href="../../base/collections/index.html#Base.maximum"><code>maximum</code></a>と<a href="../../base/collections/index.html#Base.minimum"><code>minimum</code></a>はRの<code>max</code>と<code>min</code>を置き換えますが、重要な違いがあります。</span></p></li><li><p data-translated="true"><span class="original-text">Julia's <a href="../../base/collections/index.html#Base.sum"><code>sum</code></a>, <a href="../../base/collections/index.html#Base.prod"><code>prod</code></a>, <a href="../../base/collections/index.html#Base.maximum"><code>maximum</code></a>, and <a href="../../base/collections/index.html#Base.minimum"><code>minimum</code></a> are different from their counterparts in R. They all accept an optional keyword argument <code>dims</code>, which indicates the dimensions, over which the operation is carried out. For instance, let <code>A = [1 2; 3 4]</code> in Julia and <code>B &lt;- rbind(c(1,2),c(3,4))</code> be the same matrix in R. Then <code>sum(A)</code> gives the same result as <code>sum(B)</code>, but <code>sum(A, dims=1)</code> is a row vector containing the sum over each column and <code>sum(A, dims=2)</code> is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate <code>colSums(B)</code> and <code>rowSums(B)</code> functions provide these functionalities. If the <code>dims</code> keyword argument is a vector, then it specifies all the dimensions over which the sum is performed, while retaining the dimensions of the summed array, e.g. <code>sum(A, dims=(1,2)) == hcat(10)</code>. It should be noted that there is no error checking regarding the second argument.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの<a href="../../base/collections/index.html#Base.sum"><code>sum</code></a>、<a href="../../base/collections/index.html#Base.prod"><code>prod</code></a>、<a href="../../base/collections/index.html#Base.maximum"><code>maximum</code></a>、および<a href="../../base/collections/index.html#Base.minimum"><code>minimum</code></a>は、Rの対応する関数とは異なります。これらはすべて、操作が行われる次元を示すオプションのキーワード引数<code>dims</code>を受け入れます。たとえば、Juliaで<code>A = [1 2; 3 4]</code>とし、Rで同じ行列を<code>B &lt;- rbind(c(1,2),c(3,4))</code>とします。すると、<code>sum(A)</code>は<code>sum(B)</code>と同じ結果を返しますが、<code>sum(A, dims=1)</code>は各列の合計を含む行ベクトルを返し、<code>sum(A, dims=2)</code>は各行の合計を含む列ベクトルを返します。これは、Rの動作とは対照的で、Rでは別々の<code>colSums(B)</code>および<code>rowSums(B)</code>関数がこれらの機能を提供します。<code>dims</code>キーワード引数がベクトルの場合、合計が実行されるすべての次元を指定し、合計された配列の次元を保持します。たとえば、<code>sum(A, dims=(1,2)) == hcat(10)</code>となります。第二引数に関してはエラーチェックが行われないことに注意してください。</span></p></li><li><p data-translated="true"><span class="original-text">Julia has several functions that can mutate their arguments. For example, it has both <a href="../../base/sort/index.html#Base.sort"><code>sort</code></a> and <a href="../../base/sort/index.html#Base.sort!"><code>sort!</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaには、引数を変更できるいくつかの関数があります。たとえば、<a href="../../base/sort/index.html#Base.sort"><code>sort</code></a>と<a href="../../base/sort/index.html#Base.sort!"><code>sort!</code></a>の両方があります。</span></p></li><li><p data-translated="true"><span class="original-text">In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Rでは、パフォーマンスにはベクトル化が必要です。Juliaでは、ほぼ逆のことが言えます：最もパフォーマンスの良いコードは、しばしばデベクトル化されたループを使用することで達成されます。</span></p></li><li><p data-translated="true"><span class="original-text">Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは即時評価され、Rスタイルの遅延評価をサポートしていません。ほとんどのユーザーにとって、これは引用されていない式や列名が非常に少ないことを意味します。</span></p></li><li><p data-translated="true"><span class="original-text">Julia does not support the <code>NULL</code> type. The closest equivalent is <a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a>, but it behaves like a scalar value rather than like a list. Use <code>x === nothing</code> instead of <code>is.null(x)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは<code>NULL</code>型をサポートしていません。最も近い同等物は<a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a>ですが、リストのように振る舞うのではなくスカラー値のように振る舞います。<code>x === nothing</code>を使用し、<code>is.null(x)</code>の代わりに使ってください。</span></p></li><li><p data-translated="true"><span class="original-text">In Julia, missing values are represented by the <a href="../missing/index.html#missing"><code>missing</code></a> object rather than by <code>NA</code>. Use <a href="../../base/base/index.html#Base.ismissing"><code>ismissing(x)</code></a> (or <code>ismissing.(x)</code> for element-wise operation on vectors) instead of <code>is.na(x)</code>. The <a href="../../base/base/index.html#Base.skipmissing"><code>skipmissing</code></a> function is generally used instead of <code>na.rm=TRUE</code> (though in some particular cases functions take a <code>skipmissing</code> argument).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、欠損値は<code>NA</code>ではなく、<a href="../missing/index.html#missing"><code>missing</code></a>オブジェクトで表されます。<code>is.na(x)</code>の代わりに、<a href="../../base/base/index.html#Base.ismissing"><code>ismissing(x)</code></a>（またはベクトルに対する要素ごとの操作には<code>ismissing.(x)</code>）を使用してください。<a href="../../base/base/index.html#Base.skipmissing"><code>skipmissing</code></a>関数は、一般的に<code>na.rm=TRUE</code>の代わりに使用されます（ただし、特定のケースでは関数が<code>skipmissing</code>引数を取ることがあります）。</span></p></li><li><p data-translated="true"><span class="original-text">Julia lacks the equivalent of R's <code>assign</code> or <code>get</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaには、Rの<code>assign</code>や<code>get</code>に相当するものがありません。</span></p></li><li><p data-translated="true"><span class="original-text">In Julia, <code>return</code> does not require parentheses.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>return</code>は括弧を必要としません。</span></p></li><li><p data-translated="true"><span class="original-text">In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression <code>x[x&gt;3]</code> or in the statement <code>x = x[x&gt;3]</code> to modify <code>x</code> in-place. In contrast, Julia provides the higher order functions <a href="../../base/collections/index.html#Base.filter"><code>filter</code></a> and <a href="../../base/collections/index.html#Base.filter!"><code>filter!</code></a>, allowing users to write <code>filter(z-&gt;z&gt;3, x)</code> and <code>filter!(z-&gt;z&gt;3, x)</code> as alternatives to the corresponding transliterations <code>x[x.&gt;3]</code> and <code>x = x[x.&gt;3]</code>. Using <a href="../../base/collections/index.html#Base.filter!"><code>filter!</code></a> reduces the use of temporary arrays.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Rでは、不要な値を削除するための慣用的な方法は、<code>x[x&gt;3]</code>のような論理インデックスを使用することです。また、<code>x = x[x&gt;3]</code>のように<code>x</code>をその場で変更することもできます。対照的に、Juliaは高階関数<a href="../../base/collections/index.html#Base.filter"><code>filter</code></a>と<a href="../../base/collections/index.html#Base.filter!"><code>filter!</code></a>を提供し、ユーザーは<code>filter(z-&gt;z&gt;3, x)</code>や<code>filter!(z-&gt;z&gt;3, x)</code>を書くことができます。これは、対応する翻訳<code>x[x.&gt;3]</code>や<code>x = x[x.&gt;3]</code>の代替手段です。<a href="../../base/collections/index.html#Base.filter!"><code>filter!</code></a>を使用することで、一時配列の使用を減らすことができます。</span></p></li></ul><h2 id="Noteworthy-differences-from-Python" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-Python">Noteworthy differences from Python</a><a id="Noteworthy-differences-from-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-Python" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-Python">Pythonとの注目すべき違い</a><a id="Noteworthy-differences-from-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-Python" title="Permalink"></a></span></h2><ul><li data-translated="true"><span class="original-text">Julia's <code>for</code>, <code>if</code>, <code>while</code>, etc. blocks are terminated by the <code>end</code> keyword. Indentation level is not significant as it is in Python. Unlike Python, Julia has no <code>pass</code> keyword.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの<code>for</code>、<code>if</code>、<code>while</code>などのブロックは、<code>end</code>キーワードで終了します。インデントレベルはPythonのように重要ではありません。Pythonとは異なり、Juliaには<code>pass</code>キーワードはありません。</span></li><li data-translated="true"><span class="original-text">Strings are denoted by double quotation marks (<code>"text"</code>) in Julia (with three double quotation marks for multi-line strings), whereas in Python they can be denoted either by single (<code>'text'</code>) or double quotation marks (<code>"text"</code>). Single quotation marks are used for characters in Julia (<code>'c'</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列はJuliaでは二重引用符（<code>"text"</code>）で表されます（複数行の文字列には三重の二重引用符を使用します）が、Pythonでは単一（<code>'text'</code>）または二重引用符（<code>"text"</code>）のいずれかで表すことができます。Juliaでは単一引用符は文字に使用されます（<code>'c'</code>）。</span></li><li data-translated="true"><span class="original-text">String concatenation is done with <code>*</code> in Julia, not <code>+</code> like in Python. Analogously, string repetition is done with <code>^</code>, not <code>*</code>. Implicit string concatenation of string literals like in Python (e.g. <code>'ab' 'cd' == 'abcd'</code>) is not done in Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列の連結はJuliaでは<code>*</code>を使用して行い、Pythonのように<code>+</code>は使用しません。同様に、文字列の繰り返しは<code>^</code>を使用して行い、<code>*</code>は使用しません。Pythonのように文字列リテラルの暗黙の連結（例：<code>'ab' 'cd' == 'abcd'</code>）はJuliaでは行われません。</span></li><li data-translated="true"><span class="original-text">Python Lists—flexible but slow—correspond to the Julia <code>Vector{Any}</code> type or more generally <code>Vector{T}</code> where <code>T</code> is some non-concrete element type. "Fast" arrays like NumPy arrays that store elements in-place (i.e., <code>dtype</code> is <code>np.float64</code>, <code>[('f1', np.uint64), ('f2', np.int32)]</code>, etc.) can be represented by <code>Array{T}</code> where <code>T</code> is a concrete, immutable element type. This includes built-in types like <code>Float64</code>, <code>Int32</code>, <code>Int64</code> but also more complex types like <code>Tuple{UInt64,Float64}</code> and many user-defined types as well.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Pythonのリスト—柔軟だが遅い—は、Juliaの<code>Vector{Any}</code>型、または一般的に<code>Vector{T}</code>に対応します。ここで<code>T</code>は非具体的な要素型です。「高速」配列（NumPy配列のように要素をインプレースで格納する、すなわち<code>dtype</code>が<code>np.float64</code>、<code>[('f1', np.uint64), ('f2', np.int32)]</code>など）は、具体的で不変の要素型を持つ<code>Array{T}</code>で表現できます。これには<code>Float64</code>、<code>Int32</code>、<code>Int64</code>などの組み込み型や、<code>Tuple{UInt64,Float64}</code>のようなより複雑な型、さらには多くのユーザー定義型も含まれます。</span></li><li data-translated="true"><span class="original-text">In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、配列や文字列などのインデックスは1から始まり、0から始まりません。</span></li><li data-translated="true"><span class="original-text">Julia's slice indexing includes the last element, unlike in Python. <code>a[2:3]</code> in Julia is <code>a[1:3]</code> in Python.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaのスライスインデックスは最後の要素を含むため、Pythonとは異なります。Juliaの<code>a[2:3]</code>はPythonの<code>a[1:3]</code>に相当します。</span></li><li data-translated="true"><span class="original-text">Unlike Python, Julia allows <a href="https://julialang.org/blog/2017/04/offset-arrays/">AbstractArrays with arbitrary indexes</a>. Python's special interpretation of negative indexing, <code>a[-1]</code> and <code>a[-2]</code>, should be written <code>a[end]</code> and <code>a[end-1]</code> in Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Pythonとは異なり、Juliaは<a href="https://julialang.org/blog/2017/04/offset-arrays/">任意のインデックスを持つAbstractArrays</a>を許可します。Pythonの負のインデックスの特別な解釈、<code>a[-1]</code>および<code>a[-2]</code>は、Juliaでは<code>a[end]</code>および<code>a[end-1]</code>と書く必要があります。</span></li><li data-translated="true"><span class="original-text">Julia requires <code>end</code> for indexing until the last element. <code>x[2:end]</code> in Julia is equivalent to <code>x[1:]</code> in Python.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、最後の要素までのインデックスに<code>end</code>が必要です。Juliaの<code>x[2:end]</code>はPythonの<code>x[1:]</code>に相当します。</span></li><li data-translated="true"><span class="original-text">In Julia, <code>:</code> before any object creates a <a href="../../base/base/index.html#Core.Symbol"><code>Symbol</code></a> or <em>quotes</em> an expression; so, <code>x[:5]</code> is the same as <code>x[5]</code>. If you want to get the first <code>n</code> elements of an array, then use range indexing.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、任意のオブジェクトの前に<code>:</code>を置くと、<a href="../../base/base/index.html#Core.Symbol"><code>Symbol</code></a>が作成されるか、式が<em>引用</em>されます。したがって、<code>x[:5]</code>は<code>x[5]</code>と同じです。配列の最初の<code>n</code>要素を取得したい場合は、範囲インデックスを使用してください。</span></li><li data-translated="true"><span class="original-text">Julia's range indexing has the format of <code>x[start:step:stop]</code>, whereas Python's format is <code>x[start:(stop+1):step]</code>. Hence, <code>x[0:10:2]</code> in Python is equivalent to <code>x[1:2:10]</code> in Julia. Similarly, <code>x[::-1]</code> in Python, which refers to the reversed array, is equivalent to <code>x[end:-1:1]</code> in Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの範囲インデックスは<code>x[start:step:stop]</code>の形式を持ち、Pythonの形式は<code>x[start:(stop+1):step]</code>です。したがって、Pythonの<code>x[0:10:2]</code>はJuliaの<code>x[1:2:10]</code>に相当します。同様に、Pythonの<code>x[::-1]</code>（逆順の配列を参照）は、Juliaの<code>x[end:-1:1]</code>に相当します。</span></li><li data-translated="true"><span class="original-text">In Julia, ranges can be constructed independently as <code>start:step:stop</code>, the same syntax it uses in array-indexing. The <code>range</code> function is also supported.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、範囲は<code>start:step:stop</code>として独立に構築できます。これは配列インデックスで使用されるのと同じ構文です。<code>range</code>関数もサポートされています。</span></li><li data-translated="true"><span class="original-text">In Julia, indexing a matrix with arrays like <code>X[[1,2], [1,3]]</code> refers to a sub-matrix that contains the intersections of the first and second rows with the first and third columns. In Python, <code>X[[1,2], [1,3]]</code> refers to a vector that contains the values of cell <code>[1,1]</code> and <code>[2,3]</code> in the matrix. <code>X[[1,2], [1,3]]</code> in Julia is equivalent with <code>X[np.ix_([0,1],[0,2])]</code> in Python. <code>X[[0,1], [0,2]]</code> in Python is equivalent with <code>X[[CartesianIndex(1,1), CartesianIndex(2,3)]]</code> in Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>X[[1,2], [1,3]]</code>のように配列で行列をインデックス指定すると、最初と二番目の行と最初と三番目の列の交差を含むサブマトリックスを指します。Pythonでは、<code>X[[1,2], [1,3]]</code>は行列のセル<code>[1,1]</code>と<code>[2,3]</code>の値を含むベクトルを指します。Juliaの<code>X[[1,2], [1,3]]</code>はPythonの<code>X[np.ix_([0,1],[0,2])]</code>と同等です。Pythonの<code>X[[0,1], [0,2]]</code>はJuliaの<code>X[[CartesianIndex(1,1), CartesianIndex(2,3)]]</code>と同等です。</span></li><li data-translated="true"><span class="original-text">Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaには行継続構文がありません。行の終わりで、これまでの入力が完全な式である場合、それは完了と見なされます。そうでない場合、入力は続きます。式を強制的に続けさせる方法の1つは、それを括弧で囲むことです。</span></li><li data-translated="true"><span class="original-text">Julia arrays are column-major (Fortran-ordered) whereas NumPy arrays are row-major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see <a href="../performance-tips/index.html#man-performance-column-major">relevant section of Performance Tips</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの配列は列優先（Fortran順）ですが、NumPyの配列はデフォルトで行優先（C順）です。配列をループする際に最適なパフォーマンスを得るためには、JuliaではNumPyに対してループの順序を逆にする必要があります（<a href="../performance-tips/index.html#man-performance-column-major">パフォーマンスチップの関連セクション</a>を参照）。</span></li><li data-translated="true"><span class="original-text">Julia's updating operators (e.g. <code>+=</code>, <code>-=</code>, ...) are <em>not in-place</em> whereas NumPy's are. This means <code>A = [1, 1]; B = A; B += [3, 3]</code> doesn't change values in <code>A</code>, it rather rebinds the name <code>B</code> to the result of the right-hand side <code>B = B + 3</code>, which is a new array. For in-place operation, use <code>B .+= 3</code> (see also <a href="../mathematical-operations/index.html#man-dot-operators">dot operators</a>), explicit loops, or <code>InplaceOps.jl</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの更新演算子（例：<code>+=</code>, <code>-=</code>, ...）は<em>インプレースではありません</em>が、NumPyのものはインプレースです。これは、<code>A = [1, 1]; B = A; B += [3, 3]</code>が<code>A</code>の値を変更せず、むしろ<code>B</code>という名前を右辺の結果<code>B = B + 3</code>に再バインドすることを意味します。これは新しい配列です。インプレース操作には、<code>B .+= 3</code>（<a href="../mathematical-operations/index.html#man-dot-operators">ドット演算子</a>も参照）、明示的なループ、または<code>InplaceOps.jl</code>を使用してください。</span></li><li data-translated="true"><span class="original-text">Julia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are evaluated only once when the function is defined. For example, the function <code>f(x=rand()) = x</code> returns a new random number every time it is invoked without argument. On the other hand, the function <code>g(x=[1,2]) = push!(x,3)</code> returns <code>[1,2,3]</code> every time it is called as <code>g()</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、関数引数のデフォルト値はメソッドが呼び出されるたびに評価されますが、Pythonでは関数が定義されるときに一度だけ評価されます。例えば、関数<code>f(x=rand()) = x</code>は、引数なしで呼び出されるたびに新しいランダム数を返します。一方、関数<code>g(x=[1,2]) = push!(x,3)</code>は、<code>g()</code>として呼び出されるたびに<code>[1,2,3]</code>を返します。</span></li><li data-translated="true"><span class="original-text">In Julia, keyword arguments must be passed using keywords, unlike Python in which it is usually possible to pass them positionally. Attempting to pass a keyword argument positionally alters the method signature leading to a <code>MethodError</code> or calling of the wrong method.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、キーワード引数はキーワードを使用して渡さなければなりませんが、Pythonでは通常位置引数として渡すことが可能です。キーワード引数を位置引数として渡そうとすると、メソッドシグネチャが変更され、<code>MethodError</code>や間違ったメソッドの呼び出しにつながります。</span></li><li data-translated="true"><span class="original-text">In Julia <code>%</code> is the remainder operator, whereas in Python it is the modulus.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは<code>%</code>は剰余演算子ですが、Pythonでは剰余です。</span></li><li data-translated="true"><span class="original-text">In Julia, the commonly used <code>Int</code> type corresponds to the machine integer type (<code>Int32</code> or <code>Int64</code>), unlike in Python, where <code>int</code> is an arbitrary length integer. This means in Julia the <code>Int</code> type will overflow, such that <code>2^64 == 0</code>. If you need larger values use another appropriate type, such as <code>Int128</code>, <a href="../../base/numbers/index.html#Base.GMP.BigInt"><code>BigInt</code></a> or a floating point type like <code>Float64</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、一般的に使用される<code>Int</code>型は、マシン整数型（<code>Int32</code>または<code>Int64</code>）に対応していますが、Pythonでは<code>int</code>は任意の長さの整数です。これは、Juliaでは<code>Int</code>型がオーバーフローすることを意味し、<code>2^64 == 0</code>となります。より大きな値が必要な場合は、<code>Int128</code>、<a href="../../base/numbers/index.html#Base.GMP.BigInt"><code>BigInt</code></a>、または<code>Float64</code>のような浮動小数点型など、他の適切な型を使用してください。</span></li><li data-translated="true"><span class="original-text">The imaginary unit <code>sqrt(-1)</code> is represented in Julia as <code>im</code>, not <code>j</code> as in Python.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">虚数単位<code>sqrt(-1)</code>は、Juliaでは<code>im</code>として表され、Pythonでは<code>j</code>として表されます。</span></li><li data-translated="true"><span class="original-text">In Julia, the exponentiation operator is <code>^</code>, not <code>**</code> as in Python.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、累乗演算子は<code>^</code>であり、Pythonの<code>**</code>ではありません。</span></li><li data-translated="true"><span class="original-text">Julia uses <code>nothing</code> of type <code>Nothing</code> to represent a null value, whereas Python uses <code>None</code> of type <code>NoneType</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは、型<code>Nothing</code>の<code>nothing</code>を使用してnull値を表現しますが、Pythonは型<code>NoneType</code>の<code>None</code>を使用します。</span></li><li data-translated="true"><span class="original-text">In Julia, the standard operators over a matrix type are matrix operations, whereas, in Python, the standard operators are element-wise operations. When both <code>A</code> and <code>B</code> are matrices, <code>A * B</code> in Julia performs matrix multiplication, not element-wise multiplication as in Python. <code>A * B</code> in Julia is equivalent with <code>A @ B</code> in Python, whereas <code>A * B</code> in Python is equivalent with <code>A .* B</code> in Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、行列型に対する標準演算子は行列演算ですが、Pythonでは標準演算子は要素ごとの演算です。<code>A</code>と<code>B</code>の両方が行列である場合、Juliaの<code>A * B</code>は行列の掛け算を行い、Pythonのように要素ごとの掛け算にはなりません。Juliaの<code>A * B</code>はPythonの<code>A @ B</code>に相当し、Pythonの<code>A * B</code>はJuliaの<code>A .* B</code>に相当します。</span></li><li data-translated="true"><span class="original-text">In Julia, when you want to apply a scalar-valued function elementwise to an array, use broadcasting syntax: <code>f.(A)</code> instead of <code>f(A)</code>. In some cases, both operations are defined but mean different things: <code>numpy.exp(A)</code> applies elementwise and <code>scipy.linalg.expm(A)</code> is the <a href="https://en.wikipedia.org/wiki/Matrix_exponential">matrix exponential</a>, but in Julia <code>exp.(A)</code> applies elementwise and <code>exp(A)</code> is the matrix exponential.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、スカラー値関数を配列に要素ごとに適用したい場合、ブロードキャスティング構文<code>f.(A)</code>を使用し、<code>f(A)</code>は使用しません。場合によっては、両方の操作が定義されていますが、異なる意味を持ちます：<code>numpy.exp(A)</code>は要素ごとに適用され、<code>scipy.linalg.expm(A)</code>は<a href="https://en.wikipedia.org/wiki/Matrix_exponential">行列指数関数</a>ですが、Juliaでは<code>exp.(A)</code>が要素ごとに適用され、<code>exp(A)</code>は行列指数関数です。</span></li><li data-translated="true"><span class="original-text">The adjoint operator <code>'</code> in Julia returns an adjoint of a vector (a lazy representation of row vector), whereas the transpose operator <code>.T</code> over a vector in Python returns the original vector (non-op).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの随伴演算子<code>'</code>はベクトルの随伴を返します（行ベクトルの遅延表現）が、Pythonのベクトルに対する転置演算子<code>.T</code>は元のベクトル（ノンオペレーション）を返します。</span></li><li data-translated="true"><span class="original-text">In Julia, a function may contain multiple concrete implementations (called <em>methods</em>), which are selected via multiple dispatch based on the types of all arguments to the call, as compared to functions in Python, which have a single implementation and no polymorphism (as opposed to Python method calls which use a different syntax and allows dispatch on the receiver of the method).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、関数は複数の具体的な実装（<em>メソッド</em>と呼ばれる）を含むことができ、呼び出しのすべての引数の型に基づいて複数のディスパッチによって選択されます。これに対して、Pythonの関数は単一の実装を持ち、ポリモーフィズムはありません（Pythonのメソッド呼び出しは異なる構文を使用し、メソッドの受信者に基づいてディスパッチを許可します）。</span></li><li data-translated="true"><span class="original-text">There are no classes in Julia. Instead there are structures (mutable or immutable), containing data but no methods.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaにはクラスはありません。その代わりに、データを含むがメソッドを持たない構造体（可変または不変）があります。</span></li><li data-translated="true"><span class="original-text">Calling a method of a class instance in Python (<code>x = MyClass(*args); x.f(y)</code>) corresponds to a function call in Julia, e.g. <code>x = MyType(args...); f(x, y)</code>. In general, multiple dispatch is more flexible and powerful than the Python class system.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Pythonのクラスインスタンスのメソッドを呼び出すこと（<code>x = MyClass(*args); x.f(y)</code>）は、Juliaの関数呼び出しに対応します。例えば、<code>x = MyType(args...); f(x, y)</code>です。一般に、複数のディスパッチはPythonのクラスシステムよりも柔軟で強力です。</span></li><li data-translated="true"><span class="original-text">Julia structures may have exactly one abstract supertype, whereas Python classes can inherit from one or more (abstract or concrete) superclasses.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの構造体は正確に1つの抽象スーパタイプを持つことができますが、Pythonのクラスは1つ以上の（抽象または具体的な）スーパークラスから継承できます。</span></li><li data-translated="true"><span class="original-text">The logical Julia program structure (Packages and Modules) is independent of the file structure, whereas the Python code structure is defined by directories (Packages) and files (Modules).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">論理的なJuliaプログラム構造（パッケージとモジュール）はファイル構造とは独立していますが、Pythonのコード構造はディレクトリ（パッケージ）とファイル（モジュール）によって定義されています。</span></li><li data-translated="true"><span class="original-text">In Julia, it is idiomatic to split the text of large modules into multiple files, without introducing a new module per file. The code is reassembled inside a single module in a main file via <code>include</code>. While the Python equivalent (<code>exec</code>) is not typical for this use (it will silently clobber prior definitions), Julia programs are defined as a unit at the <code>module</code> level with <code>using</code> or <code>import</code>, which will only get executed once when first needed–like <code>include</code> in Python. Within those modules, the individual files that make up that module are loaded with <code>include</code> by listing them once in the intended order.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、大きなモジュールのテキストを複数のファイルに分割することが慣用的であり、ファイルごとに新しいモジュールを導入することはありません。コードは、<code>include</code>を介してメインファイル内の単一のモジュールに再構成されます。Pythonの同等のもの（<code>exec</code>）はこの用途には一般的ではなく（以前の定義を静かに上書きしてしまいます）、Juliaプログラムは<code>using</code>または<code>import</code>を使用して<code>module</code>レベルで単位として定義され、最初に必要になったときにのみ一度実行されます—Pythonの<code>include</code>のように。これらのモジュール内では、そのモジュールを構成する個々のファイルが、意図した順序で一度リストアップして<code>include</code>によって読み込まれます。</span></li><li data-translated="true"><span class="original-text">The ternary operator <code>x &gt; 0 ? 1 : -1</code> in Julia corresponds to a conditional expression in Python <code>1 if x &gt; 0 else -1</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの三項演算子<code>x &gt; 0 ? 1 : -1</code>は、Pythonの条件式<code>1 if x &gt; 0 else -1</code>に対応します。</span></li><li data-translated="true"><span class="original-text">In Julia the <code>@</code> symbol refers to a macro, whereas in Python it refers to a decorator.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは<code>@</code>記号はマクロを指しますが、Pythonではデコレーターを指します。</span></li><li data-translated="true"><span class="original-text">Exception handling in Julia is done using <code>try</code> — <code>catch</code> — <code>finally</code>, instead of <code>try</code> — <code>except</code> — <code>finally</code>. In contrast to Python, it is not recommended to use exception handling as part of the normal workflow in Julia (compared with Python, Julia is faster at ordinary control flow but slower at exception-catching).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでの例外処理は<code>try</code> — <code>catch</code> — <code>finally</code>を使用して行われ、<code>try</code> — <code>except</code> — <code>finally</code>ではありません。Pythonとは対照的に、Juliaでは通常のワークフローの一部として例外処理を使用することは推奨されていません（Pythonと比較して、Juliaは通常の制御フローでは速いですが、例外キャッチでは遅いです）。</span></li><li data-translated="true"><span class="original-text">In Julia loops are fast, there is no need to write "vectorized" code for performance reasons.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaではループは高速であり、パフォーマンスの理由から「ベクトル化」されたコードを書く必要はありません。</span></li><li data-translated="true"><span class="original-text">Be careful with non-constant global variables in Julia, especially in tight loops. Since you can write close-to-metal code in Julia (unlike Python), the effect of globals can be drastic (see <a href="../performance-tips/index.html#man-performance-tips">Performance Tips</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、特にタイトなループ内で非定数のグローバル変数に注意してください。Juliaでは（Pythonとは異なり）メタルに近いコードを書くことができるため、グローバル変数の影響は劇的になる可能性があります（詳細は<a href="../performance-tips/index.html#man-performance-tips">パフォーマンスのヒント</a>を参照）。</span></li><li data-translated="true"><span class="original-text">In Julia, rounding and truncation are explicit. Python's <code>int(3.7)</code> should be <code>floor(Int, 3.7)</code> or <code>Int(floor(3.7))</code> and is distinguished from <code>round(Int, 3.7)</code>. <code>floor(x)</code> and <code>round(x)</code> on their own return an integer value of the same type as <code>x</code> rather than always returning <code>Int</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、丸めと切り捨ては明示的です。Pythonの<code>int(3.7)</code>は<code>floor(Int, 3.7)</code>または<code>Int(floor(3.7))</code>であり、<code>round(Int, 3.7)</code>とは区別されます。<code>floor(x)</code>と<code>round(x)</code>は、それぞれ独自に<code>x</code>と同じ型の整数値を返し、常に<code>Int</code>を返すわけではありません。</span></li><li data-translated="true"><span class="original-text">In Julia, parsing is explicit. Python's <code>float("3.7")</code> would be <code>parse(Float64, "3.7")</code> in Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、パースは明示的です。Pythonの<code>float("3.7")</code>はJuliaでは<code>parse(Float64, "3.7")</code>になります。</span></li><li data-translated="true"><span class="original-text">In Python, the majority of values can be used in logical contexts (e.g. <code>if "a":</code> means the following block is executed, and <code>if "":</code> means it is not). In Julia, you need explicit conversion to <code>Bool</code> (e.g. <code>if "a"</code> throws an exception). If you want to test for a non-empty string in Julia, you would explicitly write <code>if !isempty("")</code>. Perhaps surprisingly, in Python <code>if "False"</code> and <code>bool("False")</code> both evaluate to <code>True</code> (because <code>"False"</code> is a non-empty string); in Julia, <code>parse(Bool, "false")</code> returns <code>false</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Pythonでは、ほとんどの値は論理コンテキストで使用できます（例：<code>if "a":</code>は次のブロックが実行されることを意味し、<code>if "":</code>は実行されないことを意味します）。Juliaでは、<code>Bool</code>への明示的な変換が必要です（例：<code>if "a"</code>は例外をスローします）。Juliaで非空文字列をテストしたい場合は、明示的に<code>if !isempty("")</code>と書く必要があります。驚くべきことに、Pythonでは<code>if "False"</code>と<code>bool("False")</code>の両方が<code>True</code>に評価されます（<code>"False"</code>は非空文字列であるため）；Juliaでは、<code>parse(Bool, "false")</code>は<code>false</code>を返します。</span></li><li data-translated="true"><span class="original-text">In Julia, a new local scope is introduced by most code blocks, including loops and <code>try</code> — <code>catch</code> — <code>finally</code>. Note that comprehensions (list, generator, etc.) introduce a new local scope both in Python and Julia, whereas <code>if</code> blocks do not introduce a new local scope in both languages.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、ほとんどのコードブロック（ループや<code>try</code> — <code>catch</code> — <code>finally</code>を含む）によって新しいローカルスコープが導入されます。リスト内包表記、ジェネレーターなどは、PythonとJuliaの両方で新しいローカルスコープを導入しますが、<code>if</code>ブロックは両方の言語で新しいローカルスコープを導入しません。</span></li></ul><h2 id="Noteworthy-differences-from-C/C" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-C/C">Noteworthy differences from C/C++</a><a id="Noteworthy-differences-from-C/C-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-C/C" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-C/C">C/C++との注目すべき違い</a><a id="Noteworthy-differences-from-C/C-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-C/C" title="Permalink"></a></span></h2><ul><li data-translated="true"><span class="original-text">Julia arrays are indexed with square brackets, and can have more than one dimension <code>A[i,j]</code>. This syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. See <a href="../arrays/index.html#man-multi-dim-arrays">the manual entry about array construction</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの配列は角括弧でインデックス付けされ、複数の次元を持つことができます <code>A[i,j]</code>。この構文は、C/C++のポインタやアドレスへの参照のための単なる構文糖ではありません。<a href="../arrays/index.html#man-multi-dim-arrays">配列構築に関するマニュアルのエントリ</a>を参照してください。</span></li><li data-translated="true"><span class="original-text">In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、配列や文字列などのインデックスは1から始まり、0から始まりません。</span></li><li data-translated="true"><span class="original-text">Julia arrays are not copied when assigned to another variable. After <code>A = B</code>, changing elements of <code>B</code> will modify <code>A</code> as well. Updating operators like <code>+=</code> do not operate in-place, they are equivalent to <code>A = A + B</code> which rebinds the left-hand side to the result of the right-hand side expression.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの配列は、別の変数に代入されるときにコピーされません。<code>A = B</code>の後、<code>B</code>の要素を変更すると、<code>A</code>も変更されます。<code>+=</code>のような更新演算子はインプレースで動作せず、<code>A = A + B</code>に相当し、左辺を右辺の式の結果に再バインドします。</span></li><li data-translated="true"><span class="original-text">Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see <a href="../performance-tips/index.html#man-performance-column-major">relevant section of Performance Tips</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの配列は列優先（Fortran順）であり、C/C++の配列はデフォルトで行優先です。配列をループする際に最適なパフォーマンスを得るためには、ループの順序をC/C++に対して逆にする必要があります（<a href="../performance-tips/index.html#man-performance-column-major">パフォーマンスチップの関連セクション</a>を参照）。</span></li><li data-translated="true"><span class="original-text">Julia values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、値は代入または関数に渡されるときにコピーされません。関数が配列を変更すると、その変更は呼び出し元に表示されます。</span></li><li data-translated="true"><span class="original-text">In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、空白が重要であり、C/C++とは異なり、Juliaプログラムから空白を追加または削除する際には注意が必要です。</span></li><li data-translated="true"><span class="original-text">In Julia, literal numbers without a decimal point (such as <code>42</code>) create signed integers, of type <code>Int</code>, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as <code>Int64</code> (if <code>Int</code> is <code>Int32</code>), <code>Int128</code>, or the arbitrarily large <code>BigInt</code> type. There are no numeric literal suffixes, such as <code>L</code>, <code>LL</code>, <code>U</code>, <code>UL</code>, <code>ULL</code> to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with <code>0x</code> like C/C++), are unsigned, unless when they encode more than 128 bits, in which case they are of type <code>BigInt</code>. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the <em>length</em> of the literal, including leading 0s. For example, <code>0x0</code> and <code>0x00</code> have type <a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a>, <code>0x000</code> and <code>0x0000</code> have type <a href="../../base/numbers/index.html#Core.UInt16"><code>UInt16</code></a>, then literals with 5 to 8 hex digits have type <code>UInt32</code>, 9 to 16 hex digits type <code>UInt64</code>, 17 to 32 hex digits type <code>UInt128</code>, and more that 32 hex digits type <code>BigInt</code>. This needs to be taken into account when defining hexadecimal masks, for example <code>~0xf == 0xf0</code> is very different from <code>~0x000f == 0xfff0</code>. 64 bit <code>Float64</code> and 32 bit <a href="../../base/numbers/index.html#Core.Float32"><code>Float32</code></a> bit literals are expressed as <code>1.0</code> and <code>1.0f0</code> respectively. Floating point literals are rounded (and not promoted to the <code>BigFloat</code> type) if they can not be exactly represented.  Floating point literals are closer in behavior to C/C++. Octal (prefixed with <code>0o</code>) and binary (prefixed with <code>0b</code>) literals are also treated as unsigned (or <code>BigInt</code> for more than 128 bits).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、小数点のないリテラル数（例えば<code>42</code>）は符号付き整数を生成し、<code>Int</code>型になりますが、マシンワードサイズに収まらないほど大きなリテラルは自動的により大きなサイズの型に昇格します。例えば、<code>Int</code>が<code>Int32</code>の場合、<code>Int64</code>、<code>Int128</code>、または任意の大きさの<code>BigInt</code>型になります。符号なしおよび符号付きを示すための数値リテラル接尾辞（<code>L</code>、<code>LL</code>、<code>U</code>、<code>UL</code>、<code>ULL</code>など）はありません。10進リテラルは常に符号付きであり、16進リテラル（C/C++のように<code>0x</code>で始まる）は符号なしですが、128ビットを超える場合は<code>BigInt</code>型になります。16進リテラルは、C/C++/Javaとは異なり、Juliaの10進リテラルとは異なり、リテラルの<em>長さ</em>に基づいて型が決まります。例えば、<code>0x0</code>と<code>0x00</code>は<a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a>型、<code>0x000</code>と<code>0x0000</code>は<a href="../../base/numbers/index.html#Core.UInt16"><code>UInt16</code></a>型、5から8桁の16進数リテラルは<code>UInt32</code>型、9から16桁は<code>UInt64</code>型、17から32桁は<code>UInt128</code>型、32桁を超えるものは<code>BigInt</code>型になります。これは、例えば<code>~0xf == 0xf0</code>が<code>~0x000f == 0xfff0</code>とは非常に異なるため、16進マスクを定義する際に考慮する必要があります。64ビット<code>Float64</code>および32ビット<a href="../../base/numbers/index.html#Core.Float32"><code>Float32</code></a>のリテラルはそれぞれ<code>1.0</code>および<code>1.0f0</code>として表現されます。浮動小数点リテラルは、正確に表現できない場合は丸められ（<code>BigFloat</code>型には昇格されません）、浮動小数点リテラルはC/C++に近い動作をします。8進数（<code>0o</code>で接頭辞）および2進数（<code>0b</code>で接頭辞）のリテラルも符号なしとして扱われます（128ビットを超える場合は<code>BigInt</code>）。</span></li><li data-translated="true"><span class="original-text">In Julia, the division operator <a href="../../base/math/#Base.:/#Base.:/"><code>/</code></a> returns a floating point number when both operands are of integer type. To perform integer division, use <a href="../../base/math/index.html#Base.div"><code>div</code></a> or <a href="../../base/math/index.html#Base.div"><code>÷</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、除算演算子<a href="../../base/math/#Base.:/#Base.:/"><code>/</code></a>は、両方のオペランドが整数型の場合に浮動小数点数を返します。整数除算を行うには、<a href="../../base/math/index.html#Base.div"><code>div</code></a>または<a href="../../base/math/index.html#Base.div"><code>÷</code></a>を使用します。</span></li><li data-translated="true"><span class="original-text">Indexing an <code>Array</code> with floating point types is generally an error in Julia. The Julia equivalent of the C expression <code>a[i / 2]</code> is <code>a[i ÷ 2 + 1]</code>, where <code>i</code> is of integer type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">浮動小数点型で<code>Array</code>をインデックス付けすることは、一般的にJuliaではエラーです。Cの式<code>a[i / 2]</code>のJuliaの同等物は<code>a[i ÷ 2 + 1]</code>であり、ここで<code>i</code>は整数型です。</span></li><li data-translated="true"><span class="original-text">String literals can be delimited with either <code>"</code>  or <code>"""</code>, <code>"""</code> delimited literals can contain <code>"</code> characters without quoting it like <code>"\""</code>. String literals can have values of other variables or expressions interpolated into them, indicated by <code>$variablename</code> or <code>$(expression)</code>, which evaluates the variable name or the expression in the context of the function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列リテラルは、<code>"</code> または <code>"""</code> で区切ることができ、<code>"""</code> で区切られたリテラルは、<code>"</code> 文字を引用符なしで含むことができます。例えば、<code>"\""</code> のように。文字列リテラルには、他の変数や式の値を埋め込むことができ、<code>$variablename</code> または <code>$(expression)</code> で示され、関数のコンテキスト内で変数名や式が評価されます。</span></li><li data-translated="true"><span class="original-text"><code>//</code> indicates a <a href="../../base/numbers/index.html#Base.Rational"><code>Rational</code></a> number, and not a single-line comment (which is <code>#</code> in Julia)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>//</code> は <a href="../../base/numbers/index.html#Base.Rational"><code>Rational</code></a> 数を示し、単一行コメント（Juliaでは <code>#</code>）ではありません。</span></li><li data-translated="true"><span class="original-text"><code>#=</code> indicates the start of a multiline comment, and <code>=#</code> ends it.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>#=</code> はマルチラインコメントの開始を示し、<code>=#</code> がそれを終了します。</span></li><li data-translated="true"><span class="original-text">Functions in Julia return values from their last expression(s) or the <code>return</code> keyword. Multiple values can be returned from functions and assigned as tuples, e.g. <code>(a, b) = myfunction()</code> or <code>a, b = myfunction()</code>, instead of having to pass pointers to values as one would have to do in C/C++ (i.e. <code>a = myfunction(&amp;b)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの関数は、最後の式または <code>return</code> キーワードから値を返します。複数の値を関数から返し、タプルとして割り当てることができます。例えば、<code>(a, b) = myfunction()</code> または <code>a, b = myfunction()</code> のように、C/C++のように値へのポインタを渡す必要はありません（つまり、<code>a = myfunction(&amp;b)</code> のように）。</span></li><li data-translated="true"><span class="original-text">Julia does not require the use of semicolons to end statements. The results of expressions are not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to end with semicolons. <a href="../../base/io-network/index.html#Base.println"><code>println</code></a> or <a href="../../stdlib/Printf/index.html#Printf.@printf"><code>@printf</code></a> can be used to print specific output. In the REPL, <code>;</code> can be used to suppress output. <code>;</code> also has a different meaning within <code>[ ]</code>, something to watch out for. <code>;</code> can be used to separate expressions on a single line, but are not strictly necessary in many cases, and are more an aid to readability.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、文を終了するためにセミコロンを使用する必要はありません。式の結果は自動的に印刷されず（インタラクティブプロンプト、つまりREPLを除く）、コードの行はセミコロンで終わる必要はありません。特定の出力を印刷するには、<a href="../../base/io-network/index.html#Base.println"><code>println</code></a> または <a href="../../stdlib/Printf/index.html#Printf.@printf"><code>@printf</code></a> を使用できます。REPLでは、<code>;</code> を使用して出力を抑制できます。<code>;</code> は <code>[ ]</code> 内で異なる意味を持つため、注意が必要です。<code>;</code> は単一行の式を区切るために使用できますが、多くの場合厳密には必要なく、可読性を助けるためのものです。</span></li><li data-translated="true"><span class="original-text">In Julia, the operator <a href="../../base/math/index.html#Base.xor"><code>⊻</code></a> (<a href="../../base/math/index.html#Base.xor"><code>xor</code></a>) performs the bitwise XOR operation, i.e. <a href="../../base/math/#Base.:^-Tuple{Number, Number}#Base.:^-Tuple{Number, Number}"><code>^</code></a> in C/C++. Also, the bitwise operators do not have the same precedence as C/C++, so parenthesis may be required.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、演算子 <a href="../../base/math/index.html#Base.xor"><code>⊻</code></a> (<a href="../../base/math/index.html#Base.xor"><code>xor</code></a>) はビット単位のXOR演算を行います。つまり、C/C++の <a href="../../base/math/#Base.:^-Tuple{Number, Number}#Base.:^-Tuple{Number, Number}"><code>^</code></a> のように。また、ビット単位の演算子はC/C++と同じ優先順位を持たないため、括弧が必要な場合があります。</span></li><li data-translated="true"><span class="original-text">Julia's <a href="../../base/math/#Base.:^-Tuple{Number, Number}#Base.:^-Tuple{Number, Number}"><code>^</code></a> is exponentiation (pow), not bitwise XOR as in C/C++ (use <a href="../../base/math/index.html#Base.xor"><code>⊻</code></a>, or <a href="../../base/math/index.html#Base.xor"><code>xor</code></a>, in Julia)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの <a href="../../base/math/#Base.:^-Tuple{Number, Number}#Base.:^-Tuple{Number, Number}"><code>^</code></a> は累乗（pow）を示し、C/C++のビット単位のXORではありません（Juliaでは <a href="../../base/math/index.html#Base.xor"><code>⊻</code></a> または <a href="../../base/math/index.html#Base.xor"><code>xor</code></a> を使用してください）。</span></li><li data-translated="true"><span class="original-text">Julia has two right-shift operators, <code>&gt;&gt;</code> and <code>&gt;&gt;&gt;</code>.  <code>&gt;&gt;</code> performs an arithmetic shift, <code>&gt;&gt;&gt;</code> always performs a logical shift, unlike C/C++, where the meaning of <code>&gt;&gt;</code> depends on the type of the value being shifted.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaには2つの右シフト演算子、<code>&gt;&gt;</code> と <code>&gt;&gt;&gt;</code> があります。<code>&gt;&gt;</code> は算術シフトを行い、<code>&gt;&gt;&gt;</code> は常に論理シフトを行います。C/C++とは異なり、<code>&gt;&gt;</code> の意味はシフトされる値の型によって異なります。</span></li><li data-translated="true"><span class="original-text">Julia's <code>-&gt;</code> creates an anonymous function, it does not access a member via a pointer.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの <code>-&gt;</code> は匿名関数を作成し、ポインタを介してメンバーにアクセスするものではありません。</span></li><li data-translated="true"><span class="original-text">Julia does not require parentheses when writing <code>if</code> statements or <code>for</code>/<code>while</code> loops: use <code>for i in [1, 2, 3]</code> instead of <code>for (int i=1; i &lt;= 3; i++)</code> and <code>if i == 1</code> instead of <code>if (i == 1)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>if</code> 文や <code>for</code>/<code>while</code> ループを書く際に括弧は必要ありません。<code>for i in [1, 2, 3]</code> のように書き、<code>for (int i=1; i &lt;= 3; i++)</code> の代わりに使用し、<code>if i == 1</code> のように書き、<code>if (i == 1)</code> の代わりに使用します。</span></li><li data-translated="true"><span class="original-text">Julia does not treat the numbers <code>0</code> and <code>1</code> as Booleans. You cannot write <code>if (1)</code> in Julia, because <code>if</code> statements accept only booleans. Instead, you can write <code>if true</code>, <code>if Bool(1)</code>, or <code>if 1==1</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは、数値<code>0</code>と<code>1</code>をブール値として扱いません。<code>if (1)</code>と書くことはできません。なぜなら、<code>if</code>文はブール値のみを受け入れるからです。代わりに、<code>if true</code>、<code>if Bool(1)</code>、または<code>if 1==1</code>と書くことができます。</span></li><li data-translated="true"><span class="original-text">Julia uses <code>end</code> to denote the end of conditional blocks, like <code>if</code>, loop blocks, like <code>while</code>/ <code>for</code>, and functions. In lieu of the one-line <code>if ( cond ) statement</code>, Julia allows statements of the form <code>if cond; statement; end</code>, <code>cond &amp;&amp; statement</code> and <code>!cond || statement</code>. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. <code>cond &amp;&amp; (x = value)</code>, because of the operator precedence.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは、<code>if</code>のような条件ブロックや、<code>while</code>/<code>for</code>のようなループブロック、関数の終了を示すために<code>end</code>を使用します。1行の<code>if ( cond ) statement</code>の代わりに、Juliaは<code>if cond; statement; end</code>、<code>cond &amp;&amp; statement</code>、および<code>!cond || statement</code>の形式の文を許可します。後者の2つの構文の代入文は、演算子の優先順位のために明示的に括弧で囲む必要があります。例えば、<code>cond &amp;&amp; (x = value)</code>のようにします。</span></li><li data-translated="true"><span class="original-text">Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaには行継続構文がありません。行の終わりで、これまでの入力が完全な式である場合、それは完了と見なされます。そうでない場合、入力は続きます。式を強制的に続けさせる方法の1つは、それを括弧で囲むことです。</span></li><li data-translated="true"><span class="original-text">Julia macros operate on parsed expressions, rather than the text of the program, which allows them to perform sophisticated transformations of Julia code. Macro names start with the <code>@</code> character, and have both a function-like syntax, <code>@mymacro(arg1, arg2, arg3)</code>, and a statement-like syntax, <code>@mymacro arg1 arg2 arg3</code>. The forms are interchangeable; the function-like form is particularly useful if the macro appears within another expression, and is often clearest. The statement-like form is often used to annotate blocks, as in the distributed <code>for</code> construct: <code>@distributed for i in 1:n; #= body =#; end</code>. Where the end of the macro construct may be unclear, use the function-like form.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaのマクロは、プログラムのテキストではなく解析された式に対して動作します。これにより、Juliaコードの高度な変換を実行できます。マクロ名は<code>@</code>文字で始まり、関数のような構文<code>@mymacro(arg1, arg2, arg3)</code>と文のような構文<code>@mymacro arg1 arg2 arg3</code>の両方を持ちます。これらの形式は相互に置き換え可能です。関数のような形式は、マクロが別の式内に現れる場合に特に便利で、しばしば最も明確です。文のような形式は、分散<code>for</code>構文のようにブロックに注釈を付けるために使用されることが多いです：<code>@distributed for i in 1:n; #= body =#; end</code>。マクロ構文の終わりが不明な場合は、関数のような形式を使用してください。</span></li><li data-translated="true"><span class="original-text">Julia has an enumeration type, expressed using the macro <code>@enum(name, value1, value2, ...)</code> For example: <code>@enum(Fruit, banana=1, apple, pear)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaには列挙型があり、マクロ<code>@enum(name, value1, value2, ...)</code>を使用して表現されます。例えば：<code>@enum(Fruit, banana=1, apple, pear)</code></span></li><li data-translated="true"><span class="original-text">By convention, functions that modify their arguments have a <code>!</code> at the end of the name, for example <code>push!</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">慣例として、引数を変更する関数は名前の末尾に<code>!</code>を付けます。例えば<code>push!</code>のように。</span></li><li data-translated="true"><span class="original-text">In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is "virtual" (although it's more general than that since methods are dispatched on every argument type, not only <code>this</code>, using the most-specific-declaration rule).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C++では、デフォルトで静的ディスパッチがあります。つまり、動的ディスパッチを持つためには関数を仮想として注釈付けする必要があります。一方、Juliaではすべてのメソッドが「仮想」です（ただし、これはより一般的で、メソッドは<code>this</code>だけでなく、すべての引数の型に基づいてディスパッチされるため、最も特異な宣言ルールに従います）。</span></li></ul><h3 id="Julia-C/C:-Namespaces" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Julia-C/C:-Namespaces">Julia ⇔ C/C++: Namespaces</a><a id="Julia-C/C:-Namespaces-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-C/C:-Namespaces" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Julia-C/C:-Namespaces">Julia ⇔ C/C++: 名前空間</a><a id="Julia-C/C:-Namespaces-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-C/C:-Namespaces" title="Permalink"></a></span></h3><ul><li data-translated="true"><span class="original-text">C/C++ <code>namespace</code>s correspond roughly to Julia <code>module</code>s.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C/C++の<code>namespace</code>は、Juliaの<code>module</code>に大まかに対応します。</span></li><li data-translated="true"><span class="original-text">There are no private globals or fields in Julia. Everything is publicly accessible through fully qualified paths (or relative paths, if desired).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaにはプライベートなグローバル変数やフィールドはありません。すべては完全修飾パス（または必要に応じて相対パス）を通じて公開されています。</span></li><li data-translated="true"><span class="original-text"><code>using MyNamespace::myfun</code> (C++) corresponds roughly to <code>import MyModule: myfun</code> (Julia).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>using MyNamespace::myfun</code> (C++) はおおよそ <code>import MyModule: myfun</code> (Julia) に対応します。</span></li><li><code>using namespace MyNamespace</code> (C++) corresponds roughly to <code>using MyModule</code> (Julia)<ul><li data-translated="true"><span class="original-text">In Julia, only <code>export</code>ed symbols are made available to the calling module.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>export</code>されたシンボルのみが呼び出しモジュールに利用可能です。</span></li><li data-translated="true"><span class="original-text">In C++, only elements found in the included (public) header files are made available.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C++では、含まれている（公開）ヘッダーファイルに見つかった要素のみが利用可能です。</span></li></ul></li><li data-translated="true"><span class="original-text">Caveat: <code>import</code>/<code>using</code> keywords (Julia) also <em>load</em> modules (see below).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">注意: <code>import</code>/<code>using</code> キーワード（Julia）はモジュールを<em>ロード</em>します（下記参照）。</span></li><li>Caveat: <code>import</code>/<code>using</code> (Julia) works only at the global scope level (<code>module</code>s)<ul><li data-translated="true"><span class="original-text">In C++, <code>using namespace X</code> works within arbitrary scopes (ex: function scope).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C++では、<code>using namespace X</code> は任意のスコープ内で機能します（例: 関数スコープ）。</span></li></ul></li></ul><h3 id="Julia-C/C:-Module-loading" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Julia-C/C:-Module-loading">Julia ⇔ C/C++: Module loading</a><a id="Julia-C/C:-Module-loading-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-C/C:-Module-loading" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Julia-C/C:-Module-loading">Julia ⇔ C/C++: モジュールのロード</a><a id="Julia-C/C:-Module-loading-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-C/C:-Module-loading" title="Permalink"></a></span></h3><ul><li>When you think of a C/C++ "<strong>library</strong>", you are likely looking for a Julia "<strong>package</strong>".<ul><li data-translated="true"><span class="original-text">Caveat: C/C++ libraries often house multiple "software modules" whereas Julia "packages" typically house one.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">注意: C/C++ライブラリはしばしば複数の「ソフトウェアモジュール」を含むのに対し、Juliaの「パッケージ」は通常1つを含みます。</span></li><li data-translated="true"><span class="original-text">Reminder: Julia <code>module</code>s are global scopes (not necessarily "software modules").</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リマインダー: Juliaの<code>module</code>はグローバルスコープです（必ずしも「ソフトウェアモジュール」ではありません）。</span></li></ul></li><li><strong>Instead of build/<code>make</code> scripts</strong>, Julia uses "Project Environments" (sometimes called either "Project" or "Environment").<ul><li data-translated="true"><span class="original-text">Build scripts are only needed for more complex applications (like those needing to compile or download C/C++ executables).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ビルドスクリプトは、C/C++実行可能ファイルをコンパイルまたはダウンロードする必要があるような、より複雑なアプリケーションにのみ必要です。</span></li><li data-translated="true"><span class="original-text">To develop application or project in Julia, you can initialize its root directory as a "Project Environment", and house application-specific code/packages there. This provides good control over project dependencies, and future reproducibility.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでアプリケーションやプロジェクトを開発するには、そのルートディレクトリを「プロジェクト環境」として初期化し、アプリケーション固有のコード/パッケージをそこに配置できます。これにより、プロジェクトの依存関係や将来の再現性を良好に管理できます。</span></li><li data-translated="true"><span class="original-text">Available packages are added to a "Project Environment" with the <code>Pkg.add()</code> function or Pkg REPL mode. (This does not <strong>load</strong> said package, however).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">利用可能なパッケージは、<code>Pkg.add()</code>関数またはPkg REPLモードを使用して「プロジェクト環境」に追加されます。（ただし、これによりそのパッケージは<strong>ロード</strong>されません）。</span></li><li data-translated="true"><span class="original-text">The list of available packages (direct dependencies) for a "Project Environment" are saved in its <code>Project.toml</code> file.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">「プロジェクト環境」の利用可能なパッケージ（直接依存関係）のリストは、その<code>Project.toml</code>ファイルに保存されます。</span></li><li data-translated="true"><span class="original-text">The <em>full</em> dependency information for a "Project Environment" is auto-generated &amp; saved in its <code>Manifest.toml</code> file by <code>Pkg.resolve()</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">「プロジェクト環境」の<em>完全な</em>依存情報は、<code>Pkg.resolve()</code>によって自動生成され、<code>Manifest.toml</code>ファイルに保存されます。</span></li></ul></li><li>Packages ("software modules") available to the "Project Environment" are loaded with <code>import</code> or <code>using</code>.<ul><li data-translated="true"><span class="original-text">In C/C++, you <code>#include &lt;moduleheader&gt;</code> to get object/function declarations, and link in libraries when you build the executable.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C/C++では、<code>#include &lt;moduleheader&gt;</code>を使用してオブジェクト/関数の宣言を取得し、実行可能ファイルをビルドする際にライブラリをリンクします。</span></li><li data-translated="true"><span class="original-text">In Julia, calling using/import again just brings the existing module into scope, but does not load it again (similar to adding the non-standard <code>#pragma once</code> to C/C++).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、再度using/importを呼び出すと、既存のモジュールがスコープに持ち込まれますが、再度ロードされることはありません（C/C++における非標準の<code>#pragma once</code>を追加するのに似ています）。</span></li></ul></li><li><strong>Directory-based package repositories</strong> (Julia) can be made available by adding repository paths to the <code>Base.LOAD_PATH</code> array.<ul><li data-translated="true"><span class="original-text">Packages from directory-based repositories do not require the <code>Pkg.add()</code> tool prior to being loaded with <code>import</code> or <code>using</code>. They are simply available to the project.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ディレクトリベースのリポジトリからのパッケージは、<code>import</code>または<code>using</code>でロードする前に<code>Pkg.add()</code>ツールを必要としません。それらは単にプロジェクトに利用可能です。</span></li><li data-translated="true"><span class="original-text">Directory-based package repositories are the <strong>quickest solution</strong> to developing local libraries of "software modules".</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ディレクトリベースのパッケージリポジトリは、「ソフトウェアモジュール」のローカルライブラリを開発するための<strong>最も迅速な解決策</strong>です。</span></li></ul></li></ul><h3 id="Julia-C/C:-Assembling-modules" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Julia-C/C:-Assembling-modules">Julia ⇔ C/C++: Assembling modules</a><a id="Julia-C/C:-Assembling-modules-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-C/C:-Assembling-modules" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Julia-C/C:-Assembling-modules">Julia ⇔ C/C++: モジュールの組み立て</a><a id="Julia-C/C:-Assembling-modules-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-C/C:-Assembling-modules" title="Permalink"></a></span></h3><ul><li>In C/C++, <code>.c</code>/<code>.cpp</code> files are compiled &amp; added to a library with build/<code>make</code> scripts.<ul><li data-translated="true"><span class="original-text">In Julia, <code>import [PkgName]</code>/<code>using [PkgName]</code> statements load <code>[PkgName].jl</code> located in a package's <code>[PkgName]/src/</code> subdirectory.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>import [PkgName]</code>/<code>using [PkgName]</code>文は、パッケージの<code>[PkgName]/src/</code>サブディレクトリにある<code>[PkgName].jl</code>をロードします。</span></li><li data-translated="true"><span class="original-text">In turn, <code>[PkgName].jl</code> typically loads associated source files with calls to <code>include "[someotherfile].jl"</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">その結果、<code>[PkgName].jl</code>は通常、<code>include "[someotherfile].jl"</code>の呼び出しで関連するソースファイルをロードします。</span></li></ul></li><li><code>include "./path/to/somefile.jl"</code> (Julia) is very similar to <code>#include "./path/to/somefile.jl"</code> (C/C++).<ul><li data-translated="true"><span class="original-text">However <code>include "..."</code> (Julia) is not used to include header files (not required).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、<code>include "..."</code>（Julia）はヘッダーファイルを含めるために使用されません（必要ありません）。</span></li><li data-translated="true"><span class="original-text"><strong>Do not use</strong> <code>include "..."</code> (Julia) to load code from other "software modules" (use <code>import</code>/<code>using</code> instead).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>使用しないでください</strong> <code>include "..."</code>（Julia）を他の「ソフトウェアモジュール」からコードを読み込むために（代わりに<code>import</code>/<code>using</code>を使用してください）。</span></li><li data-translated="true"><span class="original-text"><code>include "path/to/some/module.jl"</code> (Julia) would instantiate multiple versions of the same code in different modules (creating <em>distinct</em> types (etc.) with the <em>same</em> names).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>include "path/to/some/module.jl"</code>（Julia）は、異なるモジュール内で同じコードの複数のバージョンをインスタンス化します（<em>異なる</em>型（など）を<em>同じ</em>名前で作成します）。</span></li><li data-translated="true"><span class="original-text"><code>include "somefile.jl"</code> is typically used to assemble multiple files <em>within the same Julia package</em> ("software module"). It is therefore relatively straightforward to ensure file are <code>include</code>d only once (No <code>#ifdef</code> confusion).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>include "somefile.jl"</code>は通常、<em>同じJuliaパッケージ</em>（「ソフトウェアモジュール」）内の複数のファイルを組み合わせるために使用されます。したがって、ファイルが<code>include</code>されるのは一度だけであることを比較的簡単に保証できます（<code>#ifdef</code>の混乱はありません）。</span></li></ul></li></ul><h3 id="Julia-C/C:-Module-interface" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Julia-C/C:-Module-interface">Julia ⇔ C/C++: Module interface</a><a id="Julia-C/C:-Module-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-C/C:-Module-interface" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Julia-C/C:-Module-interface">Julia ⇔ C/C++: モジュールインターフェース</a><a id="Julia-C/C:-Module-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-C/C:-Module-interface" title="Permalink"></a></span></h3><ul><li>C++ exposes interfaces using "public" <code>.h</code>/<code>.hpp</code> files whereas Julia <code>module</code>s mark specific symbols that are intended for their users as <code>public</code>or <code>export</code>ed.<ul><li data-translated="true"><span class="original-text">Often, Julia <code>module</code>s simply add functionality by generating new "methods" to existing functions (ex: <code>Base.push!</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しばしば、Juliaの<code>module</code>は既存の関数に新しい「メソッド」を生成することで機能を追加します（例: <code>Base.push!</code>）。</span></li><li data-translated="true"><span class="original-text">Developers of Julia packages therefore cannot rely on header files for interface documentation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、Juliaパッケージの開発者はインターフェースドキュメントのためにヘッダーファイルに依存することはできません。</span></li><li data-translated="true"><span class="original-text">Interfaces for Julia packages are typically described using docstrings, README.md, static web pages, ...</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaパッケージのインターフェースは通常、docstrings、README.md、静的ウェブページなどを使用して記述されます。</span></li></ul></li><li>Some developers choose not to <code>export</code> all symbols required to use their package/module, but should still mark unexported user facing symbols as <code>public</code>.<ul><li data-translated="true"><span class="original-text">Users might be expected to access these components by qualifying functions/structs/... with the package/module name (ex: <code>MyModule.run_this_task(...)</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ユーザーは、関数/構造体/...をパッケージ/モジュール名で修飾することによって、これらのコンポーネントにアクセスすることが期待されるかもしれません（例: <code>MyModule.run_this_task(...)</code>）。</span></li></ul></li></ul><h3 id="Julia-C/C:-Quick-reference" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Julia-C/C:-Quick-reference">Julia ⇔ C/C++: Quick reference</a><a id="Julia-C/C:-Quick-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-C/C:-Quick-reference" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Julia-C/C:-Quick-reference">Julia ⇔ C/C++: クイックリファレンス</a><a id="Julia-C/C:-Quick-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-C/C:-Quick-reference" title="Permalink"></a></span></h3><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Software Concept</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ソフトウェアコンセプト</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Julia</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia</span></th><th style="text-align: left" data-translated="true"><span class="original-text">C/C++</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C/C++</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text">unnamed scope</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">名前のないスコープ</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>begin</code> ... <code>end</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>begin</code> ... <code>end</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>{</code> ... <code>}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>{</code> ... <code>}</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text">function scope</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数スコープ</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>function x()</code> ... <code>end</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>function x()</code> ... <code>end</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>int x() {</code> ... <code>}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>int x() {</code> ... <code>}</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text">global scope</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバルスコープ</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>module MyMod</code> ... <code>end</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>module MyMod</code> ... <code>end</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>namespace MyNS {</code> ... <code>}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>namespace MyNS {</code> ... <code>}</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text">software module</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ソフトウェアモジュール</span></td><td style="text-align: left" data-translated="true"><span class="original-text">A Julia "package"</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの「パッケージ」</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>.h</code>/<code>.hpp</code> files&lt;br&gt;+compiled <code>somelib.a</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>.h</code>/<code>.hpp</code> ファイル&lt;br&gt;+コンパイルされた <code>somelib.a</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text">assembling&lt;br&gt;software modules</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">アセンブリング&lt;br&gt;ソフトウェアモジュール</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>SomePkg.jl</code>: ...&lt;br&gt;<code>import("subfile1.jl")</code>&lt;br&gt;<code>import("subfile2.jl")</code>&lt;br&gt;...</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>SomePkg.jl</code>: ...&lt;br&gt;<code>import("subfile1.jl")</code>&lt;br&gt;<code>import("subfile2.jl")</code>&lt;br&gt;...</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>$(AR) *.o</code> &amp;rArr; <code>somelib.a</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>$(AR) *.o</code> &amp;rArr; <code>somelib.a</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text">import&lt;br&gt;software module</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">インポート&lt;br&gt;ソフトウェアモジュール</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>import SomePkg</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>import SomePkg</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>#include &lt;somelib&gt;</code>&lt;br&gt;+link in <code>somelib.a</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>#include &lt;somelib&gt;</code>&lt;br&gt;+link in <code>somelib.a</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text">module library</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュールライブラリ</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>LOAD_PATH[]</code>, *Git repository,&lt;br&gt;**custom package registry</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>LOAD_PATH[]</code>, *Gitリポジトリ,&lt;br&gt;**カスタムパッケージレジストリ</span></td><td style="text-align: left" data-translated="true"><span class="original-text">more <code>.h</code>/<code>.hpp</code> files&lt;br&gt;+bigger compiled <code>somebiglib.a</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より多くの <code>.h</code>/<code>.hpp</code> ファイル&lt;br&gt;+より大きなコンパイル済み <code>somebiglib.a</code></span></td></tr></tbody></table><p data-translated="true"><span class="original-text">* The Julia package manager supports registering multiple packages from a single Git repository.&lt;br&gt; * This allows users to house a library of related packages in a single repository.&lt;br&gt; ** Julia registries are primarily designed to provide versioning \&amp; distribution of packages.&lt;br&gt; ** Custom package registries can be used to create a type of module library.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">* Juliaパッケージマネージャは、単一のGitリポジトリから複数のパッケージを登録することをサポートしています。&lt;br&gt; * これにより、ユーザーは関連するパッケージのライブラリを単一のリポジトリに収容できます。&lt;br&gt; ** Juliaレジストリは、主にパッケージのバージョン管理と配布を提供するために設計されています。&lt;br&gt; ** カスタムパッケージレジストリは、モジュールライブラリの一種を作成するために使用できます。</span></p><h2 id="Noteworthy-differences-from-Common-Lisp" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-Common-Lisp">Noteworthy differences from Common Lisp</a><a id="Noteworthy-differences-from-Common-Lisp-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-Common-Lisp" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-Common-Lisp">Common Lispとの注目すべき違い</a><a id="Noteworthy-differences-from-Common-Lisp-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-Common-Lisp" title="Permalink"></a></span></h2><ul><li><p data-translated="true"><span class="original-text">Julia uses 1-based indexing for arrays by default, and it can also handle arbitrary <a href="../../devdocs/offset-arrays/index.html#man-custom-indices">index offsets</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaはデフォルトで配列に1ベースのインデックスを使用し、任意の<a href="../../devdocs/offset-arrays/index.html#man-custom-indices">インデックスオフセット</a>も扱うことができます。</span></p></li><li><p data-translated="true"><span class="original-text">Functions and variables share the same namespace (“Lisp-1”).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数と変数は同じ名前空間を共有します（“Lisp-1”）。</span></p></li><li><p data-translated="true"><span class="original-text">There is a <a href="../../base/collections/index.html#Core.Pair"><code>Pair</code></a> type, but it is not meant to be used as a <code>COMMON-LISP:CONS</code>. Various iterable collections can be used interchangeably in most parts of the language (eg splatting, tuples, etc). <code>Tuple</code>s are the closest to Common Lisp lists for <em>short</em> collections of heterogeneous elements. Use <code>NamedTuple</code>s in place of alists. For larger collections of homogeneous types, <code>Array</code>s and <code>Dict</code>s should be used.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">タイプ<a href="../../base/collections/index.html#Core.Pair"><code>Pair</code></a>は存在しますが、<code>COMMON-LISP:CONS</code>として使用することは意図されていません。さまざまな反復可能なコレクションは、言語のほとんどの部分で互換的に使用できます（例：スプラッティング、タプルなど）。 <code>Tuple</code>は、<em>短い</em>異種要素のコレクションに対してCommon Lispリストに最も近いです。 alistの代わりに<code>NamedTuple</code>を使用してください。 同種の型の大きなコレクションには、<code>Array</code>と<code>Dict</code>を使用する必要があります。</span></p></li><li><p data-translated="true"><span class="original-text">The typical Julia workflow for prototyping also uses continuous manipulation of the image, implemented with the <a href="https://github.com/timholy/Revise.jl">Revise.jl</a> package.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロトタイピングのための典型的なJuliaワークフローは、<a href="https://github.com/timholy/Revise.jl">Revise.jl</a>パッケージを使用して実装された画像の継続的な操作も使用します。</span></p></li><li><p data-translated="true"><span class="original-text">For performance, Julia prefers that operations have <a href="../faq/index.html#man-type-stability">type stability</a>. Where Common Lisp abstracts away from the underlying machine operations, Julia cleaves closer to them. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パフォーマンスのために、Juliaは操作が<a href="../faq/index.html#man-type-stability">型安定性</a>を持つことを好みます。Common Lispが基盤となる機械操作から抽象化するのに対し、Juliaはそれにより近いです。例えば：</span></p><ul><li>Integer division using <code>/</code> always returns a floating-point result, even if the computation is exact.<ul><li data-translated="true"><span class="original-text"><code>//</code> always returns a rational result</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>//</code> は常に有理数の結果を返します</span></li><li data-translated="true"><span class="original-text"><code>÷</code> always returns a (truncated) integer result</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>÷</code> は常に（切り捨てられた）整数の結果を返します</span></li></ul></li><li data-translated="true"><span class="original-text">Bignums are supported, but conversion is not automatic; ordinary integers <a href="../faq/index.html#faq-integer-arithmetic">overflow</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Bignumsはサポートされていますが、変換は自動ではありません；通常の整数は<a href="../faq/index.html#faq-integer-arithmetic">オーバーフロー</a>します。</span></li><li data-translated="true"><span class="original-text">Complex numbers are supported, but to get complex results, <a href="../faq/index.html#faq-domain-errors">you need complex inputs</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複素数はサポートされていますが、複素結果を得るためには、<a href="../faq/index.html#faq-domain-errors">複素入力が必要です</a>。</span></li><li data-translated="true"><span class="original-text">There are multiple Complex and Rational types, with different component types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">異なるコンポーネントタイプを持つ複数のComplexおよびRationalタイプがあります。</span></li></ul></li><li><p data-translated="true"><span class="original-text">Modules (namespaces) can be hierarchical. <a href="../../base/base/index.html#import"><code>import</code></a> and <a href="../../base/base/index.html#using"><code>using</code></a> have a dual role: they load the code and make it available in the namespace. <code>import</code> for only the module name is possible (roughly equivalent to <code>ASDF:LOAD-OP</code>). Slot names don't need to be exported separately. Global variables can't be assigned to from outside the module (except with <code>eval(mod, :(var = val))</code> as an escape hatch).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュール（名前空間）は階層的にすることができます。<a href="../../base/base/index.html#import"><code>import</code></a> と <a href="../../base/base/index.html#using"><code>using</code></a> は二重の役割を持ちます：コードをロードし、名前空間で利用可能にします。モジュール名のみの<code>import</code>も可能です（おおよそ<code>ASDF:LOAD-OP</code>に相当します）。スロット名は別途エクスポートする必要はありません。グローバル変数はモジュールの外からは割り当てできません（<code>eval(mod, :(var = val))</code>を使うことで回避可能です）。</span></p></li><li><p data-translated="true"><span class="original-text">Macros start with <code>@</code>, and are not as seamlessly integrated into the language as Common Lisp; consequently, macro usage is not as widespread as in the latter. A form of hygiene for <a href="../metaprogramming/index.html#Metaprogramming">macros</a> is supported by the language. Because of the different surface syntax, there is no equivalent to <code>COMMON-LISP:&amp;BODY</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マクロは<code>@</code>で始まり、Common Lispほど言語にシームレスに統合されていません；その結果、マクロの使用は後者ほど広範ではありません。言語は<a href="../metaprogramming/index.html#Metaprogramming">マクロ</a>のための一種の衛生をサポートしています。異なる表面構文のため、<code>COMMON-LISP:&amp;BODY</code>に相当するものはありません。</span></p></li><li><p data-translated="true"><span class="original-text"><em>All</em> functions are generic and use multiple dispatch. Argument lists don't have to follow the same template, which leads to a powerful idiom (see <a href="../../base/base/index.html#do"><code>do</code></a>). Optional and keyword arguments are handled differently. Method ambiguities are not resolved like in the Common Lisp Object System, necessitating the definition of a more specific method for the intersection.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><em>すべての</em>関数はジェネリックであり、複数のディスパッチを使用します。引数リストは同じテンプレートに従う必要はなく、これにより強力なイディオムが生まれます（<a href="../../base/base/index.html#do"><code>do</code></a>を参照）。オプショナル引数とキーワード引数は異なる方法で処理されます。メソッドの曖昧さはCommon Lispオブジェクトシステムのようには解決されず、交差点のためにより具体的なメソッドの定義が必要です。</span></p></li><li><p data-translated="true"><span class="original-text">Symbols do not belong to any package, and do not contain any values <em>per se</em>. <code>M.var</code> evaluates the symbol <code>var</code> in the module <code>M</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">シンボルはどのパッケージにも属さず、<em>それ自体</em>に値を持ちません。<code>M.var</code>はモジュール<code>M</code>内でシンボル<code>var</code>を評価します。</span></p></li><li><p data-translated="true"><span class="original-text">A functional programming style is fully supported by the language, including closures, but isn't always the idiomatic solution for Julia. Some <a href="../performance-tips/index.html#man-performance-captured">workarounds</a> may be necessary for performance when modifying captured variables.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数型プログラミングスタイルは言語によって完全にサポートされており、クロージャも含まれていますが、必ずしもJuliaにおける慣用的な解決策ではありません。キャプチャされた変数を変更する際には、パフォーマンスのためにいくつかの<a href="../performance-tips/index.html#man-performance-captured">ワークアラウンド</a>が必要になる場合があります。</span></p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../faq/index.html">« Frequently Asked Questions</a><a class="docs-footer-nextpage" href="../unicode-input/index.html">Unicode Input »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>