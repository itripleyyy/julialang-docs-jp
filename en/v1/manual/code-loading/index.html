<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Code Loading · The Julia Language</title><meta name="title" content="Code Loading · The Julia Language"><meta property="og:title" content="Code Loading · The Julia Language"><meta property="twitter:title" content="Code Loading · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/code-loading/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/code-loading/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bi1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li class="is-active"><a class="tocitem" href="">Code Loading</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Definitions"><span>Definitions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Definitions"><span>定義</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Federation-of-packages"><span>Federation of packages</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Federation-of-packages"><span>パッケージの連合</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Environments"><span>Environments</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Environments"><span>環境</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Conclusion"><span>結論</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">コードの読み込み</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">コードの読み込み</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/code-loading.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="code-loading" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#code-loading">Code Loading</a><a id="code-loading-1"></a><a class="docs-heading-anchor-permalink" href="#code-loading" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#code-loading">コードの読み込み</a><a id="code-loading-1"></a><a class="docs-heading-anchor-permalink" href="#code-loading" title="Permalink"></a></span></h1><div class="admonition is-info" id="Note-4112ef7ac77da52a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4112ef7ac77da52a" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">This chapter covers the technical details of package loading. To install packages, use <a href="../../stdlib/Pkg/index.html#Pkg"><code>Pkg</code></a>, Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write <code>import X</code> or <code>using X</code>, as described in the <a href="../modules/index.html#modules">Modules documentation</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この章では、パッケージの読み込みに関する技術的詳細を説明します。パッケージをインストールするには、<a href="../../stdlib/Pkg/index.html#Pkg"><code>Pkg</code></a>、Juliaの組み込みパッケージマネージャを使用して、アクティブな環境にパッケージを追加します。アクティブな環境に既にあるパッケージを使用するには、<code>import X</code> または <code>using X</code> と記述します。これは、<a href="../modules/index.html#modules">モジュールのドキュメント</a>に記載されています。</span></p></div></div><h2 id="Definitions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Definitions">Definitions</a><a id="Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Definitions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Definitions">定義</a><a id="Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Definitions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Julia has two mechanisms for loading code:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaにはコードを読み込むための2つのメカニズムがあります：</span></p><ol><li data-translated="true"><span class="original-text"><strong>Code inclusion:</strong> e.g. <code>include("source.jl")</code>. Inclusion allows you to split a single program across multiple source files. The expression <code>include("source.jl")</code> causes the contents of the file <code>source.jl</code> to be evaluated in the global scope of the module where the <code>include</code> call occurs. If <code>include("source.jl")</code> is called multiple times, <code>source.jl</code> is evaluated multiple times. The included path, <code>source.jl</code>, is interpreted relative to the file where the <code>include</code> call occurs. This makes it simple to relocate a subtree of source files. In the REPL, included paths are interpreted relative to the current working directory, <a href="../../base/file/index.html#Base.Filesystem.pwd"><code>pwd()</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>コードのインクルージョン:</strong> 例: <code>include("source.jl")</code>。インクルージョンを使用すると、単一のプログラムを複数のソースファイルに分割できます。式 <code>include("source.jl")</code> は、<code>include</code> 呼び出しが行われるモジュールのグローバルスコープでファイル <code>source.jl</code> の内容を評価します。<code>include("source.jl")</code> が複数回呼び出されると、<code>source.jl</code> は複数回評価されます。インクルードされたパス <code>source.jl</code> は、<code>include</code> 呼び出しが行われるファイルに対して相対的に解釈されます。これにより、ソースファイルのサブツリーを簡単に移動できます。REPL では、インクルードされたパスは現在の作業ディレクトリに対して相対的に解釈されます。<a href="../../base/file/index.html#Base.Filesystem.pwd"><code>pwd()</code></a>。</span></li><li data-translated="true"><span class="original-text"><strong>Package loading:</strong> e.g. <code>import X</code> or <code>using X</code>. The import mechanism allows you to load a package—i.e. an independent, reusable collection of Julia code, wrapped in a module—and makes the resulting module available by the name <code>X</code> inside of the importing module. If the same <code>X</code> package is imported multiple times in the same Julia session, it is only loaded the first time—on subsequent imports, the importing module gets a reference to the same module. Note though, that <code>import X</code> can load different packages in different contexts: <code>X</code> can refer to one package named <code>X</code> in the main project but potentially to different packages also named <code>X</code> in each dependency. More on this below.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>パッケージの読み込み:</strong> 例: <code>import X</code> または <code>using X</code>。インポートメカニズムを使用すると、パッケージ（すなわち、モジュールにラップされた独立した再利用可能な Julia コードのコレクション）を読み込むことができ、インポートするモジュール内で名前 <code>X</code> で結果のモジュールを利用可能にします。同じ <code>X</code> パッケージが同じ Julia セッション内で複数回インポートされる場合、最初のインポート時にのみ読み込まれます。以降のインポートでは、インポートするモジュールは同じモジュールへの参照を取得します。ただし、<code>import X</code> は異なるコンテキストで異なるパッケージを読み込むことができます: <code>X</code> はメインプロジェクト内の <code>X</code> という名前のパッケージを指すこともあれば、各依存関係内の異なる <code>X</code> という名前のパッケージを指すこともあります。詳細は以下に記載します。</span></li></ol><p data-translated="true"><span class="original-text">Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is built on top of code inclusion and serves a <a href="../modules/index.html#modules">different purpose</a>. The rest of this chapter focuses on the behavior and mechanics of package loading.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コードのインクルージョンは非常に簡単で明快です: 呼び出し元のコンテキストで指定されたソースファイルを評価します。パッケージの読み込みはコードのインクルージョンの上に構築されており、<a href="../modules/index.html#modules">異なる目的</a>を果たします。この章の残りの部分では、パッケージの読み込みの動作とメカニズムに焦点を当てます。</span></p><p data-translated="true"><span class="original-text">A <em>package</em> is a source tree with a standard layout providing functionality that can be reused by other Julia projects. A package is loaded by <code>import X</code> or  <code>using X</code> statements. These statements also make the module named <code>X</code>—which results from loading the package code—available within the module where the import statement occurs. The meaning of <code>X</code> in <code>import X</code> is context-dependent: which <code>X</code> package is loaded depends on what code the statement occurs in. Thus, handling of <code>import X</code> happens in two stages: first, it determines <strong>what</strong> package is defined to be <code>X</code> in this context; second, it determines <strong>where</strong> that particular <code>X</code> package is found.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><em>パッケージ</em> は、他の Julia プロジェクトで再利用可能な機能を提供する標準レイアウトのソースツリーです。パッケージは <code>import X</code> または <code>using X</code> ステートメントによって読み込まれます。これらのステートメントは、パッケージコードを読み込むことによって得られる <code>X</code> という名前のモジュールを、インポートステートメントが発生するモジュール内で利用可能にします。<code>import X</code> における <code>X</code> の意味はコンテキストに依存します: どの <code>X</code> パッケージが読み込まれるかは、ステートメントが発生するコードによって決まります。したがって、<code>import X</code> の処理は二段階で行われます: 最初に、このコンテキストで <strong>何の</strong> パッケージが <code>X</code> と定義されているかを決定し、次に、その特定の <code>X</code> パッケージがどこにあるかを決定します。</span></p><p data-translated="true"><span class="original-text">These questions are answered by searching through the project environments listed in <a href="../../base/constants/index.html#Base.LOAD_PATH"><code>LOAD_PATH</code></a> for project files (<code>Project.toml</code> or <code>JuliaProject.toml</code>), manifest files (<code>Manifest.toml</code> or <code>JuliaManifest.toml</code>, or the same names suffixed by <code>-v{major}.{minor}.toml</code> for specific versions), or folders of source files.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの質問は、<a href="../../base/constants/index.html#Base.LOAD_PATH"><code>LOAD_PATH</code></a> にリストされたプロジェクト環境を検索することによって回答されます。プロジェクトファイル（<code>Project.toml</code> または <code>JuliaProject.toml</code>）、マニフェストファイル（<code>Manifest.toml</code> または <code>JuliaManifest.toml</code>、または特定のバージョンのために <code>-v{major}.{minor}.toml</code> というサフィックスが付けられた同じ名前）、またはソースファイルのフォルダーを検索します。</span></p><h2 id="Federation-of-packages" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Federation-of-packages">Federation of packages</a><a id="Federation-of-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Federation-of-packages" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Federation-of-packages">パッケージの連合</a><a id="Federation-of-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Federation-of-packages" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Most of the time, a package is uniquely identifiable simply from its name. However, sometimes a project might encounter a situation where it needs to use two different packages that share the same name. While you might be able fix this by renaming one of the packages, being forced to do so can be highly disruptive in a large, shared code base. Instead, Julia's code loading mechanism allows the same package name to refer to different packages in different components of an application.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ほとんどの場合、パッケージはその名前から一意に識別できます。しかし、時にはプロジェクトが同じ名前を持つ異なる2つのパッケージを使用する必要がある状況に直面することがあります。1つのパッケージの名前を変更することでこの問題を解決できるかもしれませんが、そうすることを強いられるのは、大規模で共有されたコードベースでは非常に混乱を招く可能性があります。代わりに、Julia のコード読み込みメカニズムは、同じパッケージ名がアプリケーションの異なるコンポーネントで異なるパッケージを指すことを許可します。</span></p><p data-translated="true"><span class="original-text">Julia supports federated package management, which means that multiple independent parties can maintain both public and private packages and registries of packages, and that projects can depend on a mix of public and private packages from different registries. Packages from various registries are installed and managed using a common set of tools and workflows. The <code>Pkg</code> package manager that ships with Julia lets you install and manage your projects' dependencies. It assists in creating and manipulating project files (which describe what other projects that your project depends on), and manifest files (which snapshot exact versions of your project's complete dependency graph).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia は連合パッケージ管理をサポートしており、これは複数の独立した当事者が公的および私的なパッケージとパッケージのレジストリを維持でき、プロジェクトが異なるレジストリからの公的および私的なパッケージの混合に依存できることを意味します。さまざまなレジストリからのパッケージは、共通のツールとワークフローを使用してインストールおよび管理されます。Julia に付属する <code>Pkg</code> パッケージマネージャーは、プロジェクトの依存関係をインストールおよび管理することを可能にします。これは、プロジェクトが依存する他のプロジェクトを説明するプロジェクトファイルを作成および操作するのを支援し、プロジェクトの完全な依存関係グラフの正確なバージョンをスナップショットするマニフェストファイルを作成します。</span></p><p data-translated="true"><span class="original-text">One consequence of federation is that there cannot be a central authority for package naming. Different entities may use the same name to refer to unrelated packages. This possibility is unavoidable since these entities do not coordinate and may not even know about each other. Because of the lack of a central naming authority, a single project may end up depending on different packages that have the same name. Julia's package loading mechanism does not require package names to be globally unique, even within the dependency graph of a single project. Instead, packages are identified by <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">universally unique identifiers</a> (UUIDs), which get assigned when each package is created. Usually you won't have to work directly with these somewhat cumbersome 128-bit identifiers since <code>Pkg</code> will take care of generating and tracking them for you. However, these UUIDs provide the definitive answer to the question of <em>"what package does <code>X</code> refer to?"</em></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">連合の結果の1つは、パッケージ名に対する中央権限が存在しないことです。異なるエンティティが無関係なパッケージを指すために同じ名前を使用する場合があります。この可能性は避けられません。なぜなら、これらのエンティティは調整を行わず、お互いの存在すら知らないかもしれないからです。中央の命名権限がないため、単一のプロジェクトが同じ名前を持つ異なるパッケージに依存することがあるかもしれません。Julia のパッケージ読み込みメカニズムは、パッケージ名が単一のプロジェクトの依存関係グラフ内でさえもグローバルに一意である必要はありません。代わりに、パッケージは <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">ユニバーサリー一意識別子</a>（UUID）によって識別され、各パッケージが作成されるときに割り当てられます。通常、これらのやや扱いにくい128ビットの識別子を直接扱う必要はありません。<code>Pkg</code> がそれらの生成と追跡を行います。ただし、これらのUUIDは、<em>「<code>X</code> はどのパッケージを指しているのか？」</em>という質問に対する決定的な答えを提供します。</span></p><p data-translated="true"><span class="original-text">Since the decentralized naming problem is somewhat abstract, it may help to walk through a concrete scenario to understand the issue. Suppose you're developing an application called <code>App</code>, which uses two packages: <code>Pub</code> and  <code>Priv</code>. <code>Priv</code> is a private package that you created, whereas <code>Pub</code> is a public package that you use but don't control. When you created <code>Priv</code>, there was no public package by the name <code>Priv</code>. Subsequently, however, an unrelated package also named <code>Priv</code> has been published and become popular. In fact, the <code>Pub</code> package has started to use it. Therefore, when you next upgrade <code>Pub</code> to get the latest bug fixes and features, <code>App</code> will end up depending on two different packages named <code>Priv</code>—through no action of yours other than upgrading. <code>App</code> has a direct dependency on your private <code>Priv</code> package, and an indirect dependency, through <code>Pub</code>, on the new public <code>Priv</code> package. Since these two <code>Priv</code> packages are different but are both required for <code>App</code> to continue working correctly, the expression <code>import Priv</code> must refer to different <code>Priv</code> packages depending on whether it occurs in <code>App</code>'s code or in <code>Pub</code>'s code. To handle this, Julia's package loading mechanism distinguishes the two <code>Priv</code> packages by their UUID and picks the correct one based on its context (the module that called <code>import</code>). How this distinction works is determined by environments, as explained in the following sections.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">分散型命名の問題はやや抽象的であるため、具体的なシナリオを通じて問題を理解するのが役立つかもしれません。あなたが <code>App</code> というアプリケーションを開発しているとしましょう。このアプリケーションは、<code>Pub</code> と <code>Priv</code> の2つのパッケージを使用しています。<code>Priv</code> はあなたが作成したプライベートパッケージであり、<code>Pub</code> はあなたが使用しているが制御していないパブリックパッケージです。あなたが <code>Priv</code> を作成したとき、<code>Priv</code> という名前のパブリックパッケージは存在しませんでした。しかし、その後、無関係なパッケージも <code>Priv</code> という名前で公開され、人気を博しました。実際、<code>Pub</code> パッケージはそれを使用し始めました。したがって、次に <code>Pub</code> をアップグレードして最新のバグ修正や機能を取得すると、<code>App</code> はあなたのプライベート <code>Priv</code> パッケージと、新しいパブリック <code>Priv</code> パッケージの2つの異なる <code>Priv</code> パッケージに依存することになります—あなたの行動によるものではなく、アップグレードによるものです。<code>App</code> はあなたのプライベート <code>Priv</code> パッケージに直接依存し、<code>Pub</code> を通じて新しいパブリック <code>Priv</code> パッケージに間接的に依存しています。これらの2つの <code>Priv</code> パッケージは異なりますが、<code>App</code> が正しく動作し続けるためには両方とも必要です。したがって、式 <code>import Priv</code> は、<code>App</code> のコード内で発生するか、<code>Pub</code> のコード内で発生するかによって異なる <code>Priv</code> パッケージを指す必要があります。これを処理するために、Julia のパッケージ読み込みメカニズムは、UUID によって2つの <code>Priv</code> パッケージを区別し、そのコンテキスト（<code>import</code> を呼び出したモジュール）に基づいて正しいものを選択します。この区別がどのように機能するかは、以下のセクションで説明される環境によって決まります。</span></p><h2 id="Environments" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Environments">Environments</a><a id="Environments-1"></a><a class="docs-heading-anchor-permalink" href="#Environments" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Environments">環境</a><a id="Environments-1"></a><a class="docs-heading-anchor-permalink" href="#Environments" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">An <em>environment</em> determines what <code>import X</code> and <code>using X</code> mean in various code contexts and what files these statements cause to be loaded. Julia understands two kinds of environments:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><em>環境</em>は、さまざまなコードコンテキストにおける <code>import X</code> と <code>using X</code> の意味、およびこれらのステートメントが読み込むファイルを決定します。Juliaは2種類の環境を理解します：</span></p><ol><li data-translated="true"><span class="original-text"><strong>A project environment</strong> is a directory with a project file and an optional manifest file, and forms an <em>explicit environment</em>. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>プロジェクト環境</strong>は、プロジェクトファイルとオプションのマニフェストファイルを持つディレクトリであり、<em>明示的環境</em>を形成します。プロジェクトファイルは、プロジェクトの直接依存関係の名前とアイデンティティを決定します。マニフェストファイルが存在する場合、すべての直接および間接依存関係、各依存関係の正確なバージョン、および正しいバージョンを特定して読み込むための十分な情報を含む完全な依存関係グラフを提供します。</span></li><li data-translated="true"><span class="original-text"><strong>A package directory</strong> is a directory containing the source trees of a set of packages as subdirectories, and forms an <em>implicit environment</em>. If <code>X</code> is a subdirectory of a package directory and <code>X/src/X.jl</code> exists, then the package <code>X</code> is available in the package directory environment and <code>X/src/X.jl</code> is the source file by which it is loaded.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>パッケージディレクトリ</strong>は、一連のパッケージのソースツリーをサブディレクトリとして含むディレクトリであり、<em>暗黙的環境</em>を形成します。もし <code>X</code> がパッケージディレクトリのサブディレクトリであり、<code>X/src/X.jl</code> が存在する場合、パッケージ <code>X</code> はパッケージディレクトリ環境で利用可能であり、<code>X/src/X.jl</code> がそれが読み込まれるソースファイルです。</span></li></ol><p data-translated="true"><span class="original-text">These can be intermixed to create <strong>a stacked environment</strong>: an ordered set of project environments and package directories, overlaid to make a single composite environment. The precedence and visibility rules then combine to determine which packages are available and where they get loaded from. Julia's load path forms a stacked environment, for example.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらは混在させて <strong>スタック環境</strong> を作成できます：プロジェクト環境とパッケージディレクトリの順序付けられたセットを重ねて、単一の複合環境を形成します。その後、優先順位と可視性のルールが組み合わさって、どのパッケージが利用可能で、どこから読み込まれるかを決定します。たとえば、Juliaのロードパスはスタック環境を形成します。</span></p><p data-translated="true"><span class="original-text">These environment each serve a different purpose:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの環境はそれぞれ異なる目的を果たします：</span></p><ul><li data-translated="true"><span class="original-text">Project environments provide <strong>reproducibility</strong>. By checking a project environment into version control—e.g. a git repository—along with the rest of the project's source code, you can reproduce the exact state of the project and all of its dependencies. The manifest file, in particular, captures the exact version of every dependency, identified by a cryptographic hash of its source tree, which makes it possible for <code>Pkg</code> to retrieve the correct versions and be sure that you are running the exact code that was recorded for all dependencies.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロジェクト環境は <strong>再現性</strong> を提供します。プロジェクト環境をバージョン管理にチェックインすることで—例えば、gitリポジトリとともに—プロジェクトとそのすべての依存関係の正確な状態を再現できます。特にマニフェストファイルは、ソースツリーの暗号学的ハッシュによって識別されるすべての依存関係の正確なバージョンをキャプチャし、<code>Pkg</code> が正しいバージョンを取得し、すべての依存関係に対して記録された正確なコードを実行していることを確認できるようにします。</span></li><li data-translated="true"><span class="original-text">Package directories provide <strong>convenience</strong> when a full carefully-tracked project environment is unnecessary. They are useful when you want to put a set of packages somewhere and be able to directly use them, without needing to create a project environment for them.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パッケージディレクトリは、完全に慎重に追跡されたプロジェクト環境が不要な場合に <strong>便利さ</strong> を提供します。これらは、パッケージのセットをどこかに配置し、プロジェクト環境を作成することなく直接使用できるようにしたい場合に便利です。</span></li><li data-translated="true"><span class="original-text">Stacked environments allow for <strong>adding</strong> tools to the primary environment. You can push an environment of development tools onto the end of the stack to make them available from the REPL and scripts, but not from inside packages.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">スタック環境は、主要な環境にツールを <strong>追加する</strong> ことを可能にします。開発ツールの環境をスタックの末尾にプッシュして、REPLやスクリプトから利用できるようにすることができますが、パッケージ内からは利用できません。</span></li></ul><div class="admonition is-info" id="Note-fd486f6ef3af68a3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fd486f6ef3af68a3" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">When loading a package from another environment in the stack other than the active environment the package is loaded in the context of the active environment. This means that the package will be loaded as if it were imported in the active environment, which may affect how its dependencies versions are resolved. When such a package is precompiling it will be marked as a <code>(serial)</code> precompile job, which means that its dependencies will be precompiled in series within the same job, which will likely be slower.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">スタック内のアクティブ環境以外の別の環境からパッケージを読み込むと、そのパッケージはアクティブ環境のコンテキストで読み込まれます。これは、パッケージがアクティブ環境でインポートされたかのように読み込まれることを意味し、依存関係のバージョンが解決される方法に影響を与える可能性があります。このようなパッケージが事前コンパイルされると、それは <code>(serial)</code> 事前コンパイルジョブとしてマークされ、依存関係は同じジョブ内で直列に事前コンパイルされることになり、これにより遅くなる可能性があります。</span></p></div></div><p data-translated="true"><span class="original-text">At a high-level, each environment conceptually defines three maps: roots, graph and paths. When resolving the meaning of <code>import X</code>, the roots and graph maps are used to determine the identity of <code>X</code>, while the paths map is used to locate the source code of <code>X</code>. The specific roles of the three maps are:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">高レベルでは、各環境は概念的に3つのマップを定義します：roots、graph、paths。<code>import X</code>の意味を解決する際には、rootsとgraphマップが<code>X</code>の識別を決定するために使用され、pathsマップは<code>X</code>のソースコードを特定するために使用されます。3つのマップの具体的な役割は次のとおりです：</span></p><ul><li><p data-translated="true"><span class="original-text"><strong>roots:</strong> <code>name::Symbol</code> ⟶ <code>uuid::UUID</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>roots:</strong> <code>name::Symbol</code> ⟶ <code>uuid::UUID</code></span></p><p data-translated="true"><span class="original-text">An environment's roots map assigns package names to UUIDs for all the top-level dependencies that the environment makes available to the main project (i.e. the ones that can be loaded in <code>Main</code>). When Julia encounters <code>import X</code> in the main project, it looks up the identity of <code>X</code> as <code>roots[:X]</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">環境のrootsマップは、環境がメインプロジェクトに提供するすべてのトップレベル依存関係に対して、パッケージ名をUUIDに割り当てます（つまり、<code>Main</code>で読み込むことができるもの）。Juliaがメインプロジェクトで<code>import X</code>に遭遇すると、<code>X</code>の識別を<code>roots[:X]</code>として検索します。</span></p></li><li><p data-translated="true"><span class="original-text"><strong>graph:</strong> <code>context::UUID</code> ⟶ <code>name::Symbol</code> ⟶ <code>uuid::UUID</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>graph:</strong> <code>context::UUID</code> ⟶ <code>name::Symbol</code> ⟶ <code>uuid::UUID</code></span></p><p data-translated="true"><span class="original-text">An environment's graph is a multilevel map which assigns, for each <code>context</code> UUID, a map from names to UUIDs, similar to the roots map but specific to that <code>context</code>. When Julia sees <code>import X</code> in the code of the package whose UUID is <code>context</code>, it looks up the identity of <code>X</code> as <code>graph[context][:X]</code>. In particular, this means that <code>import X</code> can refer to different packages depending on <code>context</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">環境のgraphは、各<code>context</code> UUIDに対して、名前からUUIDへのマップを割り当てる多層マップです。これはrootsマップに似ていますが、その<code>context</code>に特有です。JuliaがUUIDが<code>context</code>であるパッケージのコード内で<code>import X</code>を見ると、<code>X</code>の識別を<code>graph[context][:X]</code>として検索します。特に、これは<code>import X</code>が<code>context</code>に応じて異なるパッケージを参照できることを意味します。</span></p></li><li><p data-translated="true"><span class="original-text"><strong>paths:</strong> <code>uuid::UUID</code> × <code>name::Symbol</code> ⟶ <code>path::String</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>paths:</strong> <code>uuid::UUID</code> × <code>name::Symbol</code> ⟶ <code>path::String</code></span></p><p data-translated="true"><span class="original-text">The paths map assigns to each package UUID-name pair, the location of that package's entry-point source file. After the identity of <code>X</code> in <code>import X</code> has been resolved to a UUID via roots or graph (depending on whether it is loaded from the main project or a dependency), Julia determines what file to load to acquire <code>X</code> by looking up <code>paths[uuid,:X]</code> in the environment. Including this file should define a module named <code>X</code>. Once this package is loaded, any subsequent import resolving to the same <code>uuid</code> will create a new binding to the already-loaded package module.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">pathsマップは、各パッケージのUUID-名前ペアに、そのパッケージのエントリポイントソースファイルの場所を割り当てます。<code>import X</code>における<code>X</code>の識別がrootsまたはgraphを介してUUIDに解決された後（それがメインプロジェクトから読み込まれるか依存関係から読み込まれるかに応じて）、Juliaは環境内の<code>paths[uuid,:X]</code>を検索して<code>X</code>を取得するために読み込むべきファイルを決定します。このファイルを含めることで、<code>X</code>という名前のモジュールが定義されるはずです。このパッケージが読み込まれると、その後の同じ<code>uuid</code>に解決されるインポートは、すでに読み込まれたパッケージモジュールへの新しいバインディングを作成します。</span></p></li></ul><p data-translated="true"><span class="original-text">Each kind of environment defines these three maps differently, as detailed in the following sections.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各種の環境は、これらの3つのマップを異なる方法で定義します。詳細は以下のセクションに記載されています。</span></p><div class="admonition is-info" id="Note-27216dc5d66f46a8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-27216dc5d66f46a8" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">For ease of understanding, the examples throughout this chapter show full data structures for roots, graph and paths. However, Julia's package loading code does not explicitly create these. Instead, it lazily computes only as much of each structure as it needs to load a given package.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">理解を容易にするために、この章の例ではroots、graph、pathsの完全なデータ構造を示しています。しかし、Juliaのパッケージ読み込みコードはこれらを明示的に作成しません。代わりに、特定のパッケージを読み込むために必要な分だけ各構造を遅延計算します。</span></p></div></div><h3 id="Project-environments" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Project-environments">Project environments</a><a id="Project-environments-1"></a><a class="docs-heading-anchor-permalink" href="#Project-environments" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Project-environments">プロジェクト環境</a><a id="Project-environments-1"></a><a class="docs-heading-anchor-permalink" href="#Project-environments" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">A project environment is determined by a directory containing a project file called <code>Project.toml</code>, and optionally a manifest file called <code>Manifest.toml</code>. These files may also be called <code>JuliaProject.toml</code> and <code>JuliaManifest.toml</code>, in which case <code>Project.toml</code> and <code>Manifest.toml</code> are ignored. This allows for coexistence with other tools that might consider files called <code>Project.toml</code> and <code>Manifest.toml</code> significant. For pure Julia projects, however, the names <code>Project.toml</code> and <code>Manifest.toml</code> are preferred. However, from Julia v1.10.8 onwards, <code>(Julia)Manifest-v{major}.{minor}.toml</code> is recognized as a format to make a given julia version use a specific manifest file i.e. in the same folder, a <code>Manifest-v1.11.toml</code> would be used by v1.11 and <code>Manifest.toml</code> by any other julia version.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロジェクト環境は、<code>Project.toml</code>というプロジェクトファイルを含むディレクトリによって決定され、オプションで<code>Manifest.toml</code>というマニフェストファイルも含まれます。これらのファイルは、<code>JuliaProject.toml</code>および<code>JuliaManifest.toml</code>と呼ばれることもあり、その場合は<code>Project.toml</code>および<code>Manifest.toml</code>は無視されます。これにより、<code>Project.toml</code>および<code>Manifest.toml</code>という名前のファイルを重要視する他のツールとの共存が可能になります。しかし、純粋なJuliaプロジェクトの場合、<code>Project.toml</code>および<code>Manifest.toml</code>という名前が好まれます。ただし、Julia v1.10.8以降、<code>(Julia)Manifest-v{major}.{minor}.toml</code>が特定のマニフェストファイルを使用するための形式として認識されます。つまり、同じフォルダー内で、<code>Manifest-v1.11.toml</code>はv1.11によって使用され、<code>Manifest.toml</code>は他の任意のJuliaバージョンによって使用されます。</span></p><p data-translated="true"><span class="original-text">The roots, graph and paths maps of a project environment are defined as follows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロジェクト環境のルーツ、グラフ、およびパスマップは次のように定義されます：</span></p><p data-translated="true"><span class="original-text"><strong>The roots map</strong> of the environment is determined by the contents of the project file, specifically, its top-level <code>name</code> and <code>uuid</code> entries and its <code>[deps]</code> section (all optional). Consider the following example project file for the hypothetical application, <code>App</code>, as described earlier:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>環境のルーツマップ</strong>は、プロジェクトファイルの内容、具体的にはそのトップレベルの<code>name</code>および<code>uuid</code>エントリと<code>[deps]</code>セクション（すべてオプション）によって決定されます。以下の例は、仮想アプリケーション<code>App</code>のプロジェクトファイルを示しています：</span></p><pre><code class="language-toml hljs">name = "App"
uuid = "8f986787-14fe-4607-ba5d-fbff2944afa9"

[deps]
Priv = "ba13f791-ae1d-465a-978b-69c3ad90f72b"
Pub  = "c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"</code></pre><p data-translated="true"><span class="original-text">This project file implies the following roots map, if it was represented by a Julia dictionary:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このプロジェクトファイルは、Julia辞書で表現された場合、次のルーツマップを暗示します：</span></p><pre><code class="language-julia hljs">roots = Dict(
    :App  =&gt; UUID("8f986787-14fe-4607-ba5d-fbff2944afa9"),
    :Priv =&gt; UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b"),
    :Pub  =&gt; UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"),
)</code></pre><p data-translated="true"><span class="original-text">Given this roots map, in <code>App</code>'s code the statement <code>import Priv</code> will cause Julia to look up <code>roots[:Priv]</code>, which yields <code>ba13f791-ae1d-465a-978b-69c3ad90f72b</code>, the UUID of the <code>Priv</code> package that is to be loaded in that context. This UUID identifies which <code>Priv</code> package to load and use when the main application evaluates <code>import Priv</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このルーツマップを考慮すると、<code>App</code>のコード内での<code>import Priv</code>という文は、Juliaが<code>roots[:Priv]</code>を参照する原因となり、<code>ba13f791-ae1d-465a-978b-69c3ad90f72b</code>、つまりそのコンテキストで読み込まれる<code>Priv</code>パッケージのUUIDを返します。このUUIDは、メインアプリケーションが<code>import Priv</code>を評価する際に、どの<code>Priv</code>パッケージを読み込んで使用するかを特定します。</span></p><p data-translated="true"><span class="original-text"><strong>The dependency graph</strong> of a project environment is determined by the contents of the manifest file, if present. If there is no manifest file, graph is empty. A manifest file contains a stanza for each of a project's direct or indirect dependencies. For each dependency, the file lists the package's UUID and a source tree hash or an explicit path to the source code. Consider the following example manifest file for <code>App</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>プロジェクト環境の依存グラフ</strong>は、マニフェストファイルの内容によって決定されます（存在する場合）。マニフェストファイルがない場合、グラフは空です。マニフェストファイルには、プロジェクトの直接または間接の依存関係ごとにスタンザが含まれています。各依存関係について、ファイルはパッケージのUUIDとソースツリーのハッシュまたはソースコードへの明示的なパスをリストします。以下は、<code>App</code>の例のマニフェストファイルです：</span></p><pre><code class="language-toml hljs">[[Priv]] # the private one
deps = ["Pub", "Zebra"]
uuid = "ba13f791-ae1d-465a-978b-69c3ad90f72b"
path = "deps/Priv"

[[Priv]] # the public one
uuid = "2d15fe94-a1f7-436c-a4d8-07a9a496e01c"
git-tree-sha1 = "1bf63d3be994fe83456a03b874b409cfd59a6373"
version = "0.1.5"

[[Pub]]
uuid = "c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"
git-tree-sha1 = "9ebd50e2b0dd1e110e842df3b433cb5869b0dd38"
version = "2.1.4"

  [Pub.deps]
  Priv = "2d15fe94-a1f7-436c-a4d8-07a9a496e01c"
  Zebra = "f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"

[[Zebra]]
uuid = "f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"
git-tree-sha1 = "e808e36a5d7173974b90a15a353b564f3494092f"
version = "3.4.2"</code></pre><p data-translated="true"><span class="original-text">This manifest file describes a possible complete dependency graph for the <code>App</code> project:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このマニフェストファイルは、<code>App</code>プロジェクトの可能な完全な依存グラフを説明しています：</span></p><ul><li>There are two different packages named <code>Priv</code> that the application uses. It uses a private package, which is a root dependency, and a public one, which is an indirect dependency through <code>Pub</code>. These are differentiated by their distinct UUIDs, and they have different deps:<ul><li data-translated="true"><span class="original-text">The private <code>Priv</code> depends on the <code>Pub</code> and <code>Zebra</code> packages.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プライベート<code>Priv</code>は、<code>Pub</code>および<code>Zebra</code>パッケージに依存しています。</span></li><li data-translated="true"><span class="original-text">The public <code>Priv</code> has no dependencies.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パブリック<code>Priv</code>には依存関係がありません。</span></li></ul></li><li data-translated="true"><span class="original-text">The application also depends on the <code>Pub</code> package, which in turn depends on the public <code>Priv</code> and the same <code>Zebra</code> package that the private <code>Priv</code> package depends on.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">アプリケーションはまた、<code>Pub</code>パッケージにも依存しており、これはさらにパブリック<code>Priv</code>およびプライベート<code>Priv</code>パッケージが依存しているのと同じ<code>Zebra</code>パッケージに依存しています。</span></li></ul><p data-translated="true"><span class="original-text">This dependency graph represented as a dictionary, looks like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この依存関係グラフは辞書として表現され、次のようになります：</span></p><pre><code class="language-julia hljs">graph = Dict(
    # Priv – the private one:
    UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b") =&gt; Dict(
        :Pub   =&gt; UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"),
        :Zebra =&gt; UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"),
    ),
    # Priv – the public one:
    UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c") =&gt; Dict(),
    # Pub:
    UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1") =&gt; Dict(
        :Priv  =&gt; UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c"),
        :Zebra =&gt; UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"),
    ),
    # Zebra:
    UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62") =&gt; Dict(),
)</code></pre><p data-translated="true"><span class="original-text">Given this dependency <code>graph</code>, when Julia sees <code>import Priv</code> in the <code>Pub</code> package—which has UUID <code>c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1</code>—it looks up:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この依存関係<code>graph</code>が与えられたとき、Juliaが<code>Pub</code>パッケージ内で<code>import Priv</code>を見ると（UUIDは<code>c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1</code>）、次のように検索します：</span></p><pre><code class="language-julia hljs">graph[UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1")][:Priv]</code></pre><p data-translated="true"><span class="original-text">and gets <code>2d15fe94-a1f7-436c-a4d8-07a9a496e01c</code>, which indicates that in the context of the <code>Pub</code> package, <code>import Priv</code> refers to the public <code>Priv</code> package, rather than the private one which the app depends on directly. This is how the name <code>Priv</code> can refer to different packages in the main project than it does in one of its package's dependencies, which allows for duplicate names in the package ecosystem.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そして<code>2d15fe94-a1f7-436c-a4d8-07a9a496e01c</code>を取得します。これは、<code>Pub</code>パッケージのコンテキストにおいて、<code>import Priv</code>がアプリが直接依存しているプライベートなものではなく、公開された<code>Priv</code>パッケージを指していることを示しています。これにより、<code>Priv</code>という名前がメインプロジェクトの異なるパッケージと、そのパッケージの依存関係の一つで異なるパッケージを指すことができ、パッケージエコシステム内での重複した名前を許可します。</span></p><p data-translated="true"><span class="original-text">What happens if <code>import Zebra</code> is evaluated in the main <code>App</code> code base? Since <code>Zebra</code> does not appear in the project file, the import will fail even though <code>Zebra</code> <em>does</em> appear in the manifest file. Moreover, if <code>import Zebra</code> occurs in the public <code>Priv</code> package—the one with UUID <code>2d15fe94-a1f7-436c-a4d8-07a9a496e01c</code>—then that would also fail since that <code>Priv</code> package has no declared dependencies in the manifest file and therefore cannot load any packages. The <code>Zebra</code> package can only be loaded by packages for which it appear as an explicit dependency in the manifest file: the  <code>Pub</code> package and one of the <code>Priv</code> packages.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>App</code>コードベースで<code>import Zebra</code>が評価されるとどうなりますか？<code>Zebra</code>がプロジェクトファイルに現れないため、インポートは失敗しますが、<code>Zebra</code>はマニフェストファイルには<em>存在します</em>。さらに、<code>import Zebra</code>がUUID<code>2d15fe94-a1f7-436c-a4d8-07a9a496e01c</code>を持つ公開<code>Priv</code>パッケージ内で発生した場合、それも失敗します。なぜなら、その<code>Priv</code>パッケージにはマニフェストファイルに宣言された依存関係がなく、したがってパッケージをロードできないからです。<code>Zebra</code>パッケージは、マニフェストファイルに明示的な依存関係として現れるパッケージ（<code>Pub</code>パッケージといくつかの<code>Priv</code>パッケージ）によってのみロードできます。</span></p><p data-translated="true"><span class="original-text"><strong>The paths map</strong> of a project environment is extracted from the manifest file. The path of a package <code>uuid</code> named <code>X</code> is determined by these rules (in order):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>プロジェクト環境のパスマップ</strong>はマニフェストファイルから抽出されます。<code>X</code>という名前のパッケージ<code>uuid</code>のパスは、次のルール（順番に）によって決定されます：</span></p><ol><li>If the project file in the directory matches <code>uuid</code> and name <code>X</code>, then either:<ul><li data-translated="true"><span class="original-text">It has a toplevel <code>entryfile</code> entry, then <code>uuid</code> will be mapped to that path, interpreted relative to the directory containing the project file.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最上位の<code>entryfile</code>エントリがある場合、<code>uuid</code>はそのパスにマッピングされ、プロジェクトファイルを含むディレクトリに対して相対的に解釈されます。</span></li><li data-translated="true"><span class="original-text">Otherwise, <code>uuid</code> is mapped to <code>src/X.jl</code> relative to the directory containing the project file.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そうでない場合、<code>uuid</code>はプロジェクトファイルを含むディレクトリに対して相対的に<code>src/X.jl</code>にマッピングされます。</span></li></ul></li><li><ol><li>If the above is not the case and the project file has a corresponding manifest file and the manifest contains a stanza matching <code>uuid</code> then:<ul><li data-translated="true"><span class="original-text">If it has a <code>path</code> entry, use that path (relative to the directory containing the manifest file).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もし<code>path</code>エントリがある場合、そのパスを使用します（マニフェストファイルを含むディレクトリに対して相対的に）。</span></li><li data-translated="true"><span class="original-text">If it has a <code>git-tree-sha1</code> entry, compute a deterministic hash function of <code>uuid</code> and <code>git-tree-sha1</code>—call it <code>slug</code>—and look for a directory named <code>packages/X/$slug</code> in each directory in the Julia <code>DEPOT_PATH</code> global array. Use the first such directory that exists.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もし<code>git-tree-sha1</code>エントリがある場合、<code>uuid</code>と<code>git-tree-sha1</code>の決定論的ハッシュ関数を計算します（これを<code>slug</code>と呼びます）そして、Juliaの<code>DEPOT_PATH</code>グローバル配列内の各ディレクトリで<code>packages/X/$slug</code>という名前のディレクトリを探します。存在する最初のディレクトリを使用します。</span></li></ul></li><li data-translated="true"><span class="original-text">If this is a directory then <code>uuid</code> is mapped to <code>src/X.jl</code> unless the matching manifest stanza has an <code>entryfile</code> entry in which case this is used. In both cases, these are relative to the directory in 2.1.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これがディレクトリである場合、<code>uuid</code>は<code>src/X.jl</code>にマッピングされますが、対応するマニフェストスタンザに<code>entryfile</code>エントリがある場合は、これが使用されます。どちらの場合も、これらは2.1のディレクトリに対して相対的です。</span></li></ol></li></ol><p data-translated="true"><span class="original-text">If any of these result in success, the path to the source code entry point will be either that result, the relative path from that result plus <code>src/X.jl</code>; otherwise, there is no path mapping for <code>uuid</code>. When loading <code>X</code>, if no source code path is found, the lookup will fail, and the user may be prompted to install the appropriate package version or to take other corrective action (e.g. declaring <code>X</code> as a dependency).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらのいずれかが成功した場合、ソースコードエントリポイントへのパスは、その結果、またはその結果からの相対パスに <code>src/X.jl</code> を追加したものになります。それ以外の場合、<code>uuid</code> に対するパスマッピングは存在しません。<code>X</code> を読み込む際に、ソースコードパスが見つからない場合、ルックアップは失敗し、ユーザーは適切なパッケージバージョンをインストールするように促されるか、他の修正アクションを取るように求められることがあります（例：<code>X</code> を依存関係として宣言する）。</span></p><p data-translated="true"><span class="original-text">In the example manifest file above, to find the path of the first <code>Priv</code> package—the one with UUID <code>ba13f791-ae1d-465a-978b-69c3ad90f72b</code>—Julia looks for its stanza in the manifest file, sees that it has a <code>path</code> entry, looks at <code>deps/Priv</code> relative to the <code>App</code> project directory—let's suppose the <code>App</code> code lives in <code>/home/me/projects/App</code>—sees that <code>/home/me/projects/App/deps/Priv</code> exists and therefore loads <code>Priv</code> from there.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記の例のマニフェストファイルでは、最初の <code>Priv</code> パッケージ—UUID <code>ba13f791-ae1d-465a-978b-69c3ad90f72b</code> を持つもの—のパスを見つけるために、Julia はマニフェストファイル内のそのスタンザを探し、<code>path</code> エントリがあることを確認し、<code>App</code> プロジェクトディレクトリに対して <code>deps/Priv</code> を相対的に見て、<code>App</code> コードが <code>/home/me/projects/App</code> にあると仮定すると、<code>/home/me/projects/App/deps/Priv</code> が存在することを確認し、そこから <code>Priv</code> を読み込みます。</span></p><p data-translated="true"><span class="original-text">If, on the other hand, Julia was loading the <em>other</em> <code>Priv</code> package—the one with UUID <code>2d15fe94-a1f7-436c-a4d8-07a9a496e01c</code>—it finds its stanza in the manifest, see that it does <em>not</em> have a <code>path</code> entry, but that it does have a <code>git-tree-sha1</code> entry. It then computes the <code>slug</code> for this UUID/SHA-1 pair, which is <code>HDkrT</code> (the exact details of this computation aren't important, but it is consistent and deterministic). This means that the path to this <code>Priv</code> package will be <code>packages/Priv/HDkrT/src/Priv.jl</code> in one of the package depots. Suppose the contents of <code>DEPOT_PATH</code> is <code>["/home/me/.julia", "/usr/local/julia"]</code>, then Julia will look at the following paths to see if they exist:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一方、Julia が <em>別の</em> <code>Priv</code> パッケージ—UUID <code>2d15fe94-a1f7-436c-a4d8-07a9a496e01c</code> を持つもの—を読み込んでいる場合、マニフェスト内のそのスタンザを見つけ、<code>path</code> エントリが <em>ない</em> ことを確認しますが、<code>git-tree-sha1</code> エントリがあることを確認します。次に、この UUID/SHA-1 ペアの <code>slug</code> を計算し、それは <code>HDkrT</code> になります（この計算の正確な詳細は重要ではありませんが、一貫性があり決定論的です）。これは、この <code>Priv</code> パッケージへのパスが、パッケージデポのいずれかにおいて <code>packages/Priv/HDkrT/src/Priv.jl</code> になることを意味します。<code>DEPOT_PATH</code> の内容が <code>["/home/me/.julia", "/usr/local/julia"]</code> だと仮定すると、Julia は次のパスを確認して存在するかどうかを調べます：</span></p><ol><li data-translated="true"><span class="original-text"><code>/home/me/.julia/packages/Priv/HDkrT</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>/home/me/.julia/packages/Priv/HDkrT</code></span></li><li data-translated="true"><span class="original-text"><code>/usr/local/julia/packages/Priv/HDkrT</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>/usr/local/julia/packages/Priv/HDkrT</code></span></li></ol><p data-translated="true"><span class="original-text">Julia uses the first of these that exists to try to load the public <code>Priv</code> package from the file <code>packages/Priv/HDKrT/src/Priv.jl</code> in the depot where it was found.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia は、存在する最初のものを使用して、見つかったデポ内のファイル <code>packages/Priv/HDKrT/src/Priv.jl</code> から公開の <code>Priv</code> パッケージを読み込もうとします。</span></p><p data-translated="true"><span class="original-text">Here is a representation of a possible paths map for our example <code>App</code> project environment, as provided in the Manifest given above for the dependency graph, after searching the local file system:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">以下は、上記の依存関係グラフのために提供されたマニフェストに基づいて、ローカルファイルシステムを検索した後の例の <code>App</code> プロジェクト環境の可能なパスマップの表現です：</span></p><pre><code class="language-julia hljs">paths = Dict(
    # Priv – the private one:
    (UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b"), :Priv) =&gt;
        # relative entry-point inside `App` repo:
        "/home/me/projects/App/deps/Priv/src/Priv.jl",
    # Priv – the public one:
    (UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c"), :Priv) =&gt;
        # package installed in the system depot:
        "/usr/local/julia/packages/Priv/HDkr/src/Priv.jl",
    # Pub:
    (UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"), :Pub) =&gt;
        # package installed in the user depot:
        "/home/me/.julia/packages/Pub/oKpw/src/Pub.jl",
    # Zebra:
    (UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"), :Zebra) =&gt;
        # package installed in the system depot:
        "/usr/local/julia/packages/Zebra/me9k/src/Zebra.jl",
)</code></pre><p data-translated="true"><span class="original-text">This example map includes three different kinds of package locations (the first and third are part of the default load path):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例のマップには、3つの異なる種類のパッケージの場所が含まれています（最初と3番目はデフォルトのロードパスの一部です）：</span></p><ol><li data-translated="true"><span class="original-text">The private <code>Priv</code> package is "<a href="https://stackoverflow.com/a/35109534">vendored</a>" inside the <code>App</code> repository.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プライベート <code>Priv</code> パッケージは、<code>App</code> リポジトリ内に "<a href="https://stackoverflow.com/a/35109534">vendored</a>" されています。</span></li><li data-translated="true"><span class="original-text">The public <code>Priv</code> and <code>Zebra</code> packages are in the system depot, where packages installed and managed by the system administrator live. These are available to all users on the system.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">公開の <code>Priv</code> および <code>Zebra</code> パッケージは、システムデポにあり、システム管理者によってインストールおよび管理されるパッケージが存在します。これらはシステム上のすべてのユーザーが利用可能です。</span></li><li data-translated="true"><span class="original-text">The <code>Pub</code> package is in the user depot, where packages installed by the user live. These are only available to the user who installed them.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ユーザーデポにある <code>Pub</code> パッケージは、ユーザーがインストールしたパッケージが存在する場所です。これらは、インストールしたユーザーのみが利用可能です。</span></li></ol><h3 id="Package-directories" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Package-directories">Package directories</a><a id="Package-directories-1"></a><a class="docs-heading-anchor-permalink" href="#Package-directories" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Package-directories">パッケージディレクトリ</a><a id="Package-directories-1"></a><a class="docs-heading-anchor-permalink" href="#Package-directories" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Package directories provide a simpler kind of environment without the ability to handle name collisions. In a package directory, the set of top-level packages is the set of subdirectories that "look like" packages. A package <code>X</code> exists in a package directory if the directory contains one of the following "entry point" files:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パッケージディレクトリは、名前の衝突を処理する能力がない、よりシンプルな種類の環境を提供します。パッケージディレクトリでは、トップレベルパッケージのセットは「パッケージのように見える」サブディレクトリのセットです。パッケージ <code>X</code> は、ディレクトリに次の「エントリポイント」ファイルのいずれかが含まれている場合、パッケージディレクトリに存在します：</span></p><ul><li data-translated="true"><span class="original-text"><code>X.jl</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>X.jl</code></span></li><li data-translated="true"><span class="original-text"><code>X/src/X.jl</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>X/src/X.jl</code></span></li><li data-translated="true"><span class="original-text"><code>X.jl/src/X.jl</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>X.jl/src/X.jl</code></span></li></ul><p data-translated="true"><span class="original-text">Which dependencies a package in a package directory can import depends on whether the package contains a project file:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パッケージディレクトリ内のパッケージがインポートできる依存関係は、そのパッケージにプロジェクトファイルが含まれているかどうかによって異なります：</span></p><ul><li data-translated="true"><span class="original-text">If it has a project file, it can only import those packages which are identified in the <code>[deps]</code> section of the project file.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロジェクトファイルがある場合、そのプロジェクトファイルの <code>[deps]</code> セクションに識別されているパッケージのみをインポートできます。</span></li><li data-translated="true"><span class="original-text">If it does not have a project file, it can import any top-level package—i.e. the same packages that can be loaded in <code>Main</code> or the REPL.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロジェクトファイルがない場合、任意のトップレベルパッケージをインポートできます。つまり、<code>Main</code> または REPL で読み込むことができるのと同じパッケージです。</span></li></ul><p data-translated="true"><span class="original-text"><strong>The roots map</strong> is determined by examining the contents of the package directory to generate a list of all packages that exist. Additionally, a UUID will be assigned to each entry as follows: For a given package found inside the folder <code>X</code>...</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>ルーツマップ</strong> は、パッケージディレクトリの内容を調べて、存在するすべてのパッケージのリストを生成することによって決定されます。さらに、各エントリには次のように UUID が割り当てられます：フォルダー <code>X</code> 内で見つかった特定のパッケージについて...</span></p><ol><li data-translated="true"><span class="original-text">If <code>X/Project.toml</code> exists and has a <code>uuid</code> entry, then <code>uuid</code> is that value.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>X/Project.toml</code> が存在し、<code>uuid</code> エントリがある場合、<code>uuid</code> はその値です。</span></li><li data-translated="true"><span class="original-text">If <code>X/Project.toml</code> exists and but does <em>not</em> have a top-level UUID entry, <code>uuid</code> is a dummy UUID generated by hashing the canonical (real) path to <code>X/Project.toml</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>X/Project.toml</code> が存在するが、トップレベルの UUID エントリが <em>ない</em> 場合、<code>uuid</code> は <code>X/Project.toml</code> への標準的（実際の）パスをハッシュ化して生成されたダミー UUID です。</span></li><li data-translated="true"><span class="original-text">Otherwise (if <code>Project.toml</code> does not exist), then <code>uuid</code> is the all-zero <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Nil_UUID#Nil_UUID">nil UUID</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">それ以外の場合（<code>Project.toml</code> が存在しない場合）、<code>uuid</code> はすべてゼロの <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Nil_UUID#Nil_UUID">nil UUID</a> です。</span></li></ol><p data-translated="true"><span class="original-text"><strong>The dependency graph</strong> of a project directory is determined by the presence and contents of project files in the subdirectory of each package. The rules are:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>プロジェクトディレクトリの依存関係グラフ</strong> は、各パッケージのサブディレクトリ内のプロジェクトファイルの存在と内容によって決まります。ルールは次のとおりです：</span></p><ul><li data-translated="true"><span class="original-text">If a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, the same as the main project and REPL.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パッケージのサブディレクトリにプロジェクトファイルがない場合、そのグラフとインポートステートメントは省略され、メインプロジェクトや REPL と同様にトップレベルとして扱われます。</span></li><li data-translated="true"><span class="original-text">If a package subdirectory has a project file, then the graph entry for its UUID is the <code>[deps]</code> map of the project file, which is considered to be empty if the section is absent.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パッケージのサブディレクトリにプロジェクトファイルがある場合、その UUID のグラフエントリはプロジェクトファイルの <code>[deps]</code> マップであり、セクションが存在しない場合は空であると見なされます。</span></li></ul><p data-translated="true"><span class="original-text">As an example, suppose a package directory has the following structure and content:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、パッケージディレクトリが以下の構造と内容を持っているとします：</span></p><pre><code class="nohighlight hljs">Aardvark/
    src/Aardvark.jl:
        import Bobcat
        import Cobra

Bobcat/
    Project.toml:
        [deps]
        Cobra = "4725e24d-f727-424b-bca0-c4307a3456fa"
        Dingo = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Bobcat.jl:
        import Cobra
        import Dingo

Cobra/
    Project.toml:
        uuid = "4725e24d-f727-424b-bca0-c4307a3456fa"
        [deps]
        Dingo = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Cobra.jl:
        import Dingo

Dingo/
    Project.toml:
        uuid = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

    src/Dingo.jl:
        # no imports</code></pre><p data-translated="true"><span class="original-text">Here is a corresponding roots structure, represented as a dictionary:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここに対応するルーツ構造が辞書として表現されています：</span></p><pre><code class="language-julia hljs">roots = Dict(
    :Aardvark =&gt; UUID("00000000-0000-0000-0000-000000000000"), # no project file, nil UUID
    :Bobcat   =&gt; UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf"), # dummy UUID based on path
    :Cobra    =&gt; UUID("4725e24d-f727-424b-bca0-c4307a3456fa"), # UUID from project file
    :Dingo    =&gt; UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"), # UUID from project file
)</code></pre><p data-translated="true"><span class="original-text">Here is the corresponding graph structure, represented as a dictionary:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここに対応するグラフ構造が辞書として表現されています：</span></p><pre><code class="language-julia hljs">graph = Dict(
    # Bobcat:
    UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf") =&gt; Dict(
        :Cobra =&gt; UUID("4725e24d-f727-424b-bca0-c4307a3456fa"),
        :Dingo =&gt; UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"),
    ),
    # Cobra:
    UUID("4725e24d-f727-424b-bca0-c4307a3456fa") =&gt; Dict(
        :Dingo =&gt; UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"),
    ),
    # Dingo:
    UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc") =&gt; Dict(),
)</code></pre><p data-translated="true"><span class="original-text">A few general rules to note:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">注意すべき一般的なルールがいくつかあります：</span></p><ol><li data-translated="true"><span class="original-text">A package without a project file can depend on any top-level dependency, and since every package in a package directory is available at the top-level, it can import all packages in the environment.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロジェクトファイルのないパッケージは、任意のトップレベルの依存関係に依存でき、パッケージディレクトリ内のすべてのパッケージがトップレベルで利用可能であるため、環境内のすべてのパッケージをインポートできます。</span></li><li data-translated="true"><span class="original-text">A package with a project file cannot depend on one without a project file since packages with project files can only load packages in <code>graph</code> and packages without project files do not appear in <code>graph</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロジェクトファイルのあるパッケージは、プロジェクトファイルのないパッケージに依存できません。なぜなら、プロジェクトファイルのあるパッケージは<code>graph</code>内のパッケージのみをロードでき、プロジェクトファイルのないパッケージは<code>graph</code>に表示されないからです。</span></li><li data-translated="true"><span class="original-text">A package with a project file but no explicit UUID can only be depended on by packages without project files since dummy UUIDs assigned to these packages are strictly internal.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">明示的なUUIDを持たないプロジェクトファイルのあるパッケージは、プロジェクトファイルのないパッケージからのみ依存されることができます。なぜなら、これらのパッケージに割り当てられたダミーUUIDは厳密に内部的なものだからです。</span></li></ol><p data-translated="true"><span class="original-text">Observe the following specific instances of these rules in our example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらのルールの具体的な例を以下に示します：</span></p><ul><li data-translated="true"><span class="original-text"><code>Aardvark</code> can import on any of <code>Bobcat</code>, <code>Cobra</code> or <code>Dingo</code>; it does import <code>Bobcat</code> and <code>Cobra</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Aardvark</code>は<code>Bobcat</code>、<code>Cobra</code>、または<code>Dingo</code>のいずれかをインポートできます；実際に<code>Bobcat</code>と<code>Cobra</code>をインポートしています。</span></li><li data-translated="true"><span class="original-text"><code>Bobcat</code> can and does import both <code>Cobra</code> and <code>Dingo</code>, which both have project files with UUIDs and are declared as dependencies in <code>Bobcat</code>'s <code>[deps]</code> section.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Bobcat</code>は<code>Cobra</code>と<code>Dingo</code>の両方をインポートでき、実際にインポートしています。これらはどちらもUUIDを持つプロジェクトファイルを持ち、<code>Bobcat</code>の<code>[deps]</code>セクションで依存関係として宣言されています。</span></li><li data-translated="true"><span class="original-text"><code>Bobcat</code> cannot depend on <code>Aardvark</code> since <code>Aardvark</code> does not have a project file.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Bobcat</code>は<code>Aardvark</code>に依存できません。なぜなら、<code>Aardvark</code>にはプロジェクトファイルがないからです。</span></li><li data-translated="true"><span class="original-text"><code>Cobra</code> can and does import <code>Dingo</code>, which has a project file and UUID, and is declared as a dependency in <code>Cobra</code>'s  <code>[deps]</code> section.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cobra</code>は<code>Dingo</code>をインポートでき、実際にインポートしています。<code>Dingo</code>はプロジェクトファイルとUUIDを持ち、<code>Cobra</code>の<code>[deps]</code>セクションで依存関係として宣言されています。</span></li><li data-translated="true"><span class="original-text"><code>Cobra</code> cannot depend on <code>Aardvark</code> or <code>Bobcat</code> since neither have real UUIDs.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cobra</code>は<code>Aardvark</code>や<code>Bobcat</code>に依存できません。なぜなら、どちらも実際のUUIDを持っていないからです。</span></li><li data-translated="true"><span class="original-text"><code>Dingo</code> cannot import anything because it has a project file without a <code>[deps]</code> section.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Dingo</code>は<code>[deps]</code>セクションのないプロジェクトファイルを持っているため、何もインポートできません。</span></li></ul><p data-translated="true"><span class="original-text"><strong>The paths map</strong> in a package directory is simple: it maps subdirectory names to their corresponding entry-point paths. In other words, if the path to our example project directory is <code>/home/me/animals</code> then the <code>paths</code> map could be represented by this dictionary:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>パスマップ</strong>はパッケージディレクトリ内でシンプルです：サブディレクトリ名をそれに対応するエントリポイントパスにマッピングします。言い換えれば、私たちの例のプロジェクトディレクトリへのパスが<code>/home/me/animals</code>である場合、<code>paths</code>マップはこの辞書で表現できます。</span></p><pre><code class="language-julia hljs">paths = Dict(
    (UUID("00000000-0000-0000-0000-000000000000"), :Aardvark) =&gt;
        "/home/me/AnimalPackages/Aardvark/src/Aardvark.jl",
    (UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf"), :Bobcat) =&gt;
        "/home/me/AnimalPackages/Bobcat/src/Bobcat.jl",
    (UUID("4725e24d-f727-424b-bca0-c4307a3456fa"), :Cobra) =&gt;
        "/home/me/AnimalPackages/Cobra/src/Cobra.jl",
    (UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"), :Dingo) =&gt;
        "/home/me/AnimalPackages/Dingo/src/Dingo.jl",
)</code></pre><p data-translated="true"><span class="original-text">Since all packages in a package directory environment are, by definition, subdirectories with the expected entry-point files, their <code>paths</code> map entries always have this form.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パッケージディレクトリ環境内のすべてのパッケージは、定義上、期待されるエントリポイントファイルを持つサブディレクトリであるため、<code>paths</code>マップのエントリは常にこの形式を持ちます。</span></p><h3 id="Environment-stacks" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Environment-stacks">Environment stacks</a><a id="Environment-stacks-1"></a><a class="docs-heading-anchor-permalink" href="#Environment-stacks" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Environment-stacks">環境スタック</a><a id="Environment-stacks-1"></a><a class="docs-heading-anchor-permalink" href="#Environment-stacks" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The third and final kind of environment is one that combines other environments by overlaying several of them, making the packages in each available in a single composite environment. These composite environments are called <em>environment stacks</em>. The Julia <code>LOAD_PATH</code> global defines an environment stack—the environment in which the Julia process operates. If you want your Julia process to have access only to the packages in one project or package directory, make it the only entry in <code>LOAD_PATH</code>. It is often quite useful, however, to have access to some of your favorite tools—standard libraries, profilers, debuggers, personal utilities, etc.—even if they are not dependencies of the project you're working on. By adding an environment containing these tools to the load path, you immediately have access to them in top-level code without needing to add them to your project.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">環境の3番目で最後の種類は、他の環境を重ね合わせて結合するもので、各環境のパッケージを単一の複合環境で利用可能にします。これらの複合環境は<em>環境スタック</em>と呼ばれます。Juliaの<code>LOAD_PATH</code>グローバルは環境スタックを定義します—Juliaプロセスが動作する環境です。Juliaプロセスが1つのプロジェクトまたはパッケージディレクトリ内のパッケージにのみアクセスできるようにしたい場合は、それを<code>LOAD_PATH</code>の唯一のエントリにしてください。しかし、作業しているプロジェクトの依存関係でなくても、お気に入りのツール（標準ライブラリ、プロファイラ、デバッガ、個人ユーティリティなど）にアクセスできることは非常に便利です。これらのツールを含む環境をロードパスに追加することで、プロジェクトに追加することなく、トップレベルのコードでそれらにすぐにアクセスできます。</span></p><p data-translated="true"><span class="original-text">The mechanism for combining the roots, graph and paths data structures of the components of an environment stack is simple: they are merged as dictionaries, favoring earlier entries over later ones in the case of key collisions. In other words, if we have <code>stack = [env₁, env₂, …]</code> then we have:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">環境スタックのコンポーネントのルート、グラフ、パスデータ構造を結合するメカニズムはシンプルです：辞書としてマージされ、キーの衝突がある場合は、後のエントリよりも前のエントリを優先します。言い換えれば、<code>stack = [env₁, env₂, …]</code>がある場合、次のようになります：</span></p><pre><code class="language-julia hljs">roots = reduce(merge, reverse([roots₁, roots₂, …]))
graph = reduce(merge, reverse([graph₁, graph₂, …]))
paths = reduce(merge, reverse([paths₁, paths₂, …]))</code></pre><p data-translated="true"><span class="original-text">The subscripted <code>rootsᵢ</code>, <code>graphᵢ</code> and <code>pathsᵢ</code> variables correspond to the subscripted environments, <code>envᵢ</code>, contained in <code>stack</code>. The <code>reverse</code> is present because <code>merge</code> favors the last argument rather than first when there are collisions between keys in its argument dictionaries. There are a couple of noteworthy features of this design:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">添字付きの<code>rootsᵢ</code>、<code>graphᵢ</code>、および<code>pathsᵢ</code>変数は、<code>stack</code>に含まれる添字付き環境<code>envᵢ</code>に対応します。<code>reverse</code>は、キーの衝突がその引数辞書の間で発生した場合、<code>merge</code>が最初の引数ではなく最後の引数を優先するために存在します。この設計にはいくつかの注目すべき特徴があります：</span></p><ol><li data-translated="true"><span class="original-text">The <em>primary environment</em>—i.e. the first environment in a stack—is faithfully embedded in a stacked environment. The full dependency graph of the first environment in a stack is guaranteed to be included intact in the stacked environment including the same versions of all dependencies.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><em>プライマリ環境</em>—すなわちスタック内の最初の環境—は、スタックされた環境に忠実に埋め込まれています。スタック内の最初の環境の完全な依存関係グラフは、すべての依存関係の同じバージョンを含む形で、スタックされた環境に完全に含まれることが保証されています。</span></li><li data-translated="true"><span class="original-text">Packages in non-primary environments can end up using incompatible versions of their dependencies even if their own environments are entirely compatible. This can happen when one of their dependencies is shadowed by a version in an earlier environment in the stack (either by graph or path, or both).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">非プライマリ環境内のパッケージは、自身の環境が完全に互換性があっても、依存関係の互換性のないバージョンを使用することがあります。これは、依存関係の1つがスタック内の以前の環境のバージョンによって影ができるときに発生する可能性があります（グラフまたはパス、またはその両方によって）。</span></li></ol><p data-translated="true"><span class="original-text">Since the primary environment is typically the environment of a project you're working on, while environments later in the stack contain additional tools, this is the right trade-off: it's better to break your development tools but keep the project working. When such incompatibilities occur, you'll typically want to upgrade your dev tools to versions that are compatible with the main project.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プライマリ環境は通常、あなたが作業しているプロジェクトの環境であり、スタック内の後の環境には追加のツールが含まれているため、これは正しいトレードオフです：開発ツールを壊すよりも、プロジェクトを動作させ続ける方が良いです。このような互換性のない状況が発生した場合、通常は、メインプロジェクトと互換性のあるバージョンに開発ツールをアップグレードしたいと思うでしょう。</span></p><h3 id="man-extensions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-extensions">Package Extensions</a><a id="man-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#man-extensions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-extensions">パッケージ拡張</a><a id="man-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#man-extensions" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">A package "extension" is a module that is automatically loaded when a specified set of other packages (its "triggers") are loaded in the current Julia session. Extensions are defined under the <code>[extensions]</code> section in the project file. The triggers of an extension are a subset of those packages listed under the <code>[weakdeps]</code> (and possibly, but uncommonly the <code>[deps]</code>) section of the project file. Those packages can have compat entries like other packages.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パッケージ "extension" は、指定された他のパッケージ（その "triggers"）のセットが現在の Julia セッションでロードされると自動的にロードされるモジュールです。拡張はプロジェクトファイルの <code>[extensions]</code> セクションで定義されます。拡張のトリガーは、プロジェクトファイルの <code>[weakdeps]</code> （おそらく、しかし一般的ではない <code>[deps]</code>）セクションにリストされているパッケージのサブセットです。これらのパッケージは、他のパッケージと同様に互換性エントリを持つことができます。</span></p><pre><code class="language-toml hljs">name = "MyPackage"

[compat]
ExtDep = "1.0"
OtherExtDep = "1.0"

[weakdeps]
ExtDep = "c9a23..." # uuid
OtherExtDep = "862e..." # uuid

[extensions]
BarExt = ["ExtDep", "OtherExtDep"]
FooExt = "ExtDep"
...</code></pre><p data-translated="true"><span class="original-text">The keys under <code>extensions</code> are the names of the extensions. They are loaded when all the packages on the right hand side (the triggers) of that extension are loaded. If an extension only has one trigger the list of triggers can be written as just a string for brevity. The location for the entry point of the extension is either in <code>ext/FooExt.jl</code> or <code>ext/FooExt/FooExt.jl</code> for extension <code>FooExt</code>. The content of an extension is often structured as:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>extensions</code> の下のキーは、拡張の名前です。それらは、その拡張の右側にあるすべてのパッケージ（トリガー）がロードされるときにロードされます。拡張にトリガーが1つだけの場合、トリガーのリストは簡潔に文字列として書くことができます。拡張のエントリポイントの場所は、<code>ext/FooExt.jl</code> または <code>ext/FooExt/FooExt.jl</code> です。拡張 <code>FooExt</code> の内容は、しばしば次のように構成されます：</span></p><pre><code class="nohighlight hljs">module FooExt

# Load main package and triggers
using MyPackage, ExtDep

# Extend functionality in main package with types from the triggers
MyPackage.func(x::ExtDep.SomeStruct) = ...

end</code></pre><p data-translated="true"><span class="original-text">When a package with extensions is added to an environment, the <code>weakdeps</code> and <code>extensions</code> sections are stored in the manifest file in the section for that package. The dependency lookup rules for a package are the same as for its "parent" except that the listed triggers are also considered as dependencies.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">拡張を持つパッケージが環境に追加されると、<code>weakdeps</code> と <code>extensions</code> セクションは、そのパッケージのセクションにマニフェストファイルに保存されます。パッケージの依存関係の検索ルールは、その "親" と同じですが、リストされたトリガーも依存関係として考慮されます。</span></p><h3 id="workspaces" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#workspaces">Workspaces</a><a id="workspaces-1"></a><a class="docs-heading-anchor-permalink" href="#workspaces" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#workspaces">ワークスペース</a><a id="workspaces-1"></a><a class="docs-heading-anchor-permalink" href="#workspaces" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">A project file can define a workspace by giving a set of projects that is part of that workspace:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロジェクトファイルは、そのワークスペースの一部であるプロジェクトのセットを指定することでワークスペースを定義できます：</span></p><pre><code class="language-toml hljs">[workspace]
projects = ["test", "benchmarks", "docs", "SomePackage"]</code></pre><p data-translated="true"><span class="original-text">Each project listed in the <code>projects</code> array is specified by its relative path from the workspace root. This can be a direct child directory (e.g., <code>"test"</code>) or a nested subdirectory (e.g., <code>"nested/subdir/MyPackage"</code>). Each project contains its own <code>Project.toml</code> file, which may include additional dependencies and compatibility constraints. In such cases, the package manager gathers all dependency information from all the projects in the workspace generating a single manifest file that combines the versions of all dependencies.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>projects</code> 配列にリストされた各プロジェクトは、ワークスペースのルートからの相対パスで指定されます。これは、直接の子ディレクトリ（例：<code>"test"</code>）またはネストされたサブディレクトリ（例：<code>"nested/subdir/MyPackage"</code>）である可能性があります。各プロジェクトには独自の <code>Project.toml</code> ファイルが含まれており、追加の依存関係や互換性制約を含む場合があります。そのような場合、パッケージマネージャはワークスペース内のすべてのプロジェクトからすべての依存関係情報を収集し、すべての依存関係のバージョンを組み合わせた単一のマニフェストファイルを生成します。</span></p><p data-translated="true"><span class="original-text">When Julia loads a project, it searches upward through parent directories until it reaches the user's home directory to find a workspace that includes that project. This allows workspace projects to be nested at arbitrary depth within the workspace directory tree.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia がプロジェクトをロードすると、ユーザーのホームディレクトリに到達するまで親ディレクトリを上に検索して、そのプロジェクトを含むワークスペースを見つけます。これにより、ワークスペースプロジェクトはワークスペースディレクトリツリー内で任意の深さにネストできます。</span></p><p data-translated="true"><span class="original-text">Furthermore, workspaces can be "nested", meaning a project defining a workspace can also be part of another workspace. In this scenario, a single manifest file is still utilized, stored alongside the "root project" (the project that doesn't have another workspace including it). An example file structure could look like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さらに、ワークスペースは "ネスト" 可能であり、ワークスペースを定義するプロジェクトも別のワークスペースの一部であることができます。このシナリオでは、単一のマニフェストファイルが引き続き使用され、"ルートプロジェクト"（他のワークスペースを含まないプロジェクト）と一緒に保存されます。例のファイル構造は次のようになります：</span></p><pre><code class="nohighlight hljs">Project.toml # projects = ["MyPackage"]
Manifest.toml
MyPackage/
    Project.toml # projects = ["test"]
    test/
        Project.toml</code></pre><h3 id="preferences" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#preferences">Package/Environment Preferences</a><a id="preferences-1"></a><a class="docs-heading-anchor-permalink" href="#preferences" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#preferences">パッケージ/環境の設定</a><a id="preferences-1"></a><a class="docs-heading-anchor-permalink" href="#preferences" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Preferences are dictionaries of metadata that influence package behavior within an environment. The preferences system supports reading preferences at compile-time, which means that at code-loading time, we must ensure that the precompilation files selected by Julia were built with the same preferences as the current environment before loading them. The public API for modifying Preferences is contained within the <a href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a> package. Preferences are stored as TOML dictionaries within a <code>(Julia)LocalPreferences.toml</code> file next to the currently-active project. If a preference is "exported", it is instead stored within the <code>(Julia)Project.toml</code> instead. The intention is to allow shared projects to contain shared preferences, while allowing for users themselves to override those preferences with their own settings in the LocalPreferences.toml file, which should be .gitignored as the name implies.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定は、環境内でのパッケージの動作に影響を与えるメタデータの辞書です。設定システムは、コンパイル時に設定を読み取ることをサポートしており、コードロード時には、Julia によって選択されたプリコンパイルファイルが現在の環境と同じ設定で構築されていることを確認する必要があります。設定を変更するための公開 API は、<a href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a> パッケージ内に含まれています。設定は、現在アクティブなプロジェクトの隣にある <code>(Julia)LocalPreferences.toml</code> ファイル内に TOML 辞書として保存されます。設定が "エクスポート" されると、代わりに <code>(Julia)Project.toml</code> 内に保存されます。意図は、共有プロジェクトが共有設定を含むことを可能にし、ユーザー自身が LocalPreferences.toml ファイル内で独自の設定でそれらの設定を上書きできるようにすることです。このファイルは、その名前が示すように .gitignore されるべきです。</span></p><p data-translated="true"><span class="original-text">Preferences that are accessed during compilation are automatically marked as compile-time preferences, and any change recorded to these preferences will cause the Julia compiler to recompile any cached precompilation file(s) (<code>.ji</code> and corresponding <code>.so</code>, <code>.dll</code>, or <code>.dylib</code> files) for that module. This is done by serializing the hash of all compile-time preferences during compilation, then checking that hash against the current environment when searching for the proper file(s) to load.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コンパイル中にアクセスされる設定は自動的にコンパイル時設定としてマークされ、これらの設定に記録された変更は、Juliaコンパイラがそのモジュールのキャッシュされたプリコンパイルファイル（<code>.ji</code>および対応する<code>.so</code>、<code>.dll</code>、または<code>.dylib</code>ファイル）を再コンパイルする原因となります。これは、コンパイル中にすべてのコンパイル時設定のハッシュをシリアライズし、適切なファイルをロードする際にそのハッシュを現在の環境と照合することによって行われます。</span></p><p data-translated="true"><span class="original-text">Preferences can be set with depot-wide defaults; if package Foo is installed within your global environment and it has preferences set, these preferences will apply as long as your global environment is part of your <code>LOAD_PATH</code>. Preferences in environments higher up in the environment stack get overridden by the more proximal entries in the load path, ending with the currently active project. This allows depot-wide preference defaults to exist, with active projects able to merge or even completely overwrite these inherited preferences. See the docstring for <code>Preferences.set_preferences!()</code> for the full details of how to set preferences to allow or disallow merging.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定はデポ全体のデフォルトで設定できます。もしパッケージFooがグローバル環境内にインストールされており、設定がされている場合、これらの設定はグローバル環境が<code>LOAD_PATH</code>の一部である限り適用されます。環境スタックの上位にある環境の設定は、ロードパス内のより近いエントリによって上書きされ、現在アクティブなプロジェクトで終了します。これにより、デポ全体の設定デフォルトが存在し、アクティブなプロジェクトがこれらの継承された設定をマージまたは完全に上書きすることができます。設定をマージを許可または不許可にする方法の詳細については、<code>Preferences.set_preferences!()</code>のドキュメント文字列を参照してください。</span></p><h2 id="Conclusion" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Conclusion">結論</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Federated package management and precise software reproducibility are difficult but worthy goals in a package system. In combination, these goals lead to a more complex package loading mechanism than most dynamic languages have, but it also yields scalability and reproducibility that is more commonly associated with static languages. Typically, Julia users should be able to use the built-in package manager to manage their projects without needing a precise understanding of these interactions. A call to <code>Pkg.add("X")</code> will add to the appropriate project and manifest files, selected via <code>Pkg.activate("Y")</code>, so that a future call to <code>import X</code> will load <code>X</code> without further thought.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">連携パッケージ管理と正確なソフトウェア再現性は、パッケージシステムにおいて困難ですが価値のある目標です。これらの目標を組み合わせることで、ほとんどの動的言語が持つよりも複雑なパッケージロードメカニズムが生まれますが、静的言語に一般的に関連付けられるスケーラビリティと再現性も得られます。通常、Juliaユーザーは、これらの相互作用を正確に理解することなく、組み込みのパッケージマネージャを使用してプロジェクトを管理できるはずです。<code>Pkg.add("X")</code>の呼び出しは、<code>Pkg.activate("Y")</code>を介して選択された適切なプロジェクトおよびマニフェストファイルに追加されるため、将来の<code>import X</code>の呼び出しは、さらなる考慮なしに<code>X</code>をロードします。</span></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../embedding/index.html">« Embedding Julia</a><a class="docs-footer-nextpage" href="../profile/index.html">Profiling »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>