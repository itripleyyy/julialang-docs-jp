<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Frequently Asked Questions · The Julia Language</title><meta name="title" content="Frequently Asked Questions · The Julia Language"><meta property="og:title" content="Frequently Asked Questions · The Julia Language"><meta property="twitter:title" content="Frequently Asked Questions · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/faq/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/faq/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bi1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li class="is-active"><a class="tocitem" href="">Frequently Asked Questions</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#General"><span>General</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#General"><span>一般</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-api"><span>Public API</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-api"><span>公開API</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Sessions-and-the-REPL"><span>Sessions and the REPL</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Sessions-and-the-REPL"><span>セッションとREPL</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-scripting"><span>Scripting</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-scripting"><span>スクリプティング</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Variables-and-Assignments"><span>Variables and Assignments</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Variables-and-Assignments"><span>変数と代入</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Functions"><span>Functions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Functions"><span>関数</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Types,-type-declarations,-and-constructors"><span>Types, type declarations, and constructors</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Types,-type-declarations,-and-constructors"><span>型、型宣言、およびコンストラクタ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Troubleshooting-&quot;method-not-matched&quot;:-parametric-type-invariance-and-MethodErrors"><span>Troubleshooting "method not matched": parametric type invariance and <code>MethodError</code>s</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Troubleshooting-&quot;method-not-matched&quot;:-parametric-type-invariance-and-MethodErrors"><span>トラブルシューティング "メソッドが一致しない": パラメトリック型不変性と <code>MethodError</code>s</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Packages-and-Modules"><span>Packages and Modules</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Packages-and-Modules"><span>パッケージとモジュール</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Nothingness-and-missing-values"><span>Nothingness and missing values</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Nothingness-and-missing-values"><span>無と欠損値</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Memory"><span>Memory</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Memory"><span>メモリ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#faq-async-io"><span>Asynchronous IO and concurrent synchronous writes</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#faq-async-io"><span>非同期IOと同時同期書き込み</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Arrays"><span>Arrays</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Arrays"><span>配列</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Computing-cluster"><span>Computing cluster</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Computing-cluster"><span>計算クラスター</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Julia-Releases"><span>Julia Releases</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Julia-Releases"><span>Juliaのリリース</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">よくある質問</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">よくある質問</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/faq.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Frequently-Asked-Questions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Frequently-Asked-Questions">Frequently Asked Questions</a><a id="Frequently-Asked-Questions-1"></a><a class="docs-heading-anchor-permalink" href="#Frequently-Asked-Questions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Frequently-Asked-Questions">よくある質問</a><a id="Frequently-Asked-Questions-1"></a><a class="docs-heading-anchor-permalink" href="#Frequently-Asked-Questions" title="Permalink"></a></span></h1><h2 id="General" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#General">一般</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></span></h2><h3 id="Is-Julia-named-after-someone-or-something?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Is-Julia-named-after-someone-or-something?">Is Julia named after someone or something?</a><a id="Is-Julia-named-after-someone-or-something?-1"></a><a class="docs-heading-anchor-permalink" href="#Is-Julia-named-after-someone-or-something?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Is-Julia-named-after-someone-or-something?">Juliaは誰かまたは何かにちなんで名付けられたのですか？</a><a id="Is-Julia-named-after-someone-or-something?-1"></a><a class="docs-heading-anchor-permalink" href="#Is-Julia-named-after-someone-or-something?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">No.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">番号。</span></p><h3 id="Why-don't-you-compile-Matlab/Python/R/…-code-to-Julia?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Why-don't-you-compile-Matlab/Python/R/…-code-to-Julia?">Why don't you compile Matlab/Python/R/… code to Julia?</a><a id="Why-don't-you-compile-Matlab/Python/R/…-code-to-Julia?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-don't-you-compile-Matlab/Python/R/…-code-to-Julia?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Why-don't-you-compile-Matlab/Python/R/…-code-to-Julia?">なぜMatlab/Python/R/…のコードをJuliaにコンパイルしないのですか？</a><a id="Why-don't-you-compile-Matlab/Python/R/…-code-to-Julia?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-don't-you-compile-Matlab/Python/R/…-code-to-Julia?" title="パーマリンク"></a></span></h3><p data-translated="true"><span class="original-text">Since many people are familiar with the syntax of other dynamic languages, and lots of code has already been written in those languages, it is natural to wonder why we didn't just plug a Matlab or Python front-end into a Julia back-end (or “transpile” code to Julia) in order to get all the performance benefits of Julia without requiring programmers to learn a new language. Simple, right?</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">多くの人々が他の動的言語の構文に慣れており、すでに多くのコードがそれらの言語で書かれているため、プログラマーに新しい言語を学ばせることなく、Juliaのすべてのパフォーマンスの利点を得るために、MatlabやPythonのフロントエンドをJuliaのバックエンドに接続（または「トランスパイル」）しなかった理由を疑問に思うのは自然です。簡単ですよね？</span></p><p data-translated="true"><span class="original-text">The basic issue is that there is <em>nothing special about Julia's compiler</em>: we use a commonplace compiler (LLVM) with no “secret sauce” that other language developers don't know about. Indeed, Julia's compiler is in many ways much simpler than those of other dynamic languages (e.g. PyPy or LuaJIT). Julia's performance advantage derives almost entirely from its front-end: its language semantics allow a <a href="../performance-tips/index.html#man-performance-tips">well-written Julia program</a> to <em>give more opportunities to the compiler</em> to generate efficient code and memory layouts. If you tried to compile Matlab or Python code to Julia, our compiler would be limited by the semantics of Matlab or Python to producing code no better than that of existing compilers for those languages (and probably worse). The key role of semantics is also why several existing Python compilers (like Numba and Pythran) only attempt to optimize a small subset of the language (e.g. operations on Numpy arrays and scalars), and for this subset they are already doing at least as well as we could for the same semantics. The people working on those projects are incredibly smart and have accomplished amazing things, but retrofitting a compiler onto a language that was designed to be interpreted is a very difficult problem.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">基本的な問題は、<em>Juliaのコンパイラには特別なものがない</em>ということです：私たちは、他の言語の開発者が知らない「秘密のソース」なしで、一般的なコンパイラ（LLVM）を使用しています。実際、Juliaのコンパイラは、他の動的言語（例えば、PyPyやLuaJIT）よりも多くの点ではるかにシンプルです。Juliaのパフォーマンスの利点は、ほぼ完全にそのフロントエンドから派生しています：その言語の意味論は、<a href="../performance-tips/index.html#man-performance-tips">よく書かれたJuliaプログラム</a>が<em>コンパイラに効率的なコードとメモリレイアウトを生成する機会をより多く提供する</em>ことを可能にします。MatlabやPythonのコードをJuliaにコンパイルしようとすると、私たちのコンパイラはMatlabやPythonの意味論によって制限され、これらの言語の既存のコンパイラと同じかそれ以下のコードしか生成できません。意味論の重要な役割は、いくつかの既存のPythonコンパイラ（NumbaやPythranなど）が言語の小さなサブセット（例えば、Numpy配列やスカラーに対する操作）を最適化しようとする理由でもあり、このサブセットに関しては、私たちが同じ意味論のためにできることと少なくとも同じくらいの成果を上げています。これらのプロジェクトに取り組んでいる人々は非常に賢く、驚くべき成果を上げていますが、解釈されることを前提に設計された言語にコンパイラを適合させることは非常に難しい問題です。</span></p><p data-translated="true"><span class="original-text">Julia's advantage is that good performance is not limited to a small subset of “built-in” types and operations, and one can write high-level type-generic code that works on arbitrary user-defined types while remaining fast and memory-efficient. Types in languages like Python simply don't provide enough information to the compiler for similar capabilities, so as soon as you used those languages as a Julia front-end you would be stuck.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの利点は、良好なパフォーマンスが「組み込み」型や操作の小さなサブセットに制限されないことであり、高速かつメモリ効率の良いままで任意のユーザー定義型で動作する高レベルの型汎用コードを書くことができることです。Pythonのような言語では、コンパイラに対して同様の機能を提供するための情報が十分ではないため、これらの言語をJuliaのフロントエンドとして使用すると、行き詰まってしまいます。</span></p><p data-translated="true"><span class="original-text">For similar reasons, automated translation to Julia would also typically generate unreadable, slow, non-idiomatic code that would not be a good starting point for a native Julia port from another language.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同様の理由から、Juliaへの自動翻訳は通常、読みにくく、遅く、非慣用的なコードを生成し、他の言語からのネイティブなJuliaポートの良い出発点にはなりません。</span></p><p data-translated="true"><span class="original-text">On the other hand, language <em>interoperability</em> is extremely useful: we want to exploit existing high-quality code in other languages from Julia (and vice versa)!  The best way to enable this is not a transpiler, but rather via easy inter-language calling facilities. We have worked hard on this, from the built-in <code>ccall</code> intrinsic (to call C and Fortran libraries) to <a href="https://github.com/JuliaInterop">JuliaInterop</a> packages that connect Julia to Python, Matlab, C++, and more.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一方で、言語の<em>相互運用性</em>は非常に便利です：私たちはJuliaから他の言語の既存の高品質なコードを活用したい（その逆も同様です）！これを可能にする最良の方法はトランスパイラではなく、言語間の呼び出し機能を簡単にすることです。私たちは、CおよびFortranライブラリを呼び出すための組み込みの<code>ccall</code>内蔵関数から、JuliaをPython、Matlab、C++などに接続する<a href="https://github.com/JuliaInterop">JuliaInterop</a>パッケージまで、これに取り組んできました。</span></p><h2 id="man-api" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-api">Public API</a><a id="man-api-1"></a><a class="docs-heading-anchor-permalink" href="#man-api" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-api">公開API</a><a id="man-api-1"></a><a class="docs-heading-anchor-permalink" href="#man-api" title="パーマリンク"></a></span></h2><h3 id="How-does-Julia-define-its-public-API?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#How-does-Julia-define-its-public-API?">How does Julia define its public API?</a><a id="How-does-Julia-define-its-public-API?-1"></a><a class="docs-heading-anchor-permalink" href="#How-does-Julia-define-its-public-API?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#How-does-Julia-define-its-public-API?">Juliaはどのようにその公開APIを定義していますか？</a><a id="How-does-Julia-define-its-public-API?-1"></a><a class="docs-heading-anchor-permalink" href="#How-does-Julia-define-its-public-API?" title="パーマリンク"></a></span></h3><p data-translated="true"><span class="original-text">Julia's public <a href="https://en.wikipedia.org/wiki/API">API</a> is the behavior described in documentation of public bindings from <code>Base</code> and the standard libraries. Functions, types, and constants are not part of the public API if they are not public, even if they have docstrings or are described in the documentation. Further, only the documented behavior of public bindings is part of the public API. Undocumented behavior of public bindings is internal.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの公開<a href="https://en.wikipedia.org/wiki/API">API</a>は、<code>Base</code>および標準ライブラリからの公開バインディングのドキュメントに記載されている動作です。関数、型、および定数は、公開されていない場合、ドキュメントにdocstringがあっても、ドキュメントに記載されていても、公開APIの一部ではありません。さらに、公開バインディングのドキュメント化された動作のみが公開APIの一部です。公開バインディングの未文書の動作は内部的なものです。</span></p><p data-translated="true"><span class="original-text">Public bindings are those marked with either <code>public foo</code> or <code>export foo</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">公開バインディングは、<code>public foo</code>または<code>export foo</code>でマークされたものです。</span></p><p data-translated="true"><span class="original-text">In other words:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">言い換えれば：</span></p><ul><li data-translated="true"><span class="original-text">Documented behavior of public bindings is part of the public API.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">公開バインディングの文書化された動作は、公開APIの一部です。</span></li><li data-translated="true"><span class="original-text">Undocumented behavior of public bindings is not part of the public API.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">公開バインディングの文書化されていない動作は、公開APIの一部ではありません。</span></li><li data-translated="true"><span class="original-text">Documented behavior of private bindings is not part of the public API.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プライベートバインディングの文書化された動作は、公開APIの一部ではありません。</span></li><li data-translated="true"><span class="original-text">Undocumented behavior of private bindings is not part of the public API.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プライベートバインディングの文書化されていない動作は、公開APIの一部ではありません。</span></li></ul><p data-translated="true"><span class="original-text">You can get a complete list of the public bindings from a module with <code>names(MyModule)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュールから公開バインディングの完全なリストを取得するには、<code>names(MyModule)</code>を使用します。</span></p><p data-translated="true"><span class="original-text">Package authors are encouraged to define their public API similarly.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パッケージの著者は、同様に公開APIを定義することが推奨されています。</span></p><p data-translated="true"><span class="original-text">Anything in Julia's Public API is covered by <a href="https://semver.org/">SemVer</a> and therefore will not be removed or receive meaningful breaking changes before Julia 2.0.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの公開APIにあるものは、<a href="https://semver.org/">SemVer</a>の対象であり、したがって、Julia 2.0以前に削除されたり、重要な破壊的変更を受けたりすることはありません。</span></p><h3 id="There-is-a-useful-undocumented-function/type/constant.-Can-I-use-it?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#There-is-a-useful-undocumented-function/type/constant.-Can-I-use-it?">There is a useful undocumented function/type/constant. Can I use it?</a><a id="There-is-a-useful-undocumented-function/type/constant.-Can-I-use-it?-1"></a><a class="docs-heading-anchor-permalink" href="#There-is-a-useful-undocumented-function/type/constant.-Can-I-use-it?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#There-is-a-useful-undocumented-function/type/constant.-Can-I-use-it?">役立つ文書化されていない関数/型/定数があります。それを使用できますか？</a><a id="There-is-a-useful-undocumented-function/type/constant.-Can-I-use-it?-1"></a><a class="docs-heading-anchor-permalink" href="#There-is-a-useful-undocumented-function/type/constant.-Can-I-use-it?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Updating Julia may break your code if you use non-public API. If the code is self-contained, it may be a good idea to copy it into your project. If you want to rely on a complex non-public API, especially when using it from a stable package, it is a good idea to open an <a href="https://github.com/JuliaLang/julia/issues">issue</a> or <a href="https://github.com/JuliaLang/julia/pulls">pull request</a> to start a discussion for turning it into a public API. However, we do not discourage the attempt to create packages that expose stable public interfaces while relying on non-public implementation details of Julia and buffering the differences across different Julia versions.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaを更新すると、非公開APIを使用している場合、コードが壊れる可能性があります。コードが自己完結している場合は、それをプロジェクトにコピーするのが良いアイデアかもしれません。特に安定したパッケージから使用する場合、複雑な非公開APIに依存したい場合は、それを公開APIに変えるための議論を始めるために、<a href="https://github.com/JuliaLang/julia/issues">issue</a>や<a href="https://github.com/JuliaLang/julia/pulls">pull request</a>を開くのが良いアイデアです。ただし、非公開の実装詳細に依存しながら安定した公開インターフェースを公開するパッケージを作成する試みを妨げるものではありません。</span></p><h3 id="The-documentation-is-not-accurate-enough.-Can-I-rely-on-the-existing-behavior?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#The-documentation-is-not-accurate-enough.-Can-I-rely-on-the-existing-behavior?">The documentation is not accurate enough. Can I rely on the existing behavior?</a><a id="The-documentation-is-not-accurate-enough.-Can-I-rely-on-the-existing-behavior?-1"></a><a class="docs-heading-anchor-permalink" href="#The-documentation-is-not-accurate-enough.-Can-I-rely-on-the-existing-behavior?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#The-documentation-is-not-accurate-enough.-Can-I-rely-on-the-existing-behavior?">ドキュメントが十分に正確ではありません。既存の動作に依存できますか？</a><a id="The-documentation-is-not-accurate-enough.-Can-I-rely-on-the-existing-behavior?-1"></a><a class="docs-heading-anchor-permalink" href="#The-documentation-is-not-accurate-enough.-Can-I-rely-on-the-existing-behavior?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Please open an <a href="https://github.com/JuliaLang/julia/issues">issue</a> or <a href="https://github.com/JuliaLang/julia/pulls">pull request</a> to start a discussion for turning the existing behavior into a public API.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">既存の動作を公開APIに変えるための議論を始めるために、<a href="https://github.com/JuliaLang/julia/issues">issue</a>や<a href="https://github.com/JuliaLang/julia/pulls">pull request</a>を開いてください。</span></p><h2 id="Sessions-and-the-REPL" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Sessions-and-the-REPL">Sessions and the REPL</a><a id="Sessions-and-the-REPL-1"></a><a class="docs-heading-anchor-permalink" href="#Sessions-and-the-REPL" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Sessions-and-the-REPL">セッションとREPL</a><a id="Sessions-and-the-REPL-1"></a><a class="docs-heading-anchor-permalink" href="#Sessions-and-the-REPL" title="Permalink"></a></span></h2><h3 id="How-do-I-delete-an-object-in-memory?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#How-do-I-delete-an-object-in-memory?">How do I delete an object in memory?</a><a id="How-do-I-delete-an-object-in-memory?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-delete-an-object-in-memory?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#How-do-I-delete-an-object-in-memory?">メモリ内のオブジェクトを削除するにはどうすればよいですか？</a><a id="How-do-I-delete-an-object-in-memory?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-delete-an-object-in-memory?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Julia does not have an analog of MATLAB's <code>clear</code> function; once a name is defined in a Julia session (technically, in module <code>Main</code>), it is always present.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">JuliaにはMATLABの<code>clear</code>関数のアナログはありません。名前がJuliaセッション（技術的にはモジュール<code>Main</code>）で定義されると、それは常に存在します。</span></p><p data-translated="true"><span class="original-text">If memory usage is your concern, you can always replace objects with ones that consume less memory.  For example, if <code>A</code> is a gigabyte-sized array that you no longer need, you can free the memory with <code>A = nothing</code>. The memory will be released the next time the garbage collector runs; you can force this to happen with <a href="../../base/base/index.html#Base.GC.gc"><code>GC.gc()</code></a>. Moreover, an attempt to use <code>A</code> will likely result in an error, because most methods are not defined on type <code>Nothing</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メモリ使用量が懸念される場合は、常にメモリを消費しないオブジェクトに置き換えることができます。たとえば、<code>A</code>がもはや必要ないギガバイトサイズの配列である場合、<code>A = nothing</code>でメモリを解放できます。メモリは次回ガベージコレクタが実行されると解放されます。これを強制的に実行するには、<a href="../../base/base/index.html#Base.GC.gc"><code>GC.gc()</code></a>を使用できます。さらに、<code>A</code>を使用しようとすると、ほとんどのメソッドが<code>Nothing</code>型に対して定義されていないため、エラーが発生する可能性が高いです。</span></p><h2 id="man-scripting" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-scripting">Scripting</a><a id="man-scripting-1"></a><a class="docs-heading-anchor-permalink" href="#man-scripting" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-scripting">スクリプティング</a><a id="man-scripting-1"></a><a class="docs-heading-anchor-permalink" href="#man-scripting" title="Permalink"></a></span></h2><h3 id="How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?">How do I check if the current file is being run as the main script?</a><a id="How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?">現在のファイルがメインスクリプトとして実行されているかどうかを確認するにはどうすればよいですか？</a><a id="How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">When a file is run as the main script using <code>julia file.jl</code> one might want to activate extra functionality like command line argument handling. A way to determine that a file is run in this fashion is to check if <code>abspath(PROGRAM_FILE) == @__FILE__</code> is <code>true</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ファイルが<code>julia file.jl</code>を使用してメインスクリプトとして実行されると、コマンドライン引数処理などの追加機能を有効にしたい場合があります。このようにファイルが実行されているかどうかを判断する方法は、<code>abspath(PROGRAM_FILE) == @__FILE__</code>が<code>true</code>であるかどうかを確認することです。</span></p><p data-translated="true"><span class="original-text">However, it is recommended to not write files that double as a script and as an importable library. If one needs functionality both available as a library and a script, it is better to write is as a library, then import the functionality into a distinct script.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、スクリプトとインポート可能なライブラリの両方として機能するファイルを書くことは推奨されません。ライブラリとしてもスクリプトとしても利用可能な機能が必要な場合は、ライブラリとして書き、その機能を別のスクリプトにインポートする方が良いです。</span></p><h3 id="catch-ctrl-c" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#catch-ctrl-c">How do I catch CTRL-C in a script?</a><a id="catch-ctrl-c-1"></a><a class="docs-heading-anchor-permalink" href="#catch-ctrl-c" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#catch-ctrl-c">スクリプトでCTRL-Cをキャッチするにはどうすればよいですか？</a><a id="catch-ctrl-c-1"></a><a class="docs-heading-anchor-permalink" href="#catch-ctrl-c" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Running a Julia script using <code>julia file.jl</code> does not throw <a href="../../base/base/index.html#Core.InterruptException"><code>InterruptException</code></a> when you try to terminate it with CTRL-C (SIGINT). To run a certain code before terminating a Julia script, which may or may not be caused by CTRL-C, use <a href="../../base/base/index.html#Base.atexit"><code>atexit</code></a>. Alternatively, you can use <code>julia -e 'include(popfirst!(ARGS))' file.jl</code> to execute a script while being able to catch <code>InterruptException</code> in the <a href="../../base/base/index.html#try"><code>try</code></a> block. Note that with this strategy <a href="../../base/constants/index.html#Base.PROGRAM_FILE"><code>PROGRAM_FILE</code></a> will not be set.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>julia file.jl</code>を使用してJuliaスクリプトを実行すると、CTRL-C (SIGINT)で終了しようとしたときに<a href="../../base/base/index.html#Core.InterruptException"><code>InterruptException</code></a>はスローされません。CTRL-Cによって終了されるかどうかにかかわらず、Juliaスクリプトを終了する前に特定のコードを実行するには、<a href="../../base/base/index.html#Base.atexit"><code>atexit</code></a>を使用します。あるいは、<code>julia -e 'include(popfirst!(ARGS))' file.jl</code>を使用して、<a href="../../base/base/index.html#try"><code>try</code></a>ブロック内で<code>InterruptException</code>をキャッチできるようにスクリプトを実行することもできます。この戦略では、<a href="../../base/constants/index.html#Base.PROGRAM_FILE"><code>PROGRAM_FILE</code></a>は設定されないことに注意してください。</span></p><h3 id="How-do-I-pass-options-to-julia-using-#!/usr/bin/env?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#How-do-I-pass-options-to-julia-using-#!/usr/bin/env?">How do I pass options to <code>julia</code> using <code>#!/usr/bin/env</code>?</a><a id="How-do-I-pass-options-to-julia-using-#!/usr/bin/env?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-pass-options-to-julia-using-#!/usr/bin/env?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#How-do-I-pass-options-to-julia-using-#!/usr/bin/env?"><code>julia</code>に<code>#!/usr/bin/env</code>を使用してオプションを渡すにはどうすればよいですか？</a><a id="How-do-I-pass-options-to-julia-using-#!/usr/bin/env?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-pass-options-to-julia-using-#!/usr/bin/env?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Passing options to <code>julia</code> in a so-called shebang line, as in <code>#!/usr/bin/env julia --startup-file=no</code>, will not work on many platforms (BSD, macOS, Linux) where the kernel, unlike the shell, does not split arguments at space characters. The option <code>env -S</code>, which splits a single argument string into multiple arguments at spaces, similar to a shell, offers a simple workaround:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>julia</code>にいわゆるシェバン行でオプションを渡すこと、例えば<code>#!/usr/bin/env julia --startup-file=no</code>は、カーネルがシェルとは異なり、スペース文字で引数を分割しない多くのプラットフォーム（BSD、macOS、Linux）では機能しません。単一の引数文字列をスペースで複数の引数に分割する<code>env -S</code>オプションは、シェルに似た簡単な回避策を提供します：</span></p><pre><code class="language-julia hljs">#!/usr/bin/env -S julia --color=yes --startup-file=no
@show ARGS  # put any Julia code here</code></pre><div class="admonition is-info" id="Note-ea758583deaf657"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ea758583deaf657" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Option <code>env -S</code> appeared in FreeBSD 6.0 (2005), macOS Sierra (2016) and GNU/Linux coreutils 8.30 (2018).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">オプション<code>env -S</code>は、FreeBSD 6.0 (2005)、macOS Sierra (2016)、およびGNU/Linux coreutils 8.30 (2018)に登場しました。</span></p></div></div><h3 id="Why-doesn't-run-support-*-or-pipes-for-scripting-external-programs?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Why-doesn't-run-support-*-or-pipes-for-scripting-external-programs?">Why doesn't <code>run</code> support <code>*</code> or pipes for scripting external programs?</a><a id="Why-doesn't-run-support-*-or-pipes-for-scripting-external-programs?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-doesn't-run-support-*-or-pipes-for-scripting-external-programs?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Why-doesn't-run-support-*-or-pipes-for-scripting-external-programs?">なぜ<code>run</code>は外部プログラムのスクリプティングに<code>*</code>やパイプをサポートしていないのですか？</a><a id="Why-doesn't-run-support-*-or-pipes-for-scripting-external-programs?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-doesn't-run-support-*-or-pipes-for-scripting-external-programs?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Julia's <a href="../../base/base/index.html#Base.run"><code>run</code></a> function launches external programs <em>directly</em>, without invoking an <a href="https://en.wikipedia.org/wiki/Shell_(computing)">operating-system shell</a> (unlike the <code>system("...")</code> function in other languages like Python, R, or C). That means that <code>run</code> does not perform wildcard expansion of <code>*</code> (<a href="https://en.wikipedia.org/wiki/Glob_(programming)">"globbing"</a>), nor does it interpret <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">shell pipelines</a> like <code>|</code> or <code>&gt;</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの<a href="../../base/base/index.html#Base.run"><code>run</code></a>関数は、<em>直接</em>外部プログラムを起動します。これは、他の言語（Python、R、Cなど）の<code>system("...")</code>関数とは異なり、<a href="https://en.wikipedia.org/wiki/Shell_(computing)">オペレーティングシステムシェル</a>を呼び出しません。つまり、<code>run</code>は<code>*</code>のワイルドカード展開（<a href="https://en.wikipedia.org/wiki/Glob_(programming)">"グロビング"</a>）を行わず、<code>|</code>や<code>&gt;</code>のような<a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">シェルパイプライン</a>を解釈しません。</span></p><p data-translated="true"><span class="original-text">You can still do globbing and pipelines using Julia features, however. For example, the built-in <a href="../../base/base/index.html#Base.pipeline-Tuple{Any, Any, Any, Vararg{Any}}"><code>pipeline</code></a> function allows you to chain external programs and files, similar to shell pipes, and the <a href="https://github.com/vtjnash/Glob.jl">Glob.jl package</a> implements POSIX-compatible globbing.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、Juliaの機能を使用してグロビングやパイプラインを行うことはできます。たとえば、組み込みの<a href="../../base/base/index.html#Base.pipeline-Tuple{Any, Any, Any, Vararg{Any}}"><code>pipeline</code></a>関数を使用すると、シェルパイプのように外部プログラムやファイルを連鎖させることができ、<a href="https://github.com/vtjnash/Glob.jl">Glob.jlパッケージ</a>はPOSIX互換のグロビングを実装しています。</span></p><p data-translated="true"><span class="original-text">You can, of course, run programs through the shell by explicitly passing a shell and a command string to <code>run</code>, e.g. <code>run(`sh -c "ls &gt; files.txt"`)</code> to use the Unix <a href="https://en.wikipedia.org/wiki/Bourne_shell">Bourne shell</a>, but you should generally prefer pure-Julia scripting like <code>run(pipeline(`ls`, "files.txt"))</code>. The reason why we avoid the shell by default is that <a href="https://julialang.org/blog/2012/03/shelling-out-sucks/">shelling out sucks</a>: launching processes via the shell is slow, fragile to quoting of special characters,  has poor error handling, and is problematic for portability.  (The Python developers came to a <a href="https://www.python.org/dev/peps/pep-0324/#motivation#motivation">similar conclusion</a>.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もちろん、<code>run</code>にシェルとコマンド文字列を明示的に渡すことで、シェルを介してプログラムを実行することもできます。例えば、<code>run(`sh -c "ls &gt; files.txt"`)</code>を使用してUnixの<a href="https://en.wikipedia.org/wiki/Bourne_shell">ボーンシェル</a>を利用できますが、一般的には<code>run(pipeline(`ls`, "files.txt"))</code>のような純粋なJuliaスクリプティングを好むべきです。デフォルトでシェルを避ける理由は、<a href="https://julialang.org/blog/2012/03/shelling-out-sucks/">シェルを使うのは面倒だからです</a>：シェルを介してプロセスを起動するのは遅く、特殊文字の引用に対して脆弱で、エラーハンドリングが不十分で、移植性に問題があります。（Python開発者も<a href="https://www.python.org/dev/peps/pep-0324/#motivation#motivation">同様の結論に達しました</a>。）</span></p><h2 id="Variables-and-Assignments" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Variables-and-Assignments">Variables and Assignments</a><a id="Variables-and-Assignments-1"></a><a class="docs-heading-anchor-permalink" href="#Variables-and-Assignments" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Variables-and-Assignments">変数と代入</a><a id="Variables-and-Assignments-1"></a><a class="docs-heading-anchor-permalink" href="#Variables-and-Assignments" title="Permalink"></a></span></h2><h3 id="Why-am-I-getting-UndefVarError-from-a-simple-loop?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Why-am-I-getting-UndefVarError-from-a-simple-loop?">Why am I getting <code>UndefVarError</code> from a simple loop?</a><a id="Why-am-I-getting-UndefVarError-from-a-simple-loop?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-am-I-getting-UndefVarError-from-a-simple-loop?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Why-am-I-getting-UndefVarError-from-a-simple-loop?">なぜ簡単なループから<code>UndefVarError</code>が出るのですか？</a><a id="Why-am-I-getting-UndefVarError-from-a-simple-loop?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-am-I-getting-UndefVarError-from-a-simple-loop?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">You might have something like:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">あなたは次のようなものを持っているかもしれません：</span></p><pre><code class="nohighlight hljs">x = 0
while x &lt; 10
    x += 1
end</code></pre><p data-translated="true"><span class="original-text">and notice that it works fine in an interactive environment (like the Julia REPL), but gives <code>UndefVarError: `x` not defined</code> when you try to run it in script or other file. What is going on is that Julia generally requires you to <strong>be explicit about assigning to global variables in a local scope</strong>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そして、インタラクティブな環境（例えば、Julia REPL）では正常に動作することに気づきますが、スクリプトや他のファイルで実行しようとすると<code>UndefVarError: `x` not defined</code>が出ます。何が起こっているかというと、Juliaは一般的に<strong>ローカルスコープ内でグローバル変数に代入することを明示的に要求します</strong>。</span></p><p data-translated="true"><span class="original-text">Here, <code>x</code> is a global variable, <code>while</code> defines a <a href="../variables-and-scoping/index.html#scope-of-variables">local scope</a>, and <code>x += 1</code> is an assignment to a global in that local scope.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで、<code>x</code>はグローバル変数であり、<code>while</code>は<a href="../variables-and-scoping/index.html#scope-of-variables">ローカルスコープ</a>を定義し、<code>x += 1</code>はそのローカルスコープ内でのグローバル変数への代入です。</span></p><p data-translated="true"><span class="original-text">As mentioned above, Julia (version 1.5 or later) allows you to omit the <code>global</code> keyword for code in the REPL (and many other interactive environments), to simplify exploration (e.g. copy-pasting code from a function to run interactively). However, once you move to code in files, Julia requires a more disciplined approach to global variables. You have least three options:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記のように、Julia（バージョン1.5以降）は、REPL（および多くの他のインタラクティブ環境）内のコードに対して<code>global</code>キーワードを省略することを許可しており、探索を簡素化します（例えば、関数からコードをコピー＆ペーストしてインタラクティブに実行する）。しかし、ファイル内のコードに移動すると、Juliaはグローバル変数に対してより規律あるアプローチを要求します。少なくとも3つのオプションがあります：</span></p><ol><li data-translated="true"><span class="original-text">Put the code into a function (so that <code>x</code> is a <em>local</em> variable in a function). In general, it is good software engineering to use functions rather than global scripts (search online for "why global variables bad" to see many explanations). In Julia, global variables are also <a href="../performance-tips/index.html#man-performance-tips">slow</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コードを関数に入れる（これにより<code>x</code>は関数内の<em>ローカル</em>変数になります）。一般的に、グローバルスクリプトよりも関数を使用することは良いソフトウェア工学です（「なぜグローバル変数が悪いのか」をオンラインで検索すると、多くの説明が見つかります）。Juliaでは、グローバル変数も<a href="../performance-tips/index.html#man-performance-tips">遅い</a>です。</span></li><li data-translated="true"><span class="original-text">Wrap the code in a <a href="../../base/base/index.html#let"><code>let</code></a> block.  (This makes <code>x</code> a local variable within the <code>let ... end</code> statement, again eliminating the need for <code>global</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#let"><code>let</code></a>ブロックでコードをラップします。（これにより、<code>x</code>は<code>let ... end</code>文内のローカル変数になり、再び<code>global</code>の必要がなくなります）。</span></li><li data-translated="true"><span class="original-text">Explicitly mark <code>x</code> as <code>global</code> inside the local scope before assigning to it, e.g. write <code>global x += 1</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ローカルスコープ内で代入する前に<code>x</code>を<code>global</code>として明示的にマークします。例えば、<code>global x += 1</code>と書きます。</span></li></ol><p data-translated="true"><span class="original-text">More explanation can be found in the manual section <a href="../variables-and-scoping/index.html#on-soft-scope">on soft scope</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">詳細な説明はマニュアルの<a href="../variables-and-scoping/index.html#on-soft-scope">ソフトスコープに関するセクション</a>で見つけることができます。</span></p><h2 id="Functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Functions">関数</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></span></h2><h3 id="I-passed-an-argument-x-to-a-function,-modified-it-inside-that-function,-but-on-the-outside,-the-variable-x-is-still-unchanged.-Why?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#I-passed-an-argument-x-to-a-function,-modified-it-inside-that-function,-but-on-the-outside,-the-variable-x-is-still-unchanged.-Why?">I passed an argument <code>x</code> to a function, modified it inside that function, but on the outside, the variable <code>x</code> is still unchanged. Why?</a><a id="I-passed-an-argument-x-to-a-function,-modified-it-inside-that-function,-but-on-the-outside,-the-variable-x-is-still-unchanged.-Why?-1"></a><a class="docs-heading-anchor-permalink" href="#I-passed-an-argument-x-to-a-function,-modified-it-inside-that-function,-but-on-the-outside,-the-variable-x-is-still-unchanged.-Why?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#I-passed-an-argument-x-to-a-function,-modified-it-inside-that-function,-but-on-the-outside,-the-variable-x-is-still-unchanged.-Why?">引数 <code>x</code> を関数に渡し、その関数内で変更しましたが、外部では変数 <code>x</code> はまだ変更されていません。なぜですか？</a><a id="I-passed-an-argument-x-to-a-function,-modified-it-inside-that-function,-but-on-the-outside,-the-variable-x-is-still-unchanged.-Why?-1"></a><a class="docs-heading-anchor-permalink" href="#I-passed-an-argument-x-to-a-function,-modified-it-inside-that-function,-but-on-the-outside,-the-variable-x-is-still-unchanged.-Why?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Suppose you call a function like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のように関数を呼び出すとします:</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = 10
10

julia&gt; function change_value!(y)
           y = 17
       end
change_value! (generic function with 1 method)

julia&gt; change_value!(x)
17

julia&gt; x # x is unchanged!
10</code></pre><p data-translated="true"><span class="original-text">In Julia, the binding of a variable <code>x</code> cannot be changed by passing <code>x</code> as an argument to a function. When calling <code>change_value!(x)</code> in the above example, <code>y</code> is a newly created variable, bound initially to the value of <code>x</code>, i.e. <code>10</code>; then <code>y</code> is rebound to the constant <code>17</code>, while the variable <code>x</code> of the outer scope is left untouched.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、変数 <code>x</code> のバインディングは、<code>x</code> を関数の引数として渡すことで変更することはできません。上記の例で <code>change_value!(x)</code> を呼び出すと、<code>y</code> は新しく作成された変数で、最初は <code>x</code> の値、すなわち <code>10</code> にバインドされます。その後、<code>y</code> は定数 <code>17</code> に再バインドされますが、外部スコープの変数 <code>x</code> はそのままです。</span></p><p data-translated="true"><span class="original-text">However, if <code>x</code> is bound to an object of type <code>Array</code> (or any other <em>mutable</em> type). From within the function, you cannot "unbind" <code>x</code> from this Array, but you <em>can</em> change its content. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、<code>x</code> が <code>Array</code> 型のオブジェクト（または他の<em>可変</em>型）にバインドされている場合、関数内から <code>x</code> をこの配列から「バインド解除」することはできませんが、その内容を変更することは<em>できます</em>。例えば:</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1,2,3]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; function change_array!(A)
           A[1] = 5
       end
change_array! (generic function with 1 method)

julia&gt; change_array!(x)
5

julia&gt; x
3-element Vector{Int64}:
 5
 2
 3</code></pre><p data-translated="true"><span class="original-text">Here we created a function <code>change_array!</code>, that assigns <code>5</code> to the first element of the passed array (bound to <code>x</code> at the call site, and bound to <code>A</code> within the function). Notice that, after the function call, <code>x</code> is still bound to the same array, but the content of that array changed: the variables <code>A</code> and <code>x</code> were distinct bindings referring to the same mutable <code>Array</code> object.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、渡された配列の最初の要素に <code>5</code> を割り当てる関数 <code>change_array!</code> を作成しました（呼び出し元では <code>x</code> にバインドされ、関数内では <code>A</code> にバインドされています）。関数呼び出し後も <code>x</code> は同じ配列にバインドされていることに注意してくださいが、その配列の内容は変更されました：変数 <code>A</code> と <code>x</code> は同じ可変 <code>Array</code> オブジェクトを参照する異なるバインディングでした。</span></p><h3 id="Can-I-use-using-or-import-inside-a-function?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Can-I-use-using-or-import-inside-a-function?">Can I use <code>using</code> or <code>import</code> inside a function?</a><a id="Can-I-use-using-or-import-inside-a-function?-1"></a><a class="docs-heading-anchor-permalink" href="#Can-I-use-using-or-import-inside-a-function?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Can-I-use-using-or-import-inside-a-function?">関数内で <code>using</code> または <code>import</code> を使用できますか？</a><a id="Can-I-use-using-or-import-inside-a-function?-1"></a><a class="docs-heading-anchor-permalink" href="#Can-I-use-using-or-import-inside-a-function?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">No, you are not allowed to have a <code>using</code> or <code>import</code> statement inside a function. If you want to import a module but only use its bindings inside a specific function or set of functions, you have two options:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">いいえ、関数内に <code>using</code> または <code>import</code> 文を持つことは許可されていません。モジュールをインポートしたいが、特定の関数または関数のセット内でのみそのバインディングを使用したい場合は、2つのオプションがあります:</span></p><ol><li><p data-translated="true"><span class="original-text">Use <code>import</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>import</code> を使用します:</span></p><pre><code class="language-julia hljs">import Foo
function bar(...)
    # ... refer to Foo bindings via Foo.baz ...
end</code></pre><p data-translated="true"><span class="original-text">This loads the module <code>Foo</code> and defines a variable <code>Foo</code> that refers to the module, but does not import any of the other bindings from the module into the current namespace. You refer to the <code>Foo</code> bindings by their qualified names <code>Foo.bar</code> etc.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これにより、モジュール <code>Foo</code> が読み込まれ、モジュールを参照する変数 <code>Foo</code> が定義されますが、モジュールから現在の名前空間に他のバインディングはインポートされません。<code>Foo</code> のバインディングには、その修飾名 <code>Foo.bar</code> などで参照します。</span></p></li><li><p data-translated="true"><span class="original-text">Wrap your function in a module:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数をモジュールでラップします：</span></p><pre><code class="language-julia hljs">module Bar
export bar
using Foo
function bar(...)
    # ... refer to Foo.baz as simply baz ....
end
end
using Bar</code></pre><p data-translated="true"><span class="original-text">This imports all the bindings from <code>Foo</code>, but only inside the module <code>Bar</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、<code>Foo</code>からすべてのバインディングをインポートしますが、モジュール<code>Bar</code>内のみです。</span></p></li></ol><h3 id="What-does-the-...-operator-do?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#What-does-the-...-operator-do?">What does the <code>...</code> operator do?</a><a id="What-does-the-...-operator-do?-1"></a><a class="docs-heading-anchor-permalink" href="#What-does-the-...-operator-do?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#What-does-the-...-operator-do?"><code>...</code> 演算子は何をしますか？</a><a id="What-does-the-...-operator-do?-1"></a><a class="docs-heading-anchor-permalink" href="#What-does-the-...-operator-do?" title="Permalink"></a></span></h3><h4 id="The-two-uses-of-the-...-operator:-slurping-and-splatting" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#The-two-uses-of-the-...-operator:-slurping-and-splatting">The two uses of the <code>...</code> operator: slurping and splatting</a><a id="The-two-uses-of-the-...-operator:-slurping-and-splatting-1"></a><a class="docs-heading-anchor-permalink" href="#The-two-uses-of-the-...-operator:-slurping-and-splatting" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#The-two-uses-of-the-...-operator:-slurping-and-splatting"><code>...</code> 演算子の2つの使い方：スラーピングとスプラッティング</a><a id="The-two-uses-of-the-...-operator:-slurping-and-splatting-1"></a><a class="docs-heading-anchor-permalink" href="#The-two-uses-of-the-...-operator:-slurping-and-splatting" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">Many newcomers to Julia find the use of <code>...</code> operator confusing. Part of what makes the <code>...</code> operator confusing is that it means two different things depending on context.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの初心者の多くは、<code>...</code> 演算子の使い方に混乱します。<code>...</code> 演算子が混乱を招く理由の一部は、文脈によって異なる2つの意味を持つからです。</span></p><h4 id="...-combines-many-arguments-into-one-argument-in-function-definitions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#...-combines-many-arguments-into-one-argument-in-function-definitions"><code>...</code> combines many arguments into one argument in function definitions</a><a id="...-combines-many-arguments-into-one-argument-in-function-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#...-combines-many-arguments-into-one-argument-in-function-definitions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#...-combines-many-arguments-into-one-argument-in-function-definitions"><code>...</code> は関数定義において多くの引数を1つの引数にまとめます</a><a id="...-combines-many-arguments-into-one-argument-in-function-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#...-combines-many-arguments-into-one-argument-in-function-definitions" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">In the context of function definitions, the <code>...</code> operator is used to combine many different arguments into a single argument. This use of <code>...</code> for combining many different arguments into a single argument is called slurping:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数定義の文脈において、<code>...</code> 演算子は多くの異なる引数を1つの引数にまとめるために使用されます。この多くの異なる引数を1つの引数にまとめるための<code>...</code> の使い方はスラーピングと呼ばれます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function printargs(args...)
           println(typeof(args))
           for (i, arg) in enumerate(args)
               println("Arg #$i = $arg")
           end
       end
printargs (generic function with 1 method)

julia&gt; printargs(1, 2, 3)
Tuple{Int64, Int64, Int64}
Arg #1 = 1
Arg #2 = 2
Arg #3 = 3</code></pre><p data-translated="true"><span class="original-text">If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as <code>&lt;-...</code> instead of <code>...</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もしJuliaがASCII文字をより自由に使用する言語であったなら、スラーピング演算子は<code>&lt;-...</code>として書かれていたかもしれません。</span></p><h4 id="...-splits-one-argument-into-many-different-arguments-in-function-calls" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#...-splits-one-argument-into-many-different-arguments-in-function-calls"><code>...</code> splits one argument into many different arguments in function calls</a><a id="...-splits-one-argument-into-many-different-arguments-in-function-calls-1"></a><a class="docs-heading-anchor-permalink" href="#...-splits-one-argument-into-many-different-arguments-in-function-calls" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#...-splits-one-argument-into-many-different-arguments-in-function-calls"><code>...</code> は関数呼び出しにおいて1つの引数を多くの異なる引数に分割します</a><a id="...-splits-one-argument-into-many-different-arguments-in-function-calls-1"></a><a class="docs-heading-anchor-permalink" href="#...-splits-one-argument-into-many-different-arguments-in-function-calls" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">In contrast to the use of the <code>...</code> operator to denote slurping many different arguments into one argument when defining a function, the <code>...</code> operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of <code>...</code> is called splatting:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数を定義する際に多くの異なる引数を1つの引数にまとめるための<code>...</code> 演算子の使用とは対照的に、<code>...</code> 演算子は関数呼び出しの文脈で単一の関数引数を多くの異なる引数に分割するためにも使用されます。この<code>...</code> の使い方はスプラッティングと呼ばれます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function threeargs(a, b, c)
           println("a = $a::$(typeof(a))")
           println("b = $b::$(typeof(b))")
           println("c = $c::$(typeof(c))")
       end
threeargs (generic function with 1 method)

julia&gt; x = [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; threeargs(x...)
a = 1::Int64
b = 2::Int64
c = 3::Int64</code></pre><p data-translated="true"><span class="original-text">If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as <code>...-&gt;</code> instead of <code>...</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もしJuliaがASCII文字をより自由に使用する言語であったなら、スプラッティング演算子は<code>...-&gt;</code>ではなく<code>...</code>として書かれていたかもしれません。</span></p><h3 id="What-is-the-return-value-of-an-assignment?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#What-is-the-return-value-of-an-assignment?">What is the return value of an assignment?</a><a id="What-is-the-return-value-of-an-assignment?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-the-return-value-of-an-assignment?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#What-is-the-return-value-of-an-assignment?">代入の戻り値は何ですか？</a><a id="What-is-the-return-value-of-an-assignment?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-the-return-value-of-an-assignment?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The operator <code>=</code> always returns the right-hand side, therefore:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">演算子<code>=</code>は常に右辺を返すため、次のようになります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function threeint()
           x::Int = 3.0
           x # returns variable x
       end
threeint (generic function with 1 method)

julia&gt; function threefloat()
           x::Int = 3.0 # returns 3.0
       end
threefloat (generic function with 1 method)

julia&gt; threeint()
3

julia&gt; threefloat()
3.0</code></pre><p data-translated="true"><span class="original-text">and similarly:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そして同様に：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function twothreetup()
           x, y = [2, 3] # assigns 2 to x and 3 to y
           x, y # returns a tuple
       end
twothreetup (generic function with 1 method)

julia&gt; function twothreearr()
           x, y = [2, 3] # returns an array
       end
twothreearr (generic function with 1 method)

julia&gt; twothreetup()
(2, 3)

julia&gt; twothreearr()
2-element Vector{Int64}:
 2
 3</code></pre><h2 id="Types,-type-declarations,-and-constructors" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Types,-type-declarations,-and-constructors">Types, type declarations, and constructors</a><a id="Types,-type-declarations,-and-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Types,-type-declarations,-and-constructors" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Types,-type-declarations,-and-constructors">型、型宣言、およびコンストラクタ</a><a id="Types,-type-declarations,-and-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Types,-type-declarations,-and-constructors" title="Permalink"></a></span></h2><h3 id="man-type-stability" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-type-stability">What does "type-stable" mean?</a><a id="man-type-stability-1"></a><a class="docs-heading-anchor-permalink" href="#man-type-stability" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-type-stability">「型安定」とは何を意味しますか？</a><a id="man-type-stability-1"></a><a class="docs-heading-anchor-permalink" href="#man-type-stability" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">It means that the type of the output is predictable from the types of the inputs. In particular, it means that the type of the output cannot vary depending on the <em>values</em> of the inputs. The following code is <em>not</em> type-stable:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">それは、出力の型が入力の型から予測可能であることを意味します。特に、出力の型は入力の<em>値</em>に応じて変わることができないことを意味します。次のコードは<em>型安定</em>ではありません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function unstable(flag::Bool)
           if flag
               return 1
           else
               return 1.0
           end
       end
unstable (generic function with 1 method)</code></pre><p data-translated="true"><span class="original-text">It returns either an <code>Int</code> or a <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> depending on the value of its argument. Since Julia can't predict the return type of this function at compile-time, any computation that uses it must be able to cope with values of both types, which makes it hard to produce fast machine code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、引数の値に応じて<code>Int</code>または<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>のいずれかを返します。Juliaはこの関数の戻り値の型をコンパイル時に予測できないため、これを使用する計算は両方の型の値に対応できなければならず、高速な機械コードを生成するのが難しくなります。</span></p><h3 id="faq-domain-errors" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#faq-domain-errors">Why does Julia give a <code>DomainError</code> for certain seemingly-sensible operations?</a><a id="faq-domain-errors-1"></a><a class="docs-heading-anchor-permalink" href="#faq-domain-errors" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#faq-domain-errors">なぜJuliaは特定の一見妥当な操作に対して<code>DomainError</code>を返すのですか？</a><a id="faq-domain-errors-1"></a><a class="docs-heading-anchor-permalink" href="#faq-domain-errors" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Certain operations make mathematical sense but result in errors:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特定の操作は数学的には意味がありますが、エラーを引き起こします：</span></p><pre><code class="language-julia-repl hljs">julia&gt; sqrt(-2.0)
ERROR: DomainError with -2.0:
sqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">This behavior is an inconvenient consequence of the requirement for type-stability. In the case of <a href="../../base/math/index.html#Base.sqrt-Tuple{Number}"><code>sqrt</code></a>, most users want <code>sqrt(2.0)</code> to give a real number, and would be unhappy if it produced the complex number <code>1.4142135623730951 + 0.0im</code>. One could write the <a href="../../base/math/index.html#Base.sqrt-Tuple{Number}"><code>sqrt</code></a> function to switch to a complex-valued output only when passed a negative number (which is what <a href="../../base/math/index.html#Base.sqrt-Tuple{Number}"><code>sqrt</code></a> does in some other languages), but then the result would not be <a href="#man-type-stability">type-stable</a> and the <a href="../../base/math/index.html#Base.sqrt-Tuple{Number}"><code>sqrt</code></a> function would have poor performance.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この動作は、型の安定性の要件による不便な結果です。<a href="../../base/math/index.html#Base.sqrt-Tuple{Number}"><code>sqrt</code></a>の場合、ほとんどのユーザーは<code>sqrt(2.0)</code>が実数を返すことを望んでおり、複素数<code>1.4142135623730951 + 0.0im</code>を返すと不満に思うでしょう。<a href="../../base/math/index.html#Base.sqrt-Tuple{Number}"><code>sqrt</code></a>関数を負の数が渡されたときのみ複素数の出力に切り替えるように書くこともできます（これは他の言語での<a href="../../base/math/index.html#Base.sqrt-Tuple{Number}"><code>sqrt</code></a>の動作です）が、その場合、結果は<a href="#man-type-stability">型が安定していない</a>ことになり、<a href="../../base/math/index.html#Base.sqrt-Tuple{Number}"><code>sqrt</code></a>関数のパフォーマンスが低下します。</span></p><p data-translated="true"><span class="original-text">In these and other cases, you can get the result you want by choosing an <em>input type</em> that conveys your willingness to accept an <em>output type</em> in which the result can be represented:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらおよび他のケースでは、結果を表現できる<em>出力タイプ</em>を受け入れる意向を伝える<em>入力タイプ</em>を選択することで、望む結果を得ることができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; sqrt(-2.0+0im)
0.0 + 1.4142135623730951im</code></pre><h3 id="How-can-I-constrain-or-compute-type-parameters?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#How-can-I-constrain-or-compute-type-parameters?">How can I constrain or compute type parameters?</a><a id="How-can-I-constrain-or-compute-type-parameters?-1"></a><a class="docs-heading-anchor-permalink" href="#How-can-I-constrain-or-compute-type-parameters?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#How-can-I-constrain-or-compute-type-parameters?">型パラメータを制約または計算するにはどうすればよいですか？</a><a id="How-can-I-constrain-or-compute-type-parameters?-1"></a><a class="docs-heading-anchor-permalink" href="#How-can-I-constrain-or-compute-type-parameters?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The parameters of a <a href="../types/index.html#Parametric-Types">parametric type</a> can hold either types or bits values, and the type itself chooses how it makes use of these parameters. For example, <code>Array{Float64, 2}</code> is parameterized by the type <code>Float64</code> to express its element type and the integer value <code>2</code> to express its number of dimensions. When defining your own parametric type, you can use subtype constraints to declare that a certain parameter must be a subtype (<a href="../../base/base/#Core.:&lt;:#Core.:&lt;:"><code>&lt;:</code></a>) of some abstract type or a previous type parameter. There is not, however, a dedicated syntax to declare that a parameter must be a <em>value</em> of a given type — that is, you cannot directly declare that a dimensionality-like parameter <a href="../../base/base/index.html#Core.isa"><code>isa</code></a> <code>Int</code> within the <code>struct</code> definition, for example. Similarly, you cannot do computations (including simple things like addition or subtraction) on type parameters. Instead, these sorts of constraints and relationships may be expressed through additional type parameters that are computed and enforced within the type's <a href="../constructors/index.html#man-constructors">constructors</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../types/index.html#Parametric-Types">パラメトリック型</a>のパラメータは、型またはビット値を保持でき、型自体がこれらのパラメータの使用方法を選択します。たとえば、<code>Array{Float64, 2}</code>は、要素型を表すために型<code>Float64</code>でパラメータ化され、次元数を表すために整数値<code>2</code>でパラメータ化されています。独自のパラメトリック型を定義する際には、特定のパラメータがある抽象型または以前の型パラメータのサブタイプ（<a href="../../base/base/#Core.:&lt;:#Core.:&lt;:"><code>&lt;:</code></a>）であることを宣言するためにサブタイプ制約を使用できます。ただし、特定の型の<em>値</em>である必要があることを宣言するための専用の構文はありません。つまり、たとえば<code>struct</code>定義内で次元のようなパラメータが<code>isa</code> <code>Int</code>であると直接宣言することはできません。同様に、型パラメータに対して計算（加算や減算などの単純なものを含む）を行うこともできません。代わりに、これらの制約や関係は、型の<a href="../constructors/index.html#man-constructors">コンストラクタ</a>内で計算され、強制される追加の型パラメータを通じて表現される場合があります。</span></p><p data-translated="true"><span class="original-text">As an example, consider</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例として、</span></p><pre><code class="language-julia hljs">struct ConstrainedType{T,N,N+1} # NOTE: INVALID SYNTAX
    A::Array{T,N}
    B::Array{T,N+1}
end</code></pre><p data-translated="true"><span class="original-text">where the user would like to enforce that the third type parameter is always the second plus one. This can be implemented with an explicit type parameter that is checked by an <a href="../constructors/index.html#man-inner-constructor-methods">inner constructor method</a> (where it can be combined with other checks):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ユーザーが第三の型パラメータが常に第二の型パラメータに1を加えたものであることを強制したい場合を考えます。これは、<a href="../constructors/index.html#man-inner-constructor-methods">内部コンストラクタメソッド</a>によってチェックされる明示的な型パラメータを使用して実装できます（他のチェックと組み合わせることができます）：</span></p><pre><code class="language-julia hljs">struct ConstrainedType{T,N,M}
    A::Array{T,N}
    B::Array{T,M}
    function ConstrainedType(A::Array{T,N}, B::Array{T,M}) where {T,N,M}
        N + 1 == M || throw(ArgumentError("second argument should have one more axis" ))
        new{T,N,M}(A, B)
    end
end</code></pre><p data-translated="true"><span class="original-text">This check is usually <em>costless</em>, as the compiler can elide the check for valid concrete types. If the second argument is also computed, it may be advantageous to provide an <a href="../constructors/index.html#man-outer-constructor-methods">outer constructor method</a> that performs this calculation:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このチェックは通常<em>コストがかからない</em>ものであり、コンパイラは有効な具体的型のチェックを省略できます。第二の引数も計算される場合、計算を行う<a href="../constructors/index.html#man-outer-constructor-methods">外部コンストラクタメソッド</a>を提供することが有利な場合があります：</span></p><pre><code class="language-julia hljs">ConstrainedType(A) = ConstrainedType(A, compute_B(A))</code></pre><h3 id="faq-integer-arithmetic" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#faq-integer-arithmetic">Why does Julia use native machine integer arithmetic?</a><a id="faq-integer-arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#faq-integer-arithmetic" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#faq-integer-arithmetic">なぜJuliaはネイティブのマシン整数演算を使用するのですか？</a><a id="faq-integer-arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#faq-integer-arithmetic" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Julia uses machine arithmetic for integer computations. This means that the range of <code>Int</code> values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは整数計算にマシン演算を使用します。これは、<code>Int</code>値の範囲が制限され、両端でラップアラウンドすることを意味し、整数の加算、減算、乗算がオーバーフローまたはアンダーフローする可能性があり、最初は不安を感じる結果をもたらすことがあります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = typemax(Int)
9223372036854775807

julia&gt; y = x+1
-9223372036854775808

julia&gt; z = -y
-9223372036854775808

julia&gt; 2*z
0</code></pre><p data-translated="true"><span class="original-text">Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">明らかに、これは数学的整数の動作とは大きく異なり、高水準プログラミング言語がこれをユーザーに露出させるのは理想的ではないと思うかもしれません。しかし、効率と透明性が重要な数値作業においては、代替手段はさらに悪化します。</span></p><p data-translated="true"><span class="original-text">One alternative to consider would be to check each integer operation for overflow and promote results to bigger integer types such as <a href="../../base/numbers/index.html#Core.Int128"><code>Int128</code></a> or <a href="../../base/numbers/index.html#Base.GMP.BigInt"><code>BigInt</code></a> in the case of overflow. Unfortunately, this introduces major overhead on every integer operation (think incrementing a loop counter) – it requires emitting code to perform run-time overflow checks after arithmetic instructions and branches to handle potential overflows. Worse still, this would cause every computation involving integers to be type-unstable. As we mentioned above, <a href="#man-type-stability">type-stability is crucial</a> for effective generation of efficient code. If you can't count on the results of integer operations being integers, it's impossible to generate fast, simple code the way C and Fortran compilers do.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">考慮すべき代替案の一つは、各整数演算をオーバーフローのチェックを行い、オーバーフローが発生した場合には結果を<a href="../../base/numbers/index.html#Core.Int128"><code>Int128</code></a>や<a href="../../base/numbers/index.html#Base.GMP.BigInt"><code>BigInt</code></a>のようなより大きな整数型に昇格させることです。残念ながら、これはすべての整数演算に大きなオーバーヘッドをもたらします（ループカウンタのインクリメントを考えてみてください） – 算術命令の後に実行時オーバーフローのチェックを行うためのコードを生成し、潜在的なオーバーフローを処理するための分岐が必要になります。さらに悪いことに、これにより整数を含むすべての計算が型不安定になります。上記で述べたように、<a href="#man-type-stability">型の安定性は重要です</a> 効率的なコード生成のために。整数演算の結果が整数であることを信頼できない場合、CやFortranコンパイラのように高速でシンプルなコードを生成することは不可能です。</span></p><p data-translated="true"><span class="original-text">A variation on this approach, which avoids the appearance of type instability is to merge the <code>Int</code> and <a href="../../base/numbers/index.html#Base.GMP.BigInt"><code>BigInt</code></a> types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach <em>can</em> be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots – large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps – situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このアプローチの変種として、型の不安定性の外見を避けるために、<code>Int</code>と<a href="../../base/numbers/index.html#Base.GMP.BigInt"><code>BigInt</code></a>型を単一のハイブリッド整数型に統合し、結果がマシン整数のサイズに収まらなくなったときに内部的に表現を変更する方法があります。この方法は、一見するとJuliaコードのレベルで型の不安定性を回避するように見えますが、実際にはこのハイブリッド整数型を実装するCコードに同じ困難を押し付けることで問題を隠しているだけです。このアプローチは<em>機能させることができ</em>、多くの場合かなり高速にすることも可能ですが、いくつかの欠点があります。一つの問題は、整数と整数の配列のメモリ内表現がC、Fortran、その他のネイティブマシン整数を持つ言語で使用される自然な表現と一致しなくなることです。したがって、これらの言語と相互運用するためには、最終的にはネイティブ整数型を導入する必要があります。無制限の整数表現は固定ビット数を持つことができず、したがって固定サイズのスロットを持つ配列にインラインで格納することはできません – 大きな整数値は常に別のヒープ割り当てストレージを必要とします。そしてもちろん、どれほど巧妙なハイブリッド整数実装を使用しても、常にパフォーマンスの罠があります – パフォーマンスが予期せず低下する状況です。複雑な表現、CやFortranとの相互運用性の欠如、追加のヒープストレージなしで整数配列を表現できないこと、予測不可能なパフォーマンス特性は、最も巧妙なハイブリッド整数実装を高性能な数値作業にとって不適切な選択にします。</span></p><p data-translated="true"><span class="original-text">An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab™ does:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ハイブリッド整数を使用する代替案やBigIntsに昇格させる代わりに、飽和整数算術を使用することがあります。ここでは、最大の整数値に加算しても変更されず、最小の整数値から減算しても同様です。これはまさにMatlab™が行っていることです：</span></p><pre><code class="nohighlight hljs">&gt;&gt; int64(9223372036854775807)

ans =

  9223372036854775807

&gt;&gt; int64(9223372036854775807) + 1

ans =

  9223372036854775807

&gt;&gt; int64(-9223372036854775808)

ans =

 -9223372036854775808

&gt;&gt; int64(-9223372036854775808) - 1

ans =

 -9223372036854775808</code></pre><p data-translated="true"><span class="original-text">At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with <a href="../../base/base/index.html#Base.typemin"><code>typemin(Int)</code></a> or <a href="../../base/base/index.html#Base.typemax"><code>typemax(Int)</code></a> as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse – saturating integer arithmetic isn't associative. Consider this Matlab computation:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一見すると、9223372036854775807は9223372036854775808に非常に近く、-9223372036854775808よりも整数は依然としてCやFortranと互換性のある自然な方法で固定サイズで表現されているため、合理的に思えます。しかし、飽和整数算術は深刻な問題を抱えています。最初の、最も明白な問題は、これはマシン整数算術の動作方法ではないため、飽和演算を実装するには、各マシン整数演算の後にアンダーフローやオーバーフローをチェックし、結果を<a href="../../base/base/index.html#Base.typemin"><code>typemin(Int)</code></a>または<a href="../../base/base/index.html#Base.typemax"><code>typemax(Int)</code></a>に適切に置き換えるための命令を発行する必要があることです。これだけで、各整数演算が単一の高速命令から半ダースの命令に拡張され、分岐を含む可能性があります。痛いですが、さらに悪化します – 飽和整数算術は結合的ではありません。このMatlabの計算を考えてみてください：</span></p><pre><code class="nohighlight hljs">&gt;&gt; n = int64(2)^62
4611686018427387904

&gt;&gt; n + (n - 1)
9223372036854775807

&gt;&gt; (n + n) - 1
9223372036854775806</code></pre><p data-translated="true"><span class="original-text">This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow <em>is</em> associative. Consider finding the midpoint between integer values <code>lo</code> and <code>hi</code> in Julia using the expression <code>(lo + hi) &gt;&gt;&gt; 1</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これにより、多くの基本的な整数アルゴリズムを書くのが難しくなります。なぜなら、多くの一般的な手法は、オーバーフローを伴うマシン加算が<em>結合的である</em>という事実に依存しているからです。Juliaで整数値<code>lo</code>と<code>hi</code>の間の中点を見つけることを考えてみましょう。式<code>(lo + hi) &gt;&gt;&gt; 1</code>を使用します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; n = 2^62
4611686018427387904

julia&gt; (n + 2n) &gt;&gt;&gt; 1
6917529027641081856</code></pre><p data-translated="true"><span class="original-text">See? No problem. That's the correct midpoint between 2^62 and 2^63, despite the fact that <code>n + 2n</code> is -4611686018427387904. Now try it in Matlab:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">見えますか？問題ありません。これは2^62と2^63の間の正しい中点です。<code>n + 2n</code>が-4611686018427387904であるにもかかわらず。では、Matlabで試してみてください：</span></p><pre><code class="nohighlight hljs">&gt;&gt; (n + 2*n)/2

ans =

  4611686018427387904</code></pre><p data-translated="true"><span class="original-text">Oops. Adding a <code>&gt;&gt;&gt;</code> operator to Matlab wouldn't help, because saturation that occurs when adding <code>n</code> and <code>2n</code> has already destroyed the information necessary to compute the correct midpoint.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">おっと。Matlabに<code>&gt;&gt;&gt;</code>演算子を追加しても役に立ちません。なぜなら、<code>n</code>と<code>2n</code>を加算する際に発生する飽和が、正しい中点を計算するために必要な情報をすでに破壊してしまっているからです。</span></p><p data-translated="true"><span class="original-text">Not only is lack of associativity unfortunate for programmers who cannot rely it for techniques like this, but it also defeats almost anything compilers might want to do to optimize integer arithmetic. For example, since Julia integers use normal machine integer arithmetic, LLVM is free to aggressively optimize simple little functions like <code>f(k) = 5k-1</code>. The machine code for this function is just this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">結合性が欠如していることは、このような技術に依存できないプログラマーにとって不幸であるだけでなく、整数算術を最適化するためにコンパイラが行いたいことのほとんどを無効にします。たとえば、Juliaの整数は通常のマシン整数算術を使用しているため、LLVMは<code>f(k) = 5k-1</code>のようなシンプルな小さな関数を積極的に最適化することができます。この関数のマシンコードは次のようになります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; code_native(f, Tuple{Int})
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 1
  leaq  -1(%rdi,%rdi,4), %rax
  popq  %rbp
  retq
  nopl  (%rax,%rax)</code></pre><p data-translated="true"><span class="original-text">The actual body of the function is a single <code>leaq</code> instruction, which computes the integer multiply and add at once. This is even more beneficial when <code>f</code> gets inlined into another function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数の実際の本体は単一の<code>leaq</code>命令であり、整数の乗算と加算を一度に計算します。これは、<code>f</code>が別の関数にインライン化されるとさらに有益です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function g(k, n)
           for i = 1:n
               k = f(k)
           end
           return k
       end
g (generic function with 1 methods)

julia&gt; code_native(g, Tuple{Int,Int})
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 2
  testq %rsi, %rsi
  jle L26
  nopl  (%rax)
Source line: 3
L16:
  leaq  -1(%rdi,%rdi,4), %rdi
Source line: 2
  decq  %rsi
  jne L16
Source line: 5
L26:
  movq  %rdi, %rax
  popq  %rbp
  retq
  nop</code></pre><p data-translated="true"><span class="original-text">Since the call to <code>f</code> gets inlined, the loop body ends up being just a single <code>leaq</code> instruction. Next, consider what happens if we make the number of loop iterations fixed:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>f</code>への呼び出しがインライン化されるため、ループ本体は単一の<code>leaq</code>命令だけになります。次に、ループの反復回数を固定にした場合に何が起こるかを考えてみましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function g(k)
           for i = 1:10
               k = f(k)
           end
           return k
       end
g (generic function with 2 methods)

julia&gt; code_native(g,(Int,))
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 3
  imulq $9765625, %rdi, %rax    # imm = 0x9502F9
  addq  $-2441406, %rax         # imm = 0xFFDABF42
Source line: 5
  popq  %rbp
  retq
  nopw  %cs:(%rax,%rax)</code></pre><p data-translated="true"><span class="original-text">Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition – neither of which is true of saturating arithmetic – it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コンパイラは整数の加算と乗算が結合的であり、乗算が加算に対して分配的であることを知っているため（飽和算術ではどちらも真ではありません）、ループ全体を単に乗算と加算に最適化できます。飽和算術は、この種の最適化を完全に無効にします。なぜなら、結合性と分配性は各ループの反復で失敗する可能性があり、失敗が発生する反復によって異なる結果を引き起こすからです。コンパイラはループを展開できますが、複数の操作をより少ない同等の操作に代数的に削減することはできません。</span></p><p data-translated="true"><span class="original-text">The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this <a href="https://danluu.com/integer-overflow/">blog post</a>, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">整数算術が静かにオーバーフローするのを避ける最も合理的な代替手段は、すべての場所でチェックされた算術を行い、加算、減算、乗算がオーバーフローしたときにエラーを発生させ、値が正しくない値を生成することです。この<a href="https://danluu.com/integer-overflow/">ブログ記事</a>で、Dan Luuはこれを分析し、このアプローチが理論的にはわずかなコストであるべきであるのに対し、コンパイラ（LLVMおよびGCC）が追加されたオーバーフローチェックの周りで優雅に最適化しないために、実際にはかなりのコストがかかることを発見しました。将来的にこれが改善されれば、Juliaでチェックされた整数算術をデフォルトにすることを検討できますが、今のところはオーバーフローの可能性と共に生きていかなければなりません。</span></p><p data-translated="true"><span class="original-text">In the meantime, overflow-safe integer operations can be achieved through the use of external libraries such as <a href="https://github.com/JeffreySarnoff/SaferIntegers.jl">SaferIntegers.jl</a>. Note that, as stated previously, the use of these libraries significantly increases the execution time of code using the checked integer types. However, for limited usage, this is far less of an issue than if it were used for all integer operations. You can follow the status of the discussion <a href="https://github.com/JuliaLang/julia/issues/855">here</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">その間、オーバーフロー安全な整数操作は、<a href="https://github.com/JeffreySarnoff/SaferIntegers.jl">SaferIntegers.jl</a>のような外部ライブラリを使用することで実現できます。以前に述べたように、これらのライブラリを使用すると、チェックされた整数型を使用するコードの実行時間が大幅に増加することに注意してください。しかし、限られた使用の場合、すべての整数操作に使用する場合よりもはるかに問題は少ないです。議論の状況を<a href="https://github.com/JuliaLang/julia/issues/855">こちら</a>でフォローできます。</span></p><h3 id="What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?">What are the possible causes of an <code>UndefVarError</code> during remote execution?</a><a id="What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?-1"></a><a class="docs-heading-anchor-permalink" href="#What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?">リモート実行中の<code>UndefVarError</code>の可能性のある原因は何ですか？</a><a id="What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?-1"></a><a class="docs-heading-anchor-permalink" href="#What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">As the error states, an immediate cause of an <code>UndefVarError</code> on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">エラーが示すように、リモートノードでの<code>UndefVarError</code>の直接的な原因は、その名前によるバインディングが存在しないことです。いくつかの可能性のある原因を探ってみましょう。</span></p><pre><code class="language-julia-repl hljs">julia&gt; module Foo
           foo() = remotecall_fetch(x-&gt;x, 2, "Hello")
       end

julia&gt; Foo.foo()
ERROR: On worker 2:
UndefVarError: `Foo` not defined in `Main`
Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">The closure <code>x-&gt;x</code> carries a reference to <code>Foo</code>, and since <code>Foo</code> is unavailable on node 2, an <code>UndefVarError</code> is thrown.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">クロージャ<code>x-&gt;x</code>は<code>Foo</code>への参照を持っており、<code>Foo</code>がノード2で利用できないため、<code>UndefVarError</code>がスローされます。</span></p><p data-translated="true"><span class="original-text">Globals under modules other than <code>Main</code> are not serialized by value to the remote node. Only a reference is sent. Functions which create global bindings (except under <code>Main</code>) may cause an <code>UndefVarError</code> to be thrown later.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Main</code>以外のモジュールのグローバル変数は、値としてリモートノードにシリアライズされません。参照のみが送信されます。グローバルバインディングを作成する関数（<code>Main</code>以外）は、後で<code>UndefVarError</code>をスローする原因となる可能性があります。</span></p><pre><code class="language-julia-repl hljs">julia&gt; @everywhere module Foo
           function foo()
               global gvar = "Hello"
               remotecall_fetch(()-&gt;gvar, 2)
           end
       end

julia&gt; Foo.foo()
ERROR: On worker 2:
UndefVarError: `gvar` not defined in `Main.Foo`
Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">In the above example, <code>@everywhere module Foo</code> defined <code>Foo</code> on all nodes. However the call to <code>Foo.foo()</code> created a new global binding <code>gvar</code> on the local node, but this was not found on node 2 resulting in an <code>UndefVarError</code> error.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記の例では、<code>@everywhere module Foo</code>がすべてのノードで<code>Foo</code>を定義しました。しかし、<code>Foo.foo()</code>の呼び出しはローカルノードに新しいグローバルバインディング<code>gvar</code>を作成しましたが、これはノード2では見つからず、<code>UndefVarError</code>エラーが発生しました。</span></p><p data-translated="true"><span class="original-text">Note that this does not apply to globals created under module <code>Main</code>. Globals under module <code>Main</code> are serialized and new bindings created under <code>Main</code> on the remote node.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、<code>Main</code>モジュールの下で作成されたグローバル変数には適用されません。<code>Main</code>モジュールの下のグローバル変数はシリアライズされ、リモートノードで<code>Main</code>の下に新しいバインディングが作成されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; gvar_self = "Node1"
"Node1"

julia&gt; remotecall_fetch(()-&gt;gvar_self, 2)
"Node1"

julia&gt; remotecall_fetch(varinfo, 2)
name          size summary
––––––––– –––––––– –––––––
Base               Module
Core               Module
Main               Module
gvar_self 13 bytes String</code></pre><p data-translated="true"><span class="original-text">This does not apply to <code>function</code> or <code>struct</code> declarations. However, anonymous functions bound to global variables are serialized as can be seen below.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>function</code>や<code>struct</code>の宣言には適用されません。ただし、グローバル変数にバインドされた匿名関数は、以下のようにシリアライズされます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; bar() = 1
bar (generic function with 1 method)

julia&gt; remotecall_fetch(bar, 2)
ERROR: On worker 2:
UndefVarError: `#bar` not defined in `Main`
[...]

julia&gt; anon_bar  = ()-&gt;1
(::#21) (generic function with 1 method)

julia&gt; remotecall_fetch(anon_bar, 2)
1</code></pre><h2 id="Troubleshooting-&quot;method-not-matched&quot;:-parametric-type-invariance-and-MethodErrors" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Troubleshooting-&quot;method-not-matched&quot;:-parametric-type-invariance-and-MethodErrors">Troubleshooting "method not matched": parametric type invariance and <code>MethodError</code>s</a><a id="Troubleshooting-&quot;method-not-matched&quot;:-parametric-type-invariance-and-MethodErrors-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting-&quot;method-not-matched&quot;:-parametric-type-invariance-and-MethodErrors" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Troubleshooting-&quot;method-not-matched&quot;:-parametric-type-invariance-and-MethodErrors">"method not matched"のトラブルシューティング: パラメトリック型の不変性と<code>MethodError</code>について</a><a id="Troubleshooting-&quot;method-not-matched&quot;:-parametric-type-invariance-and-MethodErrors-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting-&quot;method-not-matched&quot;:-parametric-type-invariance-and-MethodErrors" title="Permalink"></a></span></h2><h3 id="Why-doesn't-it-work-to-declare-foo(bar::Vector{Real})-42-and-then-call-foo([1])?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Why-doesn't-it-work-to-declare-foo(bar::Vector{Real})-42-and-then-call-foo([1])?">Why doesn't it work to declare <code>foo(bar::Vector{Real}) = 42</code> and then call <code>foo([1])</code>?</a><a id="Why-doesn't-it-work-to-declare-foo(bar::Vector{Real})-42-and-then-call-foo([1])?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-doesn't-it-work-to-declare-foo(bar::Vector{Real})-42-and-then-call-foo([1])?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Why-doesn't-it-work-to-declare-foo(bar::Vector{Real})-42-and-then-call-foo([1])?">なぜ<code>foo(bar::Vector{Real}) = 42</code>と宣言してから<code>foo([1])</code>を呼び出すと動かないのか?</a><a id="Why-doesn't-it-work-to-declare-foo(bar::Vector{Real})-42-and-then-call-foo([1])?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-doesn't-it-work-to-declare-foo(bar::Vector{Real})-42-and-then-call-foo([1])?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">As you'll see if you try this, the result is a <code>MethodError</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これを試してみると、結果は<code>MethodError</code>になります:</span></p><pre><code class="language-julia-repl hljs">julia&gt; foo(x::Vector{Real}) = 42
foo (generic function with 1 method)

julia&gt; foo([1])
ERROR: MethodError: no method matching foo(::Vector{Int64})
The function `foo` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  foo(!Matched::Vector{Real})
   @ Main none:1

Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">This is because <code>Vector{Real}</code> is not a supertype of <code>Vector{Int}</code>! You can solve this problem with something like <code>foo(bar::Vector{T}) where {T&lt;:Real}</code> (or the short form <code>foo(bar::Vector{&lt;:Real})</code> if the static parameter <code>T</code> is not needed in the body of the function). The <code>T</code> is a wild card: you first specify that it must be a subtype of Real, then specify the function takes a Vector of with elements of that type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは<code>Vector{Real}</code>が<code>Vector{Int}</code>のスーパータイプではないためです! この問題は、<code>foo(bar::Vector{T}) where {T&lt;:Real}</code>のようなもので解決できます（または、関数の本体で静的パラメータ<code>T</code>が必要ない場合は短縮形<code>foo(bar::Vector{&lt;:Real})</code>を使用できます）。<code>T</code>はワイルドカードです: まずそれがRealのサブタイプである必要があることを指定し、その後その型の要素を持つVectorを取る関数を指定します。</span></p><p data-translated="true"><span class="original-text">This same issue goes for any composite type <code>Comp</code>, not just <code>Vector</code>. If <code>Comp</code> has a parameter declared of type <code>Y</code>, then another type <code>Comp2</code> with a parameter of type <code>X&lt;:Y</code> is not a subtype of <code>Comp</code>. This is type-invariance (by contrast, Tuple is type-covariant in its parameters). See <a href="../types/index.html#man-parametric-composite-types">Parametric Composite Types</a> for more explanation of these.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この同じ問題は、<code>Vector</code>だけでなく、任意の合成型<code>Comp</code>にも当てはまります。<code>Comp</code>が型<code>Y</code>のパラメータを宣言している場合、型<code>X&lt;:Y</code>のパラメータを持つ別の型<code>Comp2</code>は<code>Comp</code>のサブタイプではありません。これは型の不変性です（対照的に、Tupleはそのパラメータに対して型共変です）。これらの詳細については<a href="../types/index.html#man-parametric-composite-types">パラメトリック合成型</a>を参照してください。</span></p><h3 id="Why-does-Julia-use-*-for-string-concatenation?-Why-not-or-something-else?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Why-does-Julia-use-*-for-string-concatenation?-Why-not-or-something-else?">Why does Julia use <code>*</code> for string concatenation? Why not <code>+</code> or something else?</a><a id="Why-does-Julia-use-*-for-string-concatenation?-Why-not-or-something-else?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-does-Julia-use-*-for-string-concatenation?-Why-not-or-something-else?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Why-does-Julia-use-*-for-string-concatenation?-Why-not-or-something-else?">なぜJuliaは文字列の連結に<code>*</code>を使用するのか? なぜ<code>+</code>や他の何かではないのか?</a><a id="Why-does-Julia-use-*-for-string-concatenation?-Why-not-or-something-else?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-does-Julia-use-*-for-string-concatenation?-Why-not-or-something-else?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The <a href="../strings/index.html#man-concatenation">main argument</a> against <code>+</code> is that string concatenation is not commutative, while <code>+</code> is generally used as a commutative operator. While the Julia community recognizes that other languages use different operators and <code>*</code> may be unfamiliar for some users, it communicates certain algebraic properties.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../strings/index.html#man-concatenation">主な理由</a>は、文字列の連結は可換ではないのに対し、<code>+</code>は一般的に可換演算子として使用されるからです。Juliaコミュニティは他の言語が異なる演算子を使用していることを認識しており、<code>*</code>が一部のユーザーには馴染みがないかもしれませんが、特定の代数的性質を伝えています。</span></p><p data-translated="true"><span class="original-text">Note that you can also use <code>string(...)</code> to concatenate strings (and other values converted to strings); similarly, <code>repeat</code> can be used instead of <code>^</code> to repeat strings. The <a href="../strings/index.html#string-interpolation">interpolation syntax</a> is also useful for constructing strings.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列を連結するために<code>string(...)</code>を使用することもできることに注意してください（および他の値を文字列に変換して連結することもできます）。同様に、文字列を繰り返すために<code>^</code>の代わりに<code>repeat</code>を使用できます。<a href="../strings/index.html#string-interpolation">補間構文</a>も文字列を構築するのに便利です。</span></p><h2 id="Packages-and-Modules" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Packages-and-Modules">Packages and Modules</a><a id="Packages-and-Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Packages-and-Modules" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Packages-and-Modules">パッケージとモジュール</a><a id="Packages-and-Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Packages-and-Modules" title="Permalink"></a></span></h2><h3 id="What-is-the-difference-between-&quot;using&quot;-and-&quot;import&quot;?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#What-is-the-difference-between-&quot;using&quot;-and-&quot;import&quot;?">What is the difference between "using" and "import"?</a><a id="What-is-the-difference-between-&quot;using&quot;-and-&quot;import&quot;?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-the-difference-between-&quot;using&quot;-and-&quot;import&quot;?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#What-is-the-difference-between-&quot;using&quot;-and-&quot;import&quot;?">"using"と"import"の違いは何ですか?</a><a id="What-is-the-difference-between-&quot;using&quot;-and-&quot;import&quot;?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-the-difference-between-&quot;using&quot;-and-&quot;import&quot;?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">There are several differences between <code>using</code> and <code>import</code> (see the <a href="../modules/index.html#modules">Modules section</a>), but there is an important difference that may not seem intuitive at first glance, and on the surface (i.e. syntax-wise) it may seem very minor. When loading modules with <code>using</code>, you need to say <code>function Foo.bar(...</code> to extend module <code>Foo</code>'s function <code>bar</code> with a new method, but with <code>import Foo.bar</code>, you only need to say <code>function bar(...</code> and it automatically extends module <code>Foo</code>'s function <code>bar</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>using</code>と<code>import</code>の間にはいくつかの違いがあります（<a href="../modules/index.html#modules">モジュールセクション</a>を参照）。しかし、最初は直感的でないかもしれない重要な違いがあります。表面的には（つまり、構文的には）非常に小さな違いに見えるかもしれません。<code>using</code>を使ってモジュールを読み込むときは、モジュール<code>Foo</code>の関数<code>bar</code>を新しいメソッドで拡張するために<code>function Foo.bar(...</code>と言う必要がありますが、<code>import Foo.bar</code>を使うと、<code>function bar(...</code>と言うだけで、自動的にモジュール<code>Foo</code>の関数<code>bar</code>を拡張します。</span></p><p data-translated="true"><span class="original-text">The reason this is important enough to have been given separate syntax is that you don't want to accidentally extend a function that you didn't know existed, because that could easily cause a bug. This is most likely to happen with a method that takes a common type like a string or integer, because both you and the other module could define a method to handle such a common type. If you use <code>import</code>, then you'll replace the other module's implementation of <code>bar(s::AbstractString)</code> with your new implementation, which could easily do something completely different (and break all/many future usages of the other functions in module Foo that depend on calling bar).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これが別の構文を持つほど重要な理由は、存在を知らなかった関数を誤って拡張したくないからです。そうすると、バグを引き起こす可能性があります。これは、文字列や整数のような一般的な型を取るメソッドで最も起こりやすいです。なぜなら、あなたと他のモジュールの両方がそのような一般的な型を処理するメソッドを定義する可能性があるからです。<code>import</code>を使用すると、他のモジュールの<code>bar(s::AbstractString)</code>の実装をあなたの新しい実装で置き換えてしまい、全く異なる動作をする可能性があり（そして、<code>bar</code>を呼び出すことに依存するモジュールFoo内の他の関数のすべて/多くの将来の使用を壊す可能性があります）。</span></p><h2 id="Nothingness-and-missing-values" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Nothingness-and-missing-values">Nothingness and missing values</a><a id="Nothingness-and-missing-values-1"></a><a class="docs-heading-anchor-permalink" href="#Nothingness-and-missing-values" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Nothingness-and-missing-values">無と欠損値</a><a id="Nothingness-and-missing-values-1"></a><a class="docs-heading-anchor-permalink" href="#Nothingness-and-missing-values" title="Permalink"></a></span></h2><h3 id="faq-nothing" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#faq-nothing">How does "null", "nothingness" or "missingness" work in Julia?</a><a id="faq-nothing-1"></a><a class="docs-heading-anchor-permalink" href="#faq-nothing" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#faq-nothing">"null"、"無"または"欠損"はJuliaでどのように機能しますか？</a><a id="faq-nothing-1"></a><a class="docs-heading-anchor-permalink" href="#faq-nothing" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Unlike many languages (for example, C and Java), Julia objects cannot be "null" by default. When a reference (variable, object field, or array element) is uninitialized, accessing it will immediately throw an error. This situation can be detected using the <a href="../../base/base/index.html#Core.isdefined"><code>isdefined</code></a> or <a href="../../base/arrays/index.html#Base.isassigned"><code>isassigned</code></a> functions.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">多くの言語（例えば、CやJava）とは異なり、Juliaのオブジェクトはデフォルトで"null"にはなりません。参照（変数、オブジェクトフィールド、または配列要素）が初期化されていない場合、それにアクセスするとすぐにエラーが発生します。この状況は、<a href="../../base/base/index.html#Core.isdefined"><code>isdefined</code></a>または<a href="../../base/arrays/index.html#Base.isassigned"><code>isassigned</code></a>関数を使用して検出できます。</span></p><p data-translated="true"><span class="original-text">Some functions are used only for their side effects, and do not need to return a value. In these cases, the convention is to return the value <code>nothing</code>, which is just a singleton object of type <code>Nothing</code>. This is an ordinary type with no fields; there is nothing special about it except for this convention, and that the REPL does not print anything for it. Some language constructs that would not otherwise have a value also yield <code>nothing</code>, for example <code>if false; end</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">いくつかの関数は副作用のためだけに使用され、値を返す必要はありません。このような場合、慣例として<code>nothing</code>という値を返します。これは<code>Nothing</code>型の単一オブジェクトです。これはフィールドを持たない普通の型であり、この慣例を除いて特別なことはありません。また、REPLはそれに対して何も印刷しません。値を持たないはずの言語構造も<code>nothing</code>を生成します。例えば、<code>if false; end</code>です。</span></p><p data-translated="true"><span class="original-text">For situations where a value <code>x</code> of type <code>T</code> exists only sometimes, the <code>Union{T, Nothing}</code> type can be used for function arguments, object fields and array element types as the equivalent of <a href="https://en.wikipedia.org/wiki/Nullable_type"><code>Nullable</code>, <code>Option</code> or <code>Maybe</code></a> in other languages. If the value itself can be <code>nothing</code> (notably, when <code>T</code> is <code>Any</code>), the <code>Union{Some{T}, Nothing}</code> type is more appropriate since <code>x == nothing</code> then indicates the absence of a value, and <code>x == Some(nothing)</code> indicates the presence of a value equal to <code>nothing</code>. The <a href="../../base/base/index.html#Base.something"><code>something</code></a> function allows unwrapping <code>Some</code> objects and using a default value instead of <code>nothing</code> arguments. Note that the compiler is able to generate efficient code when working with <code>Union{T, Nothing}</code> arguments or fields.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型<code>T</code>の値<code>x</code>が時々しか存在しない状況では、関数引数、オブジェクトフィールド、および配列要素の型として<code>Union{T, Nothing}</code>型を使用できます。これは他の言語における<a href="https://en.wikipedia.org/wiki/Nullable_type"><code>Nullable</code>、<code>Option</code>または<code>Maybe</code></a>の同等物です。値自体が<code>nothing</code>である可能性がある場合（特に<code>T</code>が<code>Any</code>の場合）、<code>Union{Some{T}, Nothing}</code>型がより適切です。なぜなら、<code>x == nothing</code>は値の不在を示し、<code>x == Some(nothing)</code>は<code>nothing</code>に等しい値の存在を示すからです。<a href="../../base/base/index.html#Base.something"><code>something</code></a>関数は<code>Some</code>オブジェクトをアンラップし、<code>nothing</code>引数の代わりにデフォルト値を使用することを可能にします。コンパイラは<code>Union{T, Nothing}</code>引数やフィールドで効率的なコードを生成できることに注意してください。</span></p><p data-translated="true"><span class="original-text">To represent missing data in the statistical sense (<code>NA</code> in R or <code>NULL</code> in SQL), use the <a href="../missing/index.html#missing"><code>missing</code></a> object. See the <a href="../missing/index.html#missing"><code>Missing Values</code></a> section for more details.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">統計的な意味での欠損データを表すには（Rの<code>NA</code>やSQLの<code>NULL</code>）、<a href="../missing/index.html#missing"><code>missing</code></a>オブジェクトを使用します。詳細については、<a href="../missing/index.html#missing"><code>Missing Values</code></a>セクションを参照してください。</span></p><p data-translated="true"><span class="original-text">In some languages, the empty tuple (<code>()</code>) is considered the canonical form of nothingness. However, in julia it is best thought of as just a regular tuple that happens to contain zero values.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">いくつかの言語では、空のタプル（<code>()</code>）は無の標準形と見なされます。しかし、Juliaでは、これはゼロの値を含む通常のタプルとして考えるのが最適です。</span></p><p data-translated="true"><span class="original-text">The empty (or "bottom") type, written as <code>Union{}</code> (an empty union type), is a type with no values and no subtypes (except itself). You will generally not need to use this type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">空（または「ボトム」）型は<code>Union{}</code>（空のユニオン型）として書かれ、値もサブタイプも持たない型です（自分自身を除いて）。一般的に、この型を使用する必要はありません。</span></p><h2 id="Memory" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Memory">Memory</a><a id="Memory-1"></a><a class="docs-heading-anchor-permalink" href="#Memory" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Memory">メモリ</a><a id="Memory-1"></a><a class="docs-heading-anchor-permalink" href="#Memory" title="Permalink"></a></span></h2><h3 id="Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?">Why does <code>x += y</code> allocate memory when <code>x</code> and <code>y</code> are arrays?</a><a id="Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?">なぜ <code>x += y</code> は <code>x</code> と <code>y</code> が配列のときにメモリを割り当てるのか？</a><a id="Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">In Julia, <code>x += y</code> gets replaced during lowering by <code>x = x + y</code>. For arrays, this has the consequence that, rather than storing the result in the same location in memory as <code>x</code>, it allocates a new array to store the result. If you prefer to mutate <code>x</code>, use <code>x .+= y</code> to update each element individually.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>x += y</code> は低下処理中に <code>x = x + y</code> に置き換えられます。配列の場合、これは結果を <code>x</code> と同じメモリの位置に保存するのではなく、新しい配列を割り当てて結果を保存することを意味します。<code>x</code> を変更したい場合は、各要素を個別に更新するために <code>x .+= y</code> を使用してください。</span></p><p data-translated="true"><span class="original-text">While this behavior might surprise some, the choice is deliberate. The main reason is the presence of immutable objects within Julia, which cannot change their value once created. Indeed, a number is an immutable object; the statements <code>x = 5; x += 1</code> do not modify the meaning of <code>5</code>, they modify the value bound to <code>x</code>. For an immutable, the only way to change the value is to reassign it.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この動作に驚く人もいるかもしれませんが、選択は意図的です。主な理由は、Julia内に不変オブジェクトが存在し、一度作成されるとその値を変更できないことです。実際、数値は不変オブジェクトです。<code>x = 5; x += 1</code> という文は <code>5</code> の意味を変更するのではなく、<code>x</code> に束縛された値を変更します。不変の場合、値を変更する唯一の方法は再割り当てです。</span></p><p data-translated="true"><span class="original-text">To amplify a bit further, consider the following function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さらに詳しく説明するために、次の関数を考えてみましょう：</span></p><pre><code class="language-julia hljs">function power_by_squaring(x, n::Int)
    ispow2(n) || error("This implementation only works for powers of 2")
    while n &gt;= 2
        x *= x
        n &gt;&gt;= 1
    end
    x
end</code></pre><p data-translated="true"><span class="original-text">After a call like <code>x = 5; y = power_by_squaring(x, 4)</code>, you would get the expected result: <code>x == 5 &amp;&amp; y == 625</code>.  However, now suppose that <code>*=</code>, when used with matrices, instead mutated the left hand side.  There would be two problems:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>x = 5; y = power_by_squaring(x, 4)</code> のような呼び出しの後、期待される結果が得られます：<code>x == 5 &amp;&amp; y == 625</code>。しかし、<code>*=</code> が行列と共に使用されるときに左側を変更する場合を考えてみましょう。2つの問題があります：</span></p><ul><li data-translated="true"><span class="original-text">For general square matrices, <code>A = A*B</code> cannot be implemented without temporary storage: <code>A[1,1]</code> gets computed and stored on the left hand side before you're done using it on the right hand side.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般的な正方行列の場合、<code>A = A*B</code> は一時的なストレージなしには実装できません：<code>A[1,1]</code> は右側で使用する前に左側に計算されて保存されます。</span></li><li data-translated="true"><span class="original-text">Suppose you were willing to allocate a temporary for the computation (which would eliminate most of the point of making <code>*=</code> work in-place); if you took advantage of the mutability of <code>x</code>, then this function would behave differently for mutable vs. immutable inputs. In particular, for immutable <code>x</code>, after the call you'd have (in general) <code>y != x</code>, but for mutable <code>x</code> you'd have <code>y == x</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">計算のために一時的なストレージを割り当てることを厭わないと仮定すると（これは <code>*=</code> をインプレースで機能させることのほとんどの目的を排除します）、<code>x</code> の可変性を利用すると、この関数は可変入力と不変入力で異なる動作をします。特に、不変の <code>x</code> の場合、呼び出し後には（一般的に） <code>y != x</code> になりますが、可変の <code>x</code> の場合は <code>y == x</code> になります。</span></li></ul><p data-translated="true"><span class="original-text">Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using broadcasting or explicit loops), operators like <code>+=</code> and <code>*=</code> work by rebinding new values.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">汎用プログラミングをサポートすることが、他の手段（例えば、ブロードキャスティングや明示的なループを使用すること）によって達成できる潜在的なパフォーマンス最適化よりも重要であると見なされているため、<code>+=</code> や <code>*=</code> のような演算子は新しい値を再束縛することによって機能します。</span></p><h2 id="faq-async-io" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#faq-async-io">Asynchronous IO and concurrent synchronous writes</a><a id="faq-async-io-1"></a><a class="docs-heading-anchor-permalink" href="#faq-async-io" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#faq-async-io">非同期IOと同時同期書き込み</a><a id="faq-async-io-1"></a><a class="docs-heading-anchor-permalink" href="#faq-async-io" title="Permalink"></a></span></h2><h3 id="Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?">Why do concurrent writes to the same stream result in inter-mixed output?</a><a id="Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?">同じストリームへの同時書き込みが混在した出力をもたらすのはなぜですか？</a><a id="Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">While the streaming I/O API is synchronous, the underlying implementation is fully asynchronous.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ストリーミングI/O APIは同期的ですが、基盤となる実装は完全に非同期です。</span></p><p data-translated="true"><span class="original-text">Consider the printed output from the following:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次の出力を考えてみてください：</span></p><pre><code class="nohighlight hljs">julia&gt; @sync for i in 1:3
           Threads.@spawn write(stdout, string(i), " Foo ", " Bar ")
       end
123 Foo  Foo  Foo  Bar  Bar  Bar</code></pre><p data-translated="true"><span class="original-text">This is happening because, while the <code>write</code> call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、<code>write</code>呼び出しが同期的である一方で、各引数の書き込みがそのI/Oの一部が完了するのを待っている間に他のタスクに譲るために発生しています。</span></p><p data-translated="true"><span class="original-text"><code>print</code> and <code>println</code> "lock" the stream during a call. Consequently changing <code>write</code> to <code>println</code> in the above example results in:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>print</code>と<code>println</code>は呼び出し中にストリームを「ロック」します。したがって、上記の例で<code>write</code>を<code>println</code>に変更すると、次のようになります：</span></p><pre><code class="nohighlight hljs">julia&gt; @sync for i in 1:3
           Threads.@spawn println(stdout, string(i), " Foo ", " Bar ")
       end
1 Foo  Bar
2 Foo  Bar
3 Foo  Bar</code></pre><p data-translated="true"><span class="original-text">You can lock your writes with a <code>ReentrantLock</code> like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のように<code>ReentrantLock</code>を使って書き込みをロックできます：</span></p><pre><code class="nohighlight hljs">julia&gt; l = ReentrantLock();

julia&gt; @sync for i in 1:3
           Threads.@spawn begin
               lock(l)
               try
                   write(stdout, string(i), " Foo ", " Bar ")
               finally
                   unlock(l)
               end
           end
       end
1 Foo  Bar 2 Foo  Bar 3 Foo  Bar</code></pre><h2 id="Arrays" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Arrays">Arrays</a><a id="Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Arrays">配列</a><a id="Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays" title="Permalink"></a></span></h2><h3 id="faq-array-0dim" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#faq-array-0dim">What are the differences between zero-dimensional arrays and scalars?</a><a id="faq-array-0dim-1"></a><a class="docs-heading-anchor-permalink" href="#faq-array-0dim" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#faq-array-0dim">ゼロ次元配列とスカラーの違いは何ですか？</a><a id="faq-array-0dim-1"></a><a class="docs-heading-anchor-permalink" href="#faq-array-0dim" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Zero-dimensional arrays are arrays of the form <code>Array{T,0}</code>. They behave similar to scalars, but there are important differences. They deserve a special mention because they are a special case which makes logical sense given the generic definition of arrays, but might be a bit unintuitive at first. The following line defines a zero-dimensional array:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ゼロ次元配列は<code>Array{T,0}</code>の形をした配列です。スカラーに似た動作をしますが、重要な違いがあります。これは、配列の一般的な定義を考慮すると論理的に意味を持つ特別なケースであるため、特別に言及する価値がありますが、最初は少し直感的でないかもしれません。次の行はゼロ次元配列を定義します：</span></p><pre><code class="nohighlight hljs">julia&gt; A = zeros()
0-dimensional Array{Float64,0}:
0.0</code></pre><p data-translated="true"><span class="original-text">In this example, <code>A</code> is a mutable container that contains one element, which can be set by <code>A[] = 1.0</code> and retrieved with <code>A[]</code>. All zero-dimensional arrays have the same size (<code>size(A) == ()</code>), and length (<code>length(A) == 1</code>). In particular, zero-dimensional arrays are not empty. If you find this unintuitive, here are some ideas that might help to understand Julia's definition.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例では、<code>A</code>は1つの要素を含む可変コンテナであり、<code>A[] = 1.0</code>で設定でき、<code>A[]</code>で取得できます。すべてのゼロ次元配列は同じサイズ（<code>size(A) == ()</code>）と長さ（<code>length(A) == 1</code>）を持ちます。特に、ゼロ次元配列は空ではありません。これが直感的でないと感じる場合は、Juliaの定義を理解するのに役立ついくつかのアイデアがあります。</span></p><ul><li data-translated="true"><span class="original-text">Zero-dimensional arrays are the "point" to vector's "line" and matrix's "plane". Just as a line has no area (but still represents a set of things), a point has no length or any dimensions at all (but still represents a thing).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ゼロ次元配列は、ベクトルの「線」や行列の「平面」に対する「点」です。線が面積を持たないのと同様に（しかし、依然として一連のものを表します）、点は長さや次元を持たない（しかし、依然として何かを表します）。</span></li><li data-translated="true"><span class="original-text">We define <code>prod(())</code> to be 1, and the total number of elements in an array is the product of the size. The size of a zero-dimensional array is <code>()</code>, and therefore its length is <code>1</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ゼロ次元配列の <code>prod(())</code> は 1 と定義され、配列の要素の総数はサイズの積です。ゼロ次元配列のサイズは <code>()</code> であり、したがってその長さは <code>1</code> です。</span></li><li data-translated="true"><span class="original-text">Zero-dimensional arrays don't natively have any dimensions into which you index – they’re just <code>A[]</code>. We can apply the same "trailing one" rule for them as for all other array dimensionalities, so you can indeed index them as <code>A[1]</code>, <code>A[1,1]</code>, etc; see <a href="../arrays/index.html#Omitted-and-extra-indices">Omitted and extra indices</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ゼロ次元配列には、インデックスを付けるための次元が本来はありません – それらは単に <code>A[]</code> です。他のすべての配列の次元に対して適用される「末尾の1」ルールを同様に適用できるため、実際に <code>A[1]</code>、<code>A[1,1]</code> などとしてインデックスを付けることができます; 詳細は <a href="../arrays/index.html#Omitted-and-extra-indices">省略されたインデックスと余分なインデックス</a> を参照してください。</span></li></ul><p data-translated="true"><span class="original-text">It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even though they are iterable and define things like <code>length</code>, <code>getindex</code>, <em>e.g.</em> <code>1[] == 1</code>). In particular, if <code>x = 0.0</code> is defined as a scalar, it is an error to attempt to change its value via <code>x[] = 1.0</code>. A scalar <code>x</code> can be converted into a zero-dimensional array containing it via <code>fill(x)</code>, and conversely, a zero-dimensional array <code>a</code> can be converted to the contained scalar via <code>a[]</code>. Another difference is that a scalar can participate in linear algebra operations such as <code>2 * rand(2,2)</code>, but the analogous operation with a zero-dimensional array <code>fill(2) * rand(2,2)</code> is an error.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">通常のスカラーとの違いを理解することも重要です。スカラーは可変のコンテナではありません（イテラブルであり、<code>length</code>、<code>getindex</code> などを定義しますが、<em>例えば</em> <code>1[] == 1</code>）。特に、<code>x = 0.0</code> がスカラーとして定義されている場合、その値を <code>x[] = 1.0</code> で変更しようとするのはエラーです。スカラー <code>x</code> は <code>fill(x)</code> を介してそれを含むゼロ次元配列に変換でき、逆にゼロ次元配列 <code>a</code> は <code>a[]</code> を介して含まれているスカラーに変換できます。もう一つの違いは、スカラーは <code>2 * rand(2,2)</code> のような線形代数演算に参加できるのに対し、ゼロ次元配列 <code>fill(2) * rand(2,2)</code> との類似の操作はエラーです。</span></p><h3 id="Why-are-my-Julia-benchmarks-for-linear-algebra-operations-different-from-other-languages?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Why-are-my-Julia-benchmarks-for-linear-algebra-operations-different-from-other-languages?">Why are my Julia benchmarks for linear algebra operations different from other languages?</a><a id="Why-are-my-Julia-benchmarks-for-linear-algebra-operations-different-from-other-languages?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-are-my-Julia-benchmarks-for-linear-algebra-operations-different-from-other-languages?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Why-are-my-Julia-benchmarks-for-linear-algebra-operations-different-from-other-languages?">なぜ私のJuliaの線形代数演算のベンチマークは他の言語と異なるのか？</a><a id="Why-are-my-Julia-benchmarks-for-linear-algebra-operations-different-from-other-languages?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-are-my-Julia-benchmarks-for-linear-algebra-operations-different-from-other-languages?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">You may find that simple benchmarks of linear algebra building blocks like</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">線形代数の基本要素の単純なベンチマークは、</span></p><pre><code class="language-julia hljs">using BenchmarkTools
A = randn(1000, 1000)
B = randn(1000, 1000)
@btime $A \ $B
@btime $A * $B</code></pre><p data-translated="true"><span class="original-text">can be different when compared to other languages like Matlab or R.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">MatlabやRなどの他の言語と比較すると異なる場合があります。</span></p><p data-translated="true"><span class="original-text">Since operations like this are very thin wrappers over the relevant BLAS functions, the reason for the discrepancy is very likely to be</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このような操作は関連するBLAS関数の非常に薄いラッパーであるため、差異の理由は非常に可能性が高いです。</span></p><ol><li><p data-translated="true"><span class="original-text">the BLAS library each language is using,</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各言語が使用しているBLASライブラリ、</span></p></li><li><p data-translated="true"><span class="original-text">the number of concurrent threads.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同時スレッドの数。</span></p></li></ol><p data-translated="true"><span class="original-text">Julia compiles and uses its own copy of OpenBLAS, with threads currently capped at <code>8</code> (or the number of your cores).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは独自のOpenBLASのコピーをコンパイルして使用し、スレッドは現在<code>8</code>（またはコアの数）に制限されています。</span></p><p data-translated="true"><span class="original-text">Modifying OpenBLAS settings or compiling Julia with a different BLAS library, eg <a href="https://software.intel.com/en-us/mkl">Intel MKL</a>, may provide performance improvements. You can use <a href="https://github.com/JuliaComputing/MKL.jl">MKL.jl</a>, a package that makes Julia's linear algebra use Intel MKL BLAS and LAPACK instead of OpenBLAS, or search the discussion forum for suggestions on how to set this up manually. Note that Intel MKL cannot be bundled with Julia, as it is not open source.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">OpenBLASの設定を変更したり、<a href="https://software.intel.com/en-us/mkl">Intel MKL</a>などの異なるBLASライブラリでJuliaをコンパイルすることで、パフォーマンスの向上が得られる場合があります。<a href="https://github.com/JuliaComputing/MKL.jl">MKL.jl</a>を使用すると、Juliaの線形代数がOpenBLASの代わりにIntel MKL BLASおよびLAPACKを使用するようになります。また、手動で設定する方法についての提案を探すためにディスカッションフォーラムを検索することもできます。Intel MKLはオープンソースではないため、Juliaにバンドルすることはできませんので注意してください。</span></p><h2 id="Computing-cluster" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Computing-cluster">Computing cluster</a><a id="Computing-cluster-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-cluster" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Computing-cluster">計算クラスター</a><a id="Computing-cluster-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-cluster" title="Permalink"></a></span></h2><h3 id="How-do-I-manage-precompilation-caches-in-distributed-file-systems?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#How-do-I-manage-precompilation-caches-in-distributed-file-systems?">How do I manage precompilation caches in distributed file systems?</a><a id="How-do-I-manage-precompilation-caches-in-distributed-file-systems?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-manage-precompilation-caches-in-distributed-file-systems?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#How-do-I-manage-precompilation-caches-in-distributed-file-systems?">分散ファイルシステムでのプリコンパイルキャッシュを管理するにはどうすればよいですか？</a><a id="How-do-I-manage-precompilation-caches-in-distributed-file-systems?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-manage-precompilation-caches-in-distributed-file-systems?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">When using Julia in high-performance computing (HPC) facilities with shared filesystems, it is recommended to use a shared depot (via the <a href="../environment-variables/index.html#JULIA_DEPOT_PATH"><code>JULIA_DEPOT_PATH</code></a> environment variable). Since Julia v1.10, multiple Julia processes on functionally similar workers and using the same depot will coordinate via pidfile locks to only spend effort precompiling on one process while the others wait. The precompilation process will indicate when the process is precompiling or waiting for another that is precompiling. If non-interactive the messages are via <code>@debug</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">共有ファイルシステムを持つ高性能コンピューティング（HPC）施設でJuliaを使用する場合、共有デポ（<a href="../environment-variables/index.html#JULIA_DEPOT_PATH"><code>JULIA_DEPOT_PATH</code></a>環境変数を介して）を使用することをお勧めします。Julia v1.10以降、機能的に類似したワーカー上で複数のJuliaプロセスが同じデポを使用する場合、pidfileロックを介して調整され、他のプロセスが待機している間に1つのプロセスでのみプリコンパイルを行うようになります。プリコンパイルプロセスは、プロセスがプリコンパイル中または他のプリコンパイル中のプロセスを待機していることを示します。非対話的な場合、メッセージは<code>@debug</code>を介して表示されます。</span></p><p data-translated="true"><span class="original-text">However, due to caching of binary code, the cache rejection since v1.9 is more strict and users may need to set the <a href="../environment-variables/index.html#JULIA_CPU_TARGET"><code>JULIA_CPU_TARGET</code></a> environment variable appropriately to get a single cache that is usable throughout the HPC environment.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、バイナリコードのキャッシュのため、v1.9以降のキャッシュ拒否はより厳格になっており、ユーザーはHPC環境全体で使用可能な単一のキャッシュを取得するために<a href="../environment-variables/index.html#JULIA_CPU_TARGET"><code>JULIA_CPU_TARGET</code></a>環境変数を適切に設定する必要がある場合があります。</span></p><h2 id="Julia-Releases" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Julia-Releases">Julia Releases</a><a id="Julia-Releases-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Releases" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Julia-Releases">Juliaリリース</a><a id="Julia-Releases-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Releases" title="Permalink"></a></span></h2><h3 id="Do-I-want-to-use-the-Stable,-LTS,-or-nightly-version-of-Julia?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Do-I-want-to-use-the-Stable,-LTS,-or-nightly-version-of-Julia?">Do I want to use the Stable, LTS, or nightly version of Julia?</a><a id="Do-I-want-to-use-the-Stable,-LTS,-or-nightly-version-of-Julia?-1"></a><a class="docs-heading-anchor-permalink" href="#Do-I-want-to-use-the-Stable,-LTS,-or-nightly-version-of-Julia?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Do-I-want-to-use-the-Stable,-LTS,-or-nightly-version-of-Julia?">安定版、LTS、またはナイトリーバージョンのJuliaを使用したいですか？</a><a id="Do-I-want-to-use-the-Stable,-LTS,-or-nightly-version-of-Julia?-1"></a><a class="docs-heading-anchor-permalink" href="#Do-I-want-to-use-the-Stable,-LTS,-or-nightly-version-of-Julia?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The Stable version of Julia is the latest released version of Julia, this is the version most people will want to run. It has the latest features, including improved performance. The Stable version of Julia is versioned according to <a href="https://semver.org/">SemVer</a> as v1.x.y. A new minor release of Julia corresponding to a new Stable version is made approximately every 4-5 months after a few weeks of testing as a release candidate. Unlike the LTS version the Stable version will not normally receive bugfixes after another Stable version of Julia has been released. However, upgrading to the next Stable release will always be possible as each release of Julia v1.x will continue to run code written for earlier versions.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの安定版は最新のリリースバージョンであり、これはほとんどの人が実行したいバージョンです。最新の機能が含まれており、パフォーマンスが向上しています。Juliaの安定版は、<a href="https://semver.org/">SemVer</a>に従ってv1.x.yとしてバージョン管理されています。新しい安定版に対応する新しいマイナーバージョンのJuliaは、リリース候補として数週間のテストの後、約4〜5ヶ月ごとに作成されます。LTSバージョンとは異なり、安定版は別の安定版のJuliaがリリースされた後、通常はバグ修正を受けません。ただし、次の安定版へのアップグレードは常に可能であり、各リリースのJulia v1.xは以前のバージョン用に書かれたコードを引き続き実行します。</span></p><p data-translated="true"><span class="original-text">You may prefer the LTS (Long Term Support) version of Julia if you are looking for a very stable code base. The current LTS version of Julia is versioned according to SemVer as v1.6.x; this branch will continue to receive bugfixes until a new LTS branch is chosen, at which point the v1.6.x series will no longer received regular bug fixes and all but the most conservative users will be advised to upgrade to the new LTS version series. As a package developer, you may prefer to develop for the LTS version, to maximize the number of users who can use your package. As per SemVer, code written for v1.0 will continue to work for all future LTS and Stable versions. In general, even if targeting the LTS, one can develop and run code in the latest Stable version, to take advantage of the improved performance; so long as one avoids using new features (such as added library functions or new methods).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">非常に安定したコードベースを探している場合は、JuliaのLTS（長期サポート）バージョンを好むかもしれません。現在のLTSバージョンのJuliaは、SemVerに従ってv1.6.xとしてバージョン管理されています。このブランチは、新しいLTSブランチが選択されるまでバグ修正を受け続けます。その時点で、v1.6.xシリーズは定期的なバグ修正を受けなくなり、最も保守的なユーザーを除いてすべてのユーザーに新しいLTSバージョンシリーズへのアップグレードが推奨されます。パッケージ開発者としては、LTSバージョン向けに開発することで、パッケージを使用できるユーザーの数を最大化することを好むかもしれません。SemVerに従って、v1.0用に書かれたコードは、今後のすべてのLTSおよび安定版で引き続き動作します。一般的に、LTSをターゲットにしていても、最新の安定版でコードを開発および実行して、パフォーマンスの向上を利用することができます。ただし、新しい機能（追加されたライブラリ関数や新しいメソッドなど）を使用しないようにする必要があります。</span></p><p data-translated="true"><span class="original-text">You may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language, and don't mind if the version available today occasionally doesn't actually work. As the name implies, releases to the nightly version are made roughly every night (depending on build infrastructure stability). In general nightly released are fairly safe to use—your code will not catch on fire. However, they may be occasional regressions and or issues that will not be found until more thorough pre-release testing. You may wish to test against the nightly version to ensure that such regressions that affect your use case are caught before a release is made.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最新の言語の更新を利用したい場合は、夜間版のJuliaを選択することをお勧めします。ただし、今日利用可能なバージョンが時折実際には動作しないことを気にしない場合に限ります。名前が示すように、夜間版へのリリースはおおよそ毎晩行われます（ビルドインフラの安定性に依存します）。一般的に、夜間リリースは比較的安全に使用できます—あなたのコードが燃え上がることはありません。ただし、時折回帰や問題が発生する可能性があり、より徹底したプレリリーステストが行われるまで発見されないことがあります。リリースが行われる前に、あなたのユースケースに影響を与えるような回帰が検出されることを確認するために、夜間版でテストすることをお勧めします。</span></p><p data-translated="true"><span class="original-text">Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning. If this describes you, you may also be interested in reading our <a href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">guidelines for contributing</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最後に、自分自身でJuliaをソースからビルドすることも検討できます。このオプションは、コマンドラインに慣れているか、学ぶことに興味がある個人向けです。もしこれがあなたに当てはまるなら、私たちの<a href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">貢献に関するガイドライン</a>を読むことにも興味があるかもしれません。</span></p><p data-translated="true"><span class="original-text">The <a href="https://julialang.org/install/"><code>juliaup</code> install manager</a> has pre-defined channels named <code>release</code> and <code>lts</code> for the latest stable release and the current LTS release, as well as version-specific channels.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この<a href="https://julialang.org/install/"><code>juliaup</code> インストールマネージャー</a>には、最新の安定版リリースと現在のLTSリリースのための<code>release</code>および<code>lts</code>という名前の事前定義されたチャネルがあります。また、バージョン固有のチャネルもあります。</span></p><h3 id="How-can-I-transfer-the-list-of-installed-packages-after-updating-my-version-of-Julia?" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#How-can-I-transfer-the-list-of-installed-packages-after-updating-my-version-of-Julia?">How can I transfer the list of installed packages after updating my version of Julia?</a><a id="How-can-I-transfer-the-list-of-installed-packages-after-updating-my-version-of-Julia?-1"></a><a class="docs-heading-anchor-permalink" href="#How-can-I-transfer-the-list-of-installed-packages-after-updating-my-version-of-Julia?" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#How-can-I-transfer-the-list-of-installed-packages-after-updating-my-version-of-Julia?">Juliaのバージョンを更新した後、インストールされたパッケージのリストをどのように転送できますか？</a><a id="How-can-I-transfer-the-list-of-installed-packages-after-updating-my-version-of-Julia?-1"></a><a class="docs-heading-anchor-permalink" href="#How-can-I-transfer-the-list-of-installed-packages-after-updating-my-version-of-Julia?" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Each minor version of julia has its own default <a href="../code-loading/index.html#Environments-1">environment</a>. As a result, upon installing a new minor version of Julia, the packages you added using the previous minor version will not be available by default. The environment for a given julia version is defined by the files <code>Project.toml</code> and <code>Manifest.toml</code> in a folder matching the version number in <code>.julia/environments/</code>, for instance, <code>.julia/environments/v1.3</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各マイナーバージョンのJuliaには独自のデフォルト<a href="../code-loading/index.html#Environments-1">環境</a>があります。そのため、新しいマイナーバージョンのJuliaをインストールすると、以前のマイナーバージョンで追加したパッケージはデフォルトでは利用できません。特定のJuliaバージョンの環境は、<code>.julia/environments/</code>内のバージョン番号に一致するフォルダーにある<code>Project.toml</code>および<code>Manifest.toml</code>ファイルによって定義されます。例えば、<code>.julia/environments/v1.3</code>のようになります。</span></p><p data-translated="true"><span class="original-text">If you install a new minor version of Julia, say <code>1.4</code>, and want to use in its default environment the same packages as in a previous version (e.g. <code>1.3</code>), you can copy the contents of the file <code>Project.toml</code> from the <code>1.3</code> folder to <code>1.4</code>. Then, in a session of the new Julia version, enter the "package management mode" by typing the key <code>]</code>, and run the command <a href="https://julialang.github.io/Pkg.jl/v1/api/#Pkg.instantiate#Pkg.instantiate"><code>instantiate</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">新しいマイナーバージョンのJulia、例えば<code>1.4</code>をインストールし、以前のバージョン（例：<code>1.3</code>）と同じパッケージをデフォルト環境で使用したい場合は、<code>1.3</code>フォルダーから<code>Project.toml</code>ファイルの内容を<code>1.4</code>にコピーできます。その後、新しいJuliaバージョンのセッションで、キー<code>]</code>を入力して「パッケージ管理モード」に入り、コマンド<a href="https://julialang.github.io/Pkg.jl/v1/api/#Pkg.instantiate#Pkg.instantiate"><code>instantiate</code></a>を実行します。</span></p><p data-translated="true"><span class="original-text">This operation will resolve a set of feasible packages from the copied file that are compatible with the target Julia version, and will install or update them if suitable. If you want to reproduce not only the set of packages, but also the versions you were using in the previous Julia version, you should also copy the <code>Manifest.toml</code> file before running the Pkg command <code>instantiate</code>. However, note that packages may define compatibility constraints that may be affected by changing the version of Julia, so the exact set of versions you had in <code>1.3</code> may not work for <code>1.4</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この操作は、コピーしたファイルからターゲットのJuliaバージョンと互換性のある実行可能なパッケージのセットを解決し、適切であればそれらをインストールまたは更新します。パッケージのセットだけでなく、以前のJuliaバージョンで使用していたバージョンも再現したい場合は、Pkgコマンド<code>instantiate</code>を実行する前に<code>Manifest.toml</code>ファイルもコピーする必要があります。ただし、パッケージはJuliaのバージョンを変更することで影響を受ける互換性制約を定義する場合があるため、<code>1.3</code>で持っていた正確なバージョンのセットが<code>1.4</code>で動作しない可能性があることに注意してください。</span></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../style-guide/index.html">« Style Guide</a><a class="docs-footer-nextpage" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>