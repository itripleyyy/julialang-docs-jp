<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Multi-processing and Distributed Computing · The Julia Language</title><meta name="title" content="Multi-processing and Distributed Computing · The Julia Language"><meta property="og:title" content="Multi-processing and Distributed Computing · The Julia Language"><meta property="twitter:title" content="Multi-processing and Distributed Computing · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/distributed-computing/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/distributed-computing/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bj0h2"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li class="is-active"><a class="tocitem" href="">Multi-processing and Distributed Computing</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#code-availability"><span>Code Availability and Loading Packages</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#code-availability"><span>コードの可用性とパッケージの読み込み</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Starting-and-managing-worker-processes"><span>Starting and managing worker processes</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Starting-and-managing-worker-processes"><span>ワーカープロセスの開始と管理</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Data-Movement"><span>Data Movement</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Data-Movement"><span>データの移動</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Global-variables"><span>Global variables</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Global-variables"><span>グローバル変数</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Parallel-Map-and-Loops"><span>Parallel Map and Loops</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Parallel-Map-and-Loops"><span>並列マップとループ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Remote-References-and-AbstractChannels"><span>Remote References and AbstractChannels</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Remote-References-and-AbstractChannels"><span>リモート参照とAbstractChannels</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Channels-and-RemoteChannels"><span>Channels and RemoteChannels</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Channels-and-RemoteChannels"><span>チャネルとRemoteChannels</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Local-invocations"><span>Local invocations</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Local-invocations"><span>ローカル呼び出し</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-shared-arrays"><span>Shared Arrays</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-shared-arrays"><span>共有配列</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#ClusterManagers"><span>ClusterManagers</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#ClusterManagers"><span>ClusterManagers</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Specifying-Network-Topology-(Experimental)"><span>Specifying Network Topology (Experimental)</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Specifying-Network-Topology-(Experimental)"><span>ネットワークトポロジーの指定 (実験的)</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Noteworthy-external-packages"><span>Noteworthy external packages</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Noteworthy-external-packages"><span>注目すべき外部パッケージ</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">マルチプロセッシングと分散コンピューティング</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">マルチプロセッシングと分散コンピューティング</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/distributed-computing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multi-processing-and-Distributed-Computing" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Multi-processing-and-Distributed-Computing">Multi-processing and Distributed Computing</a><a id="Multi-processing-and-Distributed-Computing-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-processing-and-Distributed-Computing" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Multi-processing-and-Distributed-Computing">マルチプロセッシングと分散コンピューティング</a><a id="Multi-processing-and-Distributed-Computing-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-processing-and-Distributed-Computing" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">An implementation of distributed memory parallel computing is provided by module <a href="../../stdlib/Distributed/index.html#man-distributed"><code>Distributed</code></a> as part of the standard library shipped with Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">分散メモリ並列計算の実装は、Juliaに付属する標準ライブラリの一部としてモジュール<a href="../../stdlib/Distributed/index.html#man-distributed"><code>Distributed</code></a>によって提供されています。</span></p><p data-translated="true"><span class="original-text">Most modern computers possess more than one CPU, and several computers can be combined together in a cluster. Harnessing the power of these multiple CPUs allows many computations to be completed more quickly. There are two major factors that influence performance: the speed of the CPUs themselves, and the speed of their access to memory. In a cluster, it's fairly obvious that a given CPU will have fastest access to the RAM within the same computer (node). Perhaps more surprisingly, similar issues are relevant on a typical multicore laptop, due to differences in the speed of main memory and the <a href="https://www.akkadia.org/drepper/cpumemory.pdf">cache</a>. Consequently, a good multiprocessing environment should allow control over the "ownership" of a chunk of memory by a particular CPU. Julia provides a multiprocessing environment based on message passing to allow programs to run on multiple processes in separate memory domains at once.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ほとんどの現代のコンピュータは複数のCPUを持ち、いくつかのコンピュータをクラスターとして組み合わせることができます。これらの複数のCPUの力を活用することで、多くの計算をより迅速に完了させることができます。パフォーマンスに影響を与える主な要因は2つあります：CPU自体の速度と、メモリへのアクセス速度です。クラスターでは、特定のCPUが同じコンピュータ（ノード）内のRAMに最も速くアクセスできることは明らかです。おそらく驚くべきことに、一般的なマルチコアノートパソコンでも、主メモリと<a href="https://www.akkadia.org/drepper/cpumemory.pdf">キャッシュ</a>の速度の違いにより、同様の問題が関連しています。したがって、良好なマルチプロセッシング環境は、特定のCPUによるメモリの「所有権」を制御できる必要があります。Juliaは、メッセージパッシングに基づくマルチプロセッシング環境を提供し、プログラムが異なるメモリドメインで複数のプロセスで同時に実行できるようにします。</span></p><p data-translated="true"><span class="original-text">Julia's implementation of message passing is different from other environments such as MPI<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup>. Communication in Julia is generally "one-sided", meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like "message send" and "message receive" but rather resemble higher-level operations like calls to user functions.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaのメッセージパッシングの実装は、MPI<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup>などの他の環境とは異なります。Juliaにおける通信は一般に「一方向」であり、プログラマーは2つのプロセスの操作において明示的に1つのプロセスのみを管理する必要があります。さらに、これらの操作は通常「メッセージ送信」や「メッセージ受信」ではなく、ユーザー関数への呼び出しのような高レベルの操作に似ています。</span></p><p data-translated="true"><span class="original-text">Distributed programming in Julia is built on two primitives: <em>remote references</em> and <em>remote calls</em>. A remote reference is an object that can be used from any process to refer to an object stored on a particular process. A remote call is a request by one process to call a certain function on certain arguments on another (possibly the same) process.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaにおける分散プログラミングは、<em>リモート参照</em>と<em>リモート呼び出し</em>の2つのプリミティブに基づいています。リモート参照は、特定のプロセスに保存されたオブジェクトを参照するために任意のプロセスから使用できるオブジェクトです。リモート呼び出しは、1つのプロセスが別の（場合によっては同じ）プロセスで特定の引数を持つ特定の関数を呼び出すリクエストです。</span></p><p data-translated="true"><span class="original-text">Remote references come in two flavors: <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> and <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リモート参照には2つの種類があります：<a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>と<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>。</span></p><p data-translated="true"><span class="original-text">A remote call returns a <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> to its result. Remote calls return immediately; the process that made the call proceeds to its next operation while the remote call happens somewhere else. You can wait for a remote call to finish by calling <a href="../../base/parallel/index.html#Base.wait"><code>wait</code></a> on the returned <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>, and you can obtain the full value of the result using <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リモート呼び出しは、その結果に対する <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> を返します。リモート呼び出しは即座に返され、呼び出しを行ったプロセスは、リモート呼び出しが他の場所で行われている間に次の操作に進みます。リモート呼び出しが完了するのを待つには、返された <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> に対して <a href="../../base/parallel/index.html#Base.wait"><code>wait</code></a> を呼び出すことができ、結果の完全な値を取得するには <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> を使用します。</span></p><p data-translated="true"><span class="original-text">On the other hand, <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> s are rewritable. For example, multiple processes can coordinate their processing by referencing the same remote <code>Channel</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一方で、<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> は書き換え可能です。たとえば、複数のプロセスが同じリモート <code>Channel</code> を参照することで、処理を調整できます。</span></p><p data-translated="true"><span class="original-text">Each process has an associated identifier. The process providing the interactive Julia prompt always has an <code>id</code> equal to 1. The processes used by default for parallel operations are referred to as "workers". When there is only one process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1. As a result, adding 2 or more processes is required to gain benefits from parallel processing methods like <a href="../../stdlib/Distributed/index.html#Distributed.pmap"><code>pmap</code></a>. Adding a single process is beneficial if you just wish to do other things in the main process while a long computation is running on the worker.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各プロセスには関連付けられた識別子があります。インタラクティブなJuliaプロンプトを提供するプロセスは常に <code>id</code> が 1 です。並列操作にデフォルトで使用されるプロセスは「ワーカー」と呼ばれます。プロセスが1つだけの場合、プロセス1はワーカーと見なされます。それ以外の場合、ワーカーはプロセス1以外のすべてのプロセスと見なされます。その結果、<a href="../../stdlib/Distributed/index.html#Distributed.pmap"><code>pmap</code></a> のような並列処理メソッドの利点を得るには、2つ以上のプロセスを追加する必要があります。長い計算がワーカーで実行されている間にメインプロセスで他のことを行いたいだけの場合は、単一のプロセスを追加することが有益です。</span></p><p data-translated="true"><span class="original-text">Let's try this out. Starting with <code>julia -p n</code> provides <code>n</code> worker processes on the local machine. Generally it makes sense for <code>n</code> to equal the number of CPU threads (logical cores) on the machine. Note that the <code>-p</code> argument implicitly loads module <a href="../../stdlib/Distributed/index.html#man-distributed"><code>Distributed</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これを試してみましょう。<code>julia -p n</code> でローカルマシンに <code>n</code> のワーカープロセスを提供します。一般的に、<code>n</code> はマシン上のCPUスレッド（論理コア）の数と等しい方が理にかなっています。<code>-p</code> 引数は暗黙的にモジュール <a href="../../stdlib/Distributed/index.html#man-distributed"><code>Distributed</code></a> をロードすることに注意してください。</span></p><pre><code class="language-julia-repl hljs">$ julia -p 2

julia&gt; r = remotecall(rand, 2, 2, 2)
Future(2, 1, 4, nothing)

julia&gt; s = @spawnat 2 1 .+ fetch(r)
Future(2, 1, 5, nothing)

julia&gt; fetch(s)
2×2 Matrix{Float64}:
 1.18526  1.50912
 1.16296  1.60607</code></pre><p data-translated="true"><span class="original-text">The first argument to <a href="../../stdlib/Distributed/index.html#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall</code></a> is the function to call. Most parallel programming in Julia does not reference specific processes or the number of processes available, but <a href="../../stdlib/Distributed/index.html#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall</code></a> is considered a low-level interface providing finer control. The second argument to <a href="../../stdlib/Distributed/index.html#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall</code></a> is the <code>id</code> of the process that will do the work, and the remaining arguments will be passed to the function being called.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall</code></a> の最初の引数は呼び出す関数です。Juliaの並列プログラミングのほとんどは特定のプロセスや利用可能なプロセスの数を参照しませんが、<a href="../../stdlib/Distributed/index.html#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall</code></a> はより細かい制御を提供する低レベルのインターフェースと見なされます。<a href="../../stdlib/Distributed/index.html#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall</code></a> の2番目の引数は作業を行うプロセスの <code>id</code> であり、残りの引数は呼び出される関数に渡されます。</span></p><p data-translated="true"><span class="original-text">As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. The result of both calculations is available in the two futures, <code>r</code> and <code>s</code>. The <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> macro evaluates the expression in the second argument on the process specified by the first argument.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ご覧の通り、最初の行ではプロセス2に2x2のランダム行列を構築するように依頼し、2行目ではそれに1を加えるように依頼しました。両方の計算の結果は、2つの未来 <code>r</code> と <code>s</code> に利用可能です。<a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> マクロは、最初の引数で指定されたプロセスで2番目の引数の式を評価します。</span></p><p data-translated="true"><span class="original-text">Occasionally you might want a remotely-computed value immediately. This typically happens when you read from a remote object to obtain data needed by the next local operation. The function <a href="../../stdlib/Distributed/index.html#Distributed.remotecall_fetch-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall_fetch</code></a> exists for this purpose. It is equivalent to <code>fetch(remotecall(...))</code> but is more efficient.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">時折、リモートで計算された値をすぐに取得したい場合があります。これは通常、リモートオブジェクトからデータを読み取って次のローカル操作に必要なデータを取得する際に発生します。この目的のために <a href="../../stdlib/Distributed/index.html#Distributed.remotecall_fetch-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall_fetch</code></a> 関数が存在します。これは <code>fetch(remotecall(...))</code> と同等ですが、より効率的です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; remotecall_fetch(r-&gt; fetch(r)[1, 1], 2, r)
0.18526337335308085</code></pre><p data-translated="true"><span class="original-text">This fetches the array on worker 2 and returns the first value. Note, that <code>fetch</code> doesn't move any data in this case, since it's executed on the worker that owns the array. One can also write:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これはワーカー2で配列を取得し、最初の値を返します。注意してください、この場合 <code>fetch</code> はデータを移動しません。なぜなら、配列を所有するワーカーで実行されるからです。次のように書くこともできます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; remotecall_fetch(getindex, 2, r, 1, 1)
0.10824216411304866</code></pre><p data-translated="true"><span class="original-text">Remember that <a href="../../base/arrays/index.html#Base.getindex-Tuple{Type, Vararg{Any}}"><code>getindex(r,1,1)</code></a> is <a href="../arrays/index.html#man-array-indexing">equivalent</a> to <code>r[1,1]</code>, so this call fetches the first element of the future <code>r</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">覚えておいてください、<a href="../../base/arrays/index.html#Base.getindex-Tuple{Type, Vararg{Any}}"><code>getindex(r,1,1)</code></a> は <a href="../arrays/index.html#man-array-indexing">同等</a> に <code>r[1,1]</code> であるため、この呼び出しは未来 <code>r</code> の最初の要素を取得します。</span></p><p data-translated="true"><span class="original-text">To make things easier, the symbol <code>:any</code> can be passed to <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a>, which picks where to do the operation for you:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">物事を簡単にするために、シンボル <code>:any</code> を <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> に渡すことができ、どこで操作を行うかを自動的に選択します:</span></p><pre><code class="language-julia-repl hljs">julia&gt; r = @spawnat :any rand(2,2)
Future(2, 1, 4, nothing)

julia&gt; s = @spawnat :any 1 .+ fetch(r)
Future(3, 1, 5, nothing)

julia&gt; fetch(s)
2×2 Matrix{Float64}:
 1.38854  1.9098
 1.20939  1.57158</code></pre><p data-translated="true"><span class="original-text">Note that we used <code>1 .+ fetch(r)</code> instead of <code>1 .+ r</code>. This is because we do not know where the code will run, so in general a <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> might be required to move <code>r</code> to the process doing the addition. In this case, <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> is smart enough to perform the computation on the process that owns <code>r</code>, so the <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> will be a no-op (no work is done).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">注意してください、私たちは <code>1 .+ fetch(r)</code> を <code>1 .+ r</code> の代わりに使用しました。これは、コードがどこで実行されるかわからないため、一般的に <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> が <code>r</code> を加算を行うプロセスに移動させる必要があるかもしれないからです。この場合、<a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> は <code>r</code> を所有するプロセスで計算を行うのに十分賢いので、<a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> はノーオペレーション（作業は行われない）になります。</span></p><p data-translated="true"><span class="original-text">(It is worth noting that <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> is not built-in but defined in Julia as a <a href="../metaprogramming/index.html#man-macros">macro</a>. It is possible to define your own such constructs.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(注目すべきは、<a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> は組み込みではなく、Juliaで <a href="../metaprogramming/index.html#man-macros">マクロ</a> として定義されていることです。独自のそのような構造を定義することも可能です。)</span></p><p data-translated="true"><span class="original-text">An important thing to remember is that, once fetched, a <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> will cache its value locally. Further <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> calls do not entail a network hop. Once all referencing <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>s have fetched, the remote stored value is deleted.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">重要なことは、一度取得されると、<a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> はその値をローカルにキャッシュすることです。さらに <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> 呼び出しはネットワークホップを伴いません。すべての参照する <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> が取得された後、リモートに保存された値は削除されます。</span></p><p data-translated="true"><span class="original-text"><a href="../../base/multi-threading/index.html#Base.Threads.@spawn"><code>Threads.@spawn</code></a> is similar to <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a>, but only runs tasks on the local process. We use it to create a "feeder" task for each process. Each task picks the next index that needs to be computed, then waits for its process to finish, then repeats until we run out of indices. Note that the feeder tasks do not begin to execute until the main task reaches the end of the <a href="../../base/parallel/index.html#Base.@sync"><code>@sync</code></a> block, at which point it surrenders control and waits for all the local tasks to complete before returning from the function. As for v0.7 and beyond, the feeder tasks are able to share state via <code>nextidx</code> because they all run on the same process. Even if <code>Tasks</code> are scheduled cooperatively, locking may still be required in some contexts, as in <a href="../faq/index.html#faq-async-io">asynchronous I/O</a>. This means context switches only occur at well-defined points: in this case, when <a href="../../stdlib/Distributed/index.html#Distributed.remotecall_fetch-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall_fetch</code></a> is called. This is the current state of implementation and it may change for future Julia versions, as it is intended to make it possible to run up to N <code>Tasks</code> on M <code>Process</code>, aka <a href="https://en.wikipedia.org/wiki/Thread_(computing)#Models#Models">M:N Threading</a>. Then a lock acquiring\releasing model for <code>nextidx</code> will be needed, as it is not safe to let multiple processes read-write a resource at the same time.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/multi-threading/index.html#Base.Threads.@spawn"><code>Threads.@spawn</code></a> は <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> に似ていますが、ローカルプロセスでのみタスクを実行します。私たちはそれを各プロセスの「フィーダー」タスクを作成するために使用します。各タスクは計算する必要がある次のインデックスを選び、その後プロセスが終了するのを待ち、インデックスがなくなるまで繰り返します。フィーダータスクは、メインタスクが <a href="../../base/parallel/index.html#Base.@sync"><code>@sync</code></a> ブロックの終わりに達するまで実行を開始しないことに注意してください。この時点で制御を放棄し、すべてのローカルタスクが完了するのを待ってから関数から戻ります。v0.7以降では、フィーダータスクはすべて同じプロセスで実行されるため、<code>nextidx</code> を介して状態を共有できます。<code>Tasks</code> が協調的にスケジュールされていても、<a href="../faq/index.html#faq-async-io">非同期I/O</a> のような文脈ではロックが必要な場合があります。これは、コンテキストスイッチが明確に定義されたポイントでのみ発生することを意味します。この場合、<a href="../../stdlib/Distributed/index.html#Distributed.remotecall_fetch-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall_fetch</code></a> が呼び出されるときです。これは現在の実装の状態であり、将来のJuliaバージョンで変更される可能性があります。これは、最大Nの<code>Tasks</code>をMの<code>Process</code>で実行できるようにすることを目的としています。つまり、<code>nextidx</code> のためのロック取得/解放モデルが必要になります。なぜなら、複数のプロセスが同時にリソースを読み書きすることは安全ではないからです。</span></p><h2 id="code-availability" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#code-availability">Code Availability and Loading Packages</a><a id="code-availability-1"></a><a class="docs-heading-anchor-permalink" href="#code-availability" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#code-availability">コードの可用性とパッケージの読み込み</a><a id="code-availability-1"></a><a class="docs-heading-anchor-permalink" href="#code-availability" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Your code must be available on any process that runs it. For example, type the following into the Julia prompt:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">あなたのコードは、それを実行するすべてのプロセスで利用可能でなければなりません。たとえば、Juliaプロンプトに次のように入力します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; function rand2(dims...)
           return 2*rand(dims...)
       end

julia&gt; rand2(2,2)
2×2 Matrix{Float64}:
 0.153756  0.368514
 1.15119   0.918912

julia&gt; fetch(@spawnat :any rand2(2,2))
ERROR: RemoteException(2, CapturedException(UndefVarError(Symbol("#rand2"))))
Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">Process 1 knew about the function <code>rand2</code>, but process 2 did not.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロセス1は関数 <code>rand2</code> を知っていましたが、プロセス2は知りませんでした。</span></p><p data-translated="true"><span class="original-text">Most commonly you'll be loading code from files or packages, and you have a considerable amount of flexibility in controlling which processes load code. Consider a file, <code>DummyModule.jl</code>, containing the following code:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最も一般的には、ファイルやパッケージからコードを読み込むことになります。そして、どのプロセスがコードを読み込むかを制御するためのかなりの柔軟性があります。次のコードを含むファイル <code>DummyModule.jl</code> を考えてみてください。</span></p><pre><code class="language-julia hljs">module DummyModule

export MyType, f

mutable struct MyType
    a::Int
end

f(x) = x^2+1

println("loaded")

end</code></pre><p data-translated="true"><span class="original-text">In order to refer to <code>MyType</code> across all processes, <code>DummyModule.jl</code> needs to be loaded on every process. Calling <code>include("DummyModule.jl")</code> loads it only on a single process. To load it on every process, use the <a href="../../stdlib/Distributed/index.html#Distributed.@everywhere"><code>@everywhere</code></a> macro (starting Julia with <code>julia -p 2</code>):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>MyType</code> をすべてのプロセスで参照するためには、<code>DummyModule.jl</code> をすべてのプロセスで読み込む必要があります。<code>include("DummyModule.jl")</code> を呼び出すと、単一のプロセスでのみ読み込まれます。すべてのプロセスで読み込むには、<a href="../../stdlib/Distributed/index.html#Distributed.@everywhere"><code>@everywhere</code></a> マクロを使用します（<code>julia -p 2</code> でJuliaを起動）：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @everywhere include("DummyModule.jl")
loaded
      From worker 3:    loaded
      From worker 2:    loaded</code></pre><p data-translated="true"><span class="original-text">As usual, this does not bring <code>DummyModule</code> into scope on any of the process, which requires <a href="../../base/base/index.html#using"><code>using</code></a> or <a href="../../base/base/index.html#import"><code>import</code></a>. Moreover, when <code>DummyModule</code> is brought into scope on one process, it is not on any other:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">通常通り、これにより <code>DummyModule</code> はどのプロセスでもスコープに入るわけではなく、<a href="../../base/base/index.html#using"><code>using</code></a> または <a href="../../base/base/index.html#import"><code>import</code></a> が必要です。さらに、<code>DummyModule</code> が1つのプロセスでスコープに入ると、他のプロセスではそうではありません。</span></p><pre><code class="language-julia-repl hljs">julia&gt; using .DummyModule

julia&gt; MyType(7)
MyType(7)

julia&gt; fetch(@spawnat 2 MyType(7))
ERROR: On worker 2:
UndefVarError: `MyType` not defined in `Main`
⋮

julia&gt; fetch(@spawnat 2 DummyModule.MyType(7))
MyType(7)</code></pre><p data-translated="true"><span class="original-text">However, it's still possible, for instance, to send a <code>MyType</code> to a process which has loaded <code>DummyModule</code> even if it's not in scope:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、スコープにない場合でも、<code>DummyModule</code>をロードしたプロセスに<code>MyType</code>を送信することは依然として可能です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; put!(RemoteChannel(2), MyType(7))
RemoteChannel{Channel{Any}}(2, 1, 13)</code></pre><p data-translated="true"><span class="original-text">A file can also be preloaded on multiple processes at startup with the <code>-L</code> flag, and a driver script can be used to drive the computation:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ファイルは、<code>-L</code>フラグを使用して、起動時に複数のプロセスにプリロードすることもでき、ドライバースクリプトを使用して計算を実行できます。</span></p><pre><code class="nohighlight hljs">julia -p &lt;n&gt; -L file1.jl -L file2.jl driver.jl</code></pre><p data-translated="true"><span class="original-text">The Julia process running the driver script in the example above has an <code>id</code> equal to 1, just like a process providing an interactive prompt.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記の例でドライバースクリプトを実行しているJuliaプロセスの<code>id</code>は1であり、インタラクティブプロンプトを提供するプロセスと同様です。</span></p><p data-translated="true"><span class="original-text">Finally, if <code>DummyModule.jl</code> is not a standalone file but a package, then <code>using DummyModule</code> will <em>load</em> <code>DummyModule.jl</code> on all processes, but only bring it into scope on the process where <a href="../../base/base/index.html#using"><code>using</code></a> was called.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最後に、<code>DummyModule.jl</code>がスタンドアロンファイルではなくパッケージである場合、<code>using DummyModule</code>はすべてのプロセスで<code>DummyModule.jl</code>を<em>ロード</em>しますが、<a href="../../base/base/index.html#using"><code>using</code></a>が呼び出されたプロセスでのみスコープに持ち込みます。</span></p><h2 id="Starting-and-managing-worker-processes" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Starting-and-managing-worker-processes">Starting and managing worker processes</a><a id="Starting-and-managing-worker-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Starting-and-managing-worker-processes" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Starting-and-managing-worker-processes">ワーカープロセスの開始と管理</a><a id="Starting-and-managing-worker-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Starting-and-managing-worker-processes" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The base Julia installation has in-built support for two types of clusters:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">基本的なJuliaインストールには、2種類のクラスタに対する組み込みサポートがあります：</span></p><ul><li data-translated="true"><span class="original-text">A local cluster specified with the <code>-p</code> option as shown above.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記のように<code>-p</code>オプションで指定されたローカルクラスタ。</span></li><li data-translated="true"><span class="original-text">A cluster spanning machines using the <code>--machine-file</code> option. This uses a passwordless <code>ssh</code> login to start Julia worker processes (from the same path as the current host) on the specified machines. Each machine definition takes the form <code>[count*][user@]host[:port] [bind_addr[:port]]</code>. <code>user</code> defaults to current user, <code>port</code> to the standard ssh port. <code>count</code> is the number of workers to spawn on the node, and defaults to 1. The optional <code>bind-to bind_addr[:port]</code> specifies the IP address and port that other workers should use to connect to this worker.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>--machine-file</code>オプションを使用してマシンにまたがるクラスタ。これは、指定されたマシン上でJuliaワーカープロセスを開始するためにパスワードなしの<code>ssh</code>ログインを使用します（現在のホストと同じパスから）。各マシンの定義は<code>[count*][user@]host[:port] [bind_addr[:port]]</code>の形式を取ります。<code>user</code>は現在のユーザーにデフォルト設定され、<code>port</code>は標準のsshポートにデフォルト設定されます。<code>count</code>はノード上で生成するワーカーの数で、デフォルトは1です。オプションの<code>bind-to bind_addr[:port]</code>は、他のワーカーがこのワーカーに接続するために使用するIPアドレスとポートを指定します。</span></li></ul><div class="admonition is-info" id="Note-30b7f89814be4364"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-30b7f89814be4364" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">While Julia generally strives for backward compatibility, distribution of code to worker processes relies on <a href="../../stdlib/Serialization/index.html#Serialization.serialize"><code>Serialization.serialize</code></a>. As pointed out in the corresponding documentation, this can not be guaranteed to work across different Julia versions, so it is advised that all workers on all machines use the same version.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは一般的に後方互換性を目指していますが、ワーカープロセスへのコードの配布は<a href="../../stdlib/Serialization/index.html#Serialization.serialize"><code>Serialization.serialize</code></a>に依存しています。対応するドキュメントで指摘されているように、これは異なるJuliaバージョン間で動作することが保証されていないため、すべてのマシンのすべてのワーカーが同じバージョンを使用することをお勧めします。</span></p></div></div><p data-translated="true"><span class="original-text">Functions <a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a>, <a href="../../stdlib/Distributed/index.html#Distributed.rmprocs"><code>rmprocs</code></a>, <a href="../../stdlib/Distributed/index.html#Distributed.workers"><code>workers</code></a>, and others are available as a programmatic means of adding, removing and querying the processes in a cluster.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a>、<a href="../../stdlib/Distributed/index.html#Distributed.rmprocs"><code>rmprocs</code></a>、<a href="../../stdlib/Distributed/index.html#Distributed.workers"><code>workers</code></a>などの関数は、クラスタ内のプロセスを追加、削除、照会するためのプログラム的手段として利用可能です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributed

julia&gt; addprocs(2)
2-element Vector{Int64}:
 2
 3</code></pre><p data-translated="true"><span class="original-text">Module <a href="../../stdlib/Distributed/index.html#man-distributed"><code>Distributed</code></a> must be explicitly loaded on the master process before invoking <a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a>. It is automatically made available on the worker processes.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">モジュール <a href="../../stdlib/Distributed/index.html#man-distributed"><code>Distributed</code></a> は、<a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a> を呼び出す前に、マスタープロセスで明示的にロードする必要があります。これは、ワーカープロセスで自動的に利用可能になります。</span></p><div class="admonition is-info" id="Note-b5aa1d94a1a8c508"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b5aa1d94a1a8c508" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Note that workers do not run a <code>~/.julia/config/startup.jl</code> startup script, nor do they synchronize their global state (such as command-line switches, global variables, new method definitions, and loaded modules) with any of the other running processes. You may use <code>addprocs(exeflags="--project")</code> to initialize a worker with a particular environment, and then <code>@everywhere using &lt;modulename&gt;</code> or <code>@everywhere include("file.jl")</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ワーカーは <code>~/.julia/config/startup.jl</code> スタートアップスクリプトを実行せず、他の実行中のプロセスとグローバル状態（コマンドラインスイッチ、グローバル変数、新しいメソッド定義、ロードされたモジュールなど）を同期しません。特定の環境でワーカーを初期化するには <code>addprocs(exeflags="--project")</code> を使用し、その後 <code>@everywhere using &lt;modulename&gt;</code> または <code>@everywhere include("file.jl")</code> を使用できます。</span></p></div></div><p data-translated="true"><span class="original-text">Other types of clusters can be supported by writing your own custom <code>ClusterManager</code>, as described below in the <a href="#ClusterManagers">ClusterManagers</a> section.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">他のタイプのクラスターは、以下の <a href="#ClusterManagers">ClusterManagers</a> セクションで説明されているように、独自のカスタム <code>ClusterManager</code> を作成することでサポートできます。</span></p><h2 id="Data-Movement" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Data-Movement">Data Movement</a><a id="Data-Movement-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Movement" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Data-Movement">データ移動</a><a id="Data-Movement-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Movement" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Sending messages and moving data constitute most of the overhead in a distributed program. Reducing the number of messages and the amount of data sent is critical to achieving performance and scalability. To this end, it is important to understand the data movement performed by Julia's various distributed programming constructs.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メッセージの送信とデータの移動は、分散プログラムにおけるオーバーヘッドの大部分を占めます。メッセージの数と送信されるデータの量を減らすことは、パフォーマンスとスケーラビリティを達成するために重要です。この目的のために、Juliaのさまざまな分散プログラミング構造によって行われるデータ移動を理解することが重要です。</span></p><p data-translated="true"><span class="original-text"><a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> can be considered an explicit data movement operation, since it directly asks that an object be moved to the local machine. <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> (and a few related constructs) also moves data, but this is not as obvious, hence it can be called an implicit data movement operation. Consider these two approaches to constructing and squaring a random matrix:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> は、オブジェクトをローカルマシンに移動するように直接要求するため、明示的なデータ移動操作と見なすことができます。<a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a>（およびいくつかの関連構造）もデータを移動しますが、これは明白ではないため、暗黙的なデータ移動操作と呼ぶことができます。ランダム行列を構築して平方するためのこれら2つのアプローチを考えてみましょう：</span></p><p data-translated="true"><span class="original-text">Method 1:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">方法 1:</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(1000,1000);

julia&gt; Bref = @spawnat :any A^2;

[...]

julia&gt; fetch(Bref);</code></pre><p data-translated="true"><span class="original-text">Method 2:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">方法 2:</span></p><pre><code class="language-julia-repl hljs">julia&gt; Bref = @spawnat :any rand(1000,1000)^2;

[...]

julia&gt; fetch(Bref);</code></pre><p data-translated="true"><span class="original-text">The difference seems trivial, but in fact is quite significant due to the behavior of <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a>. In the first method, a random matrix is constructed locally, then sent to another process where it is squared. In the second method, a random matrix is both constructed and squared on another process. Therefore the second method sends much less data than the first.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">違いは些細に見えますが、実際には <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> の動作によりかなり重要です。最初の方法では、ランダム行列がローカルで構築され、その後別のプロセスに送信されて平方されます。2番目の方法では、ランダム行列が別のプロセスで構築され、平方されます。したがって、2番目の方法は最初の方法よりもはるかに少ないデータを送信します。</span></p><p data-translated="true"><span class="original-text">In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix <code>A</code> then the first method might be better. Or, if computing <code>A</code> is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> and <code>fetch(Bref)</code>, it might be better to eliminate the parallelism altogether. Or imagine <code>rand(1000,1000)</code> is replaced with a more expensive operation. Then it might make sense to add another <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> statement just for this step.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このおもちゃの例では、2つの方法を簡単に区別して選択できます。しかし、実際のプログラムではデータ移動を設計するにはより多くの考慮が必要であり、測定も必要になる可能性があります。たとえば、最初のプロセスが行列 <code>A</code> を必要とする場合、最初の方法がより良いかもしれません。また、<code>A</code> の計算が高価で、現在のプロセスだけがそれを持っている場合、別のプロセスに移動することは避けられないかもしれません。また、現在のプロセスが <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> と <code>fetch(Bref)</code> の間に非常に少ない作業を持っている場合、並列性を完全に排除する方が良いかもしれません。また、<code>rand(1000,1000)</code> がより高価な操作に置き換えられると想像してください。この場合、このステップのためだけに別の <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> ステートメントを追加することが理にかなうかもしれません。</span></p><h2 id="Global-variables" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Global-variables">Global variables</a><a id="Global-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Global-variables" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Global-variables">グローバル変数</a><a id="Global-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Global-variables" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Expressions executed remotely via <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a>, or closures specified for remote execution using <a href="../../stdlib/Distributed/index.html#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall</code></a> may refer to global variables. Global bindings under module <code>Main</code> are treated a little differently compared to global bindings in other modules. Consider the following code snippet:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リモートで実行される <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> を介して実行される式や、リモート実行のために指定されたクロージャは、<a href="../../stdlib/Distributed/index.html#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall</code></a> を使用してグローバル変数を参照することができます。モジュール <code>Main</code> の下のグローバルバインディングは、他のモジュールのグローバルバインディングとは少し異なって扱われます。次のコードスニペットを考えてみてください:</span></p><pre><code class="language-julia-repl hljs">A = rand(10,10)
remotecall_fetch(()-&gt;sum(A), 2)</code></pre><p data-translated="true"><span class="original-text">In this case <a href="../../base/collections/index.html#Base.sum"><code>sum</code></a> MUST be defined in the remote process. Note that <code>A</code> is a global variable defined in the local workspace. Worker 2 does not have a variable called <code>A</code> under <code>Main</code>. The act of shipping the closure <code>()-&gt;sum(A)</code> to worker 2 results in <code>Main.A</code> being defined on 2. <code>Main.A</code> continues to exist on worker 2 even after the call <a href="../../stdlib/Distributed/index.html#Distributed.remotecall_fetch-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall_fetch</code></a> returns. Remote calls with embedded global references (under <code>Main</code> module only) manage globals as follows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この場合、<a href="../../base/collections/index.html#Base.sum"><code>sum</code></a> はリモートプロセスで定義されている必要があります。<code>A</code> はローカルワークスペースで定義されたグローバル変数であることに注意してください。ワーカー2には <code>Main</code> の下に <code>A</code> という変数はありません。クロージャ <code>()-&gt;sum(A)</code> をワーカー2に送信する行為は、<code>Main.A</code> が2で定義されることを意味します。<code>Main.A</code> は、呼び出し <a href="../../stdlib/Distributed/index.html#Distributed.remotecall_fetch-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall_fetch</code></a> が返った後もワーカー2に存在し続けます。埋め込まれたグローバル参照を持つリモート呼び出し（<code>Main</code> モジュールの下のみ）は、グローバルを次のように管理します:</span></p><ul><li><p data-translated="true"><span class="original-text">New global bindings are created on destination workers if they are referenced as part of a remote call.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リモート呼び出しの一部として参照される場合、宛先ワーカーに新しいグローバルバインディングが作成されます。</span></p></li><li><p data-translated="true"><span class="original-text">Global constants are declared as constants on remote nodes too.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバル定数は、リモートノードでも定数として宣言されます。</span></p></li><li><p data-translated="true"><span class="original-text">Globals are re-sent to a destination worker only in the context of a remote call, and then only if its value has changed. Also, the cluster does not synchronize global bindings across nodes. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバルは、リモート呼び出しのコンテキスト内でのみ宛先ワーカーに再送信され、その値が変更された場合にのみ再送信されます。また、クラスターはノード間でグローバルバインディングを同期しません。例えば:</span></p><pre><code class="language-julia hljs">A = rand(10,10)
remotecall_fetch(()-&gt;sum(A), 2) # worker 2
A = rand(10,10)
remotecall_fetch(()-&gt;sum(A), 3) # worker 3
A = nothing</code></pre><p data-translated="true"><span class="original-text">Executing the above snippet results in <code>Main.A</code> on worker 2 having a different value from <code>Main.A</code> on worker 3, while the value of <code>Main.A</code> on node 1 is set to <code>nothing</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記のスニペットを実行すると、ワーカー2の <code>Main.A</code> はワーカー3の <code>Main.A</code> とは異なる値を持ち、ノード1の <code>Main.A</code> の値は <code>nothing</code> に設定されます。</span></p></li></ul><p data-translated="true"><span class="original-text">As you may have realized, while memory associated with globals may be collected when they are reassigned on the master, no such action is taken on the workers as the bindings continue to be valid. <a href="../../stdlib/Distributed/index.html#Distributed.clear!"><code>clear!</code></a> can be used to manually reassign specific globals on remote nodes to <code>nothing</code> once they are no longer required. This will release any memory associated with them as part of a regular garbage collection cycle.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ご存知のように、グローバルに関連付けられたメモリは、マスターで再割り当てされると収集される可能性がありますが、バインディングが有効であり続けるため、ワーカーではそのようなアクションは行われません。<a href="../../stdlib/Distributed/index.html#Distributed.clear!"><code>clear!</code></a> を使用して、もはや必要ない場合にリモートノード上の特定のグローバルを <code>nothing</code> に手動で再割り当てすることができます。これにより、通常のガーベジコレクションサイクルの一部として、それに関連付けられたメモリが解放されます。</span></p><p data-translated="true"><span class="original-text">Thus programs should be careful referencing globals in remote calls. In fact, it is preferable to avoid them altogether if possible. If you must reference globals, consider using <code>let</code> blocks to localize global variables.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、プログラムはリモート呼び出しでグローバルを参照する際に注意が必要です。実際、可能であればグローバルを完全に避けることが望ましいです。グローバルを参照する必要がある場合は、<code>let</code> ブロックを使用してグローバル変数をローカライズすることを検討してください。</span></p><p data-translated="true"><span class="original-text">For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば:</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(10,10);

julia&gt; remotecall_fetch(()-&gt;A, 2);

julia&gt; B = rand(10,10);

julia&gt; let B = B
           remotecall_fetch(()-&gt;B, 2)
       end;

julia&gt; @fetchfrom 2 InteractiveUtils.varinfo()
name           size summary
––––––––– ––––––––– ––––––––––––––––––––––
A         800 bytes 10×10 Array{Float64,2}
Base                Module
Core                Module
Main                Module</code></pre><p data-translated="true"><span class="original-text">As can be seen, global variable <code>A</code> is defined on worker 2, but <code>B</code> is captured as a local variable and hence a binding for <code>B</code> does not exist on worker 2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ご覧の通り、グローバル変数 <code>A</code> はワーカー2で定義されていますが、<code>B</code> はローカル変数としてキャプチャされているため、ワーカー2には <code>B</code> のバインディングは存在しません。</span></p><h2 id="Parallel-Map-and-Loops" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Parallel-Map-and-Loops">Parallel Map and Loops</a><a id="Parallel-Map-and-Loops-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Map-and-Loops" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Parallel-Map-and-Loops">並列マップとループ</a><a id="Parallel-Map-and-Loops-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Map-and-Loops" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> to flip coins on two processes. First, write the following function in <code>count_heads.jl</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">幸いなことに、多くの有用な並列計算はデータ移動を必要としません。一般的な例はモンテカルロシミュレーションであり、複数のプロセスが独立したシミュレーショントライアルを同時に処理できます。コインを2つのプロセスで投げるために、<a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> を使用できます。まず、次の関数を <code>count_heads.jl</code> に書きます：</span></p><pre><code class="language-julia hljs">function count_heads(n)
    c::Int = 0
    for i = 1:n
        c += rand(Bool)
    end
    c
end</code></pre><p data-translated="true"><span class="original-text">The function <code>count_heads</code> simply adds together <code>n</code> random bits. Here is how we can perform some trials on two machines, and add together the results:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数 <code>count_heads</code> は単に <code>n</code> 個のランダムビットを合計します。ここでは、2台のマシンでいくつかのトライアルを実行し、結果を合計する方法を示します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @everywhere include_string(Main, $(read("count_heads.jl", String)), "count_heads.jl")

julia&gt; a = @spawnat :any count_heads(100000000)
Future(2, 1, 6, nothing)

julia&gt; b = @spawnat :any count_heads(100000000)
Future(3, 1, 7, nothing)

julia&gt; fetch(a)+fetch(b)
100001564</code></pre><p data-translated="true"><span class="original-text">This example demonstrates a powerful and often-used parallel programming pattern. Many iterations run independently over several processes, and then their results are combined using some function. The combination process is called a <em>reduction</em>, since it is generally tensor-rank-reducing: a vector of numbers is reduced to a single number, or a matrix is reduced to a single row or column, etc. In code, this typically looks like the pattern <code>x = f(x,v[i])</code>, where <code>x</code> is the accumulator, <code>f</code> is the reduction function, and the <code>v[i]</code> are the elements being reduced. It is desirable for <code>f</code> to be associative, so that it does not matter what order the operations are performed in.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例は、強力でよく使われる並列プログラミングパターンを示しています。多くの反復が複数のプロセスで独立して実行され、その結果がいくつかの関数を使用して結合されます。この結合プロセスは <em>還元</em> と呼ばれ、一般的にはテンソルランクを減少させるものです：数のベクトルが単一の数に減少したり、行列が単一の行または列に減少したりします。コードでは、通常 <code>x = f(x,v[i])</code> のパターンのように見えます。ここで <code>x</code> はアキュムレータ、<code>f</code> は還元関数、<code>v[i]</code> は減少される要素です。<code>f</code> が結合的であることが望ましいため、操作が行われる順序は重要ではありません。</span></p><p data-translated="true"><span class="original-text">Notice that our use of this pattern with <code>count_heads</code> can be generalized. We used two explicit <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> statements, which limits the parallelism to two processes. To run on any number of processes, we can use a <em>parallel for loop</em>, running in distributed memory, which can be written in Julia using <a href="../../stdlib/Distributed/index.html#Distributed.@distributed"><code>@distributed</code></a> like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このパターンを <code>count_heads</code> で使用することは一般化できます。私たちは2つの明示的な <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> ステートメントを使用しましたが、これにより並列性が2つのプロセスに制限されます。任意の数のプロセスで実行するには、分散メモリで実行される <em>並列forループ</em> を使用できます。これは、Juliaで <a href="../../stdlib/Distributed/index.html#Distributed.@distributed"><code>@distributed</code></a> を使用して次のように書くことができます：</span></p><pre><code class="language-julia hljs">nheads = @distributed (+) for i = 1:200000000
    Int(rand(Bool))
end</code></pre><p data-translated="true"><span class="original-text">This construct implements the pattern of assigning iterations to multiple processes, and combining them with a specified reduction (in this case <code>(+)</code>). The result of each iteration is taken as the value of the last expression inside the loop. The whole parallel loop expression itself evaluates to the final answer.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この構文は、反復を複数のプロセスに割り当て、指定された還元（この場合は <code>(+)</code>）で結合するパターンを実装します。各反復の結果は、ループ内の最後の式の値として取得されます。全体の並列ループ式自体は最終的な答えを評価します。</span></p><p data-translated="true"><span class="original-text">Note that although parallel for loops look like serial for loops, their behavior is dramatically different. In particular, the iterations do not happen in a specified order, and writes to variables or arrays will not be globally visible since iterations run on different processes. Any variables used inside the parallel loop will be copied and broadcast to each process.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">並列forループは直列forループのように見えますが、その動作は大きく異なります。特に、反復は指定された順序で発生せず、変数や配列への書き込みは異なるプロセスで実行されるため、グローバルに可視ではありません。並列ループ内で使用される変数は、各プロセスにコピーされてブロードキャストされます。</span></p><p data-translated="true"><span class="original-text">For example, the following code will not work as intended:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、次のコードは意図した通りには動作しません：</span></p><pre><code class="language-julia hljs">a = zeros(100000)
@distributed for i = 1:100000
    a[i] = i
end</code></pre><p data-translated="true"><span class="original-text">This code will not initialize all of <code>a</code>, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately, <a href="#man-shared-arrays">Shared Arrays</a> can be used to get around this limitation:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このコードは <code>a</code> のすべてを初期化しません。なぜなら、各プロセスはそれの別々のコピーを持つからです。このような並列forループは避けるべきです。幸いなことに、<a href="#man-shared-arrays">共有配列</a> を使用してこの制限を回避できます：</span></p><pre><code class="language-julia hljs">using SharedArrays

a = SharedArray{Float64}(10)
@distributed for i = 1:10
    a[i] = i
end</code></pre><p data-translated="true"><span class="original-text">Using "outside" variables in parallel loops is perfectly reasonable if the variables are read-only:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">"外部"変数を並列ループで使用することは、変数が読み取り専用であれば完全に合理的です：</span></p><pre><code class="language-julia hljs">a = randn(1000)
@distributed (+) for i = 1:100000
    f(a[rand(1:end)])
end</code></pre><p data-translated="true"><span class="original-text">Here each iteration applies <code>f</code> to a randomly-chosen sample from a vector <code>a</code> shared by all processes.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、各イテレーションがすべてのプロセスで共有されるベクトル<code>a</code>からランダムに選ばれたサンプルに<code>f</code>を適用します。</span></p><p data-translated="true"><span class="original-text">As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes asynchronously, i.e. it spawns independent tasks on all available workers and returns an array of <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> immediately without waiting for completion. The caller can wait for the <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> completions at a later point by calling <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> on them, or wait for completion at the end of the loop by prefixing it with <a href="../../base/parallel/index.html#Base.@sync"><code>@sync</code></a>, like <code>@sync @distributed for</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ご覧の通り、必要ない場合は削減演算子を省略できます。その場合、ループは非同期に実行され、すなわち、すべての利用可能なワーカーで独立したタスクを生成し、完了を待たずに<code>Future</code>の配列を即座に返します。呼び出し元は、<a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>の完了を後で<a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a>を呼び出すことで待つことができるか、<a href="../../base/parallel/index.html#Base.@sync"><code>@sync</code></a>でプレフィックスを付けてループの最後で完了を待つことができます。例えば、<code>@sync @distributed for</code>のように。</span></p><p data-translated="true"><span class="original-text">In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some range (or, more generally, to all elements in some collection). This is another useful operation called <em>parallel map</em>, implemented in Julia as the <a href="../../stdlib/Distributed/index.html#Distributed.pmap"><code>pmap</code></a> function. For example, we could compute the singular values of several large random matrices in parallel as follows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">場合によっては、削減演算子は必要なく、特定の範囲内のすべての整数（または、より一般的には、コレクション内のすべての要素）に関数を適用したいだけです。これは<em>並列マップ</em>と呼ばれる別の便利な操作で、Juliaでは<a href="../../stdlib/Distributed/index.html#Distributed.pmap"><code>pmap</code></a>関数として実装されています。例えば、次のようにして、いくつかの大きなランダム行列の特異値を並列に計算できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; M = Matrix{Float64}[rand(1000,1000) for i = 1:10];

julia&gt; pmap(svdvals, M);</code></pre><p data-translated="true"><span class="original-text">Julia's <a href="../../stdlib/Distributed/index.html#Distributed.pmap"><code>pmap</code></a> is designed for the case where each function call does a large amount of work. In contrast, <code>@distributed for</code> can handle situations where each iteration is tiny, perhaps merely summing two numbers. Only worker processes are used by both <a href="../../stdlib/Distributed/index.html#Distributed.pmap"><code>pmap</code></a> and <code>@distributed for</code> for the parallel computation. In case of <code>@distributed for</code>, the final reduction is done on the calling process.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの<a href="../../stdlib/Distributed/index.html#Distributed.pmap"><code>pmap</code></a>は、各関数呼び出しが大量の作業を行う場合に設計されています。それに対して、<code>@distributed for</code>は、各イテレーションが非常に小さい場合、例えば単に二つの数を合計する場合を処理できます。並列計算には、<a href="../../stdlib/Distributed/index.html#Distributed.pmap"><code>pmap</code></a>と<code>@distributed for</code>の両方でワーカープロセスのみが使用されます。<code>@distributed for</code>の場合、最終的な削減は呼び出しプロセスで行われます。</span></p><h2 id="Remote-References-and-AbstractChannels" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Remote-References-and-AbstractChannels">Remote References and AbstractChannels</a><a id="Remote-References-and-AbstractChannels-1"></a><a class="docs-heading-anchor-permalink" href="#Remote-References-and-AbstractChannels" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Remote-References-and-AbstractChannels">リモート参照とAbstractChannels</a><a id="Remote-References-and-AbstractChannels-1"></a><a class="docs-heading-anchor-permalink" href="#Remote-References-and-AbstractChannels" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Remote references always refer to an implementation of an <code>AbstractChannel</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リモート参照は常に<code>AbstractChannel</code>の実装を指します。</span></p><p data-translated="true"><span class="original-text">A concrete implementation of an <code>AbstractChannel</code> (like <code>Channel</code>), is required to implement <a href="../../base/parallel/index.html#Base.put!-Tuple{Channel, Any}"><code>put!</code></a>, <a href="../../base/io-network/index.html#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a>, <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a>, <a href="../../base/parallel/index.html#Base.isready-Tuple{Channel}"><code>isready</code></a> and <a href="../../base/parallel/index.html#Base.wait"><code>wait</code></a>. The remote object referred to by a <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> is stored in a <code>Channel{Any}(1)</code>, i.e., a <code>Channel</code> of size 1 capable of holding objects of <code>Any</code> type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>AbstractChannel</code>（<code>Channel</code>のような）の具体的な実装は、<a href="../../base/parallel/index.html#Base.put!-Tuple{Channel, Any}"><code>put!</code></a>、<a href="../../base/io-network/index.html#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a>、<a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a>、<a href="../../base/parallel/index.html#Base.isready-Tuple{Channel}"><code>isready</code></a>、および<a href="../../base/parallel/index.html#Base.wait"><code>wait</code></a>を実装する必要があります。<a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>によって参照されるリモートオブジェクトは、<code>Channel{Any}(1)</code>に格納されます。すなわち、<code>Any</code>型のオブジェクトを保持できるサイズ1の<code>Channel</code>です。</span></p><p data-translated="true"><span class="original-text"><a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>, which is rewritable, can point to any type and size of channels, or any other implementation of an <code>AbstractChannel</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>は書き換え可能で、任意のタイプとサイズのチャネル、または他の<code>AbstractChannel</code>の実装を指すことができます。</span></p><p data-translated="true"><span class="original-text">The constructor <code>RemoteChannel(f::Function, pid)()</code> allows us to construct references to channels holding more than one value of a specific type. <code>f</code> is a function executed on <code>pid</code> and it must return an <code>AbstractChannel</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コンストラクタ<code>RemoteChannel(f::Function, pid)()</code>は、特定の型の複数の値を保持するチャネルへの参照を構築することを可能にします。<code>f</code>は<code>pid</code>で実行される関数であり、<code>AbstractChannel</code>を返す必要があります。</span></p><p data-translated="true"><span class="original-text">For example, <code>RemoteChannel(()-&gt;Channel{Int}(10), pid)</code>, will return a reference to a channel of type <code>Int</code> and size 10. The channel exists on worker <code>pid</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、<code>RemoteChannel(()-&gt;Channel{Int}(10), pid)</code>は、型<code>Int</code>でサイズ10のチャネルへの参照を返します。このチャネルはワーカー<code>pid</code>上に存在します。</span></p><p data-translated="true"><span class="original-text">Methods <a href="../../base/parallel/index.html#Base.put!-Tuple{Channel, Any}"><code>put!</code></a>, <a href="../../base/io-network/index.html#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a>, <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a>, <a href="../../base/parallel/index.html#Base.isready-Tuple{Channel}"><code>isready</code></a> and <a href="../../base/parallel/index.html#Base.wait"><code>wait</code></a> on a <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> are proxied onto the backing store on the remote process.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メソッド<a href="../../base/parallel/index.html#Base.put!-Tuple{Channel, Any}"><code>put!</code></a>、<a href="../../base/io-network/index.html#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a>、<a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a>、<a href="../../base/parallel/index.html#Base.isready-Tuple{Channel}"><code>isready</code></a>および<a href="../../base/parallel/index.html#Base.wait"><code>wait</code></a>は、<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>上でリモートプロセスのバックストアにプロキシされます。</span></p><p data-translated="true"><span class="original-text"><a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> can thus be used to refer to user implemented <code>AbstractChannel</code> objects. A simple example of this is the following <code>DictChannel</code> which uses a dictionary as its remote store:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>は、ユーザーが実装した<code>AbstractChannel</code>オブジェクトを参照するために使用できます。これの簡単な例は、辞書をリモートストアとして使用する以下の<code>DictChannel</code>です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct DictChannel{T} &lt;: AbstractChannel{T}
           d::Dict
           cond_take::Threads.Condition    # waiting for data to become available
           DictChannel{T}() where {T} = new(Dict(), Threads.Condition())
           DictChannel() = DictChannel{Any}()
       end

julia&gt; begin
       function Base.put!(D::DictChannel, k, v)
           @lock D.cond_take begin
               D.d[k] = v
               notify(D.cond_take)
           end
           return D
       end
       function Base.take!(D::DictChannel, k)
           @lock D.cond_take begin
               v = fetch(D, k)
               delete!(D.d, k)
               return v
           end
       end
       Base.isready(D::DictChannel) = @lock D.cond_take !isempty(D.d)
       Base.isready(D::DictChannel, k) = @lock D.cond_take haskey(D.d, k)
       function Base.fetch(D::DictChannel, k)
           @lock D.cond_take begin
               wait(D, k)
               return D.d[k]
           end
       end
       function Base.wait(D::DictChannel, k)
           @lock D.cond_take begin
               while !isready(D, k)
                   wait(D.cond_take)
               end
           end
       end
       end;

julia&gt; d = DictChannel();

julia&gt; isready(d)
false

julia&gt; put!(d, :k, :v);

julia&gt; isready(d, :k)
true

julia&gt; fetch(d, :k)
:v

julia&gt; wait(d, :k)

julia&gt; take!(d, :k)
:v

julia&gt; isready(d, :k)
false</code></pre><h2 id="Channels-and-RemoteChannels" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Channels-and-RemoteChannels">Channels and RemoteChannels</a><a id="Channels-and-RemoteChannels-1"></a><a class="docs-heading-anchor-permalink" href="#Channels-and-RemoteChannels" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Channels-and-RemoteChannels">チャネルとリモートチャネル</a><a id="Channels-and-RemoteChannels-1"></a><a class="docs-heading-anchor-permalink" href="#Channels-and-RemoteChannels" title="Permalink"></a></span></h2><ul><li data-translated="true"><span class="original-text">A <a href="../../base/parallel/index.html#Base.Channel"><code>Channel</code></a> is local to a process. Worker 2 cannot directly refer to a <a href="../../base/parallel/index.html#Base.Channel"><code>Channel</code></a> on worker 3 and vice-versa. A <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>, however, can put and take values across workers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/parallel/index.html#Base.Channel"><code>Channel</code></a>はプロセスにローカルです。ワーカー2はワーカー3の<a href="../../base/parallel/index.html#Base.Channel"><code>Channel</code></a>を直接参照することはできず、その逆も同様です。しかし、<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>は、ワーカー間で値を送受信できます。</span></li><li data-translated="true"><span class="original-text">A <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> can be thought of as a <em>handle</em> to a <a href="../../base/parallel/index.html#Base.Channel"><code>Channel</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>は、<a href="../../base/parallel/index.html#Base.Channel"><code>Channel</code></a>への<em>ハンドル</em>として考えることができます。</span></li><li data-translated="true"><span class="original-text">The process id, <code>pid</code>, associated with a <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> identifies the process where the backing store, i.e., the backing <a href="../../base/parallel/index.html#Base.Channel"><code>Channel</code></a> exists.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>pid</code>というプロセスIDは、<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>に関連付けられたプロセスを特定し、バックストア、すなわちバックの<a href="../../base/parallel/index.html#Base.Channel"><code>Channel</code></a>が存在するプロセスを識別します。</span></li><li data-translated="true"><span class="original-text">Any process with a reference to a <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> can put and take items from the channel. Data is automatically sent to (or retrieved from) the process a <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> is associated with.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リモートチャネルへの参照を持つ任意のプロセスは、チャネルからアイテムを送受信できます。データは、自動的に<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>が関連付けられているプロセスに送信（または取得）されます。</span></li><li data-translated="true"><span class="original-text">Serializing  a <a href="../../base/parallel/index.html#Base.Channel"><code>Channel</code></a> also serializes any data present in the channel. Deserializing it therefore effectively makes a copy of the original object.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/parallel/index.html#Base.Channel"><code>Channel</code></a>をシリアライズすると、チャネル内に存在するデータもシリアライズされます。したがって、デシリアライズすると元のオブジェクトのコピーが実質的に作成されます。</span></li><li data-translated="true"><span class="original-text">On the other hand, serializing a <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> only involves the serialization of an identifier that identifies the location and instance of <a href="../../base/parallel/index.html#Base.Channel"><code>Channel</code></a> referred to by the handle. A deserialized <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> object (on any worker), therefore also points to the same backing store as the original.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一方、<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>をシリアライズすることは、ハンドルによって参照される<a href="../../base/parallel/index.html#Base.Channel"><code>Channel</code></a>の位置とインスタンスを識別する識別子のシリアライズのみを含みます。したがって、デシリアライズされた<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>オブジェクト（任意のワーカー上）は、元のものと同じバックストアを指します。</span></li></ul><p data-translated="true"><span class="original-text">The channels example from above can be modified for interprocess communication, as shown below.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記のチャネルの例は、プロセス間通信のために修正できます。以下に示します。</span></p><p data-translated="true"><span class="original-text">We start 4 workers to process a single <code>jobs</code> remote channel. Jobs, identified by an id (<code>job_id</code>), are written to the channel. Each remotely executing task in this simulation reads a <code>job_id</code>, waits for a random amount of time and writes back a tuple of <code>job_id</code>, time taken and its own <code>pid</code> to the results channel. Finally all the <code>results</code> are printed out on the master process.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">単一の <code>jobs</code> リモートチャネルを処理するために4つのワーカーを起動します。ジョブは、id (<code>job_id</code>) によって識別され、チャネルに書き込まれます。このシミュレーション内の各リモート実行タスクは <code>job_id</code> を読み取り、ランダムな時間待機し、<code>job_id</code>、かかった時間、および自分の <code>pid</code> のタプルを結果チャネルに書き戻します。最後に、すべての <code>results</code> がマスタープロセスで出力されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; addprocs(4); # add worker processes

julia&gt; const jobs = RemoteChannel(()-&gt;Channel{Int}(32));

julia&gt; const results = RemoteChannel(()-&gt;Channel{Tuple}(32));

julia&gt; @everywhere function do_work(jobs, results) # define work function everywhere
           while true
               job_id = take!(jobs)
               exec_time = rand()
               sleep(exec_time) # simulates elapsed time doing actual work
               put!(results, (job_id, exec_time, myid()))
           end
       end

julia&gt; function make_jobs(n)
           for i in 1:n
               put!(jobs, i)
           end
       end;

julia&gt; n = 12;

julia&gt; errormonitor(Threads.@spawn make_jobs(n)); # feed the jobs channel with "n" jobs

julia&gt; for p in workers() # start tasks on the workers to process requests in parallel
           remote_do(do_work, p, jobs, results)
       end

julia&gt; @elapsed while n &gt; 0 # print out results
           job_id, exec_time, where = take!(results)
           println("$job_id finished in $(round(exec_time; digits=2)) seconds on worker $where")
           global n = n - 1
       end
1 finished in 0.18 seconds on worker 4
2 finished in 0.26 seconds on worker 5
6 finished in 0.12 seconds on worker 4
7 finished in 0.18 seconds on worker 4
5 finished in 0.35 seconds on worker 5
4 finished in 0.68 seconds on worker 2
3 finished in 0.73 seconds on worker 3
11 finished in 0.01 seconds on worker 3
12 finished in 0.02 seconds on worker 3
9 finished in 0.26 seconds on worker 5
8 finished in 0.57 seconds on worker 4
10 finished in 0.58 seconds on worker 2
0.055971741</code></pre><h3 id="Remote-References-and-Distributed-Garbage-Collection" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Remote-References-and-Distributed-Garbage-Collection">Remote References and Distributed Garbage Collection</a><a id="Remote-References-and-Distributed-Garbage-Collection-1"></a><a class="docs-heading-anchor-permalink" href="#Remote-References-and-Distributed-Garbage-Collection" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Remote-References-and-Distributed-Garbage-Collection">リモート参照と分散ガーベジコレクション</a><a id="Remote-References-and-Distributed-Garbage-Collection-1"></a><a class="docs-heading-anchor-permalink" href="#Remote-References-and-Distributed-Garbage-Collection" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Objects referred to by remote references can be freed only when <em>all</em> held references in the cluster are deleted.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リモート参照によって参照されるオブジェクトは、クラスター内のすべての保持された参照が削除されるまで解放できません。</span></p><p data-translated="true"><span class="original-text">The node where the value is stored keeps track of which of the workers have a reference to it. Every time a <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> or a (unfetched) <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> is serialized to a worker, the node pointed to by the reference is notified. And every time a <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> or a (unfetched) <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> is garbage collected locally, the node owning the value is again notified. This is implemented in an internal cluster aware serializer. Remote references are only valid in the context of a running cluster. Serializing and deserializing references to and from regular <code>IO</code> objects is not supported.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">値が保存されているノードは、それを参照しているワーカーを追跡します。<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> または (未取得の) <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> がワーカーにシリアライズされるたびに、参照が指すノードに通知されます。そして、<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> または (未取得の) <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> がローカルでガーベジコレクトされるたびに、値を所有するノードに再度通知されます。これは、内部のクラスター認識シリアライザーで実装されています。リモート参照は、実行中のクラスターのコンテキスト内でのみ有効です。通常の <code>IO</code> オブジェクトへの参照のシリアライズおよびデシリアライズはサポートされていません。</span></p><p data-translated="true"><span class="original-text">The notifications are done via sending of "tracking" messages–an "add reference" message when a reference is serialized to a different process and a "delete reference" message when a reference is locally garbage collected.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">通知は、「トラッキング」メッセージの送信を介して行われます。異なるプロセスにシリアライズされるときの「参照を追加」メッセージと、ローカルでガーベジコレクトされるときの「参照を削除」メッセージです。</span></p><p data-translated="true"><span class="original-text">Since <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>s are write-once and cached locally, the act of <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a>ing a <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> also updates reference tracking information on the node owning the value.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リモート <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> は一度書き込み可能でローカルにキャッシュされるため、<a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> する行為は、値を所有するノードの参照トラッキング情報も更新します。</span></p><p data-translated="true"><span class="original-text">The node which owns the value frees it once all references to it are cleared.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">値を所有するノードは、すべての参照がクリアされると、それを解放します。</span></p><p data-translated="true"><span class="original-text">With <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>s, serializing an already fetched <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> to a different node also sends the value since the original remote store may have collected the value by this time.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> を使用する場合、すでに取得された <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> を別のノードにシリアライズすると、元のリモートストアがこの時点で値を収集している可能性があるため、値も送信されます。</span></p><p data-translated="true"><span class="original-text">It is important to note that <em>when</em> an object is locally garbage collected depends on the size of the object and the current memory pressure in the system.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">オブジェクトがローカルでガーベジコレクトされる「時期」は、オブジェクトのサイズとシステム内の現在のメモリ圧力に依存することに注意することが重要です。</span></p><p data-translated="true"><span class="original-text">In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite large. Since the local object may not be collected immediately, it is a good practice to explicitly call <a href="../../base/base/index.html#Base.finalize"><code>finalize</code></a> on local instances of a <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>, or on unfetched <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>s. Since calling <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> on a <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> also removes its reference from the remote store, this is not required on fetched <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>s. Explicitly calling <a href="../../base/base/index.html#Base.finalize"><code>finalize</code></a> results in an immediate message sent to the remote node to go ahead and remove its reference to the value.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リモート参照の場合、ローカル参照オブジェクトのサイズは非常に小さいですが、リモートノードに保存されている値は非常に大きい場合があります。ローカルオブジェクトはすぐに収集されない可能性があるため、<a href="../../base/base/index.html#Base.finalize"><code>finalize</code></a>をローカルインスタンスの<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>や未取得の<a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>に対して明示的に呼び出すことが良いプラクティスです。<a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>に対して<a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a>を呼び出すことは、リモートストアからその参照を削除するため、取得済みの<a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>に対しては必要ありません。<a href="../../base/base/index.html#Base.finalize"><code>finalize</code></a>を明示的に呼び出すことで、リモートノードに対してその値への参照を削除するように即座にメッセージが送信されます。</span></p><p data-translated="true"><span class="original-text">Once finalized, a reference becomes invalid and cannot be used in any further calls.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一度ファイナライズされると、参照は無効になり、以降の呼び出しには使用できなくなります。</span></p><h2 id="Local-invocations" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Local-invocations">Local invocations</a><a id="Local-invocations-1"></a><a class="docs-heading-anchor-permalink" href="#Local-invocations" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Local-invocations">ローカル呼び出し</a><a id="Local-invocations-1"></a><a class="docs-heading-anchor-permalink" href="#Local-invocations" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Data is necessarily copied over to the remote node for execution. This is the case for both remotecalls and when data is stored to a <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> / <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a> on a different node. As expected, this results in a copy of the serialized objects on the remote node. However, when the destination node is the local node, i.e. the calling process id is the same as the remote node id, it is executed as a local call. It is usually (not always) executed in a different task - but there is no serialization/deserialization of data. Consequently, the call refers to the same object instances as passed - no copies are created. This behavior is highlighted below:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">データは実行のためにリモートノードに必ずコピーされます。これはリモートコールと、データが異なるノードの<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> / <a href="../../stdlib/Distributed/index.html#Distributed.Future"><code>Future</code></a>に保存される場合の両方に当てはまります。予想通り、これによりリモートノード上にシリアライズされたオブジェクトのコピーが作成されます。しかし、宛先ノードがローカルノード、つまり呼び出しプロセスIDがリモートノードIDと同じである場合、これはローカル呼び出しとして実行されます。通常（常にではありませんが）、異なるタスクで実行されますが、データのシリアライズ/デシリアライズは行われません。その結果、呼び出しは渡された同じオブジェクトインスタンスを参照します - コピーは作成されません。この動作は以下に示されています。</span></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributed

julia&gt; rc = RemoteChannel(()-&gt;Channel(3));   # RemoteChannel created on local node

julia&gt; v = [0];

julia&gt; for i in 1:3
           v[1] = i                          # Reusing `v`
           put!(rc, v)
       end;

julia&gt; result = [take!(rc) for _ in 1:3];

julia&gt; println(result);
[[3], [3], [3]]

julia&gt; println("Num Unique objects : ", length(unique(map(objectid, result))));
Num Unique objects : 1

julia&gt; addprocs(1);

julia&gt; rc = RemoteChannel(()-&gt;Channel(3), workers()[1]);   # RemoteChannel created on remote node

julia&gt; v = [0];

julia&gt; for i in 1:3
           v[1] = i
           put!(rc, v)
       end;

julia&gt; result = [take!(rc) for _ in 1:3];

julia&gt; println(result);
[[1], [2], [3]]

julia&gt; println("Num Unique objects : ", length(unique(map(objectid, result))));
Num Unique objects : 3</code></pre><p data-translated="true"><span class="original-text">As can be seen, <a href="../../base/parallel/index.html#Base.put!-Tuple{Channel, Any}"><code>put!</code></a> on a locally owned <a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a> with the same object <code>v</code> modified between calls results in the same single object instance stored. As opposed to copies of <code>v</code> being created when the node owning <code>rc</code> is a different node.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ご覧の通り、ローカルに所有されている<a href="../../stdlib/Distributed/index.html#Distributed.RemoteChannel"><code>RemoteChannel</code></a>に対して同じオブジェクト<code>v</code>を呼び出し間で変更した場合、同じ単一のオブジェクトインスタンスが保存されます。これは、<code>rc</code>を所有するノードが異なるノードである場合に<code>v</code>のコピーが作成されるのとは対照的です。</span></p><p data-translated="true"><span class="original-text">It is to be noted that this is generally not an issue. It is something to be factored in only if the object is both being stored locally and modified post the call. In such cases it may be appropriate to store a <code>deepcopy</code> of the object.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは一般的には問題ではないことに注意が必要です。オブジェクトがローカルに保存され、呼び出し後に変更される場合にのみ考慮すべきことです。そのような場合、オブジェクトの<code>deepcopy</code>を保存することが適切かもしれません。</span></p><p data-translated="true"><span class="original-text">This is also true for remotecalls on the local node as seen in the following example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、以下の例に見られるように、ローカルノードでのリモートコールにも当てはまります。</span></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributed; addprocs(1);

julia&gt; v = [0];

julia&gt; v2 = remotecall_fetch(x-&gt;(x[1] = 1; x), myid(), v);     # Executed on local node

julia&gt; println("v=$v, v2=$v2, ", v === v2);
v=[1], v2=[1], true

julia&gt; v = [0];

julia&gt; v2 = remotecall_fetch(x-&gt;(x[1] = 1; x), workers()[1], v); # Executed on remote node

julia&gt; println("v=$v, v2=$v2, ", v === v2);
v=[0], v2=[1], false</code></pre><p data-translated="true"><span class="original-text">As can be seen once again, a remote call onto the local node behaves just like a direct invocation. The call modifies local objects passed as arguments. In the remote invocation, it operates on a copy of the arguments.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">再度ご覧の通り、ローカルノードへのリモートコールは直接呼び出しと同様に動作します。呼び出しは引数として渡されたローカルオブジェクトを変更します。リモート呼び出しでは、引数のコピーで操作します。</span></p><p data-translated="true"><span class="original-text">To repeat, in general this is not an issue. If the local node is also being used as a compute node, and the arguments used post the call, this behavior needs to be factored in and if required deep copies of arguments must be passed to the call invoked on the local node. Calls on remote nodes will always operate on copies of arguments.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">繰り返しになりますが、一般的にはこれは問題ではありません。ローカルノードが計算ノードとしても使用され、呼び出し後に使用される引数がある場合、この動作を考慮する必要があり、必要に応じて引数のディープコピーをローカルノードで呼び出される呼び出しに渡す必要があります。リモートノードでの呼び出しは常に引数のコピーで操作します。</span></p><h2 id="man-shared-arrays" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-shared-arrays">Shared Arrays</a><a id="man-shared-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#man-shared-arrays" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-shared-arrays">共有配列</a><a id="man-shared-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#man-shared-arrays" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Shared Arrays use system shared memory to map the same array across many processes. A <a href="../../stdlib/SharedArrays/index.html#SharedArrays.SharedArray"><code>SharedArray</code></a> is a good choice when you want to have a large amount of data jointly accessible to two or more processes on the same machine. Shared Array support is available via the module <code>SharedArrays</code>, which must be explicitly loaded on all participating workers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Shared Arraysは、システム共有メモリを使用して、複数のプロセス間で同じ配列をマッピングします。<a href="../../stdlib/SharedArrays/index.html#SharedArrays.SharedArray"><code>SharedArray</code></a>は、同じマシン上で2つ以上のプロセスが共同でアクセスできる大量のデータを持ちたい場合に適した選択肢です。Shared Arrayのサポートは、すべての参加ワーカーで明示的にロードする必要があるモジュール<code>SharedArrays</code>を介して利用可能です。</span></p><p data-translated="true"><span class="original-text">A complementary data structure is provided by the external package <a href="https://github.com/JuliaParallel/DistributedArrays.jl"><code>DistributedArrays.jl</code></a> in the form of a <code>DArray</code>. While there are some similarities to a <a href="../../stdlib/SharedArrays/index.html#SharedArrays.SharedArray"><code>SharedArray</code></a>, the behavior of a <a href="https://github.com/JuliaParallel/DistributedArrays.jl"><code>DArray</code></a> is quite different. In a <a href="../../stdlib/SharedArrays/index.html#SharedArrays.SharedArray"><code>SharedArray</code></a>, each "participating" process has access to the entire array; in contrast, in a <a href="https://github.com/JuliaParallel/DistributedArrays.jl"><code>DArray</code></a>, each process has local access to just a chunk of the data, and no two processes share the same chunk.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">補完的なデータ構造は、外部パッケージ<a href="https://github.com/JuliaParallel/DistributedArrays.jl"><code>DistributedArrays.jl</code></a>によって<code>DArray</code>の形で提供されます。<a href="../../stdlib/SharedArrays/index.html#SharedArrays.SharedArray"><code>SharedArray</code></a>とのいくつかの類似点はありますが、<a href="https://github.com/JuliaParallel/DistributedArrays.jl"><code>DArray</code></a>の動作はかなり異なります。<a href="../../stdlib/SharedArrays/index.html#SharedArrays.SharedArray"><code>SharedArray</code></a>では、各「参加」プロセスが配列全体にアクセスできますが、<a href="https://github.com/JuliaParallel/DistributedArrays.jl"><code>DArray</code></a>では、各プロセスがデータの一部にのみローカルアクセスを持ち、2つのプロセスが同じチャンクを共有することはありません。</span></p><p data-translated="true"><span class="original-text"><a href="../../stdlib/SharedArrays/index.html#SharedArrays.SharedArray"><code>SharedArray</code></a> indexing (assignment and accessing values) works just as with regular arrays, and is efficient because the underlying memory is available to the local process. Therefore, most algorithms work naturally on <a href="../../stdlib/SharedArrays/index.html#SharedArrays.SharedArray"><code>SharedArray</code></a>s, albeit in single-process mode. In cases where an algorithm insists on an <a href="../../base/arrays/index.html#Core.Array"><code>Array</code></a> input, the underlying array can be retrieved from a <a href="../../stdlib/SharedArrays/index.html#SharedArrays.SharedArray"><code>SharedArray</code></a> by calling <a href="../../stdlib/SharedArrays/index.html#SharedArrays.sdata"><code>sdata</code></a>. For other <code>AbstractArray</code> types, <a href="../../stdlib/SharedArrays/index.html#SharedArrays.sdata"><code>sdata</code></a> just returns the object itself, so it's safe to use <a href="../../stdlib/SharedArrays/index.html#SharedArrays.sdata"><code>sdata</code></a> on any <code>Array</code>-type object.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/SharedArrays/index.html#SharedArrays.SharedArray"><code>SharedArray</code></a>のインデックス（値の代入とアクセス）は通常の配列と同様に機能し、基盤となるメモリがローカルプロセスに利用可能であるため効率的です。したがって、ほとんどのアルゴリズムは、単一プロセスモードであっても<a href="../../stdlib/SharedArrays/index.html#SharedArrays.SharedArray"><code>SharedArray</code></a>上で自然に動作します。アルゴリズムが<a href="../../base/arrays/index.html#Core.Array"><code>Array</code></a>入力を要求する場合、基盤となる配列は<a href="../../stdlib/SharedArrays/index.html#SharedArrays.SharedArray"><code>SharedArray</code></a>から<a href="../../stdlib/SharedArrays/index.html#SharedArrays.sdata"><code>sdata</code></a>を呼び出すことで取得できます。他の<code>AbstractArray</code>タイプの場合、<a href="../../stdlib/SharedArrays/index.html#SharedArrays.sdata"><code>sdata</code></a>はオブジェクト自体を返すだけなので、<a href="../../stdlib/SharedArrays/index.html#SharedArrays.sdata"><code>sdata</code></a>を任意の<code>Array</code>-タイプのオブジェクトで使用することは安全です。</span></p><p data-translated="true"><span class="original-text">The constructor for a shared array is of the form:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">共有配列のコンストラクタは次の形式です：</span></p><pre><code class="language-julia hljs">SharedArray{T,N}(dims::NTuple; init=false, pids=Int[])</code></pre><p data-translated="true"><span class="original-text">which creates an <code>N</code>-dimensional shared array of a bits type <code>T</code> and size <code>dims</code> across the processes specified by <code>pids</code>. Unlike distributed arrays, a shared array is accessible only from those participating workers specified by the <code>pids</code> named argument (and the creating process too, if it is on the same host). Note that only elements that are <a href="../../base/base/index.html#Base.isbits"><code>isbits</code></a> are supported in a SharedArray.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、<code>pids</code>で指定されたプロセス間で、ビット型<code>T</code>の<code>N</code>次元の共有配列を作成します。分散配列とは異なり、共有配列は<code>pids</code>の名前付き引数で指定された参加ワーカーからのみアクセス可能です（同じホスト上にいる場合は作成プロセスも含まれます）。<code>SharedArray</code>では、<a href="../../base/base/index.html#Base.isbits"><code>isbits</code></a>である要素のみがサポートされていることに注意してください。</span></p><p data-translated="true"><span class="original-text">If an <code>init</code> function, of signature <code>initfn(S::SharedArray)</code>, is specified, it is called on all the participating workers. You can specify that each worker runs the <code>init</code> function on a distinct portion of the array, thereby parallelizing initialization.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もし<code>init</code>関数（シグネチャ<code>initfn(S::SharedArray)</code>）が指定されている場合、それはすべての参加ワーカーで呼び出されます。各ワーカーが配列の異なる部分で<code>init</code>関数を実行するように指定することで、初期化を並列化できます。</span></p><p data-translated="true"><span class="original-text">Here's a brief example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単な例を示します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributed

julia&gt; addprocs(3)
3-element Vector{Int64}:
 2
 3
 4

julia&gt; @everywhere using SharedArrays

julia&gt; S = SharedArray{Int,2}((3,4), init = S -&gt; S[localindices(S)] = repeat([myid()], length(localindices(S))))
3×4 SharedMatrix{Int64}:
 2  2  3  4
 2  3  3  4
 2  3  4  4

julia&gt; S[3,2] = 7
7

julia&gt; S
3×4 SharedMatrix{Int64}:
 2  2  3  4
 2  3  3  4
 2  7  4  4</code></pre><p data-translated="true"><span class="original-text"><a href="../../stdlib/SharedArrays/index.html#SharedArrays.localindices"><code>SharedArrays.localindices</code></a> provides disjoint one-dimensional ranges of indices, and is sometimes convenient for splitting up tasks among processes. You can, of course, divide the work any way you wish:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/SharedArrays/index.html#SharedArrays.localindices"><code>SharedArrays.localindices</code></a>は、プロセス間でタスクを分割するのに便利な、互いに重ならない1次元のインデックス範囲を提供します。もちろん、作業を任意の方法で分割することができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; S = SharedArray{Int,2}((3,4), init = S -&gt; S[indexpids(S):length(procs(S)):length(S)] = repeat([myid()], length( indexpids(S):length(procs(S)):length(S))))
3×4 SharedMatrix{Int64}:
 2  2  2  2
 3  3  3  3
 4  4  4  4</code></pre><p data-translated="true"><span class="original-text">Since all processes have access to the underlying data, you do have to be careful not to set up conflicts. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべてのプロセスが基盤となるデータにアクセスできるため、競合を設定しないように注意する必要があります。例えば：</span></p><pre><code class="language-julia hljs">@sync begin
    for p in procs(S)
        Threads.@spawn begin
            remotecall_wait(fill!, p, S, p)
        end
    end
end</code></pre><p data-translated="true"><span class="original-text">would result in undefined behavior. Because each process fills the <em>entire</em> array with its own <code>pid</code>, whichever process is the last to execute (for any particular element of <code>S</code>) will have its <code>pid</code> retained.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは未定義の動作を引き起こします。各プロセスが<em>全体</em>の配列を自分の<code>pid</code>で埋めるため、特定の<code>S</code>の要素に対して最後に実行されるプロセスがその<code>pid</code>を保持します。</span></p><p data-translated="true"><span class="original-text">As a more extended and complex example, consider running the following "kernel" in parallel:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より拡張され、複雑な例として、次の「カーネル」を並列で実行することを考えてみましょう：</span></p><pre><code class="language-julia hljs">q[i,j,t+1] = q[i,j,t] + u[i,j,t]</code></pre><p data-translated="true"><span class="original-text">In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if <code>q[i,j,t]</code> is near the end of the block assigned to one worker and <code>q[i,j,t+1]</code> is near the beginning of the block assigned to another, it's very likely that <code>q[i,j,t]</code> will not be ready at the time it's needed for computing <code>q[i,j,t+1]</code>. In such cases, one is better off chunking the array manually. Let's split along the second dimension. Define a function that returns the <code>(irange, jrange)</code> indices assigned to this worker:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この場合、1次元インデックスを使用して作業を分割しようとすると、問題が発生する可能性があります：もし<code>q[i,j,t]</code>が1人のワーカーに割り当てられたブロックの終わり近くにあり、<code>q[i,j,t+1]</code>が別のワーカーに割り当てられたブロックの始まり近くにある場合、<code>q[i,j,t]</code>が<code>q[i,j,t+1]</code>の計算に必要な時点で準備が整っていない可能性が非常に高いです。このような場合、配列を手動でチャンクに分割する方が良いでしょう。2次元目に沿って分割しましょう。このワーカーに割り当てられた<code>(irange, jrange)</code>インデックスを返す関数を定義します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @everywhere function myrange(q::SharedArray)
           idx = indexpids(q)
           if idx == 0 # This worker is not assigned a piece
               return 1:0, 1:0
           end
           nchunks = length(procs(q))
           splits = [round(Int, s) for s in range(0, stop=size(q,2), length=nchunks+1)]
           1:size(q,1), splits[idx]+1:splits[idx+1]
       end</code></pre><p data-translated="true"><span class="original-text">Next, define the kernel:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次に、カーネルを定義します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @everywhere function advection_chunk!(q, u, irange, jrange, trange)
           @show (irange, jrange, trange)  # display so we can see what's happening
           for t in trange, j in jrange, i in irange
               q[i,j,t+1] = q[i,j,t] + u[i,j,t]
           end
           q
       end</code></pre><p data-translated="true"><span class="original-text">We also define a convenience wrapper for a <code>SharedArray</code> implementation</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、<code>SharedArray</code>実装のための便利なラッパーも定義します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; @everywhere advection_shared_chunk!(q, u) =
           advection_chunk!(q, u, myrange(q)..., 1:size(q,3)-1)</code></pre><p data-translated="true"><span class="original-text">Now let's compare three different versions, one that runs in a single process:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さて、1つのプロセスで実行されるバージョン、</span></p><pre><code class="language-julia-repl hljs">julia&gt; advection_serial!(q, u) = advection_chunk!(q, u, 1:size(q,1), 1:size(q,2), 1:size(q,3)-1);</code></pre><p data-translated="true"><span class="original-text">one that uses <a href="../../stdlib/Distributed/index.html#Distributed.@distributed"><code>@distributed</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.@distributed"><code>@distributed</code></a>を使用するバージョン、</span></p><pre><code class="language-julia-repl hljs">julia&gt; function advection_parallel!(q, u)
           for t = 1:size(q,3)-1
               @sync @distributed for j = 1:size(q,2)
                   for i = 1:size(q,1)
                       q[i,j,t+1]= q[i,j,t] + u[i,j,t]
                   end
               end
           end
           q
       end;</code></pre><p data-translated="true"><span class="original-text">and one that delegates in chunks:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">およびチャンクで委任するバージョンの3つの異なるバージョンを比較してみましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function advection_shared!(q, u)
           @sync begin
               for p in procs(q)
                   Threads.@spawn remotecall_wait(advection_shared_chunk!, p, q, u)
               end
           end
           q
       end;</code></pre><p data-translated="true"><span class="original-text">If we create <code>SharedArray</code>s and time these functions, we get the following results (with <code>julia -p 4</code>):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>SharedArray</code>を作成し、これらの関数の実行時間を計測すると、次の結果が得られます（<code>julia -p 4</code>を使用）：</span></p><pre><code class="language-julia-repl hljs">julia&gt; q = SharedArray{Float64,3}((500,500,500));

julia&gt; u = SharedArray{Float64,3}((500,500,500));</code></pre><p data-translated="true"><span class="original-text">Run the functions once to JIT-compile and <a href="../profile/index.html#@time"><code>@time</code></a> them on the second run:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数を1回実行してJITコンパイルし、2回目の実行で<a href="../profile/index.html#@time"><code>@time</code></a>を計測します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @time advection_serial!(q, u);
(irange,jrange,trange) = (1:500,1:500,1:499)
 830.220 milliseconds (216 allocations: 13820 bytes)

julia&gt; @time advection_parallel!(q, u);
   2.495 seconds      (3999 k allocations: 289 MB, 2.09% gc time)

julia&gt; @time advection_shared!(q,u);
        From worker 2:       (irange,jrange,trange) = (1:500,1:125,1:499)
        From worker 4:       (irange,jrange,trange) = (1:500,251:375,1:499)
        From worker 3:       (irange,jrange,trange) = (1:500,126:250,1:499)
        From worker 5:       (irange,jrange,trange) = (1:500,376:500,1:499)
 238.119 milliseconds (2264 allocations: 169 KB)</code></pre><p data-translated="true"><span class="original-text">The biggest advantage of <code>advection_shared!</code> is that it minimizes traffic among the workers, allowing each to compute for an extended time on the assigned piece.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>advection_shared!</code>の最大の利点は、ワーカー間のトラフィックを最小限に抑え、各ワーカーが割り当てられた部分で長時間計算できるようにすることです。</span></p><h3 id="Shared-Arrays-and-Distributed-Garbage-Collection" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Shared-Arrays-and-Distributed-Garbage-Collection">Shared Arrays and Distributed Garbage Collection</a><a id="Shared-Arrays-and-Distributed-Garbage-Collection-1"></a><a class="docs-heading-anchor-permalink" href="#Shared-Arrays-and-Distributed-Garbage-Collection" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Shared-Arrays-and-Distributed-Garbage-Collection">共有配列と分散ガーベジコレクション</a><a id="Shared-Arrays-and-Distributed-Garbage-Collection-1"></a><a class="docs-heading-anchor-permalink" href="#Shared-Arrays-and-Distributed-Garbage-Collection" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Like remote references, shared arrays are also dependent on garbage collection on the creating node to release references from all participating workers. Code which creates many short lived shared array objects would benefit from explicitly finalizing these objects as soon as possible. This results in both memory and file handles mapping the shared segment being released sooner.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リモート参照と同様に、共有配列も作成ノードのガーベジコレクションに依存しており、すべての参加ワーカーからの参照を解放します。多くの短命の共有配列オブジェクトを作成するコードは、これらのオブジェクトをできるだけ早く明示的にファイナライズすることで利益を得るでしょう。これにより、メモリとファイルハンドルが共有セグメントをより早く解放されます。</span></p><h2 id="ClusterManagers" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#ClusterManagers">ClusterManagers</a><a id="ClusterManagers-1"></a><a class="docs-heading-anchor-permalink" href="#ClusterManagers" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#ClusterManagers">クラスターマネージャー</a><a id="ClusterManagers-1"></a><a class="docs-heading-anchor-permalink" href="#ClusterManagers" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The launching, management and networking of Julia processes into a logical cluster is done via cluster managers. A <code>ClusterManager</code> is responsible for</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaプロセスを論理クラスタに起動、管理、ネットワーク化するのはクラスターマネージャーによって行われます。<code>ClusterManager</code>は以下の責任があります。</span></p><ul><li data-translated="true"><span class="original-text">launching worker processes in a cluster environment</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">クラスタ環境でのワーカープロセスの起動</span></li><li data-translated="true"><span class="original-text">managing events during the lifetime of each worker</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各ワーカーのライフタイム中のイベントの管理</span></li><li data-translated="true"><span class="original-text">optionally, providing data transport</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">オプションで、データ輸送の提供</span></li></ul><p data-translated="true"><span class="original-text">A Julia cluster has the following characteristics:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaクラスタには以下の特性があります：</span></p><ul><li data-translated="true"><span class="original-text">The initial Julia process, also called the <code>master</code>, is special and has an <code>id</code> of 1.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">初期のJuliaプロセスは、<code>master</code>とも呼ばれ、特別で<code>id</code>は1です。</span></li><li data-translated="true"><span class="original-text">Only the <code>master</code> process can add or remove worker processes.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ワーカープロセスを追加または削除できるのは<code>master</code>プロセスのみです。</span></li><li data-translated="true"><span class="original-text">All processes can directly communicate with each other.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべてのプロセスは互いに直接通信できます。</span></li></ul><p data-translated="true"><span class="original-text">Connections between workers (using the in-built TCP/IP transport) is established in the following manner:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ワーカー間の接続（組み込みのTCP/IPトランスポートを使用）は、以下の方法で確立されます：</span></p><ul><li data-translated="true"><span class="original-text"><a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a> is called on the master process with a <code>ClusterManager</code> object.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a>は、<code>ClusterManager</code>オブジェクトを使用してマスタープロセスで呼び出されます。</span></li><li data-translated="true"><span class="original-text"><a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a> calls the appropriate <a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a> method which spawns required number of worker processes on appropriate machines.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a>は、適切な<a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a>メソッドを呼び出し、適切なマシン上に必要な数のワーカープロセスを生成します。</span></li><li data-translated="true"><span class="original-text">Each worker starts listening on a free port and writes out its host and port information to <a href="../../base/io-network/index.html#Base.stdout"><code>stdout</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各ワーカーは空いているポートでリスニングを開始し、そのホストとポート情報を<a href="../../base/io-network/index.html#Base.stdout"><code>stdout</code></a>に書き出します。</span></li><li data-translated="true"><span class="original-text">The cluster manager captures the <a href="../../base/io-network/index.html#Base.stdout"><code>stdout</code></a> of each worker and makes it available to the master process.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">クラスター管理者は各ワーカーの<a href="../../base/io-network/index.html#Base.stdout"><code>stdout</code></a>をキャプチャし、それをマスタープロセスに提供します。</span></li><li data-translated="true"><span class="original-text">The master process parses this information and sets up TCP/IP connections to each worker.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マスタープロセスはこの情報を解析し、各ワーカーへのTCP/IP接続を設定します。</span></li><li data-translated="true"><span class="original-text">Every worker is also notified of other workers in the cluster.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各ワーカーはクラスター内の他のワーカーについても通知を受けます。</span></li><li data-translated="true"><span class="original-text">Each worker connects to all workers whose <code>id</code> is less than the worker's own <code>id</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各ワーカーは、自身の<code>id</code>よりも小さい<code>id</code>を持つすべてのワーカーに接続します。</span></li><li data-translated="true"><span class="original-text">In this way a mesh network is established, wherein every worker is directly connected with every other worker.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このようにしてメッシュネットワークが確立され、すべてのワーカーが他のすべてのワーカーと直接接続されます。</span></li></ul><p data-translated="true"><span class="original-text">While the default transport layer uses plain <a href="../../stdlib/Sockets/index.html#Sockets.TCPSocket"><code>TCPSocket</code></a>, it is possible for a Julia cluster to provide its own transport.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトのトランスポート層はプレーン<a href="../../stdlib/Sockets/index.html#Sockets.TCPSocket"><code>TCPSocket</code></a>を使用しますが、Juliaクラスタが独自のトランスポートを提供することも可能です。</span></p><p data-translated="true"><span class="original-text">Julia provides two in-built cluster managers:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは2つの組み込みクラスタマネージャを提供します：</span></p><ul><li data-translated="true"><span class="original-text"><code>LocalManager</code>, used when <a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs()</code></a> or <a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs(np::Integer)</code></a> are called</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>LocalManager</code>は、<a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs()</code></a>または<a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs(np::Integer)</code></a>が呼び出されたときに使用されます。</span></li><li data-translated="true"><span class="original-text"><code>SSHManager</code>, used when <a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs(hostnames::Array)</code></a> is called with a list of hostnames</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>SSHManager</code>は、ホスト名のリストを使って<a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs(hostnames::Array)</code></a>が呼び出されたときに使用されます。</span></li></ul><p data-translated="true"><span class="original-text"><code>LocalManager</code> is used to launch additional workers on the same host, thereby leveraging multi-core and multi-processor hardware.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>LocalManager</code>は、同じホスト上で追加のワーカーを起動するために使用され、マルチコアおよびマルチプロセッサハードウェアを活用します。</span></p><p data-translated="true"><span class="original-text">Thus, a minimal cluster manager would need to:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、最小限のクラスタマネージャは以下を満たす必要があります：</span></p><ul><li data-translated="true"><span class="original-text">be a subtype of the abstract <code>ClusterManager</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">抽象<code>ClusterManager</code>のサブタイプであること</span></li><li data-translated="true"><span class="original-text">implement <a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a>, a method responsible for launching new workers</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a>を実装すること。これは新しいワーカーを起動する責任を持つメソッドです。</span></li><li data-translated="true"><span class="original-text">implement <a href="../../stdlib/Distributed/index.html#Distributed.manage"><code>manage</code></a>, which is called at various events during a worker's lifetime (for example, sending an interrupt signal)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.manage"><code>manage</code></a>を実装すること。これはワーカーのライフタイム中のさまざまなイベントで呼び出されます（例えば、割り込み信号を送信するなど）。</span></li></ul><p data-translated="true"><span class="original-text"><a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs(manager::FooManager)</code></a> requires <code>FooManager</code> to implement:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs(manager::FooManager)</code></a>は<code>FooManager</code>が以下を実装することを要求します：</span></p><pre><code class="language-julia hljs">function launch(manager::FooManager, params::Dict, launched::Array, c::Condition)
    [...]
end

function manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)
    [...]
end</code></pre><p data-translated="true"><span class="original-text">As an example let us see how the <code>LocalManager</code>, the manager responsible for starting workers on the same host, is implemented:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例として、同じホスト上でワーカーを起動する責任を持つマネージャである <code>LocalManager</code> がどのように実装されているかを見てみましょう：</span></p><pre><code class="language-julia hljs">struct LocalManager &lt;: ClusterManager
    np::Integer
end

function launch(manager::LocalManager, params::Dict, launched::Array, c::Condition)
    [...]
end

function manage(manager::LocalManager, id::Integer, config::WorkerConfig, op::Symbol)
    [...]
end</code></pre><p data-translated="true"><span class="original-text">The <a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a> method takes the following arguments:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次の引数を取る <a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a> メソッド：</span></p><ul><li data-translated="true"><span class="original-text"><code>manager::ClusterManager</code>: the cluster manager that <a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a> is called with</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>manager::ClusterManager</code>: <a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a> が呼ばれるクラスターマネージャ</span></li><li data-translated="true"><span class="original-text"><code>params::Dict</code>: all the keyword arguments passed to <a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>params::Dict</code>: <a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a> に渡されるすべてのキーワード引数</span></li><li data-translated="true"><span class="original-text"><code>launched::Array</code>: the array to append one or more <code>WorkerConfig</code> objects to</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>launched::Array</code>: 1つ以上の <code>WorkerConfig</code> オブジェクトを追加するための配列</span></li><li data-translated="true"><span class="original-text"><code>c::Condition</code>: the condition variable to be notified as and when workers are launched</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>c::Condition</code>: ワーカーが起動されるときに通知される条件変数</span></li></ul><p data-translated="true"><span class="original-text">The <a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a> method is called asynchronously in a separate task. The termination of this task signals that all requested workers have been launched. Hence the <a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a> function MUST exit as soon as all the requested workers have been launched.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a> メソッドは、別のタスクで非同期に呼び出されます。このタスクの終了は、要求されたすべてのワーカーが起動されたことを示します。したがって、<a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a> 関数は、要求されたすべてのワーカーが起動されるとすぐに終了しなければなりません。</span></p><p data-translated="true"><span class="original-text">Newly launched workers are connected to each other and the master process in an all-to-all manner. Specifying the command line argument <code>--worker[=&lt;cookie&gt;]</code> results in the launched processes initializing themselves as workers and connections being set up via TCP/IP sockets.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">新しく起動されたワーカーは、全てのワーカーとマスタープロセスに対して相互接続されます。コマンドライン引数 <code>--worker[=&lt;cookie&gt;]</code> を指定すると、起動されたプロセスは自らをワーカーとして初期化し、TCP/IPソケットを介して接続が設定されます。</span></p><p data-translated="true"><span class="original-text">All workers in a cluster share the same <a href="#man-cluster-cookie">cookie</a> as the master. When the cookie is unspecified, i.e, with the <code>--worker</code> option, the worker tries to read it from its standard input.  <code>LocalManager</code> and <code>SSHManager</code> both pass the cookie to newly launched workers via their  standard inputs.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">クラスター内のすべてのワーカーは、マスターと同じ <a href="#man-cluster-cookie">cookie</a> を共有します。cookie が指定されていない場合、すなわち <code>--worker</code> オプションを使用する場合、ワーカーは標準入力からそれを読み取ろうとします。 <code>LocalManager</code> と <code>SSHManager</code> は、どちらも標準入力を介して新しく起動されたワーカーにcookieを渡します。</span></p><p data-translated="true"><span class="original-text">By default a worker will listen on a free port at the address returned by a call to <a href="../../stdlib/Sockets/index.html#Sockets.getipaddr"><code>getipaddr()</code></a>. A specific address to listen on may be specified by optional argument <code>--bind-to bind_addr[:port]</code>. This is useful for multi-homed hosts.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトでは、ワーカーは <a href="../../stdlib/Sockets/index.html#Sockets.getipaddr"><code>getipaddr()</code></a> の呼び出しによって返されるアドレスの空いているポートでリッスンします。リッスンする特定のアドレスは、オプション引数 <code>--bind-to bind_addr[:port]</code> で指定できます。これは、マルチホーミングホストにとって便利です。</span></p><p data-translated="true"><span class="original-text">As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case <code>--worker</code> must NOT be specified. Instead, newly launched workers should call <code>init_worker(cookie)</code> before using any of the parallel constructs.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">非TCP/IPトランスポートの例として、実装はMPIを使用することを選択する場合があり、その場合は<code>--worker</code>を指定してはいけません。代わりに、新しく起動されたワーカーは、並列構造を使用する前に<code>init_worker(cookie)</code>を呼び出す必要があります。</span></p><p data-translated="true"><span class="original-text">For every worker launched, the <a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a> method must add a <code>WorkerConfig</code> object (with appropriate fields initialized) to <code>launched</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">起動された各ワーカーについて、<a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a>メソッドは、<code>launched</code>に適切なフィールドが初期化された<code>WorkerConfig</code>オブジェクトを追加しなければなりません。</span></p><pre><code class="language-julia hljs">mutable struct WorkerConfig
    # Common fields relevant to all cluster managers
    io::Union{IO, Nothing}
    host::Union{AbstractString, Nothing}
    port::Union{Integer, Nothing}

    # Used when launching additional workers at a host
    count::Union{Int, Symbol, Nothing}
    exename::Union{AbstractString, Cmd, Nothing}
    exeflags::Union{Cmd, Nothing}

    # External cluster managers can use this to store information at a per-worker level
    # Can be a dict if multiple fields need to be stored.
    userdata::Any

    # SSHManager / SSH tunnel connections to workers
    tunnel::Union{Bool, Nothing}
    bind_addr::Union{AbstractString, Nothing}
    sshflags::Union{Cmd, Nothing}
    max_parallel::Union{Integer, Nothing}

    # Used by Local/SSH managers
    connect_at::Any

    [...]
end</code></pre><p data-translated="true"><span class="original-text">Most of the fields in <code>WorkerConfig</code> are used by the inbuilt managers. Custom cluster managers would typically specify only <code>io</code> or <code>host</code> / <code>port</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>WorkerConfig</code>のほとんどのフィールドは、組み込みマネージャによって使用されます。カスタムクラスター管理者は通常、<code>io</code>または<code>host</code> / <code>port</code>のみを指定します。</span></p><ul><li><p data-translated="true"><span class="original-text">If <code>io</code> is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows Julia workers to listen on any free port available instead of requiring worker ports to be configured manually.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>io</code>が指定されている場合、ホスト/ポート情報を読み取るために使用されます。Juliaワーカーは起動時にそのバインドアドレスとポートを出力します。これにより、Juliaワーカーはワーカーポートを手動で設定する必要なく、利用可能な任意の空いているポートでリッスンできます。</span></p></li><li><p data-translated="true"><span class="original-text">If <code>io</code> is not specified, <code>host</code> and <code>port</code> are used to connect.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>io</code>が指定されていない場合、<code>host</code>と<code>port</code>が接続に使用されます。</span></p></li><li><p data-translated="true"><span class="original-text"><code>count</code>, <code>exename</code> and <code>exeflags</code> are relevant for launching additional workers from a worker. For example, a cluster manager may launch a single worker per node, and use that to launch additional workers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>count</code>、<code>exename</code>、および<code>exeflags</code>は、ワーカーから追加のワーカーを起動する際に関連します。たとえば、クラスター管理者はノードごとに単一のワーカーを起動し、それを使用して追加のワーカーを起動することがあります。</span></p><ul><li data-translated="true"><span class="original-text"><code>count</code> with an integer value <code>n</code> will launch a total of <code>n</code> workers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>count</code>に整数値<code>n</code>を指定すると、合計<code>n</code>のワーカーが起動されます。</span></li><li data-translated="true"><span class="original-text"><code>count</code> with a value of <code>:auto</code> will launch as many workers as the number of CPU threads (logical cores) on that machine.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>count</code>に<code>:auto</code>の値を指定すると、そのマシン上のCPUスレッド（論理コア）の数と同じだけのワーカーが起動されます。</span></li><li data-translated="true"><span class="original-text"><code>exename</code> is the name of the <code>julia</code> executable including the full path.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>exename</code>は、フルパスを含む<code>julia</code>実行可能ファイルの名前です。</span></li><li data-translated="true"><span class="original-text"><code>exeflags</code> should be set to the required command line arguments for new workers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>exeflags</code>は、新しいワーカーに必要なコマンドライン引数を設定する必要があります。</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>tunnel</code>, <code>bind_addr</code>, <code>sshflags</code> and <code>max_parallel</code> are used when a ssh tunnel is required to connect to the workers from the master process.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>tunnel</code>, <code>bind_addr</code>, <code>sshflags</code> および <code>max_parallel</code> は、マスタープロセスからワーカーに接続するために ssh トンネルが必要な場合に使用されます。</span></p></li><li><p data-translated="true"><span class="original-text"><code>userdata</code> is provided for custom cluster managers to store their own worker-specific information.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>userdata</code> は、カスタムクラスター管理者が独自のワーカー固有の情報を保存するために提供されます。</span></p></li></ul><p data-translated="true"><span class="original-text"><code>manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)</code> is called at different times during the worker's lifetime with appropriate <code>op</code> values:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)</code> は、ワーカーのライフサイクルの異なるタイミングで適切な <code>op</code> 値と共に呼び出されます：</span></p><ul><li data-translated="true"><span class="original-text">with <code>:register</code>/<code>:deregister</code> when a worker is added / removed from the Julia worker pool.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>:register</code>/<code>:deregister</code> を使用して、ワーカーが Julia ワーカープールに追加または削除されるとき。</span></li><li data-translated="true"><span class="original-text">with <code>:interrupt</code> when <code>interrupt(workers)</code> is called. The <code>ClusterManager</code> should signal the appropriate worker with an interrupt signal.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>:interrupt</code> を使用して <code>interrupt(workers)</code> が呼び出されたとき。<code>ClusterManager</code> は、適切なワーカーに中断信号を送信する必要があります。</span></li><li data-translated="true"><span class="original-text">with <code>:finalize</code> for cleanup purposes.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>:finalize</code> を使用してクリーンアップを行います。</span></li></ul><h3 id="Cluster-Managers-with-Custom-Transports" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Cluster-Managers-with-Custom-Transports">Cluster Managers with Custom Transports</a><a id="Cluster-Managers-with-Custom-Transports-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-Managers-with-Custom-Transports" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Cluster-Managers-with-Custom-Transports">カスタムトランスポートを使用したクラスター管理者</a><a id="Cluster-Managers-with-Custom-Transports-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-Managers-with-Custom-Transports" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Replacing the default TCP/IP all-to-all socket connections with a custom transport layer is a little more involved. Each Julia process has as many communication tasks as the workers it is connected to. For example, consider a Julia cluster of 32 processes in an all-to-all mesh network:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトの TCP/IP の全対全ソケット接続をカスタムトランスポート層に置き換えるのは、少し手間がかかります。各 Julia プロセスは、接続されているワーカーの数だけ通信タスクを持っています。例えば、全対全メッシュネットワークの 32 プロセスからなる Julia クラスターを考えてみましょう：</span></p><ul><li data-translated="true"><span class="original-text">Each Julia process thus has 31 communication tasks.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、各 Julia プロセスは 31 の通信タスクを持っています。</span></li><li data-translated="true"><span class="original-text">Each task handles all incoming messages from a single remote worker in a message-processing loop.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各タスクは、メッセージ処理ループ内で単一のリモートワーカーからのすべての受信メッセージを処理します。</span></li><li data-translated="true"><span class="original-text">The message-processing loop waits on an <code>IO</code> object (for example, a <a href="../../stdlib/Sockets/index.html#Sockets.TCPSocket"><code>TCPSocket</code></a> in the default implementation), reads an entire message, processes it and waits for the next one.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メッセージ処理ループは、<code>IO</code>オブジェクト（デフォルト実装の<code><a href="../../stdlib/Sockets/index.html#Sockets.TCPSocket">TCPSocket</a></code>など）で待機し、メッセージ全体を読み取り、処理し、次のメッセージを待ちます。</span></li><li data-translated="true"><span class="original-text">Sending messages to a process is done directly from any Julia task–not just communication tasks–again, via the appropriate <code>IO</code> object.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プロセスへのメッセージの送信は、適切な<code>IO</code>オブジェクトを介して、任意のJuliaタスクから直接行われます。通信タスクだけではありません。</span></li></ul><p data-translated="true"><span class="original-text">Replacing the default transport requires the new implementation to set up connections to remote workers and to provide appropriate <code>IO</code> objects that the message-processing loops can wait on. The manager-specific callbacks to be implemented are:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトのトランスポートを置き換えるには、新しい実装がリモートワーカーへの接続を設定し、メッセージ処理ループが待機できる適切な<code>IO</code>オブジェクトを提供する必要があります。実装すべきマネージャー固有のコールバックは次のとおりです：</span></p><pre><code class="language-julia hljs">connect(manager::FooManager, pid::Integer, config::WorkerConfig)
kill(manager::FooManager, pid::Int, config::WorkerConfig)</code></pre><p data-translated="true"><span class="original-text">The default implementation (which uses TCP/IP sockets) is implemented as <code>connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトの実装（TCP/IPソケットを使用）は、<code>connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)</code>として実装されています。</span></p><p data-translated="true"><span class="original-text"><code>connect</code> should return a pair of <code>IO</code> objects, one for reading data sent from worker <code>pid</code>, and the other to write data that needs to be sent to worker <code>pid</code>. Custom cluster managers can use an in-memory <code>BufferStream</code> as the plumbing to proxy data between the custom, possibly non-<code>IO</code> transport and Julia's in-built parallel infrastructure.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>connect</code>は、ワーカー<code>pid</code>から送信されたデータを読み取るための<code>IO</code>オブジェクトと、ワーカー<code>pid</code>に送信する必要があるデータを書き込むための<code>IO</code>オブジェクトのペアを返す必要があります。カスタムクラスターマネージャーは、カスタムの、場合によっては非<code>IO</code>トランスポートとJuliaの組み込み並列インフラストラクチャの間でデータをプロキシするために、メモリ内の<code>BufferStream</code>を使用できます。</span></p><p data-translated="true"><span class="original-text">A <code>BufferStream</code> is an in-memory <a href="../../base/io-network/index.html#Base.IOBuffer"><code>IOBuffer</code></a> which behaves like an <code>IO</code>–it is a stream which can be handled asynchronously.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>BufferStream</code>は、<a href="../../base/io-network/index.html#Base.IOBuffer"><code>IOBuffer</code></a>として動作するメモリ内のストリームで、<code>IO</code>のように振る舞います。非同期に処理できるストリームです。</span></p><p data-translated="true"><span class="original-text">The folder <code>clustermanager/0mq</code> in the <a href="https://github.com/JuliaAttic/Examples">Examples repository</a> contains an example of using ZeroMQ to connect Julia workers in a star topology with a 0MQ broker in the middle. Note: The Julia processes are still all <em>logically</em> connected to each other–any worker can message any other worker directly without any awareness of 0MQ being used as the transport layer.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>clustermanager/0mq</code>フォルダーは、<a href="https://github.com/JuliaAttic/Examples">Examplesリポジトリ</a>にあり、ZeroMQを使用して、中央に0MQブローカーを持つ星型トポロジーでJuliaワーカーを接続する例が含まれています。注意：Juliaプロセスはすべて<em>論理的に</em>互いに接続されています。どのワーカーも、トランスポート層として0MQが使用されていることを意識することなく、他のワーカーに直接メッセージを送信できます。</span></p><p data-translated="true"><span class="original-text">When using custom transports:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">カスタムトランスポートを使用する場合：</span></p><ul><li data-translated="true"><span class="original-text">Julia workers must NOT be started with <code>--worker</code>. Starting with <code>--worker</code> will result in the newly launched workers defaulting to the TCP/IP socket transport implementation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaワーカーは<code>--worker</code>で起動してはいけません。<code>--worker</code>で起動すると、新しく起動されたワーカーはTCP/IPソケットトランスポート実装にデフォルト設定されます。</span></li><li data-translated="true"><span class="original-text">For every incoming logical connection with a worker, <code>Base.process_messages(rd::IO, wr::IO)()</code> must be called. This launches a new task that handles reading and writing of messages from/to the worker represented by the <code>IO</code> objects.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ワーカーとのすべての受信論理接続に対して、<code>Base.process_messages(rd::IO, wr::IO)()</code>を呼び出す必要があります。これにより、<code>IO</code>オブジェクトで表されるワーカーとのメッセージの読み取りと書き込みを処理する新しいタスクが起動されます。</span></li><li data-translated="true"><span class="original-text"><code>init_worker(cookie, manager::FooManager)</code> <em>must</em> be called as part of worker process initialization.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>init_worker(cookie, manager::FooManager)</code> <em>は</em> ワーカープロセスの初期化の一部として呼び出される必要があります。</span></li><li data-translated="true"><span class="original-text">Field <code>connect_at::Any</code> in <code>WorkerConfig</code> can be set by the cluster manager when <a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a> is called. The value of this field is passed in all <a href="../../stdlib/Distributed/index.html#Sockets.connect-Tuple{ClusterManager, Int64, WorkerConfig}"><code>connect</code></a> callbacks. Typically, it carries information on <em>how to connect</em> to a worker. For example, the TCP/IP socket transport uses this field to specify the <code>(host, port)</code> tuple at which to connect to a worker.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>WorkerConfig</code> のフィールド <code>connect_at::Any</code> は、<a href="../../stdlib/Distributed/index.html#Distributed.launch"><code>launch</code></a> が呼び出されるときにクラスターマネージャによって設定されることがあります。このフィールドの値は、すべての <a href="../../stdlib/Distributed/index.html#Sockets.connect-Tuple{ClusterManager, Int64, WorkerConfig}"><code>connect</code></a> コールバックに渡されます。通常、これはワーカーに接続する方法に関する情報を持っています。例えば、TCP/IPソケットトランスポートは、このフィールドを使用してワーカーに接続するための <code>(host, port)</code> タプルを指定します。</span></li></ul><p data-translated="true"><span class="original-text"><code>kill(manager, pid, config)</code> is called to remove a worker from the cluster. On the master process, the corresponding <code>IO</code> objects must be closed by the implementation to ensure proper cleanup. The default implementation simply executes an <code>exit()</code> call on the specified remote worker.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>kill(manager, pid, config)</code> は、クラスタからワーカーを削除するために呼び出されます。マスタープロセスでは、対応する <code>IO</code> オブジェクトは、適切なクリーンアップを確保するために実装によって閉じられなければなりません。デフォルトの実装は、指定されたリモートワーカーで単に <code>exit()</code> コールを実行します。</span></p><p data-translated="true"><span class="original-text">The Examples folder <code>clustermanager/simple</code> is an example that shows a simple implementation using UNIX domain sockets for cluster setup.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Examplesフォルダの <code>clustermanager/simple</code> は、クラスタセットアップのためにUNIXドメインソケットを使用したシンプルな実装を示す例です。</span></p><h3 id="Network-Requirements-for-LocalManager-and-SSHManager" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Network-Requirements-for-LocalManager-and-SSHManager">Network Requirements for LocalManager and SSHManager</a><a id="Network-Requirements-for-LocalManager-and-SSHManager-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Requirements-for-LocalManager-and-SSHManager" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Network-Requirements-for-LocalManager-and-SSHManager">LocalManagerおよびSSHManagerのネットワーク要件</a><a id="Network-Requirements-for-LocalManager-and-SSHManager-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Requirements-for-LocalManager-and-SSHManager" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Julia clusters are designed to be executed on already secured environments on infrastructure such as local laptops, departmental clusters, or even the cloud. This section covers network security requirements for the inbuilt <code>LocalManager</code> and <code>SSHManager</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaクラスタは、ローカルのラップトップ、部門のクラスタ、またはクラウドなどの既に安全な環境で実行されるように設計されています。このセクションでは、組み込みの <code>LocalManager</code> と <code>SSHManager</code> のネットワークセキュリティ要件について説明します：</span></p><ul><li><p data-translated="true"><span class="original-text">The master process does not listen on any port. It only connects out to the workers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マスタープロセスは、ポートをリッスンしません。ワーカーに接続するだけです。</span></p></li><li><p data-translated="true"><span class="original-text">Each worker binds to only one of the local interfaces and listens on an ephemeral port number assigned by the OS.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各ワーカーは、ローカルインターフェースの1つにのみバインドし、OSによって割り当てられたエフェメラルポート番号でリッスンします。</span></p></li><li><p data-translated="true"><span class="original-text"><code>LocalManager</code>, used by <code>addprocs(N)</code>, by default binds only to the loopback interface. This means that workers started later on remote hosts (or by anyone with malicious intentions) are unable to connect to the cluster. An <code>addprocs(4)</code> followed by an <code>addprocs(["remote_host"])</code> will fail. Some users may need to create a cluster comprising their local system and a few remote systems. This can be done by explicitly requesting <code>LocalManager</code> to bind to an external network interface via the <code>restrict</code> keyword argument: <code>addprocs(4; restrict=false)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>LocalManager</code> は、<code>addprocs(N)</code> によって使用され、デフォルトではループバックインターフェースのみにバインドされます。これは、リモートホストで後から開始されたワーカー（または悪意のある意図を持つ誰か）がクラスタに接続できないことを意味します。<code>addprocs(4)</code> の後に <code>addprocs(["remote_host"])</code> を実行すると失敗します。一部のユーザーは、ローカルシステムといくつかのリモートシステムで構成されるクラスタを作成する必要があるかもしれません。これは、<code>restrict</code> キーワード引数を介して <code>LocalManager</code> に外部ネットワークインターフェースにバインドするように明示的に要求することで実行できます：<code>addprocs(4; restrict=false)</code>。</span></p></li><li><p data-translated="true"><span class="original-text"><code>SSHManager</code>, used by <code>addprocs(list_of_remote_hosts)</code>, launches workers on remote hosts via SSH. By default SSH is only used to launch Julia workers. Subsequent master-worker and worker-worker connections use plain, unencrypted TCP/IP sockets. The remote hosts must have passwordless login enabled. Additional SSH flags or credentials may be specified via keyword argument <code>sshflags</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>SSHManager</code> は、<code>addprocs(list_of_remote_hosts)</code> によって使用され、SSHを介してリモートホストでワーカーを起動します。デフォルトでは、SSHはJuliaワーカーを起動するためにのみ使用されます。その後のマスター-ワーカーおよびワーカー-ワーカー接続は、平文の暗号化されていないTCP/IPソケットを使用します。リモートホストは、パスワードなしのログインを有効にしている必要があります。追加のSSHフラグや資格情報は、キーワード引数 <code>sshflags</code> を介して指定できます。</span></p></li><li><p data-translated="true"><span class="original-text"><code>addprocs(list_of_remote_hosts; tunnel=true, sshflags=&lt;ssh keys and other flags&gt;)</code> is useful when we wish to use SSH connections for master-worker too. A typical scenario for this is a local laptop running the Julia REPL (i.e., the master) with the rest of the cluster on the cloud, say on Amazon EC2. In this case only port 22 needs to be opened at the remote cluster coupled with SSH client authenticated via public key infrastructure (PKI). Authentication credentials can be supplied via <code>sshflags</code>, for example <code>sshflags=`-i &lt;keyfile&gt;`</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>addprocs(list_of_remote_hosts; tunnel=true, sshflags=&lt;ssh keys and other flags&gt;)</code> は、マスターとワーカー間でSSH接続を使用したい場合に便利です。典型的なシナリオは、ローカルのラップトップでJulia REPL（つまり、マスター）を実行し、クラスタの残りがクラウド上、例えばAmazon EC2上にある場合です。この場合、リモートクラスタではポート22のみを開放し、公開鍵基盤（PKI）を介して認証されたSSHクライアントが必要です。認証情報は<code>sshflags</code>を介して提供できます。例えば、<code>sshflags=`-i &lt;keyfile&gt;`</code>のように指定します。</span></p><p data-translated="true"><span class="original-text">In an all-to-all topology (the default), all workers connect to each other via plain TCP sockets. The security policy on the cluster nodes must thus ensure free connectivity between workers for the ephemeral port range (varies by OS).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">全対全トポロジー（デフォルト）では、すべてのワーカーが通常のTCPソケットを介して互いに接続します。したがって、クラスタノードのセキュリティポリシーは、エフェメラルポート範囲（OSによって異なる）でワーカー間の自由な接続を保証する必要があります。</span></p><p data-translated="true"><span class="original-text">Securing and encrypting all worker-worker traffic (via SSH) or encrypting individual messages can be done via a custom <code>ClusterManager</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべてのワーカー間のトラフィックを保護し暗号化する（SSHを介して）か、個々のメッセージを暗号化することは、カスタム<code>ClusterManager</code>を介して行うことができます。</span></p></li><li><p data-translated="true"><span class="original-text">If you specify <code>multiplex=true</code> as an option to <a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a>, SSH multiplexing is used to create a tunnel between the master and workers. If you have configured SSH multiplexing on your own and the connection has already been established, SSH multiplexing is used regardless of <code>multiplex</code> option. If multiplexing is enabled, forwarding is set by using the existing connection (<code>-O forward</code> option in ssh). This is beneficial if your servers require password authentication; you can avoid authentication in Julia by logging in to the server ahead of <a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a>. The control socket will be located at <code>~/.ssh/julia-%r@%h:%p</code> during the session unless the existing multiplexing connection is used. Note that bandwidth may be limited if you create multiple processes on a node and enable multiplexing, because in that case processes share a single multiplexing TCP connection.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">オプションとして<code>multiplex=true</code>を<a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a>に指定すると、SSHマルチプレクシングが使用され、マスターとワーカー間にトンネルが作成されます。自分でSSHマルチプレクシングを設定し、接続がすでに確立されている場合は、<code>multiplex</code>オプションに関係なくSSHマルチプレクシングが使用されます。マルチプレクシングが有効になっている場合、フォワーディングは既存の接続を使用して設定されます（sshの<code>-O forward</code>オプション）。これは、サーバーがパスワード認証を必要とする場合に有益です。<a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a>の前にサーバーにログインすることで、Juliaでの認証を回避できます。制御ソケットは、既存のマルチプレクシング接続が使用されない限り、セッション中に<code>~/.ssh/julia-%r@%h:%p</code>に配置されます。ノード上で複数のプロセスを作成し、マルチプレクシングを有効にすると、プロセスが単一のマルチプレクシングTCP接続を共有するため、帯域幅が制限される可能性があることに注意してください。</span></p></li></ul><h3 id="man-cluster-cookie" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-cluster-cookie">Cluster Cookie</a><a id="man-cluster-cookie-1"></a><a class="docs-heading-anchor-permalink" href="#man-cluster-cookie" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-cluster-cookie">クラスタクッキー</a><a id="man-cluster-cookie-1"></a><a class="docs-heading-anchor-permalink" href="#man-cluster-cookie" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">クラスタ内のすべてのプロセスは、デフォルトでマスタープロセス上のランダムに生成された文字列である同じクッキーを共有します：</span></p><ul><li data-translated="true"><span class="original-text"><a href="../../stdlib/Distributed/index.html#Distributed.cluster_cookie-Tuple{}"><code>cluster_cookie()</code></a> returns the cookie, while <code>cluster_cookie(cookie)()</code> sets it and returns the new cookie.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Distributed/index.html#Distributed.cluster_cookie-Tuple{}"><code>cluster_cookie()</code></a>はクッキーを返し、<code>cluster_cookie(cookie)()</code>はそれを設定し、新しいクッキーを返します。</span></li><li data-translated="true"><span class="original-text">All connections are authenticated on both sides to ensure that only workers started by the master are allowed to connect to each other.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべての接続は両側で認証され、マスターによって開始されたワーカーのみが互いに接続できることを保証します。</span></li><li data-translated="true"><span class="original-text">The cookie may be passed to the workers at startup via argument <code>--worker=&lt;cookie&gt;</code>. If argument <code>--worker</code> is specified without the cookie, the worker tries to read the cookie from its standard input (<a href="../../base/io-network/index.html#Base.stdin"><code>stdin</code></a>). The <code>stdin</code> is closed immediately after the cookie is retrieved.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">クッキーは、引数<code>--worker=&lt;cookie&gt;</code>を介してワーカーに渡すことができます。引数<code>--worker</code>がクッキーなしで指定された場合、ワーカーは標準入力からクッキーを読み取ろうとします（<a href="../../base/io-network/index.html#Base.stdin"><code>stdin</code></a>）。<code>stdin</code>は、クッキーが取得されるとすぐに閉じられます。</span></li><li data-translated="true"><span class="original-text"><code>ClusterManager</code>s can retrieve the cookie on the master by calling <a href="../../stdlib/Distributed/index.html#Distributed.cluster_cookie-Tuple{}"><code>cluster_cookie()</code></a>. Cluster managers not using the default TCP/IP transport (and hence not specifying <code>--worker</code>) must call <code>init_worker(cookie, manager)</code> with the same cookie as on the master.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ClusterManager</code>は、<a href="../../stdlib/Distributed/index.html#Distributed.cluster_cookie-Tuple{}"><code>cluster_cookie()</code></a>を呼び出すことでマスター上のクッキーを取得できます。デフォルトのTCP/IPトランスポートを使用しないクラスターマネージャー（したがって<code>--worker</code>を指定しない場合）は、マスターと同じクッキーで<code>init_worker(cookie, manager)</code>を呼び出す必要があります。</span></li></ul><p data-translated="true"><span class="original-text">Note that environments requiring higher levels of security can implement this via a custom <code>ClusterManager</code>. For example, cookies can be pre-shared and hence not specified as a startup argument.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">セキュリティレベルが高い環境では、カスタム<code>ClusterManager</code>を介してこれを実装できます。たとえば、クッキーは事前に共有されるため、起動引数として指定されません。</span></p><h2 id="Specifying-Network-Topology-(Experimental)" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Specifying-Network-Topology-(Experimental)">Specifying Network Topology (Experimental)</a><a id="Specifying-Network-Topology-(Experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-Network-Topology-(Experimental)" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Specifying-Network-Topology-(Experimental)">ネットワークトポロジーの指定 (実験的)</a><a id="Specifying-Network-Topology-(Experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-Network-Topology-(Experimental)" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The keyword argument <code>topology</code> passed to <a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a> is used to specify how the workers must be connected to each other:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キーワード引数<code>topology</code>は、<a href="../../stdlib/Distributed/index.html#Distributed.addprocs"><code>addprocs</code></a>に渡され、ワーカーがどのように接続されるべきかを指定します：</span></p><ul><li data-translated="true"><span class="original-text"><code>:all_to_all</code>, the default: all workers are connected to each other.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>:all_to_all</code>、デフォルト：すべてのワーカーが互いに接続されています。</span></li><li data-translated="true"><span class="original-text"><code>:master_worker</code>: only the driver process, i.e. <code>pid</code> 1, has connections to the workers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>:master_worker</code>：ドライバプロセス、すなわち<code>pid</code> 1のみがワーカーに接続されています。</span></li><li data-translated="true"><span class="original-text"><code>:custom</code>: the <code>launch</code> method of the cluster manager specifies the connection topology via the fields <code>ident</code> and <code>connect_idents</code> in <code>WorkerConfig</code>. A worker with a cluster-manager-provided identity <code>ident</code> will connect to all workers specified in <code>connect_idents</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>:custom</code>：クラスター管理者の<code>launch</code>メソッドが、<code>WorkerConfig</code>内のフィールド<code>ident</code>と<code>connect_idents</code>を介して接続トポロジーを指定します。クラスター管理者が提供するアイデンティティ<code>ident</code>を持つワーカーは、<code>connect_idents</code>で指定されたすべてのワーカーに接続します。</span></li></ul><p data-translated="true"><span class="original-text">Keyword argument <code>lazy=true|false</code> only affects <code>topology</code> option <code>:all_to_all</code>. If <code>true</code>, the cluster starts off with the master connected to all workers. Specific worker-worker connections are established at the first remote invocation between two workers. This helps in reducing initial resources allocated for intra-cluster communication. Connections are setup depending on the runtime requirements of a parallel program. Default value for <code>lazy</code> is <code>true</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キーワード引数<code>lazy=true|false</code>は、<code>topology</code>オプション<code>:all_to_all</code>にのみ影響します。<code>true</code>の場合、クラスターはマスターがすべてのワーカーに接続された状態で開始します。特定のワーカー間の接続は、2つのワーカー間の最初のリモート呼び出しで確立されます。これにより、クラスター内通信のために初期に割り当てられるリソースが削減されます。接続は、並列プログラムの実行時要件に応じて設定されます。<code>lazy</code>のデフォルト値は<code>true</code>です。</span></p><p data-translated="true"><span class="original-text">Currently, sending a message between unconnected workers results in an error. This behaviour, as with the functionality and interface, should be considered experimental in nature and may change in future releases.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">現在、接続されていないワーカー間でメッセージを送信するとエラーが発生します。この動作は、機能やインターフェースと同様に、実験的な性質を持つと考えられ、将来のリリースで変更される可能性があります。</span></p><h2 id="Noteworthy-external-packages" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Noteworthy-external-packages">Noteworthy external packages</a><a id="Noteworthy-external-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-external-packages" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Noteworthy-external-packages">注目すべき外部パッケージ</a><a id="Noteworthy-external-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-external-packages" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Outside of Julia parallelism there are plenty of external packages that should be mentioned. For example, <a href="https://github.com/JuliaParallel/MPI.jl"><code>MPI.jl</code></a> is a Julia wrapper for the <code>MPI</code> protocol, <a href="https://github.com/JuliaParallel/Dagger.jl"><code>Dagger.jl</code></a> provides functionality similar to Python's <a href="https://dask.org/">Dask</a>, and <a href="https://github.com/JuliaParallel/Distributedarrays.jl"><code>DistributedArrays.jl</code></a> provides array operations distributed across workers, as <a href="#man-shared-arrays">outlined above</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの並列処理の外には、言及すべき多くの外部パッケージがあります。たとえば、<a href="https://github.com/JuliaParallel/MPI.jl"><code>MPI.jl</code></a>は<code>MPI</code>プロトコルのためのJuliaラッパーであり、<a href="https://github.com/JuliaParallel/Dagger.jl"><code>Dagger.jl</code></a>はPythonの<a href="https://dask.org/">Dask</a>に類似した機能を提供し、<a href="https://github.com/JuliaParallel/Distributedarrays.jl"><code>DistributedArrays.jl</code></a>は、<a href="#man-shared-arrays">上記に概説されている</a>ように、ワーカー間で分散された配列操作を提供します。</span></p><p data-translated="true"><span class="original-text">A mention must be made of Julia's GPU programming ecosystem, which includes:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">JuliaのGPUプログラミングエコシステムについて言及する必要があります。これには以下が含まれます：</span></p><ol><li><p data-translated="true"><span class="original-text"><a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> wraps the various CUDA libraries and supports compiling Julia kernels for Nvidia GPUs.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a>は、さまざまなCUDAライブラリをラップし、Nvidia GPU用のJuliaカーネルのコンパイルをサポートします。</span></p></li><li><p data-translated="true"><span class="original-text"><a href="https://github.com/JuliaGPU/oneAPI.jl">oneAPI.jl</a> wraps the oneAPI unified programming model, and supports executing Julia kernels on supported accelerators. Currently only Linux is supported.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaGPU/oneAPI.jl">oneAPI.jl</a>は、oneAPI統一プログラミングモデルをラップし、サポートされているアクセラレータ上でJuliaカーネルを実行することをサポートします。現在、Linuxのみがサポートされています。</span></p></li><li><p data-translated="true"><span class="original-text"><a href="https://github.com/JuliaGPU/AMDGPU.jl">AMDGPU.jl</a> wraps the AMD ROCm libraries and supports compiling Julia kernels for AMD GPUs. Currently only Linux is supported.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaGPU/AMDGPU.jl">AMDGPU.jl</a>は、AMD ROCmライブラリをラップし、AMD GPU用のJuliaカーネルのコンパイルをサポートします。現在、Linuxのみがサポートされています。</span></p></li><li><p data-translated="true"><span class="original-text">High-level libraries like <a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions.jl</a>, <a href="https://github.com/mcabbott/Tullio.jl">Tullio.jl</a> and <a href="https://github.com/JuliaComputing/ArrayFire.jl">ArrayFire.jl</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions.jl</a>、<a href="https://github.com/mcabbott/Tullio.jl">Tullio.jl</a>、および<a href="https://github.com/JuliaComputing/ArrayFire.jl">ArrayFire.jl</a>のような高レベルライブラリ。</span></p></li></ol><p data-translated="true"><span class="original-text">In the following example we will use both <code>DistributedArrays.jl</code> and <code>CUDA.jl</code> to distribute an array across multiple processes by first casting it through <code>distribute()</code> and <code>CuArray()</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次の例では、<code>DistributedArrays.jl</code>と<code>CUDA.jl</code>の両方を使用して、最初に<code>distribute()</code>と<code>CuArray()</code>を通じて配列を複数のプロセスに分散させます。</span></p><p data-translated="true"><span class="original-text">Remember when importing <code>DistributedArrays.jl</code> to import it across all processes using <a href="../../stdlib/Distributed/index.html#Distributed.@everywhere"><code>@everywhere</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>DistributedArrays.jl</code>をインポートする際は、すべてのプロセスでインポートすることを忘れないでください。これは<a href="../../stdlib/Distributed/index.html#Distributed.@everywhere"><code>@everywhere</code></a>を使用します。</span></p><pre><code class="language-julia-repl hljs">$ ./julia -p 4

julia&gt; addprocs()

julia&gt; @everywhere using DistributedArrays

julia&gt; using CUDA

julia&gt; B = ones(10_000) ./ 2;

julia&gt; A = ones(10_000) .* π;

julia&gt; C = 2 .* A ./ B;

julia&gt; all(C .≈ 4*π)
true

julia&gt; typeof(C)
Vector{Float64} (alias for Array{Float64, 1})

julia&gt; dB = distribute(B);

julia&gt; dA = distribute(A);

julia&gt; dC = 2 .* dA ./ dB;

julia&gt; all(dC .≈ 4*π)
true

julia&gt; typeof(dC)
DistributedArrays.DArray{Float64,1,Vector{Float64}}

julia&gt; cuB = CuArray(B);

julia&gt; cuA = CuArray(A);

julia&gt; cuC = 2 .* cuA ./ cuB;

julia&gt; all(cuC .≈ 4*π);
true

julia&gt; typeof(cuC)
CuArray{Float64,1}</code></pre><p data-translated="true"><span class="original-text">In the following example we will use both <code>DistributedArrays.jl</code> and <code>CUDA.jl</code> to distribute an array across multiple processes and call a generic function on it.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次の例では、<code>DistributedArrays.jl</code>と<code>CUDA.jl</code>の両方を使用して、配列を複数のプロセスに分散させ、その上で汎用関数を呼び出します。</span></p><pre><code class="language-julia hljs">function power_method(M, v)
    for i in 1:100
        v = M*v
        v /= norm(v)
    end

    return v, norm(M*v) / norm(v)  # or  (M*v) ./ v
end</code></pre><p data-translated="true"><span class="original-text"><code>power_method</code> repeatedly creates a new vector and normalizes it. We have not specified any type signature in function declaration, let's see if it works with the aforementioned datatypes:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>power_method</code>は、新しいベクトルを繰り返し作成し、それを正規化します。関数宣言で型シグネチャを指定していませんが、前述のデータ型で動作するか見てみましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; M = [2. 1; 1 1];

julia&gt; v = rand(2)
2-element Vector{Float64}:
0.40395
0.445877

julia&gt; power_method(M,v)
([0.850651, 0.525731], 2.618033988749895)

julia&gt; cuM = CuArray(M);

julia&gt; cuv = CuArray(v);

julia&gt; curesult = power_method(cuM, cuv);

julia&gt; typeof(curesult)
CuArray{Float64,1}

julia&gt; dM = distribute(M);

julia&gt; dv = distribute(v);

julia&gt; dC = power_method(dM, dv);

julia&gt; typeof(dC)
Tuple{DistributedArrays.DArray{Float64,1,Vector{Float64}},Float64}</code></pre><p data-translated="true"><span class="original-text">To end this short exposure to external packages, we can consider <code>MPI.jl</code>, a Julia wrapper of the MPI protocol. As it would take too long to consider every inner function, it would be better to simply appreciate the approach used to implement the protocol.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">外部パッケージへのこの短い紹介を終えるために、<code>MPI.jl</code>を考慮することができます。これはMPIプロトコルのJuliaラッパーです。すべての内部関数を考慮するには時間がかかりすぎるため、プロトコルを実装するために使用されるアプローチを単に評価する方が良いでしょう。</span></p><p data-translated="true"><span class="original-text">Consider this toy script which simply calls each subprocess, instantiate its rank and when the master process is reached, performs the ranks' sum</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このおもちゃのスクリプトは、各サブプロセスを呼び出し、そのランクをインスタンス化し、マスタープロセスに到達したときにランクの合計を計算します。</span></p><pre><code class="language-julia hljs">import MPI

MPI.Init()

comm = MPI.COMM_WORLD
MPI.Barrier(comm)

root = 0
r = MPI.Comm_rank(comm)

sr = MPI.Reduce(r, MPI.SUM, root, comm)

if(MPI.Comm_rank(comm) == root)
   @printf("sum of ranks: %s\n", sr)
end

MPI.Finalize()</code></pre><pre><code class="nohighlight hljs">mpirun -np 4 ./julia example.jl</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1" data-translated="true"><span class="original-text"><a class="tag is-link" href="#citeref-1">1</a>In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding rma to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see <a href="https://mpi-forum.org/docs">https://mpi-forum.org/docs</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tag is-link" href="#citeref-1">1</a>この文脈において、MPIはMPI-1標準を指します。MPI-2からは、MPI標準委員会がリモートメモリアクセス（RMA）と総称される新しい通信メカニズムのセットを導入しました。RMAをMPI標準に追加する動機は、片方向通信パターンを促進することでした。最新のMPI標準に関する追加情報については、<a href="https://mpi-forum.org/docs">https://mpi-forum.org/docs</a>を参照してください。</span></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../multi-threading/index.html">« Multi-Threading</a><a class="docs-footer-nextpage" href="../running-external-programs/index.html">Running External Programs »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>