<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Single- and multi-dimensional Arrays · The Julia Language</title><meta name="title" content="Single- and multi-dimensional Arrays · The Julia Language"><meta property="og:title" content="Single- and multi-dimensional Arrays · The Julia Language"><meta property="twitter:title" content="Single- and multi-dimensional Arrays · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/arrays/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/arrays/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bi1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li class="is-active"><a class="tocitem" href="">Single- and multi-dimensional Arrays</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Basic-Functions"><span>Basic Functions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Basic-Functions"><span>基本関数</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Construction-and-Initialization"><span>Construction and Initialization</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Construction-and-Initialization"><span>構築と初期化</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-array-literals"><span>Array literals</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-array-literals"><span>配列リテラル</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-comprehensions"><span>Comprehensions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-comprehensions"><span>内包表記</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-generators"><span>Generator Expressions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-generators"><span>ジェネレーター式</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-array-indexing"><span>Indexing</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-array-indexing"><span>インデクシング</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-indexed-assignment"><span>Indexed Assignment</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-indexed-assignment"><span>インデックス付き代入</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-supported-index-types"><span>Supported index types</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-supported-index-types"><span>サポートされているインデックス型</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Iteration"><span>Iteration</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Iteration"><span>反復処理</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Array-traits"><span>Array traits</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Array-traits"><span>配列の特性</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-array-and-vectorized-operators-and-functions"><span>Array and Vectorized Operators and Functions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-array-and-vectorized-operators-and-functions"><span>配列およびベクトル化演算子と関数</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Broadcasting"><span>Broadcasting</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Broadcasting"><span>ブロードキャスティング</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Implementation"><span>Implementation</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Implementation"><span>実装</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">一次元および多次元配列</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">一次元および多次元配列</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/arrays.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-multi-dim-arrays" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-multi-dim-arrays">Single- and multi-dimensional Arrays</a><a id="man-multi-dim-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#man-multi-dim-arrays" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-multi-dim-arrays">一次元および多次元配列</a><a id="man-multi-dim-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#man-multi-dim-arrays" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's also possible to define custom array types by inheriting from <a href="../../base/arrays/index.html#Core.AbstractArray"><code>AbstractArray</code></a>. See the <a href="../interfaces/index.html#man-interface-array">manual section on the AbstractArray interface</a> for more details on implementing a custom array type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは、ほとんどの技術計算言語と同様に、第一級の配列実装を提供します。ほとんどの技術計算言語は、他のコンテナを犠牲にして配列実装に多くの注意を払っています。Juliaは配列を特別な方法で扱いません。配列ライブラリはほぼ完全にJulia自体で実装されており、他のJuliaで書かれたコードと同様にコンパイラからパフォーマンスを引き出します。そのため、<a href="../../base/arrays/index.html#Core.AbstractArray"><code>AbstractArray</code></a>から継承することでカスタム配列タイプを定義することも可能です。カスタム配列タイプの実装に関する詳細は、<a href="../interfaces/index.html#man-interface-array">AbstractArrayインターフェースに関するマニュアルセクション</a>を参照してください。</span></p><p data-translated="true"><span class="original-text">An array is a collection of objects stored in a multi-dimensional grid. Zero-dimensional arrays are allowed, see <a href="../faq/index.html#faq-array-0dim">this FAQ entry</a>. In the most general case, an array may contain objects of type <a href="../../base/base/index.html#Core.Any"><code>Any</code></a>. For most computational purposes, arrays should contain objects of a more specific type, such as <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> or <a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列は、多次元グリッドに格納されたオブジェクトのコレクションです。ゼロ次元配列も許可されています。詳細は<a href="../faq/index.html#faq-array-0dim">このFAQエントリ</a>を参照してください。最も一般的な場合、配列は<a href="../../base/base/index.html#Core.Any"><code>Any</code></a>型のオブジェクトを含むことができます。ほとんどの計算目的では、配列は<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>や<a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a>など、より具体的な型のオブジェクトを含むべきです。</span></p><p data-translated="true"><span class="original-text">In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for performance. Julia's compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing performance, and using less memory at times.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般的に、他の多くの技術計算言語とは異なり、Juliaはパフォーマンスのためにプログラムがベクトル化スタイルで書かれることを期待しません。Juliaのコンパイラは型推論を使用し、スカラー配列インデックスのために最適化されたコードを生成します。これにより、パフォーマンスを犠牲にすることなく、便利で読みやすいスタイルでプログラムを書くことができ、時にはメモリを少なく使用することができます。</span></p><p data-translated="true"><span class="original-text">In Julia, all arguments to functions are <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing#Call_by_sharing">passed by sharing</a> (i.e. by pointers). Some technical computing languages pass arrays by value, and while this prevents accidental modification by callees of a value in the caller, it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a <code>!</code> indicates that it will mutate or destroy the value of one or more of its arguments (compare, for example, <a href="../../base/sort/index.html#Base.sort"><code>sort</code></a> and <a href="../../base/sort/index.html#Base.sort!"><code>sort!</code></a>). Callees must make explicit copies to ensure that they don't modify inputs that they don't intend to change. Many non-mutating functions are implemented by calling a function of the same name with an added <code>!</code> at the end on an explicit copy of the input, and returning that copy.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、関数へのすべての引数は<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing#Call_by_sharing">共有によって渡されます</a>（つまり、ポインタによって）。いくつかの技術計算言語は配列を値として渡しますが、これは呼び出し元の値を呼び出し先が誤って変更するのを防ぎますが、配列の不要なコピーを避けるのが難しくなります。慣例として、<code>!</code>で終わる関数名は、1つ以上の引数の値を変更または破壊することを示します（例えば、<a href="../../base/sort/index.html#Base.sort"><code>sort</code></a>と<a href="../../base/sort/index.html#Base.sort!"><code>sort!</code></a>を比較してください）。呼び出し先は、変更したくない入力を変更しないように明示的なコピーを作成する必要があります。多くの非変更関数は、入力の明示的なコピーに対して同じ名前の関数を呼び出し、末尾に<code>!</code>を追加して実装され、そのコピーを返します。</span></p><h2 id="Basic-Functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Basic-Functions">Basic Functions</a><a id="Basic-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Basic-Functions">基本関数</a><a id="Basic-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Functions" title="Permalink"></a></span></h2><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Function</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">説明</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/collections/index.html#Base.eltype"><code>eltype(A)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/collections/index.html#Base.eltype"><code>eltype(A)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">the type of the elements contained in <code>A</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A</code>に含まれる要素の型</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.length-Tuple{AbstractArray}"><code>length(A)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.length-Tuple{AbstractArray}"><code>length(A)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">the number of elements in <code>A</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A</code>の要素数</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.ndims"><code>ndims(A)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.ndims"><code>ndims(A)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">the number of dimensions of <code>A</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A</code>の次元数</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.size"><code>size(A)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.size"><code>size(A)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">a tuple containing the dimensions of <code>A</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A</code>の次元を含むタプル</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.size"><code>size(A,n)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.size"><code>size(A,n)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">the size of <code>A</code> along dimension <code>n</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A</code>の次元<code>n</code>に沿ったサイズ</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.axes-Tuple{Any}"><code>axes(A)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.axes-Tuple{Any}"><code>axes(A)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">a tuple containing the valid indices of <code>A</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A</code>の有効なインデックスを含むタプル</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.axes-Tuple{Any}"><code>axes(A,n)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.axes-Tuple{Any}"><code>axes(A,n)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">a range expressing the valid indices along dimension <code>n</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>n</code>次元に沿った有効なインデックスを表す範囲</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.eachindex"><code>eachindex(A)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.eachindex"><code>eachindex(A)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">an efficient iterator for visiting each position in <code>A</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A</code>の各位置を訪れるための効率的なイテレータ</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.stride"><code>stride(A,k)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.stride"><code>stride(A,k)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">the stride (linear index distance between adjacent elements) along dimension <code>k</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次元 <code>k</code> に沿ったストライド（隣接要素間の線形インデックス距離）</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.strides"><code>strides(A)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.strides"><code>strides(A)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">a tuple of the strides in each dimension</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各次元のストライドのタプル</span></td></tr></tbody></table><h2 id="Construction-and-Initialization" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Construction-and-Initialization">Construction and Initialization</a><a id="Construction-and-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Construction-and-Initialization" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Construction-and-Initialization">構築と初期化</a><a id="Construction-and-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Construction-and-Initialization" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Many functions for constructing and initializing arrays are provided. In the following list of such functions, calls with a <code>dims...</code> argument can either take a single tuple of dimension sizes or a series of dimension sizes passed as a variable number of arguments. Most of these functions also accept a first input <code>T</code>, which is the element type of the array. If the type <code>T</code> is omitted it will default to <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列を構築および初期化するための多くの関数が提供されています。以下の関数のリストでは、<code>dims...</code> 引数を持つ呼び出しは、次元サイズの単一のタプルまたは可変数の引数として渡された一連の次元サイズを取ることができます。これらの関数のほとんどは、配列の要素型である最初の入力 <code>T</code> も受け入れます。型 <code>T</code> が省略された場合、デフォルトで <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> になります。</span></p><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Function</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">説明</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Core.Array"><code>Array{T}(undef, dims...)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Core.Array"><code>Array{T}(undef, dims...)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">an uninitialized dense <a href="../../base/arrays/index.html#Core.Array"><code>Array</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">初期化されていない密な<a href="../../base/arrays/index.html#Core.Array"><code>Array</code></a></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.zeros"><code>zeros(T, dims...)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.zeros"><code>zeros(T, dims...)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">an <code>Array</code> of all zeros</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべての要素がゼロの <code>Array</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.ones"><code>ones(T, dims...)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.ones"><code>ones(T, dims...)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">an <code>Array</code> of all ones</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべての要素が1の <code>Array</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.trues"><code>trues(dims...)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.trues"><code>trues(dims...)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">a <a href="../../base/arrays/index.html#Base.BitArray"><code>BitArray</code></a> with all values <code>true</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべての値が <code>true</code> の <a href="../../base/arrays/index.html#Base.BitArray"><code>BitArray</code></a></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.falses"><code>falses(dims...)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.falses"><code>falses(dims...)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">a <code>BitArray</code> with all values <code>false</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべての値が <code>false</code> の <code>BitArray</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.reshape"><code>reshape(A, dims...)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.reshape"><code>reshape(A, dims...)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">an array containing the same data as <code>A</code>, but with different dimensions</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A</code> と同じデータを含む配列だが、異なる次元を持つ</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/base/index.html#Base.copy"><code>copy(A)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Base.copy"><code>copy(A)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">copy <code>A</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コピー <code>A</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/base/index.html#Base.deepcopy"><code>deepcopy(A)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Base.deepcopy"><code>deepcopy(A)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">copy <code>A</code>, recursively copying its elements</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コピー <code>A</code>、その要素を再帰的にコピーします</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.similar"><code>similar(A, T, dims...)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.similar"><code>similar(A, T, dims...)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">an uninitialized array of the same type as <code>A</code> (dense, sparse, etc.), but with the specified element type and dimensions. The second and third arguments are both optional, defaulting to the element type and dimensions of <code>A</code> if omitted.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A</code>と同じ型の初期化されていない配列（密、疎など）ですが、指定された要素型と次元を持ちます。第二引数と第三引数はどちらもオプションで、省略した場合は<code>A</code>の要素型と次元がデフォルトとなります。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.reinterpret"><code>reinterpret(T, A)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.reinterpret"><code>reinterpret(T, A)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">an array with the same binary data as <code>A</code>, but with element type <code>T</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A</code>と同じバイナリデータを持つ配列ですが、要素型は<code>T</code>です。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../stdlib/Random/index.html#Base.rand"><code>rand(T, dims...)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Random/index.html#Base.rand"><code>rand(T, dims...)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">an <code>Array</code> with random, iid <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup> and uniformly distributed values. For floating point types <code>T</code>, the values lie in the half-open interval <span>$[0, 1)$</span>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ランダムで独立同分布の<code>Array</code> <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup>で、均等に分布した値を持ちます。浮動小数点型<code>T</code>の場合、値は半開区間<span>$[0, 1)$</span>にあります。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../stdlib/Random/index.html#Base.randn"><code>randn(T, dims...)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/Random/index.html#Base.randn"><code>randn(T, dims...)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">an <code>Array</code> with random, iid and standard normally distributed values</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ランダムで独立同分布（iid）かつ標準正規分布の値を持つ<code>Array</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.Matrix"><code>Matrix{T}(I, m, n)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.Matrix"><code>Matrix{T}(I, m, n)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>m</code>-by-<code>n</code> identity matrix. Requires <code>using LinearAlgebra</code> for <a href="../../stdlib/LinearAlgebra/index.html#LinearAlgebra.I"><code>I</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>m</code>行<code>n</code>列の単位行列。<a href="../../stdlib/LinearAlgebra/index.html#LinearAlgebra.I"><code>I</code></a>には<code>using LinearAlgebra</code>が必要です。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/math/index.html#Base.range"><code>range(start, stop, n)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/math/index.html#Base.range"><code>range(start, stop, n)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">a range of <code>n</code> linearly spaced elements from <code>start</code> to <code>stop</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>start</code>から<code>stop</code>までの<code>n</code>個の線形に間隔を空けた要素の範囲</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.fill!"><code>fill!(A, x)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.fill!"><code>fill!(A, x)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">fill the array <code>A</code> with the value <code>x</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列<code>A</code>を値<code>x</code>で埋める</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.fill"><code>fill(x, dims...)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.fill"><code>fill(x, dims...)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">an <code>Array</code> filled with the value <code>x</code>. In particular, <code>fill(x)</code> constructs a zero-dimensional <code>Array</code> containing <code>x</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">値<code>x</code>で埋められた<code>Array</code>。特に、<code>fill(x)</code>は<code>x</code>を含むゼロ次元の<code>Array</code>を構築します。</span></td></tr></tbody></table><p data-translated="true"><span class="original-text">To see the various ways we can pass dimensions to these functions, consider the following examples:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの関数に次元を渡すさまざまな方法を見るために、次の例を考えてみましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; zeros(Int8, 2, 3)
2×3 Matrix{Int8}:
 0  0  0
 0  0  0

julia&gt; zeros(Int8, (2, 3))
2×3 Matrix{Int8}:
 0  0  0
 0  0  0

julia&gt; zeros((2, 3))
2×3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p data-translated="true"><span class="original-text">Here, <code>(2, 3)</code> is a <a href="../../base/base/index.html#Core.Tuple"><code>Tuple</code></a> and the first argument — the element type — is optional, defaulting to <code>Float64</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで、<code>(2, 3)</code> は <a href="../../base/base/index.html#Core.Tuple"><code>Tuple</code></a> であり、最初の引数 — 要素の型 — はオプションで、デフォルトは <code>Float64</code> です。</span></p><h2 id="man-array-literals" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-array-literals">Array literals</a><a id="man-array-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-literals" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-array-literals">配列リテラル</a><a id="man-array-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-literals" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Arrays can also be directly constructed with square braces; the syntax <code>[A, B, C, ...]</code> creates a one-dimensional array (i.e., a vector) containing the comma-separated arguments as its elements. The element type (<a href="../../base/collections/index.html#Base.eltype"><code>eltype</code></a>) of the resulting array is automatically determined by the types of the arguments inside the braces. If all the arguments are the same type, then that is its <code>eltype</code>. If they all have a common <a href="../conversion-and-promotion/index.html#conversion-and-promotion">promotion type</a> then they get converted to that type using <a href="../../base/base/index.html#Base.convert"><code>convert</code></a> and that type is the array's <code>eltype</code>. Otherwise, a heterogeneous array that can hold anything — a <code>Vector{Any}</code> — is constructed; this includes the literal <code>[]</code> where no arguments are given. <a href="#man-array-typed-literal">Array literal can be typed</a> with the syntax <code>T[A, B, C, ...]</code> where <code>T</code> is a type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列は角括弧を使って直接構築することもできます。構文 <code>[A, B, C, ...]</code> は、カンマ区切りの引数を要素として含む一次元配列（すなわちベクトル）を作成します。結果の配列の要素型（<a href="../../base/collections/index.html#Base.eltype"><code>eltype</code></a>）は、波括弧内の引数の型によって自動的に決定されます。すべての引数が同じ型であれば、それがその <code>eltype</code> です。すべての引数が共通の <a href="../conversion-and-promotion/index.html#conversion-and-promotion">昇格型</a> を持っている場合、それらは <a href="../../base/base/index.html#Base.convert"><code>convert</code></a> を使用してその型に変換され、その型が配列の <code>eltype</code> になります。そうでない場合、何でも保持できる異種配列 — <code>Vector{Any}</code> — が構築されます。これは、引数が与えられないリテラル <code>[]</code> を含みます。<a href="#man-array-typed-literal">配列リテラルは型指定できます</a>、構文 <code>T[A, B, C, ...]</code> で、ここで <code>T</code> は型です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; [1, 2, 3] # An array of `Int`s
3-element Vector{Int64}:
 1
 2
 3

julia&gt; promote(1, 2.3, 4//5) # This combination of Int, Float64 and Rational promotes to Float64
(1.0, 2.3, 0.8)

julia&gt; [1, 2.3, 4//5] # Thus that's the element type of this Array
3-element Vector{Float64}:
 1.0
 2.3
 0.8

julia&gt; Float32[1, 2.3, 4//5] # Specify element type manually
3-element Vector{Float32}:
 1.0
 2.3
 0.8

julia&gt; []
Any[]</code></pre><h3 id="man-array-concatenation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-array-concatenation">Concatenation</a><a id="man-array-concatenation-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-concatenation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-array-concatenation">連結</a><a id="man-array-concatenation-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-concatenation" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">If the arguments inside the square brackets are separated by single semicolons (<code>;</code>) or newlines instead of commas, then their contents are <em>vertically concatenated</em> together instead of the arguments being used as elements themselves.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">角括弧内の引数がカンマの代わりに単一のセミコロン（<code>;</code>）や改行で区切られている場合、それらの内容は要素自体として使用されるのではなく、<em>垂直に連結</em> されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; [1:2, 4:5] # Has a comma, so no concatenation occurs. The ranges are themselves the elements
2-element Vector{UnitRange{Int64}}:
 1:2
 4:5

julia&gt; [1:2; 4:5]
4-element Vector{Int64}:
 1
 2
 4
 5

julia&gt; [1:2
        4:5
        6]
5-element Vector{Int64}:
 1
 2
 4
 5
 6</code></pre><p data-translated="true"><span class="original-text">Similarly, if the arguments are separated by tabs or spaces or double semicolons, then their contents are <em>horizontally concatenated</em> together.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同様に、引数がタブやスペース、またはダブルセミコロンで区切られている場合、その内容は<em>水平方向に連結</em>されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; [1:2  4:5  7:8]
2×3 Matrix{Int64}:
 1  4  7
 2  5  8

julia&gt; [[1,2]  [4,5]  [7,8]]
2×3 Matrix{Int64}:
 1  4  7
 2  5  8

julia&gt; [1 2 3] # Numbers can also be horizontally concatenated
1×3 Matrix{Int64}:
 1  2  3

julia&gt; [1;; 2;; 3;; 4]
1×4 Matrix{Int64}:
 1  2  3  4</code></pre><p data-translated="true"><span class="original-text">Single semicolons (or newlines) and spaces (or tabs) can be combined to concatenate both horizontally and vertically at the same time.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">シングルセミコロン（または改行）とスペース（またはタブ）を組み合わせることで、同時に水平方向と垂直方向の両方で連結できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; [1 2
        3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; [zeros(Int, 2, 2) [1; 2]
        [3 4]            5]
3×3 Matrix{Int64}:
 0  0  1
 0  0  2
 3  4  5

julia&gt; [[1 1]; 2 3; [4 4]]
3×2 Matrix{Int64}:
 1  1
 2  3
 4  4</code></pre><p data-translated="true"><span class="original-text">Spaces (and tabs) have a higher precedence than semicolons, performing any horizontal concatenations first and then concatenating the result. Using double semicolons for the horizontal concatenation, on the other hand, performs any vertical concatenations before horizontally concatenating the result.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">スペース（およびタブ）はセミコロンよりも優先度が高く、最初に水平方向の連結を行い、その後結果を連結します。一方、ダブルセミコロンを使用した水平方向の連結は、結果を水平方向に連結する前に、すべての垂直方向の連結を行います。</span></p><pre><code class="language-julia-repl hljs">julia&gt; [zeros(Int, 2, 2) ; [3 4] ;; [1; 2] ; 5]
3×3 Matrix{Int64}:
 0  0  1
 0  0  2
 3  4  5

julia&gt; [1:2; 4;; 1; 3:4]
3×2 Matrix{Int64}:
 1  1
 2  3
 4  4</code></pre><p data-translated="true"><span class="original-text">Just as <code>;</code> and <code>;;</code> concatenate in the first and second dimension, using more semicolons extends this same general scheme. The number of semicolons in the separator specifies the particular dimension, so <code>;;;</code> concatenates in the third dimension, <code>;;;;</code> in the 4th, and so on. Fewer semicolons take precedence, so the lower dimensions are generally concatenated first.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>;</code>と<code>;;</code>が第一および第二次元で連結するのと同様に、セミコロンを増やすことでこの一般的なスキームを拡張できます。区切りのセミコロンの数が特定の次元を指定するため、<code>;;;</code>は第三次元で連結し、<code>;;;;</code>は第四次元で連結します。セミコロンが少ない方が優先されるため、一般的に低次元が最初に連結されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; [1; 2;; 3; 4;; 5; 6;;;
        7; 8;; 9; 10;; 11; 12]
2×3×2 Array{Int64, 3}:
[:, :, 1] =
 1  3  5
 2  4  6

[:, :, 2] =
 7   9  11
 8  10  12</code></pre><p data-translated="true"><span class="original-text">Like before, spaces (and tabs) for horizontal concatenation have a higher precedence than any number of semicolons. Thus, higher-dimensional arrays can also be written by specifying their rows first, with their elements textually arranged in a manner similar to their layout:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">以前と同様に、水平方向の連結のためのスペース（およびタブ）は、任意の数のセミコロンよりも優先度が高いです。したがって、高次元の配列も、最初に行を指定し、その要素をレイアウトに似た方法でテキスト的に配置することで記述できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; [1 3 5
        2 4 6;;;
        7 9 11
        8 10 12]
2×3×2 Array{Int64, 3}:
[:, :, 1] =
 1  3  5
 2  4  6

[:, :, 2] =
 7   9  11
 8  10  12

julia&gt; [1 2;;; 3 4;;;; 5 6;;; 7 8]
1×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  2

[:, :, 2, 1] =
 3  4

[:, :, 1, 2] =
 5  6

[:, :, 2, 2] =
 7  8

julia&gt; [[1 2;;; 3 4];;;; [5 6];;; [7 8]]
1×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  2

[:, :, 2, 1] =
 3  4

[:, :, 1, 2] =
 5  6

[:, :, 2, 2] =
 7  8</code></pre><p data-translated="true"><span class="original-text">Although they both mean concatenation in the second dimension, spaces (or tabs) and <code>;;</code> cannot appear in the same array expression unless the double semicolon is simply serving as a "line continuation" character. This allows a single horizontal concatenation to span multiple lines (without the line break being interpreted as a vertical concatenation).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">両者が第二次元での連結を意味するにもかかわらず、スペース（またはタブ）と<code>;;</code>は、ダブルセミコロンが単に「行継続」文字として機能している場合を除いて、同じ配列式に現れることはできません。これにより、単一の水平方向の連結が複数行にまたがることが可能になり（改行が垂直方向の連結として解釈されることはありません）、</span></p><pre><code class="language-julia-repl hljs">julia&gt; [1 2 ;;
       3 4]
1×4 Matrix{Int64}:
 1  2  3  4</code></pre><p data-translated="true"><span class="original-text">Terminating semicolons may also be used to add trailing length 1 dimensions.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">終了セミコロンは、長さ1の次元を追加するためにも使用できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; [1;;]
1×1 Matrix{Int64}:
 1

julia&gt; [2; 3;;;]
2×1×1 Array{Int64, 3}:
[:, :, 1] =
 2
 3</code></pre><p data-translated="true"><span class="original-text">More generally, concatenation can be accomplished through the <a href="../../base/arrays/index.html#Base.cat"><code>cat</code></a> function. These syntaxes are shorthands for function calls that themselves are convenience functions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より一般的には、連結は<a href="../../base/arrays/index.html#Base.cat"><code>cat</code></a>関数を通じて実現できます。これらの構文は、便利な関数である関数呼び出しの省略形です：</span></p><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Syntax</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">構文</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Function</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">説明</span></th></tr><tr><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.cat"><code>cat</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.cat"><code>cat</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">concatenate input arrays along dimension(s) <code>k</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">入力配列を次元 <code>k</code> に沿って連結する</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>[A; B; C; ...]</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>[A; B; C; ...]</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.vcat"><code>vcat</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.vcat"><code>vcat</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">shorthand for <code>cat(A...; dims=1)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>cat(A...; dims=1)</code> の省略形</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>[A B C ...]</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>[A B C ...]</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.hcat"><code>hcat</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.hcat"><code>hcat</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">shorthand for <code>cat(A...; dims=2)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>cat(A...; dims=2)</code>の省略形</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>[A B; C D; ...]</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>[A B; C D; ...]</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.hvcat"><code>hvcat</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.hvcat"><code>hvcat</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">simultaneous vertical and horizontal concatenation</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">垂直および水平の同時連結</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>[A; C;; B; D;;; ...]</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>[A; C;; B; D;;; ...]</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.hvncat"><code>hvncat</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.hvncat"><code>hvncat</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">simultaneous n-dimensional concatenation, where number of semicolons indicate the dimension to concatenate</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同時n次元連結、セミコロンの数が連結する次元を示す</span></td></tr></tbody></table><h3 id="man-array-typed-literal" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-array-typed-literal">Typed array literals</a><a id="man-array-typed-literal-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-typed-literal" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-array-typed-literal">型付き配列リテラル</a><a id="man-array-typed-literal-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-typed-literal" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">An array with a specific element type can be constructed using the syntax <code>T[A, B, C, ...]</code>. This will construct a 1-d array with element type <code>T</code>, initialized to contain elements <code>A</code>, <code>B</code>, <code>C</code>, etc. For example, <code>Any[x, y, z]</code> constructs a heterogeneous array that can contain any values.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特定の要素型を持つ配列は、<code>T[A, B, C, ...]</code>という構文を使用して構築できます。これにより、要素型<code>T</code>の1次元配列が構築され、要素<code>A</code>、<code>B</code>、<code>C</code>などを含むように初期化されます。例えば、<code>Any[x, y, z]</code>は任意の値を含むことができる異種配列を構築します。</span></p><p data-translated="true"><span class="original-text">Concatenation syntax can similarly be prefixed with a type to specify the element type of the result.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">連結構文も同様に型を前置して、結果の要素型を指定できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; [[1 2] [3 4]]
1×4 Matrix{Int64}:
 1  2  3  4

julia&gt; Int8[[1 2] [3 4]]
1×4 Matrix{Int8}:
 1  2  3  4</code></pre><h2 id="man-comprehensions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-comprehensions">Comprehensions</a><a id="man-comprehensions-1"></a><a class="docs-heading-anchor-permalink" href="#man-comprehensions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-comprehensions">内包表記</a><a id="man-comprehensions-1"></a><a class="docs-heading-anchor-permalink" href="#man-comprehensions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to set construction notation in mathematics:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">内包表記は、配列を構築するための一般的で強力な方法を提供します。内包表記の構文は、数学における集合構築記法に似ています:</span></p><pre><code class="language-julia hljs">A = [ F(x, y, ...) for x=rx, y=ry, ... ]</code></pre><p data-translated="true"><span class="original-text">The meaning of this form is that <code>F(x,y,...)</code> is evaluated with the variables <code>x</code>, <code>y</code>, etc. taking on each value in their given list of values. Values can be specified as any iterable object, but will commonly be ranges like <code>1:n</code> or <code>2:(n-1)</code>, or explicit arrays of values like <code>[1.2, 3.4, 5.7]</code>. The result is an N-d dense array with dimensions that are the concatenation of the dimensions of the variable ranges <code>rx</code>, <code>ry</code>, etc. and each <code>F(x,y,...)</code> evaluation returns a scalar.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この形式の意味は、<code>F(x,y,...)</code>が変数<code>x</code>、<code>y</code>などが与えられた値のリストの各値を取ることで評価されるということです。値は任意の反復可能なオブジェクトとして指定できますが、一般的には<code>1:n</code>や<code>2:(n-1)</code>のような範囲や、<code>[1.2, 3.4, 5.7]</code>のような明示的な値の配列が使われます。結果は、変数範囲<code>rx</code>、<code>ry</code>などの次元の連結からなるN次元の密な配列であり、各<code>F(x,y,...)</code>の評価はスカラーを返します。</span></p><p data-translated="true"><span class="original-text">The following example computes a weighted average of the current element and its left and right neighbor along a 1-d grid:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次の例は、1次元グリッドに沿った現在の要素とその左隣および右隣の重み付き平均を計算します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(8)
8-element Vector{Float64}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia&gt; [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Vector{Float64}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511</code></pre><p data-translated="true"><span class="original-text">The resulting array type depends on the types of the computed elements just like <a href="#man-array-literals">array literals</a> do. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">結果の配列の型は、計算された要素の型に依存します。これは<a href="#man-array-literals">配列リテラル</a>と同様です。型を明示的に制御するために、理解式の前に型を追加することができます。たとえば、次のように書くことで単精度の結果を要求することができます：</span></p><pre><code class="language-julia hljs">Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]</code></pre><h2 id="man-generators" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-generators">Generator Expressions</a><a id="man-generators-1"></a><a class="docs-heading-anchor-permalink" href="#man-generators" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-generators">ジェネレーター式</a><a id="man-generators-1"></a><a class="docs-heading-anchor-permalink" href="#man-generators" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see <a href="#Iteration">Iteration</a>). For example, the following expression sums a series without allocating memory:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">理解式は、囲む角括弧なしで書くこともでき、これによりジェネレーターと呼ばれるオブジェクトが生成されます。このオブジェクトは、事前に配列を割り当てて値を保存するのではなく、必要に応じて値を生成するために反復可能です（<a href="#Iteration">反復</a>を参照）。たとえば、次の式はメモリを割り当てることなく一連の合計を計算します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; sum(1/n^2 for n=1:1000)
1.6439345666815615</code></pre><p data-translated="true"><span class="original-text">When writing a generator expression with multiple dimensions inside an argument list, parentheses are needed to separate the generator from subsequent arguments:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数リスト内で複数の次元を持つジェネレーター式を書く場合、ジェネレーターを後続の引数から分離するために括弧が必要です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification</code></pre><p data-translated="true"><span class="original-text">All comma-separated expressions after <code>for</code> are interpreted as ranges. Adding parentheses lets us add a third argument to <a href="../../base/collections/index.html#Base.map"><code>map</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>for</code>の後のすべてのカンマ区切りの式は範囲として解釈されます。括弧を追加することで、<a href="../../base/collections/index.html#Base.map"><code>map</code></a>に3番目の引数を追加できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Matrix{Tuple{Float64, Int64}}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)</code></pre><p data-translated="true"><span class="original-text">Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be "captured" in the inner function. For example, <code>sum(p[i] - q[i] for i=1:n)</code> captures the three variables <code>p</code>, <code>q</code> and <code>n</code> from the enclosing scope. Captured variables can present performance challenges; see <a href="../performance-tips/index.html#man-performance-captured">performance tips</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ジェネレーターは内部関数を介して実装されています。言語の他の場所で使用される内部関数と同様に、囲むスコープからの変数は内部関数で「キャプチャ」されることができます。たとえば、<code>sum(p[i] - q[i] for i=1:n)</code>は、囲むスコープから3つの変数<code>p</code>、<code>q</code>、<code>n</code>をキャプチャします。キャプチャされた変数はパフォーマンス上の課題を引き起こす可能性があります。詳細は<a href="../performance-tips/index.html#man-performance-captured">パフォーマンスのヒント</a>を参照してください。</span></p><p data-translated="true"><span class="original-text">Ranges in generators and comprehensions can depend on previous ranges by writing multiple <code>for</code> keywords:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ジェネレーターや理解式の範囲は、複数の<code>for</code>キーワードを書くことで前の範囲に依存することがあります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; [(i, j) for i=1:3 for j=1:i]
6-element Vector{Tuple{Int64, Int64}}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)</code></pre><p data-translated="true"><span class="original-text">In such cases, the result is always 1-d.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そのような場合、結果は常に1次元です。</span></p><p data-translated="true"><span class="original-text">Generated values can be filtered using the <code>if</code> keyword:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">生成された値は <code>if</code> キーワードを使用してフィルタリングできます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; [(i, j) for i=1:3 for j=1:i if i+j == 4]
2-element Vector{Tuple{Int64, Int64}}:
 (2, 2)
 (3, 1)</code></pre><h2 id="man-array-indexing" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-array-indexing">Indexing</a><a id="man-array-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-indexing" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-array-indexing">インデクシング</a><a id="man-array-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-indexing" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The general syntax for indexing into an n-dimensional array <code>A</code> is:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">n次元配列 <code>A</code> へのインデクシングの一般的な構文は次のとおりです：</span></p><pre><code class="nohighlight hljs">X = A[I_1, I_2, ..., I_n]</code></pre><p data-translated="true"><span class="original-text">where each <code>I_k</code> may be a scalar integer, an array of integers, or any other <a href="#man-supported-index-types">supported index</a>. This includes <a href="../../base/arrays/index.html#Base.Colon"><code>Colon</code></a> (<code>:</code>) to select all indices within the entire dimension, ranges of the form <code>a:c</code> or <code>a:b:c</code> to select contiguous or strided subsections, and arrays of booleans to select elements at their <code>true</code> indices.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで、各 <code>I_k</code> はスカラー整数、整数の配列、またはその他の<a href="#man-supported-index-types">サポートされているインデックス</a>である可能性があります。これには、全次元内のすべてのインデックスを選択するための<a href="../../base/arrays/index.html#Base.Colon"><code>Colon</code></a> (<code>:</code>)、連続またはストライドされたサブセクションを選択するための形式 <code>a:c</code> または <code>a:b:c</code>、およびその <code>true</code> インデックスで要素を選択するためのブール値の配列が含まれます。</span></p><p data-translated="true"><span class="original-text">If all the indices are scalars, then the result <code>X</code> is a single element from the array <code>A</code>. Otherwise, <code>X</code> is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべてのインデックスがスカラーである場合、結果 <code>X</code> は配列 <code>A</code> からの単一要素になります。それ以外の場合、<code>X</code> はすべてのインデックスの次元数の合計と同じ次元数を持つ配列になります。</span></p><p data-translated="true"><span class="original-text">If all indices <code>I_k</code> are vectors, for example, then the shape of <code>X</code> would be <code>(length(I_1), length(I_2), ..., length(I_n))</code>, with location <code>i_1, i_2, ..., i_n</code> of <code>X</code> containing the value <code>A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべてのインデックス <code>I_k</code> がベクトルである場合、例えば、<code>X</code> の形状は <code>(length(I_1), length(I_2), ..., length(I_n))</code> となり、<code>X</code> の位置 <code>i_1, i_2, ..., i_n</code> には値 <code>A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]</code> が含まれます。</span></p><p data-translated="true"><span class="original-text">Example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パスワードは <a href="../commands/rclone_obscure/index.html">隠蔽された</a> 形式であることに注意してください。また、多くのストレージシステムはパスワードの代わりにトークンベースの認証を使用しており、これには追加の手順が必要です。設定ファイルを手動で編集する代わりに、インタラクティブコマンド <code>rclone config</code> を使用する方が簡単で安全です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; A[1, 2, 1, 1] # all scalar indices
3

julia&gt; A[[1, 2], [1], [1, 2], [1]] # all vector indices
2×1×2×1 Array{Int64, 4}:
[:, :, 1, 1] =
 1
 2

[:, :, 2, 1] =
 5
 6

julia&gt; A[[1, 2], [1], [1, 2], 1] # a mix of index types
2×1×2 Array{Int64, 3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 5
 6</code></pre><p data-translated="true"><span class="original-text">Note how the size of the resulting array is different in the last two cases.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">結果の配列のサイズが最後の2つのケースで異なることに注意してください。</span></p><p data-translated="true"><span class="original-text">If <code>I_1</code> is changed to a two-dimensional matrix, then <code>X</code> becomes an <code>n+1</code>-dimensional array of shape <code>(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))</code>. The matrix adds a dimension.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>I_1</code> が2次元行列に変更されると、<code>X</code> は形状 <code>(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))</code> の <code>n+1</code> 次元配列になります。行列が次元を追加します。</span></p><p data-translated="true"><span class="original-text">Example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パスワードは <a href="../commands/rclone_obscure/index.html">隠蔽された</a> 形式であることに注意してください。また、多くのストレージシステムはパスワードの代わりにトークンベースの認証を使用しており、これには追加の手順が必要です。設定ファイルを手動で編集する代わりに、インタラクティブコマンド <code>rclone config</code> を使用する方が簡単で安全です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2));

julia&gt; A[[1 2; 1 2]]
2×2 Matrix{Int64}:
 1  2
 1  2

julia&gt; A[[1 2; 1 2], 1, 2, 1]
2×2 Matrix{Int64}:
 5  6
 5  6</code></pre><p data-translated="true"><span class="original-text">The location <code>i_1, i_2, i_3, ..., i_{n+1}</code> contains the value at <code>A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]</code>. All dimensions indexed with scalars are dropped. For example, if <code>J</code> is an array of indices, then the result of <code>A[2, J, 3]</code> is an array with size <code>size(J)</code>. Its <code>j</code>th element is populated by <code>A[2, J[j], 3]</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">位置 <code>i_1, i_2, i_3, ..., i_{n+1}</code> には <code>A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]</code> の値が含まれています。スカラーでインデックス付けされたすべての次元は削除されます。例えば、<code>J</code> がインデックスの配列である場合、<code>A[2, J, 3]</code> の結果はサイズ <code>size(J)</code> の配列になります。その <code>j</code> 番目の要素は <code>A[2, J[j], 3]</code> によって埋められます。</span></p><p data-translated="true"><span class="original-text">As a special part of this syntax, the <code>end</code> keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax without the <code>end</code> keyword is equivalent to a call to <a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この構文の特別な部分として、<code>end</code> キーワードを使用して、インデックス付けされたブラケット内の各次元の最後のインデックスを表すことができます。これは、インデックス付けされる最も内側の配列のサイズによって決まります。<code>end</code> キーワードなしのインデックス付け構文は、<a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a> の呼び出しと同等です：</span></p><pre><code class="nohighlight hljs">X = getindex(A, I_1, I_2, ..., I_n)</code></pre><p data-translated="true"><span class="original-text">Example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パスワードは <a href="../commands/rclone_obscure/index.html">隠蔽された</a> 形式であることに注意してください。また、多くのストレージシステムはパスワードの代わりにトークンベースの認証を使用しており、これには追加の手順が必要です。設定ファイルを手動で編集する代わりに、インタラクティブコマンド <code>rclone config</code> を使用する方が簡単で安全です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[2:3, 2:end-1]
2×2 Matrix{Int64}:
 6  10
 7  11

julia&gt; x[1, [2 3; 4 1]]
2×2 Matrix{Int64}:
  5  9
 13  1</code></pre><h2 id="man-indexed-assignment" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-indexed-assignment">Indexed Assignment</a><a id="man-indexed-assignment-1"></a><a class="docs-heading-anchor-permalink" href="#man-indexed-assignment" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-indexed-assignment">インデックス付き代入</a><a id="man-indexed-assignment-1"></a><a class="docs-heading-anchor-permalink" href="#man-indexed-assignment" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The general syntax for assigning values in an n-dimensional array <code>A</code> is:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">n次元配列 <code>A</code> に値を代入するための一般的な構文は次のとおりです：</span></p><pre><code class="nohighlight hljs">A[I_1, I_2, ..., I_n] = X</code></pre><p data-translated="true"><span class="original-text">where each <code>I_k</code> may be a scalar integer, an array of integers, or any other <a href="#man-supported-index-types">supported index</a>. This includes <a href="../../base/arrays/index.html#Base.Colon"><code>Colon</code></a> (<code>:</code>) to select all indices within the entire dimension, ranges of the form <code>a:c</code> or <code>a:b:c</code> to select contiguous or strided subsections, and arrays of booleans to select elements at their <code>true</code> indices.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで、各 <code>I_k</code> はスカラー整数、整数の配列、またはその他の<a href="#man-supported-index-types">サポートされているインデックス</a>である可能性があります。これには、全次元内のすべてのインデックスを選択するための<a href="../../base/arrays/index.html#Base.Colon"><code>Colon</code></a> (<code>:</code>)、連続またはストライドされたサブセクションを選択するための形式 <code>a:c</code> または <code>a:b:c</code>、およびその <code>true</code> インデックスで要素を選択するためのブール値の配列が含まれます。</span></p><p data-translated="true"><span class="original-text">If all indices <code>I_k</code> are integers, then the value in location <code>I_1, I_2, ..., I_n</code> of <code>A</code> is overwritten with the value of <code>X</code>, <a href="../../base/base/index.html#Base.convert"><code>convert</code></a>ing to the <a href="../../base/collections/index.html#Base.eltype"><code>eltype</code></a> of <code>A</code> if necessary.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべてのインデックス <code>I_k</code> が整数である場合、<code>A</code> の位置 <code>I_1, I_2, ..., I_n</code> の値は <code>X</code> の値で上書きされ、必要に応じて <a href="../../base/base/index.html#Base.convert"><code>convert</code></a> されて <code>A</code> の<a href="../../base/collections/index.html#Base.eltype"><code>eltype</code></a> になります。</span></p><p data-translated="true"><span class="original-text">If any index <code>I_k</code> is itself an array, then the right hand side <code>X</code> must also be an array with the same shape as the result of indexing <code>A[I_1, I_2, ..., I_n]</code> or a vector with the same number of elements. The value in location <code>I_1[i_1], I_2[i_2], ..., I_n[i_n]</code> of <code>A</code> is overwritten with the value <code>X[i_1, i_2, ..., i_n]</code>, converting if necessary. The element-wise assignment operator <code>.=</code> may be used to <a href="#Broadcasting">broadcast</a> <code>X</code> across the selected locations:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">任意のインデックス <code>I_k</code> が配列である場合、右辺の <code>X</code> も <code>A[I_1, I_2, ..., I_n]</code> のインデックス結果と同じ形状の配列であるか、同じ数の要素を持つベクトルでなければなりません。<code>A</code> の位置 <code>I_1[i_1], I_2[i_2], ..., I_n[i_n]</code> の値は <code>X[i_1, i_2, ..., i_n]</code> の値で上書きされ、必要に応じて変換されます。要素ごとの代入演算子 <code>.=</code> を使用して、選択された位置に <code>X</code> を<a href="#Broadcasting">ブロードキャスト</a>することができます：</span></p><pre><code class="nohighlight hljs">A[I_1, I_2, ..., I_n] .= X</code></pre><p data-translated="true"><span class="original-text">Just as in <a href="#man-array-indexing">Indexing</a>, the <code>end</code> keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the <code>end</code> keyword is equivalent to a call to <a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-array-indexing">インデックス付け</a> と同様に、<code>end</code> キーワードを使用して、代入される配列のサイズによって決まるインデックス付けブラケット内の各次元の最後のインデックスを表すことができます。<code>end</code> キーワードなしのインデックス付き代入構文は、<a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a> の呼び出しと同等です：</span></p><pre><code class="nohighlight hljs">setindex!(A, X, I_1, I_2, ..., I_n)</code></pre><p data-translated="true"><span class="original-text">Example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パスワードは <a href="../commands/rclone_obscure/index.html">隠蔽された</a> 形式であることに注意してください。また、多くのストレージシステムはパスワードの代わりにトークンベースの認証を使用しており、これには追加の手順が必要です。設定ファイルを手動で編集する代わりに、インタラクティブコマンド <code>rclone config</code> を使用する方が簡単で安全です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = collect(reshape(1:9, 3, 3))
3×3 Matrix{Int64}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; x[3, 3] = -9;

julia&gt; x[1:2, 1:2] = [-1 -4; -2 -5];

julia&gt; x
3×3 Matrix{Int64}:
 -1  -4   7
 -2  -5   8
  3   6  -9</code></pre><h2 id="man-supported-index-types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-supported-index-types">Supported index types</a><a id="man-supported-index-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-supported-index-types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-supported-index-types">サポートされているインデックスの種類</a><a id="man-supported-index-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-supported-index-types" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">In the expression <code>A[I_1, I_2, ..., I_n]</code>, each <code>I_k</code> may be a scalar index, an array of scalar indices, or an object that represents an array of scalar indices and can be converted to such by <a href="../../base/arrays/index.html#Base.to_indices"><code>to_indices</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">式 <code>A[I_1, I_2, ..., I_n]</code> では、各 <code>I_k</code> はスカラーインデックス、スカラーインデックスの配列、またはスカラーインデックスの配列を表し、<a href="../../base/arrays/index.html#Base.to_indices"><code>to_indices</code></a> によってそのように変換できるオブジェクトである可能性があります。</span></p><ol><li>A scalar index. By default this includes:<ul><li data-translated="true"><span class="original-text">Non-boolean integers</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">非ブール整数</span></li><li data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex{N}</code></a>s, which behave like an <code>N</code>-tuple of integers spanning multiple dimensions (see below for more details)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex{N}</code></a>sは、複数の次元にまたがる整数の<code>N</code>-タプルのように振る舞います（詳細は以下を参照）</span></li></ul></li><li>An array of scalar indices. This includes:<ul><li data-translated="true"><span class="original-text">Vectors and multidimensional arrays of integers</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">整数のベクトルおよび多次元配列</span></li><li data-translated="true"><span class="original-text">Empty arrays like <code>[]</code>, which select no elements e.g. <code>A[[]]</code> (not to be confused with <code>A[]</code>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>[]</code>のような空の配列は、要素を選択しません。例えば、<code>A[[]]</code>（<code>A[]</code>と混同しないでください）</span></li><li data-translated="true"><span class="original-text">Ranges like <code>a:c</code> or <code>a:b:c</code>, which select contiguous or strided subsections from <code>a</code> to <code>c</code> (inclusive)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>a:c</code>や<code>a:b:c</code>のような範囲は、<code>a</code>から<code>c</code>（含む）までの連続したまたはストライドされた部分を選択します</span></li><li data-translated="true"><span class="original-text">Any custom array of scalar indices that is a subtype of <code>AbstractArray</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>AbstractArray</code>のサブタイプである任意のスカラーインデックスのカスタム配列</span></li><li data-translated="true"><span class="original-text">Arrays of <code>CartesianIndex{N}</code> (see below for more details)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>CartesianIndex{N}</code> の配列（詳細については以下を参照）</span></li></ul></li><li>An object that represents an array of scalar indices and can be converted to such by <a href="../../base/arrays/index.html#Base.to_indices"><code>to_indices</code></a>. By default this includes:<ul><li data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.Colon"><code>Colon()</code></a> (<code>:</code>), which represents all indices within an entire dimension or across the entire array</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.Colon"><code>Colon()</code></a> (<code>:</code>) は、全次元または配列全体のすべてのインデックスを表します</span></li><li data-translated="true"><span class="original-text">Arrays of booleans, which select elements at their <code>true</code> indices (see below for more details)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ブール値の配列で、<code>true</code> インデックスで要素を選択します（詳細については以下を参照）</span></li></ul></li></ol><p data-translated="true"><span class="original-text">Some examples:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">いくつかの例:</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(collect(1:2:18), (3, 3))
3×3 Matrix{Int64}:
 1   7  13
 3   9  15
 5  11  17

julia&gt; A[4]
7

julia&gt; A[[2, 5, 8]]
3-element Vector{Int64}:
  3
  9
 15

julia&gt; A[[1 4; 3 8]]
2×2 Matrix{Int64}:
 1   7
 5  15

julia&gt; A[[]]
Int64[]

julia&gt; A[1:2:5]
3-element Vector{Int64}:
 1
 5
 9

julia&gt; A[2, :]
3-element Vector{Int64}:
  3
  9
 15

julia&gt; A[:, 3]
3-element Vector{Int64}:
 13
 15
 17

julia&gt; A[:, 3:3]
3×1 Matrix{Int64}:
 13
 15
 17</code></pre><h3 id="Cartesian-indices" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Cartesian-indices">Cartesian indices</a><a id="Cartesian-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-indices" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Cartesian-indices">デカルトインデックス</a><a id="Cartesian-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-indices" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The special <code>CartesianIndex{N}</code> object represents a scalar index that behaves like an <code>N</code>-tuple of integers spanning multiple dimensions. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特別な <code>CartesianIndex{N}</code> オブジェクトは、複数の次元にまたがる整数の <code>N</code>-タプルのように振る舞うスカラーインデックスを表します。例えば:</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(1:32, 4, 4, 2);

julia&gt; A[3, 2, 1]
7

julia&gt; A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true</code></pre><p data-translated="true"><span class="original-text">Considered alone, this may seem relatively trivial; <code>CartesianIndex</code> simply gathers multiple integers together into one object that represents a single multidimensional index. When combined with other indexing forms and iterators that yield <code>CartesianIndex</code>es, however, this can produce very elegant and efficient code. See <a href="#Iteration">Iteration</a> below, and for some more advanced examples, see <a href="https://julialang.org/blog/2016/02/iteration">this blog post on multidimensional algorithms and iteration</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">単独で考えると、これは比較的些細に見えるかもしれません; <code>CartesianIndex</code> は単に複数の整数を一つのオブジェクトにまとめて、単一の多次元インデックスを表します。しかし、他のインデックス形式や <code>CartesianIndex</code> を生成するイテレータと組み合わせると、非常に優雅で効率的なコードを生み出すことができます。以下の <a href="#Iteration">イテレーション</a> を参照し、さらに高度な例については、<a href="https://julialang.org/blog/2016/02/iteration">このブログ記事</a>を参照してください。</span></p><p data-translated="true"><span class="original-text">Arrays of <code>CartesianIndex{N}</code> are also supported. They represent a collection of scalar indices that each span <code>N</code> dimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first "page" of <code>A</code> from above:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>CartesianIndex{N}</code> の配列もサポートされています。これらはそれぞれ <code>N</code> 次元にまたがるスカラーインデックスのコレクションを表し、時には点ごとのインデックス付けと呼ばれる形式のインデックス付けを可能にします。例えば、上記の <code>A</code> の最初の「ページ」から対角要素にアクセスすることができます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; page = A[:, :, 1]
4×4 Matrix{Int64}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; page[[CartesianIndex(1, 1),
             CartesianIndex(2, 2),
             CartesianIndex(3, 3),
             CartesianIndex(4, 4)]]
4-element Vector{Int64}:
  1
  6
 11
 16</code></pre><p data-translated="true"><span class="original-text">This can be expressed much more simply with <a href="../functions/index.html#man-vectorized">dot broadcasting</a> and by combining it with a normal integer index (instead of extracting the first <code>page</code> from <code>A</code> as a separate step). It can even be combined with a <code>:</code> to extract both diagonals from the two pages at the same time:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../functions/index.html#man-vectorized">ドットブロードキャスティング</a> を使用し、通常の整数インデックスと組み合わせることで、これをはるかに簡単に表現できます（<code>A</code> から最初の <code>page</code> を別のステップとして抽出するのではなく）。<code>:</code> を組み合わせることで、2つのページから同時に両方の対角を抽出することもできます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]
4-element Vector{Int64}:
  1
  6
 11
 16

julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]
4×2 Matrix{Int64}:
  1  17
  6  22
 11  27
 16  32</code></pre><div class="admonition is-warning" id="Warning-3d505b4723551dec"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-3d505b4723551dec" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text"><code>CartesianIndex</code> and arrays of <code>CartesianIndex</code> are not compatible with the <code>end</code> keyword to represent the last index of a dimension. Do not use <code>end</code> in indexing expressions that may contain either <code>CartesianIndex</code> or arrays thereof.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>CartesianIndex</code> と <code>CartesianIndex</code> の配列は、次元の最後のインデックスを表すために <code>end</code> キーワードと互換性がありません。<code>CartesianIndex</code> またはその配列を含む可能性のあるインデックス式で <code>end</code> を使用しないでください。</span></p></div></div><h3 id="Logical-indexing" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Logical-indexing">Logical indexing</a><a id="Logical-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Logical-indexing" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Logical-indexing">論理インデクシング</a><a id="Logical-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Logical-indexing" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Often referred to as logical indexing or indexing with a logical mask, indexing by a boolean array selects elements at the indices where its values are <code>true</code>. Indexing by a boolean vector <code>B</code> is effectively the same as indexing by the vector of integers that is returned by <a href="../../base/arrays/index.html#Base.findall-Tuple{Any}"><code>findall(B)</code></a>. Similarly, indexing by a <code>N</code>-dimensional boolean array is effectively the same as indexing by the vector of <code>CartesianIndex{N}</code>s where its values are <code>true</code>. A logical index must be an array of the same shape as the dimension(s) it indexes into, or it must be the only index provided and match the shape of the one-dimensional reshaped view of the array it indexes into. It is generally more efficient to use boolean arrays as indices directly instead of first calling <a href="../../base/arrays/index.html#Base.findall-Tuple{Any}"><code>findall</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">論理インデックス付けまたは論理マスクによるインデックス付けと呼ばれることが多いですが、ブール配列によるインデックス付けは、その値が <code>true</code> であるインデックスで要素を選択します。ブールベクトル <code>B</code> によるインデックス付けは、<a href="../../base/arrays/index.html#Base.findall-Tuple{Any}"><code>findall(B)</code></a> によって返される整数のベクトルによるインデックス付けと実質的に同じです。同様に、<code>N</code> 次元のブール配列によるインデックス付けは、その値が <code>true</code> である <code>CartesianIndex{N}</code> のベクトルによるインデックス付けと実質的に同じです。論理インデックスは、インデックス付けされる次元と同じ形状の配列でなければならず、または提供される唯一のインデックスであり、インデックス付けされる配列の一次元の再形成されたビューの形状と一致しなければなりません。一般的に、最初に <a href="../../base/arrays/index.html#Base.findall-Tuple{Any}"><code>findall</code></a> を呼び出すのではなく、ブール配列をインデックスとして直接使用する方が効率的です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = reshape(1:12, 2, 3, 2)
2×3×2 reshape(::UnitRange{Int64}, 2, 3, 2) with eltype Int64:
[:, :, 1] =
 1  3  5
 2  4  6

[:, :, 2] =
 7   9  11
 8  10  12

julia&gt; x[:, [true false; false true; true false]]
2×3 Matrix{Int64}:
 1  5   9
 2  6  10

julia&gt; mask = map(ispow2, x)
2×3×2 Array{Bool, 3}:
[:, :, 1] =
 1  0  0
 1  1  0

[:, :, 2] =
 0  0  0
 1  0  0

julia&gt; x[mask]
4-element Vector{Int64}:
 1
 2
 4
 8

julia&gt; x[vec(mask)] == x[mask] # we can also index with a single Boolean vector
true</code></pre><h3 id="Number-of-indices" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Number-of-indices">Number of indices</a><a id="Number-of-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Number-of-indices" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Number-of-indices">インデックスの数</a><a id="Number-of-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Number-of-indices" title="Permalink"></a></span></h3><h4 id="Cartesian-indexing" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Cartesian-indexing">Cartesian indexing</a><a id="Cartesian-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-indexing" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Cartesian-indexing">デカルトインデクシング</a><a id="Cartesian-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-indexing" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">The ordinary way to index into an <code>N</code>-dimensional array is to use exactly <code>N</code> indices; each index selects the position(s) in its particular dimension. For example, in the three-dimensional array <code>A = rand(4, 3, 2)</code>, <code>A[2, 3, 1]</code> will select the number in the second row of the third column in the first "page" of the array. This is often referred to as <em>cartesian indexing</em>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">N次元配列にインデックスを付ける通常の方法は、正確にN個のインデックスを使用することです。各インデックスは、その特定の次元における位置を選択します。例えば、三次元配列 <code>A = rand(4, 3, 2)</code> において、<code>A[2, 3, 1]</code> は配列の最初の「ページ」の第三列の第二行の数を選択します。これはしばしば <em>直交インデックス</em> と呼ばれます。</span></p><h4 id="Linear-indexing" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Linear-indexing">Linear indexing</a><a id="Linear-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-indexing" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Linear-indexing">線形インデクシング</a><a id="Linear-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-indexing" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">When exactly one index <code>i</code> is provided, that index no longer represents a location in a particular dimension of the array. Instead, it selects the <code>i</code>th element using the column-major iteration order that linearly spans the entire array. This is known as <em>linear indexing</em>. It essentially treats the array as though it had been reshaped into a one-dimensional vector with <a href="../../base/arrays/index.html#Base.vec"><code>vec</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">正確に1つのインデックス <code>i</code> が提供されると、そのインデックスは配列の特定の次元における位置を表さなくなります。代わりに、全体の配列を線形にスパンする列優先の反復順序を使用して <code>i</code> 番目の要素を選択します。これは <em>線形インデックス</em> として知られています。これは基本的に、配列を <a href="../../base/arrays/index.html#Base.vec"><code>vec</code></a> を使って1次元ベクトルに変形したかのように扱います。</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = [2 6; 4 7; 3 1]
3×2 Matrix{Int64}:
 2  6
 4  7
 3  1

julia&gt; A[5]
7

julia&gt; vec(A)[5]
7</code></pre><p data-translated="true"><span class="original-text">A linear index into the array <code>A</code> can be converted to a <code>CartesianIndex</code> for cartesian indexing with <code>CartesianIndices(A)[i]</code> (see <a href="../../base/arrays/index.html#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a>), and a set of <code>N</code> cartesian indices can be converted to a linear index with <code>LinearIndices(A)[i_1, i_2, ..., i_N]</code> (see <a href="../../base/arrays/index.html#Base.LinearIndices"><code>LinearIndices</code></a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列 <code>A</code> への線形インデックスは、<code>CartesianIndices(A)[i]</code> を使用して直交インデックスに変換できます（<a href="../../base/arrays/index.html#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a> を参照）、また、<code>N</code> 個の直交インデックスのセットは、<code>LinearIndices(A)[i_1, i_2, ..., i_N]</code> を使用して線形インデックスに変換できます（<a href="../../base/arrays/index.html#Base.LinearIndices"><code>LinearIndices</code></a> を参照）。</span></p><pre><code class="language-julia-repl hljs">julia&gt; CartesianIndices(A)[5]
CartesianIndex(2, 2)

julia&gt; LinearIndices(A)[2, 2]
5</code></pre><p data-translated="true"><span class="original-text">It's important to note that there's a very large asymmetry in the performance of these conversions. Converting a linear index to a set of cartesian indices requires dividing and taking the remainder, whereas going the other way is just multiplies and adds. In modern processors, integer division can be 10-50 times slower than multiplication. While some arrays — like <a href="../../base/arrays/index.html#Core.Array"><code>Array</code></a> itself — are implemented using a linear chunk of memory and directly use a linear index in their implementations, other arrays — like <a href="../../stdlib/LinearAlgebra/index.html#LinearAlgebra.Diagonal"><code>Diagonal</code></a> — need the full set of cartesian indices to do their lookup (see <a href="../../base/arrays/index.html#Base.IndexStyle"><code>IndexStyle</code></a> to introspect which is which).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの変換のパフォーマンスには非常に大きな非対称性があることに注意することが重要です。線形インデックスを直交インデックスのセットに変換するには、割り算と余りを取る必要がありますが、逆に行く場合は単に掛け算と足し算です。現代のプロセッサでは、整数の割り算は掛け算の10〜50倍遅くなることがあります。一部の配列 — 例えば <a href="../../base/arrays/index.html#Core.Array"><code>Array</code></a> 自体 — は線形メモリチャンクを使用して実装され、実装内で線形インデックスを直接使用しますが、他の配列 — 例えば <a href="../../stdlib/LinearAlgebra/index.html#LinearAlgebra.Diagonal"><code>Diagonal</code></a> — は、ルックアップを行うために完全な直交インデックスのセットが必要です（どちらがどちらかを調べるには <a href="../../base/arrays/index.html#Base.IndexStyle"><code>IndexStyle</code></a> を参照）。</span></p><div class="admonition is-warning" id="Warning-2d52139087bb599f"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-2d52139087bb599f" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">When iterating over all the indices for an array, it is better to iterate over <a href="../../base/arrays/index.html#Base.eachindex"><code>eachindex(A)</code></a> instead of <code>1:length(A)</code>. Not only will this be faster in cases where <code>A</code> is <code>IndexCartesian</code>, but it will also support arrays with custom indexing, such as <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays</a>. If only the values are needed, then is better to just iterate the array directly, i.e. <code>for a in A</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列のすべてのインデックスを反復処理する場合は、<code>1:length(A)</code> の代わりに <a href="../../base/arrays/index.html#Base.eachindex"><code>eachindex(A)</code></a> を反復処理する方が良いです。これは、<code>A</code> が <code>IndexCartesian</code> の場合に速くなるだけでなく、<a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays</a> のようなカスタムインデックスを持つ配列もサポートします。値だけが必要な場合は、配列を直接反復処理する方が良い、つまり <code>for a in A</code> のようにします。</span></p></div></div><h4 id="Omitted-and-extra-indices" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Omitted-and-extra-indices">Omitted and extra indices</a><a id="Omitted-and-extra-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Omitted-and-extra-indices" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Omitted-and-extra-indices">省略されたインデックスと追加のインデックス</a><a id="Omitted-and-extra-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Omitted-and-extra-indices" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">In addition to linear indexing, an <code>N</code>-dimensional array may be indexed with fewer or more than <code>N</code> indices in certain situations.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">線形インデックスに加えて、<code>N</code> 次元配列は、特定の状況で <code>N</code> 個未満または以上のインデックスでインデックス付けされることがあります。</span></p><p data-translated="true"><span class="original-text">Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words, trailing indices can be omitted only if there is only one possible value that those omitted indices could be for an in-bounds indexing expression. For example, a four-dimensional array with size <code>(3, 4, 2, 1)</code> may be indexed with only three indices as the dimension that gets skipped (the fourth dimension) has length one. Note that linear indexing takes precedence over this rule.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">インデックスは、インデックスされていない末尾の次元がすべて長さ1である場合に省略できます。言い換えれば、末尾のインデックスは、インバウンズインデックス式に対して省略されたインデックスが取ることができる値が1つだけの場合にのみ省略できます。例えば、サイズが<code>(3, 4, 2, 1)</code>の4次元配列は、スキップされる次元（4次元目）が長さ1であるため、3つのインデックスのみでインデックス指定できます。線形インデックスはこのルールに優先します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(1:24, 3, 4, 2, 1)
3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64:
[:, :, 1, 1] =
 1  4  7  10
 2  5  8  11
 3  6  9  12

[:, :, 2, 1] =
 13  16  19  22
 14  17  20  23
 15  18  21  24

julia&gt; A[1, 3, 2] # Omits the fourth dimension (length 1)
19

julia&gt; A[1, 3] # Attempts to omit dimensions 3 &amp; 4 (lengths 2 and 1)
ERROR: BoundsError: attempt to access 3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64 at index [1, 3]

julia&gt; A[19] # Linear indexing
19</code></pre><p data-translated="true"><span class="original-text">When omitting <em>all</em> indices with <code>A[]</code>, this semantic provides a simple idiom to retrieve the only element in an array and simultaneously ensure that there was only one element.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべてのインデックスを<code>A[]</code>で省略する場合、このセマンティクスは配列内の唯一の要素を取得し、同時に要素が1つだけであることを保証する簡単なイディオムを提供します。</span></p><p data-translated="true"><span class="original-text">Similarly, more than <code>N</code> indices may be provided if all the indices beyond the dimensionality of the array are <code>1</code> (or more generally are the first and only element of <code>axes(A, d)</code> where <code>d</code> is that particular dimension number). This allows vectors to be indexed like one-column matrices, for example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同様に、配列の次元を超えるすべてのインデックスが<code>1</code>（または一般的には<code>axes(A, d)</code>の最初の要素であり、<code>d</code>がその特定の次元番号である場合）である場合、<code>N</code>を超えるインデックスを提供できます。これにより、ベクトルを1列の行列のようにインデックス指定できます。例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = [8, 6, 7]
3-element Vector{Int64}:
 8
 6
 7

julia&gt; A[2, 1]
6</code></pre><h2 id="Iteration" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Iteration">反復</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The recommended ways to iterate over a whole array are</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列全体を反復処理するための推奨される方法は</span></p><pre><code class="language-julia hljs">for a in A
    # Do something with the element a
end

for i in eachindex(A)
    # Do something with i and/or A[i]
end</code></pre><p data-translated="true"><span class="original-text">The first construct is used when you need the value, but not index, of each element. In the second construct, <code>i</code> will be an <code>Int</code> if <code>A</code> is an array type with fast linear indexing; otherwise, it will be a <code>CartesianIndex</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初の構文は、各要素の値は必要だがインデックスは必要ない場合に使用されます。2番目の構文では、<code>i</code>は、<code>A</code>が高速な線形インデックスを持つ配列型である場合は<code>Int</code>になり、それ以外の場合は<code>CartesianIndex</code>になります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(4, 3);

julia&gt; B = view(A, 1:3, 2:3);

julia&gt; for i in eachindex(B)
           @show i
       end
i = CartesianIndex(1, 1)
i = CartesianIndex(2, 1)
i = CartesianIndex(3, 1)
i = CartesianIndex(1, 2)
i = CartesianIndex(2, 2)
i = CartesianIndex(3, 2)</code></pre><div class="admonition is-info" id="Note-a0d20c2312d184cd"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a0d20c2312d184cd" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">In contrast with <code>for i = 1:length(A)</code>, iterating with <a href="../../base/arrays/index.html#Base.eachindex"><code>eachindex</code></a> provides an efficient way to iterate over any array type. Besides, this also supports generic arrays with custom indexing such as <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>for i = 1:length(A)</code>と対照的に、<a href="../../base/arrays/index.html#Base.eachindex"><code>eachindex</code></a>を使用して反復処理することで、任意の配列型を効率的に反復処理できます。さらに、これは<a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays</a>のようなカスタムインデックスを持つ一般的な配列もサポートします。</span></p></div></div><h2 id="Array-traits" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Array-traits">Array traits</a><a id="Array-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Array-traits" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Array-traits">配列の特性</a><a id="Array-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Array-traits" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">If you write a custom <a href="../../base/arrays/index.html#Core.AbstractArray"><code>AbstractArray</code></a> type, you can specify that it has fast linear indexing using</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">カスタム<a href="../../base/arrays/index.html#Core.AbstractArray"><code>AbstractArray</code></a>型を作成する場合、高速な線形インデックスを持つことを指定できます。</span></p><pre><code class="language-julia hljs">Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</code></pre><p data-translated="true"><span class="original-text">This setting will cause <code>eachindex</code> iteration over a <code>MyArray</code> to use integers. If you don't specify this trait, the default value <code>IndexCartesian()</code> is used.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この設定により、<code>MyArray</code>に対する<code>eachindex</code>の反復処理が整数を使用するようになります。この特性を指定しない場合、デフォルト値<code>IndexCartesian()</code>が使用されます。</span></p><h2 id="man-array-and-vectorized-operators-and-functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-array-and-vectorized-operators-and-functions">Array and Vectorized Operators and Functions</a><a id="man-array-and-vectorized-operators-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-and-vectorized-operators-and-functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-array-and-vectorized-operators-and-functions">配列およびベクトル化演算子と関数</a><a id="man-array-and-vectorized-operators-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-and-vectorized-operators-and-functions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The following operators are supported for arrays:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次の演算子が配列に対してサポートされています：</span></p><ol><li data-translated="true"><span class="original-text">Unary arithmetic – <code>-</code>, <code>+</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">単項算術 – <code>-</code>, <code>+</code></span></li><li data-translated="true"><span class="original-text">Binary arithmetic – <code>-</code>, <code>+</code>, <code>*</code>, <code>/</code>, <code>\</code>, <code>^</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">二項算術 – <code>-</code>, <code>+</code>, <code>*</code>, <code>/</code>, <code>\</code>, <code>^</code></span></li><li data-translated="true"><span class="original-text">Comparison – <code>==</code>, <code>!=</code>, <code>≈</code> (<a href="../../base/math/index.html#Base.isapprox"><code>isapprox</code></a>), <code>≉</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">比較 – <code>==</code>, <code>!=</code>, <code>≈</code> (<a href="../../base/math/index.html#Base.isapprox"><code>isapprox</code></a>), <code>≉</code></span></li></ol><p data-translated="true"><span class="original-text">To enable convenient vectorization of mathematical and other operations, Julia <a href="../functions/index.html#man-vectorized">provides the dot syntax</a> <code>f.(args...)</code>, e.g. <code>sin.(x)</code> or <code>min.(x, y)</code>, for elementwise operations over arrays or mixtures of arrays and scalars (a <a href="#Broadcasting">Broadcasting</a> operation); these have the additional advantage of "fusing" into a single loop when combined with other dot calls, e.g. <code>sin.(cos.(x))</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">数学的およびその他の操作の便利なベクトル化を可能にするために、Juliaは<a href="../functions/index.html#man-vectorized">ドット構文</a> <code>f.(args...)</code>を提供します。例えば、<code>sin.(x)</code>や<code>min.(x, y)</code>など、配列やスカラーの混合に対する要素ごとの操作（<a href="#Broadcasting">ブロードキャスティング</a>操作）を行います。これらは、他のドット呼び出しと組み合わせるときに「融合」して単一のループにする追加の利点があります。例えば、<code>sin.(cos.(x))</code>のように。</span></p><p data-translated="true"><span class="original-text">Also, <em>every</em> binary operator supports a <a href="../mathematical-operations/index.html#man-dot-operators">dot version</a> that can be applied to arrays (and combinations of arrays and scalars) in such <a href="../functions/index.html#man-vectorized">fused broadcasting operations</a>, e.g. <code>z .== sin.(x .* y)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、<em>すべての</em>二項演算子は、配列（および配列とスカラーの組み合わせ）に適用できる<a href="../mathematical-operations/index.html#man-dot-operators">ドットバージョン</a>をサポートしています。例えば、<code>z .== sin.(x .* y)</code>のような<a href="../functions/index.html#man-vectorized">融合ブロードキャスティング操作</a>です。</span></p><p data-translated="true"><span class="original-text">Note that comparisons such as <code>==</code> operate on whole arrays, giving a single boolean answer. Use dot operators like <code>.==</code> for elementwise comparisons. (For comparison operations like <code>&lt;</code>, <em>only</em> the elementwise <code>.&lt;</code> version is applicable to arrays.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">比較演算子<code>==</code>は全体の配列に対して動作し、単一のブール値の答えを返すことに注意してください。要素ごとの比較には、<code>.==</code>のようなドット演算子を使用してください。（<code>&lt;</code>のような比較演算子の場合、<em>要素ごとの</em> <code>.&lt;</code>バージョンのみが配列に適用可能です。）</span></p><p data-translated="true"><span class="original-text">Also notice the difference between <code>max.(a,b)</code>, which <a href="../../base/arrays/index.html#Base.Broadcast.broadcast"><code>broadcast</code></a>s <a href="../../base/math/index.html#Base.max"><code>max</code></a> elementwise over <code>a</code> and <code>b</code>, and <a href="../../base/collections/index.html#Base.maximum"><code>maximum(a)</code></a>, which finds the largest value within <code>a</code>. The same relationship holds for <code>min.(a, b)</code> and <code>minimum(a)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、<code>max.(a,b)</code>と<a href="../../base/arrays/index.html#Base.Broadcast.broadcast"><code>broadcast</code></a>が<code>a</code>と<code>b</code>に対して要素ごとに<a href="../../base/math/index.html#Base.max"><code>max</code></a>を行うのと、<a href="../../base/collections/index.html#Base.maximum"><code>maximum(a)</code></a>が<code>a</code>内の最大値を見つけることとの違いに注意してください。同様の関係は<code>min.(a, b)</code>と<code>minimum(a)</code>にも当てはまります。</span></p><h2 id="Broadcasting" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Broadcasting">Broadcasting</a><a id="Broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Broadcasting">ブロードキャスティング</a><a id="Broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as adding a vector to each column of a matrix. An inefficient way to do this would be to replicate the vector to the size of the matrix:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">異なるサイズの配列に対して要素ごとの二項演算を行うことは、時には便利です。たとえば、ベクトルを行列の各列に加算する場合などです。これを非効率的に行う方法は、ベクトルを行列のサイズに複製することです。</span></p><pre><code class="language-julia-repl hljs">julia&gt; a = rand(2, 1); A = rand(2, 3);

julia&gt; repeat(a, 1, 3) + A
2×3 Matrix{Float64}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846</code></pre><p data-translated="true"><span class="original-text">This is wasteful when dimensions get large, so Julia provides <a href="../../base/arrays/index.html#Base.Broadcast.broadcast"><code>broadcast</code></a>, which expands singleton dimensions in array arguments to match the corresponding dimension in the other array without using extra memory, and applies the given function elementwise:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次元が大きくなると無駄が生じるため、Juliaは<a href="../../base/arrays/index.html#Base.Broadcast.broadcast"><code>broadcast</code></a>を提供しています。これは、配列引数の単一次元を他の配列の対応する次元に合わせて拡張し、追加のメモリを使用せずに指定された関数を要素ごとに適用します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; broadcast(+, a, A)
2×3 Matrix{Float64}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia&gt; b = rand(1,2)
1×2 Matrix{Float64}:
 0.867535  0.00457906

julia&gt; broadcast(+, a, b)
2×2 Matrix{Float64}:
 1.71056  0.847604
 1.73659  0.873631</code></pre><p data-translated="true"><span class="original-text"><a href="../mathematical-operations/index.html#man-dot-operators">Dotted operators</a> such as <code>.+</code> and <code>.*</code> are equivalent to <code>broadcast</code> calls (except that they fuse, as <a href="#man-array-and-vectorized-operators-and-functions">described above</a>). There is also a <a href="../../base/arrays/index.html#Base.Broadcast.broadcast!"><code>broadcast!</code></a> function to specify an explicit destination (which can also be accessed in a fusing fashion by <code>.=</code> assignment). In fact, <code>f.(args...)</code> is equivalent to <code>broadcast(f, args...)</code>, providing a convenient syntax to broadcast any function (<a href="../functions/index.html#man-vectorized">dot syntax</a>). Nested "dot calls" <code>f.(...)</code> (including calls to <code>.+</code> etcetera) <a href="../mathematical-operations/index.html#man-dot-operators">automatically fuse</a> into a single <code>broadcast</code> call.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../mathematical-operations/index.html#man-dot-operators">ドット演算子</a>（<code>.+</code>や<code>.*</code>など）は、<code>broadcast</code>呼び出しと同等です（ただし、<a href="#man-array-and-vectorized-operators-and-functions">上記のように</a>融合します）。明示的な宛先を指定するための<a href="../../base/arrays/index.html#Base.Broadcast.broadcast!"><code>broadcast!</code></a>関数もあり、これは<code>.=</code>代入によって融合的にアクセスすることもできます。実際、<code>f.(args...)</code>は<code>broadcast(f, args...)</code>と同等であり、任意の関数をブロードキャストするための便利な構文を提供します（<a href="../functions/index.html#man-vectorized">ドット構文</a>）。ネストされた「ドット呼び出し」<code>f.(...)</code>（<code>.+</code>などの呼び出しを含む）は、<a href="../mathematical-operations/index.html#man-dot-operators">自動的に融合</a>して単一の<code>broadcast</code>呼び出しになります。</span></p><p data-translated="true"><span class="original-text">Additionally, <a href="../../base/arrays/index.html#Base.Broadcast.broadcast"><code>broadcast</code></a> is not limited to arrays (see the function documentation); it also handles scalars, tuples and other collections. By default, only some argument types are considered scalars, including (but not limited to) <code>Number</code>s, <code>String</code>s, <code>Symbol</code>s, <code>Type</code>s, <code>Function</code>s and some common singletons like <code>missing</code> and <code>nothing</code>. All other arguments are iterated over or indexed into elementwise.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さらに、<a href="../../base/arrays/index.html#Base.Broadcast.broadcast"><code>broadcast</code></a>は配列に限定されません（関数のドキュメントを参照）。スカラー、タプル、その他のコレクションも扱います。デフォルトでは、<code>Number</code>、<code>String</code>、<code>Symbol</code>、<code>Type</code>、<code>Function</code>、および<code>missing</code>や<code>nothing</code>のような一般的な単一値を含む（がそれに限定されない）いくつかの引数タイプのみがスカラーと見なされます。他のすべての引数は要素ごとに反復処理またはインデックス化されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; convert.(Float32, [1, 2])
2-element Vector{Float32}:
 1.0
 2.0

julia&gt; ceil.(UInt8, [1.2 3.4; 5.6 6.7])
2×2 Matrix{UInt8}:
 0x02  0x04
 0x06  0x07

julia&gt; string.(1:3, ". ", ["First", "Second", "Third"])
3-element Vector{String}:
 "1. First"
 "2. Second"
 "3. Third"</code></pre><p data-translated="true"><span class="original-text">Sometimes, you want a container (like an array) that would normally participate in broadcast to be "protected" from broadcast's behavior of iterating over all of its elements. By placing it inside another container (like a single element <a href="../../base/base/index.html#Core.Tuple"><code>Tuple</code></a>) broadcast will treat it as a single value.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">時には、通常はブロードキャストに参加するコンテナ（配列のようなもの）が、すべての要素を反復処理するブロードキャストの動作から「保護」されることを望むことがあります。別のコンテナ（単一要素の<a href="../../base/base/index.html#Core.Tuple"><code>Tuple</code></a>など）の中に配置することで、ブロードキャストはそれを単一の値として扱います。</span></p><pre><code class="language-julia-repl hljs">julia&gt; ([1, 2, 3], [4, 5, 6]) .+ ([1, 2, 3],)
([2, 4, 6], [5, 7, 9])

julia&gt; ([1, 2, 3], [4, 5, 6]) .+ tuple([1, 2, 3])
([2, 4, 6], [5, 7, 9])</code></pre><h2 id="Implementation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Implementation">実装</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The base array type in Julia is the abstract type <a href="../../base/arrays/index.html#Core.AbstractArray"><code>AbstractArray{T,N}</code></a>. It is parameterized by the number of dimensions <code>N</code> and the element type <code>T</code>. <a href="../../base/arrays/index.html#Base.AbstractVector"><code>AbstractVector</code></a> and <a href="../../base/arrays/index.html#Base.AbstractMatrix"><code>AbstractMatrix</code></a> are aliases for the 1-d and 2-d cases. Operations on <code>AbstractArray</code> objects are defined using higher level operators and functions, in a way that is independent of the underlying storage. These operations generally work correctly as a fallback for any specific array implementation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの基本配列タイプは抽象型<a href="../../base/arrays/index.html#Core.AbstractArray"><code>AbstractArray{T,N}</code></a>です。これは次元数<code>N</code>と要素タイプ<code>T</code>によってパラメータ化されています。<a href="../../base/arrays/index.html#Base.AbstractVector"><code>AbstractVector</code></a>と<a href="../../base/arrays/index.html#Base.AbstractMatrix"><code>AbstractMatrix</code></a>は1次元および2次元の場合のエイリアスです。<code>AbstractArray</code>オブジェクトに対する操作は、基盤となるストレージに依存しない方法で高レベルの演算子と関数を使用して定義されています。これらの操作は、特定の配列実装に対しても一般的に正しく機能します。</span></p><p data-translated="true"><span class="original-text">The <code>AbstractArray</code> type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete <code>AbstractArray{T,N}</code> type should generally implement at least <a href="../../base/arrays/index.html#Base.size"><code>size(A)</code></a> (returning an <code>Int</code> tuple), <a href="../../base/arrays/index.html#Base.getindex-Tuple{Type, Vararg{Any}}"><code>getindex(A, i)</code></a> and <a href="../../base/collections/index.html#Base.getindex"><code>getindex(A, i1, ..., iN)</code></a>; mutable arrays should also implement <a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a>. It is recommended that these operations have nearly constant time complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a <a href="../../base/arrays/index.html#Base.similar"><code>similar(A, T=eltype(A), dims=size(A))</code></a> method, which is used to allocate a similar array for <a href="../../base/base/index.html#Base.copy"><code>copy</code></a> and other out-of-place operations. No matter how an <code>AbstractArray{T,N}</code> is represented internally, <code>T</code> is the type of object returned by <em>integer</em> indexing (<code>A[1, ..., 1]</code>, when <code>A</code> is not empty) and <code>N</code> should be the length of the tuple returned by <a href="../../base/arrays/index.html#Base.size"><code>size</code></a>. For more details on defining custom <code>AbstractArray</code> implementations, see the <a href="../interfaces/index.html#man-interface-array">array interface guide in the interfaces chapter</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>AbstractArray</code>タイプには、配列のようなものがすべて含まれ、その実装は従来の配列とはかなり異なる場合があります。たとえば、要素は保存されるのではなく、要求に応じて計算されることがあります。ただし、具体的な<code>AbstractArray{T,N}</code>タイプは、一般的に少なくとも<a href="../../base/arrays/index.html#Base.size"><code>size(A)</code></a>（<code>Int</code>タプルを返す）、<a href="../../base/arrays/index.html#Base.getindex-Tuple{Type, Vararg{Any}}"><code>getindex(A, i)</code></a>、および<a href="../../base/collections/index.html#Base.getindex"><code>getindex(A, i1, ..., iN)</code></a>を実装する必要があります。可変配列は、<a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a>も実装する必要があります。これらの操作はほぼ定数時間の複雑さを持つことが推奨されます。そうでない場合、一部の配列関数が予期せず遅くなる可能性があります。具体的なタイプは、<a href="../../base/arrays/index.html#Base.similar"><code>similar(A, T=eltype(A), dims=size(A))</code></a>メソッドも提供する必要があります。これは、<a href="../../base/base/index.html#Base.copy"><code>copy</code></a>や他の場所での操作のために類似の配列を割り当てるために使用されます。<code>AbstractArray{T,N}</code>が内部的にどのように表現されていても、<code>T</code>は<em>整数</em>インデックス（<code>A[1, ..., 1]</code>、<code>A</code>が空でない場合）によって返されるオブジェクトのタイプであり、<code>N</code>は<a href="../../base/arrays/index.html#Base.size"><code>size</code></a>によって返されるタプルの長さである必要があります。カスタム<code>AbstractArray</code>実装を定義する詳細については、<a href="../interfaces/index.html#man-interface-array">インターフェース章の配列インターフェースガイド</a>を参照してください。</span></p><p data-translated="true"><span class="original-text"><code>DenseArray</code> is an abstract subtype of <code>AbstractArray</code> intended to include all arrays where elements are stored contiguously in column-major order (see <a href="../performance-tips/index.html#man-performance-column-major">additional notes in Performance Tips</a>). The <a href="../../base/arrays/index.html#Core.Array"><code>Array</code></a> type is a specific instance of <code>DenseArray</code>;  <a href="../../base/arrays/index.html#Base.Vector"><code>Vector</code></a> and <a href="../../base/arrays/index.html#Base.Matrix"><code>Matrix</code></a> are aliases for the 1-d and 2-d cases. Very few operations are implemented specifically for <code>Array</code> beyond those that are required for all <code>AbstractArray</code>s; much of the array library is implemented in a generic manner that allows all custom arrays to behave similarly.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>DenseArray</code>は、要素が列優先順に連続して格納されるすべての配列を含むことを目的とした<code>AbstractArray</code>の抽象サブタイプです（詳細は<a href="../performance-tips/index.html#man-performance-column-major">パフォーマンスヒントの追加ノート</a>を参照）。<a href="../../base/arrays/index.html#Core.Array"><code>Array</code></a>タイプは<code>DenseArray</code>の特定のインスタンスであり、<a href="../../base/arrays/index.html#Base.Vector"><code>Vector</code></a>と<a href="../../base/arrays/index.html#Base.Matrix"><code>Matrix</code></a>は1次元および2次元の場合のエイリアスです。<code>Array</code>に特有の操作は、すべての<code>AbstractArray</code>に必要な操作を超えてはほとんど実装されていません。配列ライブラリの多くは、すべてのカスタム配列が同様に動作できるように一般的な方法で実装されています。</span></p><p data-translated="true"><span class="original-text"><code>SubArray</code> is a specialization of <code>AbstractArray</code> that performs indexing by sharing memory with the original array rather than by copying it. A <code>SubArray</code> is created with the <a href="../../base/arrays/index.html#Base.view"><code>view</code></a> function, which is called the same way as <a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a> (with an array and a series of index arguments). The result of <a href="../../base/arrays/index.html#Base.view"><code>view</code></a> looks the same as the result of <a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a>, except the data is left in place. <a href="../../base/arrays/index.html#Base.view"><code>view</code></a> stores the input index vectors in a <code>SubArray</code> object, which can later be used to index the original array indirectly. By putting the <a href="../../base/arrays/index.html#Base.@views"><code>@views</code></a> macro in front of an expression or block of code, any <code>array[...]</code> slice in that expression will be converted to create a <code>SubArray</code> view instead.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>SubArray</code>は、コピーするのではなく、元の配列とメモリを共有することによってインデックスを実行する<code>AbstractArray</code>の特殊化です。<code>SubArray</code>は、<a href="../../base/arrays/index.html#Base.view"><code>view</code></a>関数を使用して作成され、これは<a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a>（配列と一連のインデックス引数を持つ）と同じ方法で呼び出されます。<a href="../../base/arrays/index.html#Base.view"><code>view</code></a>の結果は、<a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a>の結果と同じように見えますが、データはそのまま残されます。<a href="../../base/arrays/index.html#Base.view"><code>view</code></a>は、入力インデックスベクトルを<code>SubArray</code>オブジェクトに格納し、後で元の配列を間接的にインデックスするために使用できます。<a href="../../base/arrays/index.html#Base.@views"><code>@views</code></a>マクロを式やコードブロックの前に置くことで、その式内の任意の<code>array[...]</code>スライスは、代わりに<code>SubArray</code>ビューを作成するように変換されます。</span></p><p data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.BitArray"><code>BitArray</code></a>s are space-efficient "packed" boolean arrays, which store one bit per boolean value. They can be used similarly to <code>Array{Bool}</code> arrays (which store one byte per boolean value), and can be converted to/from the latter via <code>Array(bitarray)</code> and <code>BitArray(array)</code>, respectively.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.BitArray"><code>BitArray</code></a>は、1つのブール値につき1ビットを保存する、スペース効率の良い「パックされた」ブール配列です。これらは、1つのブール値につき1バイトを保存する<code>Array{Bool}</code>配列と同様に使用でき、<code>Array(bitarray)</code>および<code>BitArray(array)</code>を介して相互に変換できます。</span></p><p data-translated="true"><span class="original-text">An array is "strided" if it is stored in memory with well-defined spacings (strides) between its elements. A strided array with a supported element type may be passed to an external (non-Julia) library like BLAS or LAPACK by simply passing its <a href="../../base/c/index.html#Base.pointer"><code>pointer</code></a> and the stride for each dimension. The <a href="../../base/arrays/index.html#Base.stride"><code>stride(A, d)</code></a> is the distance between elements along dimension <code>d</code>. For example, the builtin <code>Array</code> returned by <code>rand(5,7,2)</code> has its elements arranged contiguously in column major order. This means that the stride of the first dimension — the spacing between elements in the same column — is <code>1</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列は、要素間に明確に定義された間隔（ストライド）がある場合、「ストライド付き」と呼ばれます。サポートされている要素型のストライド付き配列は、<a href="../../base/c/index.html#Base.pointer"><code>pointer</code></a>と各次元のストライドを渡すだけで、BLASやLAPACKのような外部（非Julia）ライブラリに渡すことができます。<a href="../../base/arrays/index.html#Base.stride"><code>stride(A, d)</code></a>は、次元<code>d</code>に沿った要素間の距離です。例えば、<code>rand(5,7,2)</code>によって返される組み込みの<code>Array</code>は、要素が列優先順に連続して配置されています。これは、最初の次元のストライド、すなわち同じ列内の要素間の間隔が<code>1</code>であることを意味します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(5, 7, 2);

julia&gt; stride(A, 1)
1</code></pre><p data-translated="true"><span class="original-text">The stride of the second dimension is the spacing between elements in the same row, skipping as many elements as there are in a single column (<code>5</code>). Similarly, jumping between the two "pages" (in the third dimension) requires skipping <code>5*7 == 35</code> elements. The <a href="../../base/arrays/index.html#Base.strides"><code>strides</code></a> of this array is the tuple of these three numbers together:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">2番目の次元のストライドは、同じ行内の要素間の間隔であり、1つの列にある要素の数（<code>5</code>）だけスキップします。同様に、2つの「ページ」（3次元間）を移動するには、<code>5*7 == 35</code>の要素をスキップする必要があります。この配列の<a href="../../base/arrays/index.html#Base.strides"><code>strides</code></a>は、これら3つの数のタプルです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; strides(A)
(1, 5, 35)</code></pre><p data-translated="true"><span class="original-text">In this particular case, the number of elements skipped <em>in memory</em> matches the number of <em>linear indices</em> skipped. This is only the case for contiguous arrays like <code>Array</code> (and other <code>DenseArray</code> subtypes) and is not true in general. Views with range indices are a good example of <em>non-contiguous</em> strided arrays; consider <code>V = @view A[1:3:4, 2:2:6, 2:-1:1]</code>. This view <code>V</code> refers to the same memory as <code>A</code> but is skipping and re-arranging some of its elements. The stride of the first dimension of <code>V</code> is <code>3</code> because we're only selecting every third row from our original array:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この特定のケースでは、<em>メモリ内</em>でスキップされた要素の数が、スキップされた<em>線形インデックス</em>の数と一致します。これは、<code>Array</code>（および他の<code>DenseArray</code>サブタイプ）のような連続配列にのみ当てはまり、一般的には真ではありません。範囲インデックスを持つビューは、<em>非連続</em>ストライド付き配列の良い例です。<code>V = @view A[1:3:4, 2:2:6, 2:-1:1]</code>を考えてみてください。このビュー<code>V</code>は、<code>A</code>と同じメモリを参照していますが、一部の要素をスキップして再配置しています。<code>V</code>の最初の次元のストライドは<code>3</code>です。なぜなら、元の配列から毎回3行目を選択しているからです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; V = @view A[1:3:4, 2:2:6, 2:-1:1];

julia&gt; stride(V, 1)
3</code></pre><p data-translated="true"><span class="original-text">This view is similarly selecting every other column from our original <code>A</code> — and thus it needs to skip the equivalent of two five-element columns when moving between indices in the second dimension:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このビューは、元の<code>A</code>から毎回別の列を選択しているため、2番目の次元のインデックス間を移動する際に、5要素の列2つ分に相当する要素をスキップする必要があります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; stride(V, 2)
10</code></pre><p data-translated="true"><span class="original-text">The third dimension is interesting because its order is reversed! Thus to get from the first "page" to the second one it must go <em>backwards</em> in memory, and so its stride in this dimension is negative!</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">3次元は、その順序が逆になっているため興味深いです！したがって、最初の「ページ」から2番目のページに移動するには、メモリ内で<em>逆方向</em>に移動する必要があり、この次元のストライドは負になります！</span></p><pre><code class="language-julia-repl hljs">julia&gt; stride(V, 3)
-35</code></pre><p data-translated="true"><span class="original-text">This means that the <code>pointer</code> for <code>V</code> is actually pointing into the middle of <code>A</code>'s memory block, and it refers to elements both backwards and forwards in memory. See the <a href="../interfaces/index.html#man-interface-strided-arrays">interface guide for strided arrays</a> for more details on defining your own strided arrays. <a href="../../base/arrays/index.html#Base.StridedVector"><code>StridedVector</code></a> and <a href="../../base/arrays/index.html#Base.StridedMatrix"><code>StridedMatrix</code></a> are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、<code>V</code>の<code>pointer</code>が実際には<code>A</code>のメモリブロックの中央を指しており、メモリ内で前後の要素を参照していることを意味します。独自のストライド付き配列を定義する詳細については、<a href="../interfaces/index.html#man-interface-strided-arrays">ストライド付き配列のインターフェースガイド</a>を参照してください。<a href="../../base/arrays/index.html#Base.StridedVector"><code>StridedVector</code></a>および<a href="../../base/arrays/index.html#Base.StridedMatrix"><code>StridedMatrix</code></a>は、ストライド付き配列と見なされる多くの組み込み配列型の便利なエイリアスであり、ポインタとストライドを使用して、高度に調整された最適化されたBLASおよびLAPACK関数を呼び出す特化した実装にディスパッチできます。</span></p><p data-translated="true"><span class="original-text">It is worth emphasizing that strides are about offsets in memory rather than indexing. If you are looking to convert between linear (single-index) indexing and cartesian (multi-index) indexing, see <a href="../../base/arrays/index.html#Base.LinearIndices"><code>LinearIndices</code></a> and <a href="../../base/arrays/index.html#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ストライドは、インデックスではなくメモリ内のオフセットに関するものであることを強調する価値があります。線形（単一インデックス）インデックスと直交（多重インデックス）インデックス間の変換を行いたい場合は、<a href="../../base/arrays/index.html#Base.LinearIndices"><code>LinearIndices</code></a>および<a href="../../base/arrays/index.html#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a>を参照してください。</span></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1" data-translated="true"><span class="original-text"><a class="tag is-link" href="#citeref-1">1</a><em>iid</em>, independently and identically distributed.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tag is-link" href="#citeref-1">1</a><em>iid</em>、独立同分布。</span></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../metaprogramming/index.html">« Metaprogramming</a><a class="docs-footer-nextpage" href="../missing/index.html">Missing Values »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>