<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Calling C and Fortran Code · The Julia Language</title><meta name="title" content="Calling C and Fortran Code · The Julia Language"><meta property="og:title" content="Calling C and Fortran Code · The Julia Language"><meta property="twitter:title" content="Calling C and Fortran Code · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bj0h2"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li class="is-active"><a class="tocitem" href="">Calling C and Fortran Code</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Creating-C-Compatible-Julia-Function-Pointers"><span>Creating C-Compatible Julia Function Pointers</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Creating-C-Compatible-Julia-Function-Pointers"><span>C互換のJulia関数ポインタの作成</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#mapping-c-types-to-julia"><span>Mapping C Types to Julia</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#mapping-c-types-to-julia"><span>C型をJuliaにマッピングする</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Mapping-C-Functions-to-Julia"><span>Mapping C Functions to Julia</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Mapping-C-Functions-to-Julia"><span>C関数をJuliaにマッピングする</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#C-Wrapper-Examples"><span>C Wrapper Examples</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#C-Wrapper-Examples"><span>Cラッパーの例</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Fortran-Wrapper-Example"><span>Fortran Wrapper Example</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Fortran-Wrapper-Example"><span>Fortranラッパーの例</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Garbage-Collection-Safety"><span>Garbage Collection Safety</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Garbage-Collection-Safety"><span>ガーベジコレクションの安全性</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Non-constant-Function-Specifications"><span>Non-constant Function Specifications</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Non-constant-Function-Specifications"><span>非定数関数の仕様</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Indirect-Calls"><span>Indirect Calls</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Indirect-Calls"><span>間接呼び出し</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Closure-cfunctions"><span>Closure cfunctions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Closure-cfunctions"><span>クロージャcfunctions</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Closing-a-Library"><span>Closing a Library</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Closing-a-Library"><span>ライブラリの閉じ方</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Variadic-function-calls"><span>Variadic function calls</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Variadic-function-calls"><span>可変引数関数呼び出し</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#ccall-interface"><span><code>ccall</code> interface</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#ccall-interface"><span><code>ccall</code> インターフェース</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#calling-convention"><span>Calling Convention</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#calling-convention"><span>呼び出し規約</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Accessing-Global-Variables"><span>Accessing Global Variables</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Accessing-Global-Variables"><span>グローバル変数へのアクセス</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Accessing-Data-through-a-Pointer"><span>Accessing Data through a Pointer</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Accessing-Data-through-a-Pointer"><span>ポインタを通じたデータへのアクセス</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Thread-safety"><span>Thread-safety</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Thread-safety"><span>スレッドセーフ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#More-About-Callbacks"><span>More About Callbacks</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#More-About-Callbacks"><span>コールバックについての詳細</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#C"><span>C++</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#C"><span>C++</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">CおよびFortranコードの呼び出し</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">CおよびFortranコードの呼び出し</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Calling-C-and-Fortran-Code" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Calling-C-and-Fortran-Code">Calling C and Fortran Code</a><a id="Calling-C-and-Fortran-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-C-and-Fortran-Code" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Calling-C-and-Fortran-Code">CおよびFortranコードの呼び出し</a><a id="Calling-C-and-Fortran-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-C-and-Fortran-Code" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a "no boilerplate" philosophy: functions can be called directly from Julia without any "glue" code, code generation, or compilation – even from the interactive prompt. This is accomplished just by making an appropriate call with the <a href="../../base/c/index.html#Base.@ccall"><code>@ccall</code></a> macro (or the less convenient <a href="../../base/c/index.html#ccall"><code>ccall</code></a> syntax, see the <a href="#ccall-interface"><code>ccall</code> syntax section</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ほとんどのコードはJuliaで書くことができますが、すでにCやFortranで書かれた高品質で成熟した数値計算ライブラリが多数存在します。この既存のコードを簡単に利用できるようにするために、JuliaはCおよびFortran関数を呼び出すのを簡単かつ効率的にします。Juliaには「ボイラープレートなし」の哲学があります：関数は「グルー」コード、コード生成、またはコンパイルなしで、インタラクティブプロンプトから直接呼び出すことができます。これは、<a href="../../base/c/index.html#Base.@ccall"><code>@ccall</code></a>マクロ（またはあまり便利ではない<a href="../../base/c/index.html#ccall"><code>ccall</code></a>構文、<a href="#ccall-interface"><code>ccall</code>構文セクション</a>を参照）を使用して適切な呼び出しを行うことで実現されます。</span></p><p data-translated="true"><span class="original-text">The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the <code>-shared</code> and <code>-fPIC</code> options. The machine instructions generated by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">呼び出すコードは共有ライブラリとして利用可能でなければなりません。ほとんどのCおよびFortranライブラリは、すでに共有ライブラリとしてコンパイルされて出荷されますが、GCC（またはClang）を使用して自分でコードをコンパイルする場合は、<code>-shared</code>および<code>-fPIC</code>オプションを使用する必要があります。JuliaのJITによって生成される機械命令は、ネイティブC呼び出しと同じであるため、結果として得られるオーバーヘッドはCコードからライブラリ関数を呼び出す場合と同じです。<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup></span></p><p data-translated="true"><span class="original-text">By default, Fortran compilers <a href="https://en.wikipedia.org/wiki/Name_mangling#Fortran#Fortran">generate mangled names</a> (for example, converting function names to lowercase or uppercase, often appending an underscore), and so to call a Fortran function you must pass the mangled identifier corresponding to the rule followed by your Fortran compiler. Also, when calling a Fortran function, all inputs must be passed as pointers to allocated values on the heap or stack. This applies not only to arrays and other mutable objects which are normally heap-allocated, but also to scalar values such as integers and floats which are normally stack-allocated and commonly passed in registers when using C or Julia calling conventions.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトでは、Fortranコンパイラは<a href="https://en.wikipedia.org/wiki/Name_mangling#Fortran#Fortran">マングルされた名前</a>を生成します（例えば、関数名を小文字または大文字に変換し、しばしばアンダースコアを追加します）。そのため、Fortran関数を呼び出すには、Fortranコンパイラが従うルールに対応するマングルされた識別子を渡す必要があります。また、Fortran関数を呼び出す際には、すべての入力をヒープまたはスタック上の割り当てられた値へのポインタとして渡す必要があります。これは、通常ヒープに割り当てられる配列や他の可変オブジェクトだけでなく、通常スタックに割り当てられ、CまたはJuliaの呼び出し規約を使用する際にレジスタで渡される整数や浮動小数点数などのスカラー値にも適用されます。</span></p><p data-translated="true"><span class="original-text">The syntax for <a href="../../base/c/index.html#Base.@ccall"><code>@ccall</code></a> to generate a call to the library function is:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/c/index.html#Base.@ccall"><code>@ccall</code></a>を使用してライブラリ関数への呼び出しを生成するための構文は次のとおりです：</span></p><pre><code class="language-julia hljs">@ccall library.function_name(argvalue1::argtype1, ...)::returntype
@ccall function_name(argvalue1::argtype1, ...)::returntype
@ccall $function_pointer(argvalue1::argtype1, ...)::returntype</code></pre><p data-translated="true"><span class="original-text">where <code>library</code> is a string constant or literal (but see <a href="#Non-constant-Function-Specifications">Non-constant Function Specifications</a> below). The library may be omitted, in which case the function name is resolved in the current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia. The full path to the library may also be specified. Alternatively, <code>@ccall</code> may also be used to call a function pointer <code>$function_pointer</code>, such as one returned by <code>Libdl.dlsym</code>. The <code>argtype</code>s corresponds to the C-function signature and the <code>argvalue</code>s are the actual argument values to be passed to the function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで、<code>library</code>は文字列定数またはリテラルです（ただし、下記の<a href="#Non-constant-Function-Specifications">非定数関数仕様</a>を参照）。ライブラリは省略可能で、その場合、関数名は現在のプロセスで解決されます。この形式は、Cライブラリ関数、Juliaランタイム内の関数、またはJuliaにリンクされたアプリケーション内の関数を呼び出すために使用できます。ライブラリへのフルパスも指定できます。あるいは、<code>@ccall</code>を使用して、<code>Libdl.dlsym</code>によって返されるような関数ポインタ<code>$function_pointer</code>を呼び出すこともできます。<code>argtype</code>はC関数のシグネチャに対応し、<code>argvalue</code>は関数に渡される実際の引数値です。</span></p><div class="admonition is-info" id="Note-39ac12a5ec553e21"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-39ac12a5ec553e21" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">See below for how to <a href="#mapping-c-types-to-julia">map C types to Julia types</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C型をJulia型に<a href="#mapping-c-types-to-julia">マッピングする方法</a>については、以下を参照してください。</span></p></div></div><p data-translated="true"><span class="original-text">As a complete but simple example, the following calls the <code>clock</code> function from the standard C library on most Unix-derived systems:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">完全でありながら簡単な例として、以下はほとんどのUnix系システムの標準Cライブラリから<code>clock</code>関数を呼び出します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; t = @ccall clock()::Int32
2292761

julia&gt; typeof(t)
Int32</code></pre><p data-translated="true"><span class="original-text"><code>clock</code> takes no arguments and returns an <code>Int32</code>. To call the <code>getenv</code> function to get a pointer to the value of an environment variable, one makes a call like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>clock</code>は引数を取らず、<code>Int32</code>を返します。環境変数の値へのポインタを取得するために<code>getenv</code>関数を呼び出すには、次のように呼び出します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; path = @ccall getenv("SHELL"::Cstring)::Cstring
Cstring(@0x00007fff5fbffc45)

julia&gt; unsafe_string(path)
"/bin/bash"</code></pre><p data-translated="true"><span class="original-text">In practice, especially when providing reusable functionality, one generally wraps <code>@ccall</code> uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function specifies. And if an error occurs it is thrown as a normal Julia exception. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the <code>getenv</code> C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from <a href="https://github.com/JuliaLang/julia/blob/master/base/env.jl"><code>env.jl</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実際には、特に再利用可能な機能を提供する場合、一般的に<code>@ccall</code>の使用を引数を設定し、その後CまたはFortran関数が指定する方法でエラーをチェックするJulia関数にラップします。そして、エラーが発生した場合、それは通常のJulia例外としてスローされます。これは、CおよびFortranのAPIがエラー条件を示す方法について非常に一貫性がないため、特に重要です。例えば、<code>getenv</code> Cライブラリ関数は、以下のJulia関数にラップされており、これは<a href="https://github.com/JuliaLang/julia/blob/master/base/env.jl"><code>env.jl</code></a>からの実際の定義の簡略版です：</span></p><pre><code class="language-julia hljs">function getenv(var::AbstractString)
    val = @ccall getenv(var::Cstring)::Cstring
    if val == C_NULL
        error("getenv: undefined variable: ", var)
    end
    return unsafe_string(val)
end</code></pre><p data-translated="true"><span class="original-text">The C <code>getenv</code> function indicates an error by returning <code>C_NULL</code>, but other standard C functions indicate errors in different ways, including by returning -1, 0, 1, and other special values. This wrapper throws an exception indicating the problem if the caller tries to get a non-existent environment variable:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cの<code>getenv</code>関数は、<code>C_NULL</code>を返すことでエラーを示しますが、他の標準C関数は-1、0、1、その他の特別な値を返すことでエラーを示します。このラッパーは、呼び出し元が存在しない環境変数を取得しようとした場合に問題を示す例外をスローします。</span></p><pre><code class="language-julia-repl hljs">julia&gt; getenv("SHELL")
"/bin/bash"

julia&gt; getenv("FOOBAR")
ERROR: getenv: undefined variable: FOOBAR</code></pre><p data-translated="true"><span class="original-text">Here is a slightly more complex example that discovers the local machine's hostname.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">こちらは、ローカルマシンのホスト名を取得する少し複雑な例です。</span></p><pre><code class="language-julia hljs">function gethostname()
    hostname = Vector{UInt8}(undef, 256) # MAXHOSTNAMELEN
    err = @ccall gethostname(hostname::Ptr{UInt8}, sizeof(hostname)::Csize_t)::Int32
    Base.systemerror("gethostname", err != 0)
    hostname[end] = 0 # ensure null-termination
    return GC.@preserve hostname unsafe_string(pointer(hostname))
end</code></pre><p data-translated="true"><span class="original-text">This example first allocates an array of bytes. It then calls the C library function <code>gethostname</code> to populate the array with the hostname. Finally, it takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a null-terminated C string.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例では、まずバイトの配列を割り当てます。次に、Cライブラリ関数<code>gethostname</code>を呼び出して、配列にホスト名を格納します。最後に、ホスト名バッファへのポインタを取得し、それをヌル終端のC文字列であると仮定して、Juliaの文字列に変換します。</span></p><p data-translated="true"><span class="original-text">It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and populated. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don't use the <code>Cstring</code> type here: as the array is uninitialized, it could contain null bytes. Converting to a <code>Cstring</code> as part of the <code>@ccall</code> checks for contained null bytes and could therefore throw a conversion error.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cライブラリが呼び出し元にメモリを割り当てさせて、呼び出し先に渡して populated させるこのパターンを使用することは一般的です。このようにJuliaからメモリを割り当てることは、初期化されていない配列を作成し、そのデータへのポインタをC関数に渡すことで一般的に達成されます。これが、ここで<code>Cstring</code>型を使用しない理由です：配列が初期化されていないため、ヌルバイトを含む可能性があります。<code>@ccall</code>の一部として<code>Cstring</code>に変換すると、含まれているヌルバイトをチェックし、したがって変換エラーをスローする可能性があります。</span></p><p data-translated="true"><span class="original-text">Dereferencing <code>pointer(hostname)</code> with <code>unsafe_string</code> is an unsafe operation as it requires access to the memory allocated for <code>hostname</code> that may have been in the meanwhile garbage collected. The macro <a href="../../base/base/index.html#Base.GC.@preserve"><code>GC.@preserve</code></a> prevents this from happening and therefore accessing an invalid memory location.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>pointer(hostname)</code>を<code>unsafe_string</code>でデリファレンスすることは、安全でない操作です。なぜなら、<code>hostname</code>のために割り当てられたメモリにアクセスする必要があり、そのメモリはその間にガーベジコレクションされている可能性があるからです。マクロ<a href="../../base/base/index.html#Base.GC.@preserve"><code>GC.@preserve</code></a>は、これが発生するのを防ぎ、したがって無効なメモリ位置にアクセスすることを防ぎます。</span></p><p data-translated="true"><span class="original-text">Finally, here is an example of specifying a library via a path. We create a shared library with the following content</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最後に、パスを指定してライブラリを指定する例を示します。以下の内容で共有ライブラリを作成します。</span></p><pre><code class="language-c hljs">#include &lt;stdio.h&gt;

void say_y(int y)
{
    printf("Hello from C: got y = %d.\n", y);
}</code></pre><p data-translated="true"><span class="original-text">and compile it with <code>gcc -fPIC -shared -o mylib.so mylib.c</code>. It can then be called by specifying the (absolute) path as the library name:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そして、<code>gcc -fPIC -shared -o mylib.so mylib.c</code>でコンパイルします。その後、ライブラリ名として（絶対）パスを指定することで呼び出すことができます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; @ccall "./mylib.so".say_y(5::Cint)::Cvoid
Hello from C: got y = 5.</code></pre><h2 id="Creating-C-Compatible-Julia-Function-Pointers" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Creating-C-Compatible-Julia-Function-Pointers">Creating C-Compatible Julia Function Pointers</a><a id="Creating-C-Compatible-Julia-Function-Pointers-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-C-Compatible-Julia-Function-Pointers" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Creating-C-Compatible-Julia-Function-Pointers">C互換のJulia関数ポインタの作成</a><a id="Creating-C-Compatible-Julia-Function-Pointers-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-C-Compatible-Julia-Function-Pointers" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example, to match C prototypes of the form:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数ポインタ引数を受け入れるネイティブC関数にJulia関数を渡すことが可能です。例えば、次のようなCプロトタイプに一致させるために：</span></p><pre><code class="language-c hljs">typedef returntype (*functiontype)(argumenttype, ...)</code></pre><p data-translated="true"><span class="original-text">The macro <a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a> generates the C-compatible function pointer for a call to a Julia function. The arguments to <a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a> are:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マクロ<a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a>は、Julia関数への呼び出しのためのC互換の関数ポインタを生成します。<a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a>への引数は：</span></p><ol><li data-translated="true"><span class="original-text">A Julia function</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia関数</span></li><li data-translated="true"><span class="original-text">The function's return type</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数の戻り値の型</span></li><li data-translated="true"><span class="original-text">A tuple of input types, corresponding to the function signature</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数シグネチャに対応する入力型のタプル</span></li></ol><div class="admonition is-info" id="Note-8f57e3a4799c7f89"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8f57e3a4799c7f89" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">As with <code>@ccall</code>, the return type and the input types must be literal constants.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@ccall</code>と同様に、戻り値の型と入力型はリテラル定数でなければなりません。</span></p></div></div><div class="admonition is-info" id="Note-7f810a8fee1fe9de"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7f810a8fee1fe9de" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Currently, only the platform-default C calling convention is supported. This means that <code>@cfunction</code>-generated pointers cannot be used in calls where WINAPI expects a <code>stdcall</code> function on 32-bit Windows, but can be used on WIN64 (where <code>stdcall</code> is unified with the C calling convention).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">現在、プラットフォームのデフォルトのC呼び出し規約のみがサポートされています。これは、<code>@cfunction</code>で生成されたポインタが、32ビットWindowsでWINAPIが<code>stdcall</code>関数を期待する呼び出しに使用できないことを意味しますが、WIN64では使用できます（ここでは<code>stdcall</code>がC呼び出し規約と統一されています）。</span></p></div></div><div class="admonition is-info" id="Note-4e65b09cc66c4905"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4e65b09cc66c4905" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Callback functions exposed via <code>@cfunction</code> should not throw errors, as that will return control to the Julia runtime unexpectedly and may leave the program in an undefined state.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@cfunction</code>を介して公開されたコールバック関数はエラーをスローしてはいけません。そうしないと、制御が予期せずJuliaランタイムに戻り、プログラムが未定義の状態になる可能性があります。</span></p></div></div><p data-translated="true"><span class="original-text">A classic example is the standard C library <code>qsort</code> function, declared as:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">古典的な例は、標準Cライブラリの<code>qsort</code>関数で、次のように宣言されています：</span></p><pre><code class="language-c hljs">void qsort(void *base, size_t nitems, size_t size,
           int (*compare)(const void*, const void*));</code></pre><p data-translated="true"><span class="original-text">The <code>base</code> argument is a pointer to an array of length <code>nitems</code>, with elements of <code>size</code> bytes each. <code>compare</code> is a callback function which takes pointers to two elements <code>a</code> and <code>b</code> and returns an integer less/greater than zero if <code>a</code> should appear before/after <code>b</code> (or zero if any order is permitted).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>base</code>引数は、<code>nitems</code>の長さを持つ配列へのポインタであり、各要素は<code>size</code>バイトです。<code>compare</code>は、2つの要素<code>a</code>と<code>b</code>へのポインタを受け取り、<code>a</code>が<code>b</code>の前/後に出現すべき場合はゼロより小さい/大きい整数を返します（または任意の順序が許可される場合はゼロ）。</span></p><p data-translated="true"><span class="original-text">Now, suppose that we have a 1-d array <code>A</code> of values in Julia that we want to sort using the <code>qsort</code> function (rather than Julia's built-in <code>sort</code> function). Before we consider calling <code>qsort</code> and passing arguments, we need to write a comparison function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さて、Juliaの値の1次元配列<code>A</code>を持っていて、<code>qsort</code>関数を使用してソートしたいとします（Juliaの組み込み<code>sort</code>関数ではなく）。<code>qsort</code>を呼び出して引数を渡すことを考える前に、比較関数を書く必要があります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function mycompare(a, b)::Cint
           return (a &lt; b) ? -1 : ((a &gt; b) ? +1 : 0)
       end;</code></pre><p data-translated="true"><span class="original-text"><code>qsort</code> expects a comparison function that return a C <code>int</code>, so we annotate the return type to be <code>Cint</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>qsort</code>はCの<code>int</code>を返す比較関数を期待しているので、戻り値の型を<code>Cint</code>として注釈します。</span></p><p data-translated="true"><span class="original-text">In order to pass this function to C, we obtain its address using the macro <code>@cfunction</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この関数をCに渡すために、マクロ<code>@cfunction</code>を使用してそのアドレスを取得します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));</code></pre><p data-translated="true"><span class="original-text"><a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a> requires three arguments: the Julia function (<code>mycompare</code>), the return type (<code>Cint</code>), and a literal tuple of the input argument types, in this case to sort an array of <code>Cdouble</code> (<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>) elements.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a>は3つの引数を必要とします：Julia関数（<code>mycompare</code>）、戻り値の型（<code>Cint</code>）、および入力引数の型のリテラルタプル。この場合、<code>Cdouble</code>（<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>）要素の配列をソートします。</span></p><p data-translated="true"><span class="original-text">The final call to <code>qsort</code> looks like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最終的な<code>qsort</code>の呼び出しは次のようになります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.3, -2.7, 4.4, 3.1];

julia&gt; @ccall qsort(A::Ptr{Cdouble}, length(A)::Csize_t, sizeof(eltype(A))::Csize_t, mycompare_c::Ptr{Cvoid})::Cvoid

julia&gt; A
4-element Vector{Float64}:
 -2.7
  1.3
  3.1
  4.4</code></pre><p data-translated="true"><span class="original-text">As the example shows, the original Julia array <code>A</code> has now been sorted: <code>[-2.7, 1.3, 3.1, 4.4]</code>. Note that Julia <a href="#automatic-type-conversion">takes care of converting the array to a <code>Ptr{Cdouble}</code></a>), computing the size of the element type in bytes, and so on.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例が示すように、元のJulia配列<code>A</code>は現在ソートされています：<code>[-2.7, 1.3, 3.1, 4.4]</code>。Juliaは<a href="#automatic-type-conversion">配列を<code>Ptr{Cdouble}</code>に変換すること</a>、要素型のサイズをバイト単位で計算することなどを自動的に処理します。</span></p><p data-translated="true"><span class="original-text">For fun, try inserting a <code>println("mycompare($a, $b)")</code> line into <code>mycompare</code>, which will allow you to see the comparisons that <code>qsort</code> is performing (and to verify that it is really calling the Julia function that you passed to it).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">楽しみのために、<code>mycompare</code>に<code>println("mycompare($a, $b)")</code>行を挿入してみてください。これにより、<code>qsort</code>が実行している比較を確認でき（実際に渡したJulia関数が呼び出されていることを確認できます）、</span></p><h2 id="mapping-c-types-to-julia" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#mapping-c-types-to-julia">Mapping C Types to Julia</a><a id="mapping-c-types-to-julia-1"></a><a class="docs-heading-anchor-permalink" href="#mapping-c-types-to-julia" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#mapping-c-types-to-julia">C型をJuliaにマッピングする</a><a id="mapping-c-types-to-julia-1"></a><a class="docs-heading-anchor-permalink" href="#mapping-c-types-to-julia" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">宣言されたC型とJuliaでの宣言が正確に一致することが重要です。不一致があると、あるシステムで正しく動作するコードが別のシステムで失敗したり、不確定な結果を生成したりする可能性があります。</span></p><p data-translated="true"><span class="original-text">Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file.<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2" class="footnote-ref">[2]</a><span class="footnote-preview" id="fn-2"></span></sup></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C関数を呼び出すプロセスのどこにもCヘッダーファイルは使用されていないことに注意してください：あなたは自分のJulia型と呼び出しシグネチャがCヘッダーファイルのものを正確に反映していることを確認する責任があります。<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2" class="footnote-ref">[2]</a><span class="footnote-preview" id="fn-2"></span></sup></span></p><h3 id="automatic-type-conversion" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#automatic-type-conversion">Automatic Type Conversion</a><a id="automatic-type-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#automatic-type-conversion" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#automatic-type-conversion">自動型変換</a><a id="automatic-type-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#automatic-type-conversion" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Julia automatically inserts calls to the <a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert</code></a> function to convert each argument to the specified type. For example, the following call:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは、各引数を指定された型に変換するために<a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert</code></a>関数への呼び出しを自動的に挿入します。例えば、次の呼び出し：</span></p><pre><code class="language-julia hljs">@ccall "libfoo".foo(x::Int32, y::Float64)::Cvoid</code></pre><p data-translated="true"><span class="original-text">will behave as if it were written like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは次のように書かれているかのように振る舞います：</span></p><pre><code class="language-julia hljs">c_x = Base.cconvert(Int32, x)
c_y = Base.cconvert(Float64, y)
GC.@preserve c_x c_y begin
    @ccall "libfoo".foo(
        Base.unsafe_convert(Int32, c_x)::Int32,
        Base.unsafe_convert(Float64, c_y)::Float64
    )::Cvoid
end</code></pre><p data-translated="true"><span class="original-text"><a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert</code></a> normally just calls <a href="../../base/base/index.html#Base.convert"><code>convert</code></a>, but can be defined to return an arbitrary new object more appropriate for passing to C. This should be used to perform all allocations of memory that will be accessed by the C code. For example, this is used to convert an <code>Array</code> of objects (e.g. strings) to an array of pointers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert</code></a> は通常 <a href="../../base/base/index.html#Base.convert"><code>convert</code></a> を呼び出しますが、Cに渡すのにより適した任意の新しいオブジェクトを返すように定義することができます。これは、Cコードによってアクセスされるすべてのメモリの割り当てを行うために使用されるべきです。例えば、これはオブジェクトの <code>Array</code>（例えば文字列）をポインタの配列に変換するために使用されます。</span></p><p data-translated="true"><span class="original-text"><a href="../../base/c/index.html#Base.unsafe_convert"><code>Base.unsafe_convert</code></a> handles conversion to <a href="../../base/c/index.html#Core.Ptr"><code>Ptr</code></a> types. It is considered unsafe because converting an object to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/c/index.html#Base.unsafe_convert"><code>Base.unsafe_convert</code></a> は <a href="../../base/c/index.html#Core.Ptr"><code>Ptr</code></a> タイプへの変換を処理します。これは、オブジェクトをネイティブポインタに変換すると、ガーベジコレクタからオブジェクトが隠され、早期に解放される可能性があるため、安全ではないと見なされます。</span></p><h3 id="Type-Correspondences" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Type-Correspondences">Type Correspondences</a><a id="Type-Correspondences-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Correspondences" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Type-Correspondences">型の対応</a><a id="Type-Correspondences-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Correspondences" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">First, let's review some relevant Julia type terminology:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">まず、関連するJuliaの型用語を確認しましょう：</span></p><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Syntax / Keyword</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">構文 / キーワード</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Example</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">説明</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>mutable struct</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>mutable struct</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>BitSet</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>BitSet</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">"Concrete Type" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a concrete type must be fully defined (no <code>TypeVars</code> are allowed) in order for the instance to be constructed. Also see <a href="../../base/base/index.html#Base.isconcretetype"><code>isconcretetype</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">"具体的な型" :: 型タグを含む関連データのグループで、JuliaのGCによって管理され、オブジェクトのアイデンティティによって定義されます。具体的な型の型パラメータは、インスタンスを構築するために完全に定義されている必要があります（<code>TypeVars</code> は許可されません）。また、<a href="../../base/base/index.html#Base.isconcretetype"><code>isconcretetype</code></a> も参照してください。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>abstract type</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>abstract type</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Any</code>, <code>AbstractArray{T, N}</code>, <code>Complex{T}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Any</code>, <code>AbstractArray{T, N}</code>, <code>Complex{T}</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">"Super Type" :: A super-type (not a concrete type) that cannot be instantiated, but can be used to describe a group of types. Also see <a href="../../base/base/index.html#Base.isabstracttype"><code>isabstracttype</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">"スーパタイプ" :: インスタンス化できないが、タイプのグループを説明するために使用できるスーパタイプ（具体的なタイプではない）。また、<a href="../../base/base/index.html#Base.isabstracttype"><code>isabstracttype</code></a>も参照してください。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>T{A}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>T{A}</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Vector{Int}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Vector{Int}</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">"Type Parameter" :: A specialization of a type (typically used for dispatch or storage optimization).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">"タイプパラメータ" :: タイプの特化（通常はディスパッチやストレージ最適化に使用される）。</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text">"TypeVar" :: The <code>T</code> in the type parameter declaration is referred to as a TypeVar (short for type variable).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">"TypeVar" :: タイプパラメータ宣言の<code>T</code>はTypeVar（タイプ変数の略）と呼ばれます。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>primitive type</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>primitive type</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Int</code>, <code>Float64</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Int</code>, <code>Float64</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">"Primitive Type" :: A type with no fields, but a size. It is stored and defined by-value.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">"プリミティブタイプ" :: フィールドを持たないがサイズを持つタイプ。値として保存され、定義されます。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>struct</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>struct</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Pair{Int, Int}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Pair{Int, Int}</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">"Struct" :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">"Struct" :: すべてのフィールドが定数として定義されている型。値として定義され、型タグと共に保存されることがあります。</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>ComplexF64</code> (<code>isbits</code>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ComplexF64</code> (<code>isbits</code>)</span></td><td style="text-align: left" data-translated="true"><span class="original-text">"Is-Bits"   :: A <code>primitive type</code>, or a <code>struct</code> type where all fields are other <code>isbits</code> types. It is defined by-value, and is stored without a type-tag.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">"Is-Bits"   :: <code>primitive type</code>、またはすべてのフィールドが他の<code>isbits</code>型である<code>struct</code>型。値として定義され、型タグなしで保存されます。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>struct ...; end</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>struct ...; end</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>nothing</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>nothing</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">"Singleton" :: a concrete Type or Struct with no fields.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">"Singleton" :: フィールドを持たない具体的な型または構造体。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>(...)</code> or <code>tuple(...)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>(...)</code> または <code>tuple(...)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>(1, 2, 3)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>(1, 2, 3)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">"Tuple" :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">"Tuple" :: 不変のデータ構造で、匿名の構造体型や定数配列に似ています。配列または構造体として表現されます。</span></td></tr></tbody></table><h3 id="man-bits-types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-bits-types">Bits Types</a><a id="man-bits-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-bits-types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-bits-types">ビット型</a><a id="man-bits-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-bits-types" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">There are several special types to be aware of, as no other type can be defined to behave the same:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">他の型が同じように振る舞うように定義されることはないため、注意すべき特別な型がいくつかあります：</span></p><ul><li><p data-translated="true"><span class="original-text"><code>Float32</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Float32</code></span></p><p data-translated="true"><span class="original-text">Exactly corresponds to the <code>float</code> type in C (or <code>REAL*4</code> in Fortran).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cの<code>float</code>型（またはFortranの<code>REAL*4</code>）に正確に対応します。</span></p></li><li><p data-translated="true"><span class="original-text"><code>Float64</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Float64</code></span></p><p data-translated="true"><span class="original-text">Exactly corresponds to the <code>double</code> type in C (or <code>REAL*8</code> in Fortran).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cの<code>double</code>型（またはFortranの<code>REAL*8</code>）に正確に対応します。</span></p></li><li><p data-translated="true"><span class="original-text"><code>ComplexF32</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ComplexF32</code></span></p><p data-translated="true"><span class="original-text">Exactly corresponds to the <code>complex float</code> type in C (or <code>COMPLEX*8</code> in Fortran).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cの<code>complex float</code>型（またはFortranの<code>COMPLEX*8</code>）に正確に対応します。</span></p></li><li><p data-translated="true"><span class="original-text"><code>ComplexF64</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ComplexF64</code></span></p><p data-translated="true"><span class="original-text">Exactly corresponds to the <code>complex double</code> type in C (or <code>COMPLEX*16</code> in Fortran).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cの<code>complex double</code>型（またはFortranの<code>COMPLEX*16</code>）に正確に対応します。</span></p></li><li><p data-translated="true"><span class="original-text"><code>Signed</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Signed</code></span></p><p data-translated="true"><span class="original-text">Exactly corresponds to the <code>signed</code> type annotation in C (or any <code>INTEGER</code> type in Fortran). Any Julia type that is not a subtype of <a href="../../base/numbers/index.html#Core.Signed"><code>Signed</code></a> is assumed to be unsigned.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cの<code>signed</code>型注釈（またはFortranの任意の<code>INTEGER</code>型）に正確に対応します。<a href="../../base/numbers/index.html#Core.Signed"><code>Signed</code></a>のサブタイプでない任意のJulia型は符号なしと見なされます。</span></p></li></ul><ul><li><p data-translated="true"><span class="original-text"><code>Ref{T}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ref{T}</code></span></p><p data-translated="true"><span class="original-text">Behaves like a <code>Ptr{T}</code> that can manage its memory via the Julia GC.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">JuliaのGCを介してメモリを管理できる<code>Ptr{T}</code>のように動作します。</span></p></li></ul><ul><li><p data-translated="true"><span class="original-text"><code>Array{T,N}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Array{T,N}</code></span></p><p data-translated="true"><span class="original-text">When an array is passed to C as a <code>Ptr{T}</code> argument, it is not reinterpret-cast: Julia requires that the element type of the array matches <code>T</code>, and the address of the first element is passed.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列が<code>Ptr{T}</code>引数としてCに渡されるとき、再解釈キャストは行われません：Juliaは配列の要素型が<code>T</code>と一致することを要求し、最初の要素のアドレスが渡されます。</span></p><p data-translated="true"><span class="original-text">Therefore, if an <code>Array</code> contains data in the wrong format, it will have to be explicitly converted using a call such as <code>trunc.(Int32, A)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、<code>Array</code>が間違った形式のデータを含む場合、<code>trunc.(Int32, A)</code>のような呼び出しを使用して明示的に変換する必要があります。</span></p><p data-translated="true"><span class="original-text">To pass an array <code>A</code> as a pointer of a different type <em>without</em> converting the data beforehand (for example, to pass a <code>Float64</code> array to a function that operates on uninterpreted bytes), you can declare the argument as <code>Ptr{Cvoid}</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">異なる型のポインタとして配列<code>A</code>を<em>事前に</em>データを変換せずに渡すには（たとえば、<code>Float64</code>配列を解釈されていないバイトで動作する関数に渡すため）、引数を<code>Ptr{Cvoid}</code>として宣言できます。</span></p><p data-translated="true"><span class="original-text">If an array of eltype <code>Ptr{T}</code> is passed as a <code>Ptr{Ptr{T}}</code> argument, <a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert</code></a> will attempt to first make a null-terminated copy of the array with each element replaced by its <a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert</code></a> version. This allows, for example, passing an <code>argv</code> pointer array of type <code>Vector{String}</code> to an argument of type <code>Ptr{Ptr{Cchar}}</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">要素型<code>Ptr{T}</code>の配列が<code>Ptr{Ptr{T}}</code>引数として渡されると、<a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert</code></a>は最初に各要素をその<a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert</code></a>バージョンに置き換えたヌル終端の配列のコピーを作成しようとします。これにより、たとえば、型<code>Vector{String}</code>の<code>argv</code>ポインタ配列を型<code>Ptr{Ptr{Cchar}}</code>の引数に渡すことができます。</span></p></li></ul><p data-translated="true"><span class="original-text">On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help when writing portable code (and remembering that an <code>int</code> in C is not the same as an <code>Int</code> in Julia).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">現在サポートしているすべてのシステムにおいて、基本的なC/C++の値型は次のようにJulia型に変換される可能性があります。すべてのC型には、同じ名前でCがプレフィックスとして付けられた対応するJulia型があります。これは、ポータブルなコードを書く際に役立ちます（Cの<code>int</code>がJuliaの<code>Int</code>とは異なることを覚えておくためにも）。</span></p><p data-translated="true"><span class="original-text"><strong>System Independent Types</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>システム非依存型</strong></span></p><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">C name</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C名</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Fortran name</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Fortran名</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Standard Julia Alias</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">標準Juliaエイリアス</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Julia Base Type</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaベースタイプ</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>unsigned char</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>unsigned char</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>CHARACTER</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>CHARACTER</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cuchar</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cuchar</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>UInt8</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>UInt8</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>bool</code> (_Bool in C99+)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>bool</code> (C99+の_Bool)</span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cuchar</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cuchar</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>UInt8</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>UInt8</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>short</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>short</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>INTEGER*2</code>, <code>LOGICAL*2</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>INTEGER*2</code>, <code>LOGICAL*2</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cshort</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cshort</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Int16</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Int16</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>unsigned short</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>unsigned short</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cushort</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cushort</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>UInt16</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>UInt16</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>int</code>, <code>BOOL</code> (C, typical)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>int</code>, <code>BOOL</code> (C, 一般的な)</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>INTEGER*4</code>, <code>LOGICAL*4</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>INTEGER*4</code>, <code>LOGICAL*4</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cint</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cint</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Int32</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Int32</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>unsigned int</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>unsigned int</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cuint</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cuint</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>UInt32</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>UInt32</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>long long</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>long long</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>INTEGER*8</code>, <code>LOGICAL*8</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>INTEGER*8</code>, <code>LOGICAL*8</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Clonglong</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Clonglong</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Int64</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Int64</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>unsigned long long</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>unsigned long long</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Culonglong</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Culonglong</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>UInt64</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>UInt64</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>intmax_t</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>intmax_t</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cintmax_t</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cintmax_t</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Int64</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Int64</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>uintmax_t</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>uintmax_t</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cuintmax_t</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cuintmax_t</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>UInt64</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>UInt64</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>float</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>float</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>REAL*4i</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>REAL*4i</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cfloat</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cfloat</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Float32</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Float32</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>double</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>double</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>REAL*8</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>REAL*8</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cdouble</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cdouble</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Float64</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Float64</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>complex float</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>complex float</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>COMPLEX*8</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>COMPLEX*8</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>ComplexF32</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ComplexF32</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Complex{Float32}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Complex{Float32}</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>complex double</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>complex double</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>COMPLEX*16</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>COMPLEX*16</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>ComplexF64</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ComplexF64</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Complex{Float64}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Complex{Float64}</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>ptrdiff_t</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ptrdiff_t</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cptrdiff_t</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cptrdiff_t</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Int</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Int</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>ssize_t</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ssize_t</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cssize_t</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cssize_t</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Int</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Int</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>size_t</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>size_t</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Csize_t</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Csize_t</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>UInt</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>UInt</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>void</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>void</code></span></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cvoid</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cvoid</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>void</code> and <code>[[noreturn]]</code> or <code>_Noreturn</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>void</code> と <code>[[noreturn]]</code> または <code>_Noreturn</code></span></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Union{}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Union{}</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>void*</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>void*</code></span></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Ptr{Cvoid}</code> (or similarly <code>Ref{Cvoid}</code>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ptr{Cvoid}</code>（または同様に<code>Ref{Cvoid}</code>）</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>T*</code> (where T represents an appropriately defined type)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>T*</code>（ここでTは適切に定義された型を表します）</span></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Ref{T}</code> (T may be safely mutated only if T is an isbits type)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ref{T}</code>（Tはisbits型の場合のみ安全に変更できます）</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>char*</code> (or <code>char[]</code>, e.g. a string)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>char*</code>（または<code>char[]</code>、例えば文字列）</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>CHARACTER*N</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>CHARACTER*N</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cstring</code> if null-terminated, or <code>Ptr{UInt8}</code> if not</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cstring</code>がヌル終端の場合、または<code>Ptr{UInt8}</code>がそうでない場合</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>char**</code> (or <code>*char[]</code>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>char**</code>（または<code>*char[]</code>）</span></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Ptr{Ptr{UInt8}}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ptr{Ptr{UInt8}}</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>jl_value_t*</code> (any Julia Type)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_value_t*</code>（任意のJulia型）</span></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Any</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Any</code></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>jl_value_t* const*</code> (a reference to a Julia value)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_value_t* const*</code> (Julia値への参照)</span></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Ref{Any}</code> (const, since mutation would require a write barrier, which is not possible to insert correctly)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ref{Any}</code> (const、変更には書き込みバリアが必要であり、正しく挿入することはできません)</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>va_arg</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>va_arg</code></span></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text">Not supported</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">サポートされていません</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>...</code> (variadic function specification)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>...</code> (可変引数関数の仕様)</span></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>T...</code> (where <code>T</code> is one of the above types, when using the <code>ccall</code> function)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>T...</code> (ここで<code>T</code>は上記の型の1つであり、<code>ccall</code>関数を使用する場合)</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>...</code> (variadic function specification)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>...</code> (可変引数関数の仕様)</span></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>; va_arg1::T, va_arg2::S, etc.</code> (only supported with <code>@ccall</code> macro)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>; va_arg1::T, va_arg2::S, etc.</code> (のみ<code>@ccall</code>マクロでサポートされています)</span></td></tr></tbody></table><p data-translated="true"><span class="original-text">The <a href="../../base/c/index.html#Base.Cstring"><code>Cstring</code></a> type is essentially a synonym for <code>Ptr{UInt8}</code>, except the conversion to <code>Cstring</code> throws an error if the Julia string contains any embedded null characters (which would cause the string to be silently truncated if the C routine treats null as the terminator). If you are passing a <code>char*</code> to a C routine that does not assume null termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain null and want to skip the check, you can use <code>Ptr{UInt8}</code> as the argument type. <code>Cstring</code> can also be used as the <a href="../../base/c/index.html#ccall"><code>ccall</code></a> return type, but in that case it obviously does not introduce any extra checks and is only meant to improve the readability of the call.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/c/index.html#Base.Cstring"><code>Cstring</code></a>型は本質的に<code>Ptr{UInt8}</code>の同義語ですが、<code>Cstring</code>への変換は、Julia文字列に埋め込まれたヌル文字が含まれている場合にエラーをスローします（これはCルーチンがヌルを終端子として扱う場合、文字列が静かに切り捨てられる原因となります）。ヌル終端を仮定しないCルーチンに<code>char*</code>を渡す場合（例えば、明示的な文字列の長さを渡すため）、またはJulia文字列にヌルが含まれていないことが確実であり、チェックをスキップしたい場合は、引数型として<code>Ptr{UInt8}</code>を使用できます。<code>Cstring</code>は<a href="../../base/c/index.html#ccall"><code>ccall</code></a>の戻り値型としても使用できますが、その場合は明らかに追加のチェックを導入せず、呼び出しの可読性を向上させることを目的としています。</span></p><p data-translated="true"><span class="original-text"><strong>System Dependent Types</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>システム依存型</strong></span></p><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">C name</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C名</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Standard Julia Alias</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">標準Juliaエイリアス</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Julia Base Type</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaベースタイプ</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>char</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>char</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cchar</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cchar</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Int8</code> (x86, x86_64), <code>UInt8</code> (powerpc, arm)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Int8</code> (x86, x86_64), <code>UInt8</code> (powerpc, arm)</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>long</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>long</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Clong</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Clong</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Int</code> (UNIX), <code>Int32</code> (Windows)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Int</code> (UNIX), <code>Int32</code> (Windows)</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>unsigned long</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>unsigned long</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Culong</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Culong</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>UInt</code> (UNIX), <code>UInt32</code> (Windows)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>UInt</code> (UNIX), <code>UInt32</code> (Windows)</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>wchar_t</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>wchar_t</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Cwchar_t</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cwchar_t</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Int32</code> (UNIX), <code>UInt16</code> (Windows)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Int32</code> (UNIX), <code>UInt16</code> (Windows)</span></td></tr></tbody></table><div class="admonition is-info" id="Note-8ce4e7685dfc8681"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8ce4e7685dfc8681" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">When calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated values, so all type correspondences above should contain an additional <code>Ptr{..}</code> or <code>Ref{..}</code> wrapper around their type specification.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Fortranを呼び出す際、すべての入力はヒープまたはスタックに割り当てられた値へのポインタとして渡す必要があるため、上記のすべての型の対応には、型仕様の周りに追加の<code>Ptr{..}</code>または<code>Ref{..}</code>ラッパーを含める必要があります。</span></p></div></div><div class="admonition is-warning" id="Warning-85341210b0dedd1b"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-85341210b0dedd1b" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">For string arguments (<code>char*</code>) the Julia type should be <code>Cstring</code> (if null-terminated data is expected), or either <code>Ptr{Cchar}</code> or <code>Ptr{UInt8}</code> otherwise (these two pointer types have the same effect), as described above, not <code>String</code>. Similarly, for array arguments (<code>T[]</code> or <code>T*</code>), the Julia type should again be <code>Ptr{T}</code>, not <code>Vector{T}</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列引数（<code>char*</code>）の場合、Juliaの型は<code>Cstring</code>（ヌル終端データが期待される場合）であるべきですが、そうでない場合は<code>Ptr{Cchar}</code>または<code>Ptr{UInt8}</code>のいずれか（これら2つのポインタ型は同じ効果があります）であるべきです。上記のように、<code>String</code>ではありません。同様に、配列引数（<code>T[]</code>または<code>T*</code>）の場合、Juliaの型は再び<code>Ptr{T}</code>であるべきであり、<code>Vector{T}</code>ではありません。</span></p></div></div><div class="admonition is-warning" id="Warning-b3d09cdc606b3a8a"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-b3d09cdc606b3a8a" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Julia's <code>Char</code> type is 32 bits, which is not the same as the wide-character type (<code>wchar_t</code> or <code>wint_t</code>) on all platforms.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの<code>Char</code>型は32ビットであり、すべてのプラットフォームでワイドキャラクター型（<code>wchar_t</code>または<code>wint_t</code>）とは異なります。</span></p></div></div><div class="admonition is-warning" id="Warning-6e970534d5fb15fc"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-6e970534d5fb15fc" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">A return type of <code>Union{}</code> means the function will not return, i.e., C++11 <code>[[noreturn]]</code> or C11 <code>_Noreturn</code> (e.g. <code>jl_throw</code> or <code>longjmp</code>). Do not use this for functions that return no value (<code>void</code>) but do return, for those, use <code>Cvoid</code> instead.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Union{}</code>の戻り値の型は、関数が戻らないことを意味します。つまり、C++11の<code>[[noreturn]]</code>またはC11の<code>_Noreturn</code>（例：<code>jl_throw</code>または<code>longjmp</code>）です。戻り値がない関数（<code>void</code>）にはこれを使用しないでください。そういった場合には、代わりに<code>Cvoid</code>を使用してください。</span></p></div></div><div class="admonition is-info" id="Note-1e4ccb6468666661"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1e4ccb6468666661" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">For <code>wchar_t*</code> arguments, the Julia type should be <a href="../../base/c/index.html#Base.Cwstring"><code>Cwstring</code></a> (if the C routine expects a null-terminated string), or <code>Ptr{Cwchar_t}</code> otherwise. Note also that UTF-8 string data in Julia is internally null-terminated, so it can be passed to C functions expecting null-terminated data without making a copy (but using the <code>Cwstring</code> type will cause an error to be thrown if the string itself contains null characters).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>wchar_t*</code>引数の場合、Juliaの型は<a href="../../base/c/index.html#Base.Cwstring"><code>Cwstring</code></a>（Cルーチンがヌル終端文字列を期待する場合）であるべきですが、そうでない場合は<code>Ptr{Cwchar_t}</code>であるべきです。また、JuliaのUTF-8文字列データは内部的にヌル終端されているため、ヌル終端データを期待するC関数にコピーを作成せずに渡すことができます（ただし、<code>Cwstring</code>型を使用すると、文字列自体にヌル文字が含まれている場合にエラーが発生します）。</span></p></div></div><div class="admonition is-info" id="Note-f276151aaed9f82f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f276151aaed9f82f" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">C functions that take an argument of type <code>char**</code> can be called by using a <code>Ptr{Ptr{UInt8}}</code> type within Julia. For example, C functions of the form:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型 <code>char**</code> の引数を取るC関数は、Julia内で <code>Ptr{Ptr{UInt8}}</code> 型を使用することで呼び出すことができます。例えば、次の形式のC関数は：</span></p><pre><code class="language-c hljs">int main(int argc, char **argv);</code></pre><p data-translated="true"><span class="original-text">can be called via the following Julia code:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のJuliaコードを介して呼び出すことができます：</span></p><pre><code class="language-julia hljs">argv = [ "a.out", "arg1", "arg2" ]
@ccall main(length(argv)::Int32, argv::Ptr{Ptr{UInt8}})::Int32</code></pre></div></div><div class="admonition is-info" id="Note-67f41cfff497a08"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-67f41cfff497a08" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">For Fortran functions taking variable length strings of type <code>character(len=*)</code> the string lengths are provided as <em>hidden arguments</em>. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using <code>Csize_t</code> as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others <em>optionally</em> permit placing hidden arguments directly after the character argument (Intel, PGI). For example, Fortran subroutines of the form</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">可変長文字列の型 <code>character(len=*)</code> を取るFortran関数では、文字列の長さが<em>隠れた引数</em>として提供されます。これらの引数の型と位置はコンパイラによって異なり、コンパイラベンダーは通常、<code>Csize_t</code> を型として使用し、隠れた引数を引数リストの最後に追加することをデフォルトとしています。この動作は一部のコンパイラ（GNU）では固定されていますが、他のコンパイラ（Intel、PGIなど）は<em>オプションで</em>隠れた引数を文字引数の直後に配置することを許可しています。例えば、次の形式のFortranサブルーチンは</span></p><pre><code class="language-fortran hljs">subroutine test(str1, str2)
character(len=*) :: str1,str2</code></pre><p data-translated="true"><span class="original-text">can be called via the following Julia code, where the lengths are appended</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のJuliaコードを介して呼び出すことができ、長さが追加されます。</span></p><pre><code class="language-julia hljs">str1 = "foo"
str2 = "bar"
ccall(:test, Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),
                    str1, str2, sizeof(str1), sizeof(str2))</code></pre></div></div><div class="admonition is-warning" id="Warning-a72a0de2023d3e4a"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-a72a0de2023d3e4a" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Fortran compilers <em>may</em> also add other hidden arguments for pointers, assumed-shape (<code>:</code>) and assumed-size (<code>*</code>) arrays. Such behaviour can be avoided by using <code>ISO_C_BINDING</code> and including <code>bind(c)</code> in the definition of the subroutine, which is strongly recommended for interoperable code. In this case, there will be no hidden arguments, at the cost of some language features (e.g. only <code>character(len=1)</code> will be permitted to pass strings).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Fortranコンパイラは、ポインタ、仮定形（<code>:</code>）および仮定サイズ（<code>*</code>）配列のために他の隠れた引数を追加する<em>可能性があります</em>。このような動作は、<code>ISO_C_BINDING</code> を使用し、サブルーチンの定義に <code>bind(c)</code> を含めることで回避できます。これは相互運用可能なコードのために強く推奨されます。この場合、隠れた引数はなくなりますが、いくつかの言語機能（例：<code>character(len=1)</code> のみが文字列を渡すことが許可される）を犠牲にすることになります。</span></p></div></div><div class="admonition is-info" id="Note-4d32191f52f44b88"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4d32191f52f44b88" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">A C function declared to return <code>Cvoid</code> will return the value <code>nothing</code> in Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型 <code>Cvoid</code> を返すと宣言されたC関数は、Juliaでは値 <code>nothing</code> を返します。</span></p></div></div><h3 id="Struct-Type-Correspondences" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Struct-Type-Correspondences">Struct Type Correspondences</a><a id="Struct-Type-Correspondences-1"></a><a class="docs-heading-anchor-permalink" href="#Struct-Type-Correspondences" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Struct-Type-Correspondences">構造体型の対応</a><a id="Struct-Type-Correspondences-1"></a><a class="docs-heading-anchor-permalink" href="#Struct-Type-Correspondences" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Composite types such as <code>struct</code> in C or <code>TYPE</code> in Fortran90 (or <code>STRUCTURE</code> / <code>RECORD</code> in some variants of F77), can be mirrored in Julia by creating a <code>struct</code> definition with the same field layout.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cの <code>struct</code> やFortran90の <code>TYPE</code>（またはF77の一部のバリアントでの <code>STRUCTURE</code> / <code>RECORD</code>）のような複合型は、同じフィールドレイアウトを持つ <code>struct</code> 定義を作成することでJuliaにミラーリングできます。</span></p><p data-translated="true"><span class="original-text">When used recursively, <code>isbits</code> types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare an <code>isbits</code> struct type and use that instead. Unnamed structs are not possible in the translation to Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">再帰的に使用される場合、<code>isbits</code> 型はインラインで保存されます。他のすべての型はデータへのポインタとして保存されます。C内の別の構造体の中で値として使用される構造体をミラーリングする場合、フィールドの手動コピーを試みないことが重要です。そうしないと、正しいフィールドのアラインメントが保持されません。代わりに、<code>isbits</code> 構造体型を宣言し、それを使用してください。無名構造体はJuliaへの翻訳では不可能です。</span></p><p data-translated="true"><span class="original-text">Packed structs and union declarations are not supported by Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パックされた構造体および共用体の宣言はJuliaではサポートされていません。</span></p><p data-translated="true"><span class="original-text">You can get an approximation of a <code>union</code> if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最も大きなサイズ（パディングを含む可能性がある）を持つフィールドを事前に知っている場合、<code>union</code>の近似を得ることができます。フィールドをJuliaに変換する際には、そのタイプのみでJuliaフィールドを宣言してください。</span></p><p data-translated="true"><span class="original-text">Arrays of parameters can be expressed with <code>NTuple</code>. For example, the struct in C notation is written as</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パラメータの配列は<code>NTuple</code>で表現できます。例えば、C表記の構造体は次のように書かれます。</span></p><pre><code class="language-c hljs">struct B {
    int A[3];
};

b_a_2 = B.A[2];</code></pre><p data-translated="true"><span class="original-text">can be written in Julia as</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これはJuliaでは次のように書けます。</span></p><pre><code class="language-julia hljs">struct B
    A::NTuple{3, Cint}
end

b_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)</code></pre><p data-translated="true"><span class="original-text">Arrays of unknown size (C99-compliant variable length structs specified by <code>[]</code> or <code>[0]</code>) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">未知のサイズの配列（<code>[]</code>または<code>[0]</code>で指定されたC99準拠の可変長構造体）は直接サポートされていません。これらに対処する最良の方法は、バイトオフセットを直接扱うことです。例えば、Cライブラリが適切な文字列型を宣言し、それへのポインタを返した場合：</span></p><pre><code class="language-c hljs">struct String {
    int strlen;
    char data[];
};</code></pre><p data-translated="true"><span class="original-text">In Julia, we can access the parts independently to make a copy of that string:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、その文字列のコピーを作成するために部分に独立してアクセスできます：</span></p><pre><code class="language-julia hljs">str = from_c::Ptr{Cvoid}
len = unsafe_load(Ptr{Cint}(str))
unsafe_string(str + Core.sizeof(Cint), len)</code></pre><h3 id="Type-Parameters" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Type-Parameters">Type Parameters</a><a id="Type-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Parameters" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Type-Parameters">型パラメータ</a><a id="Type-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Parameters" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The type arguments to <code>@ccall</code> and <code>@cfunction</code> are evaluated statically, when the method containing the usage is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@ccall</code>および<code>@cfunction</code>への型引数は、使用を含むメソッドが定義されるときに静的に評価されます。したがって、リテラルタプルの形式でなければならず、変数ではなく、ローカル変数を参照することはできません。</span></p><p data-translated="true"><span class="original-text">This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは奇妙な制限のように聞こえるかもしれませんが、CはJuliaのような動的言語ではないため、その関数は静的に知られた固定のシグネチャを持つ引数タイプしか受け入れられないことを思い出してください。</span></p><p data-translated="true"><span class="original-text">However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don't affect the layout of the type. For example, <code>f(x::T) where {T} = @ccall valid(x::Ptr{T})::Ptr{T}</code> is valid, since <code>Ptr</code> is always a word-size primitive type. But, <code>g(x::T) where {T} = @ccall notvalid(x::T)::T</code> is not valid, since the type layout of <code>T</code> is not known statically.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、型レイアウトは意図されたC ABIを計算するために静的に知られている必要がありますが、関数の静的パラメータはこの静的環境の一部と見なされます。型のレイアウトに影響を与えない限り、関数の静的パラメータは呼び出しシグネチャの型パラメータとして使用できます。例えば、<code>f(x::T) where {T} = @ccall valid(x::Ptr{T})::Ptr{T}</code>は有効です。なぜなら、<code>Ptr</code>は常にワードサイズのプリミティブ型だからです。しかし、<code>g(x::T) where {T} = @ccall notvalid(x::T)::T</code>は無効です。なぜなら、<code>T</code>の型レイアウトは静的に知られていないからです。</span></p><h3 id="SIMD-Values" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#SIMD-Values">SIMD Values</a><a id="SIMD-Values-1"></a><a class="docs-heading-anchor-permalink" href="#SIMD-Values" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#SIMD-Values">SIMD値</a><a id="SIMD-Values-1"></a><a class="docs-heading-anchor-permalink" href="#SIMD-Values" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of <code>VecElement</code> that naturally maps to the SIMD type. Specifically:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C/C++ルーチンにネイティブSIMD型の引数または戻り値がある場合、対応するJulia型は、SIMD型に自然にマッピングされる<code>VecElement</code>の同種タプルです。具体的には、</span></p><blockquote><ul><li data-translated="true"><span class="original-text">The tuple must be the same size and elements as the SIMD type. For example, a tuple representing an <code>__m128</code> on x86 must have a size of 16 bytes and Float32 elements.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">タプルはSIMD型と同じサイズおよび要素でなければなりません。たとえば、x86上の<code>__m128</code>を表すタプルは、サイズが16バイトでFloat32要素を持つ必要があります。</span></li><li data-translated="true"><span class="original-text">The element type of the tuple must be an instance of <code>VecElement{T}</code> where <code>T</code> is a primitive type with a power-of-two number of bytes (e.g. 1, 2, 4, 8, 16, etc) such as Int8 or Float64.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">タプルの要素型は、<code>VecElement{T}</code>のインスタンスでなければならず、<code>T</code>は2の累乗バイト数（例：1、2、4、8、16など）のプリミティブ型である必要があります。たとえば、Int8やFloat64などです。</span></li></ul></blockquote><p data-translated="true"><span class="original-text">For instance, consider this C routine that uses AVX intrinsics:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">たとえば、AVXインストリームを使用するこのCルーチンを考えてみましょう：</span></p><pre><code class="language-c hljs">#include &lt;immintrin.h&gt;

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}</code></pre><p data-translated="true"><span class="original-text">The following Julia code calls <code>dist</code> using <code>ccall</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のJuliaコードは<code>ccall</code>を使用して<code>dist</code>を呼び出します：</span></p><pre><code class="language-julia hljs">const m256 = NTuple{8, VecElement{Float32}}

a = m256(ntuple(i -&gt; VecElement(sin(Float32(i))), 8))
b = m256(ntuple(i -&gt; VecElement(cos(Float32(i))), 8))

function call_dist(a::m256, b::m256)
    @ccall "libdist".dist(a::m256, b::m256)::m256
end

println(call_dist(a,b))</code></pre><p data-translated="true"><span class="original-text">The host machine must have the requisite SIMD registers. For example, the code above will not work on hosts without AVX support.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ホストマシンは必要なSIMDレジスタを持っている必要があります。たとえば、上記のコードはAVXサポートのないホストでは動作しません。</span></p><h3 id="Memory-Ownership" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Memory-Ownership">Memory Ownership</a><a id="Memory-Ownership-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Ownership" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Memory-Ownership">メモリ所有権</a><a id="Memory-Ownership-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Ownership" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text"><strong><code>malloc</code>/<code>free</code></strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong><code>malloc</code>/<code>free</code></strong></span></p><p data-translated="true"><span class="original-text">Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with <a href="../../base/libc/index.html#Base.Libc.free"><code>Libc.free</code></a> in Julia, as this may result in the <code>free</code> function being called via the wrong library and cause the process to abort. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このようなオブジェクトのメモリ割り当てと解放は、使用しているライブラリの適切なクリーンアップルーチンへの呼び出しによって処理されなければなりません。これは、任意のCプログラムと同様です。JuliaでCライブラリから受け取ったオブジェクトを<a href="../../base/libc/index.html#Base.Libc.free"><code>Libc.free</code></a>で解放しようとしないでください。これは、<code>free</code>関数が誤ったライブラリを介して呼び出され、プロセスが中止される原因となる可能性があります。逆に、Juliaで割り当てられたオブジェクトを外部ライブラリによって解放するために渡すことも同様に無効です。</span></p><h3 id="When-to-use-T,-Ptr{T}-and-Ref{T}" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#When-to-use-T,-Ptr{T}-and-Ref{T}">When to use <code>T</code>, <code>Ptr{T}</code> and <code>Ref{T}</code></a><a id="When-to-use-T,-Ptr{T}-and-Ref{T}-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-use-T,-Ptr{T}-and-Ref{T}" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#When-to-use-T,-Ptr{T}-and-Ref{T}">いつ<code>T</code>、<code>Ptr{T}</code>および<code>Ref{T}</code>を使用するか</a><a id="When-to-use-T,-Ptr{T}-and-Ref{T}-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-use-T,-Ptr{T}-and-Ref{T}" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type <code>T</code> inside the <code>@ccall</code>, as they are passed by value. For C code accepting pointers, <a href="../../base/c/index.html#Core.Ref"><code>Ref{T}</code></a> should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to <a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert</code></a>. In contrast, pointers returned by the C function called should be declared to be of the output type <a href="../../base/c/index.html#Core.Ptr"><code>Ptr{T}</code></a>, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type <code>Ptr{T}</code> within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaコードで外部Cルーチンへの呼び出しをラップする際、通常の（ポインタでない）データは、<code>T</code>型として<code>@ccall</code>内で宣言する必要があります。これは値渡しされるためです。ポインタを受け取るCコードの場合、<a href="../../base/c/index.html#Core.Ref"><code>Ref{T}</code></a>を一般的に入力引数の型として使用し、<a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert</code></a>への暗黙の呼び出しを通じて、JuliaまたはCによって管理されるメモリへのポインタを使用できるようにします。対照的に、呼び出されたC関数によって返されるポインタは、出力型<a href="../../base/c/index.html#Core.Ptr"><code>Ptr{T}</code></a>として宣言されるべきであり、これは指し示すメモリがCによってのみ管理されていることを反映しています。C構造体に含まれるポインタは、対応するJulia構造体型内の<code>Ptr{T}</code>型のフィールドとして表現されるべきです。</span></p><p data-translated="true"><span class="original-text">In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type <code>Ref{T}</code>, as Fortran passes all variables by pointers to memory locations. The return type should either be <code>Cvoid</code> for Fortran subroutines, or a <code>T</code> for Fortran functions returning the type <code>T</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaコードで外部Fortranルーチンへの呼び出しをラップする際、すべての入力引数は<code>Ref{T}</code>型として宣言する必要があります。Fortranはすべての変数をメモリ位置へのポインタとして渡すためです。戻り値の型は、Fortranサブルーチンの場合は<code>Cvoid</code>、またはFortran関数が型<code>T</code>を返す場合は<code>T</code>であるべきです。</span></p><h2 id="Mapping-C-Functions-to-Julia" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Mapping-C-Functions-to-Julia">Mapping C Functions to Julia</a><a id="Mapping-C-Functions-to-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping-C-Functions-to-Julia" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Mapping-C-Functions-to-Julia">C関数をJuliaにマッピングする</a><a id="Mapping-C-Functions-to-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping-C-Functions-to-Julia" title="Permalink"></a></span></h2><h3 id="@ccall-/-@cfunction-argument-translation-guide" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#@ccall-/-@cfunction-argument-translation-guide"><code>@ccall</code> / <code>@cfunction</code> argument translation guide</a><a id="@ccall-/-@cfunction-argument-translation-guide-1"></a><a class="docs-heading-anchor-permalink" href="#@ccall-/-@cfunction-argument-translation-guide" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#@ccall-/-@cfunction-argument-translation-guide"><code>@ccall</code> / <code>@cfunction</code> 引数変換ガイド</a><a id="@ccall-/-@cfunction-argument-translation-guide-1"></a><a class="docs-heading-anchor-permalink" href="#@ccall-/-@cfunction-argument-translation-guide" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">For translating a C argument list to Julia:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C引数リストをJuliaに変換するためには:</span></p><ul><li><p data-translated="true"><span class="original-text"><code>T</code>, where <code>T</code> is one of the primitive types: <code>char</code>, <code>int</code>, <code>long</code>, <code>short</code>, <code>float</code>, <code>double</code>, <code>complex</code>, <code>enum</code> or any of their <code>typedef</code> equivalents</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>T</code>、ここで <code>T</code> は原始型のいずれか: <code>char</code>、<code>int</code>、<code>long</code>、<code>short</code>、<code>float</code>、<code>double</code>、<code>complex</code>、<code>enum</code> またはそれらの <code>typedef</code> 等価物のいずれかです</span></p><ul><li data-translated="true"><span class="original-text"><code>T</code>, where <code>T</code> is an equivalent Julia Bits Type (per the table above)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>T</code>、ここで<code>T</code>は上記の表に従ったJuliaのBits型の等価物</span></li><li data-translated="true"><span class="original-text">if <code>T</code> is an <code>enum</code>, the argument type should be equivalent to <code>Cint</code> or <code>Cuint</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もし<code>T</code>が<code>enum</code>の場合、引数の型は<code>Cint</code>または<code>Cuint</code>に等しいべきです。</span></li><li data-translated="true"><span class="original-text">argument value will be copied (passed by value)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数の値はコピーされます（値渡し）</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>struct T</code> (including typedef to a struct)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>struct T</code>（構造体へのtypedefを含む）</span></p><ul><li data-translated="true"><span class="original-text"><code>T</code>, where <code>T</code> is a concrete Julia type</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>T</code>は具体的なJulia型です</span></li><li data-translated="true"><span class="original-text">argument value will be copied (passed by value)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数の値はコピーされます（値渡し）</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>vector T</code> (or <code>__attribute__ vector_size</code>, or a typedef such as <code>__m128</code>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>vector T</code>（または<code>__attribute__ vector_size</code>、または<code>__m128</code>のようなtypedef）</span></p><ul><li data-translated="true"><span class="original-text"><code>NTuple{N, VecElement{T}}</code>, where <code>T</code> is a primitive Julia type of the correct size and N is the number of elements in the vector (equal to <code>vector_size / sizeof T</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>NTuple{N, VecElement{T}}</code>、ここで<code>T</code>は正しいサイズのプリミティブなJulia型で、Nはベクターの要素数（<code>vector_size / sizeof T</code>に等しい）です。</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>void*</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>void*</code></span></p><ul><li data-translated="true"><span class="original-text">depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このパラメータの使用方法によります。まず、これを意図されたポインタ型に変換し、その後、このリストの残りのルールを使用してJuliaの同等物を決定します。</span></li><li data-translated="true"><span class="original-text">this argument may be declared as <code>Ptr{Cvoid}</code> if it really is just an unknown pointer</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この引数は、実際に未知のポインタである場合、<code>Ptr{Cvoid}</code>として宣言できます。</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>jl_value_t*</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_value_t*</code></span></p><ul><li data-translated="true"><span class="original-text"><code>Any</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Any</code></span></li><li data-translated="true"><span class="original-text">argument value must be a valid Julia object</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数の値は有効なJuliaオブジェクトでなければなりません</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>jl_value_t* const*</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_value_t* const*</code></span></p><ul><li data-translated="true"><span class="original-text"><code>Ref{Any}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ref{Any}</code></span></li><li data-translated="true"><span class="original-text">argument list must be a valid Julia object (or <code>C_NULL</code>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数リストは有効なJuliaオブジェクト（または<code>C_NULL</code>）でなければなりません</span></li><li data-translated="true"><span class="original-text">cannot be used for an output parameter, unless the user is able to separately arrange for the object to be GC-preserved</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">出力パラメータとして使用することはできません。ユーザーがオブジェクトをGCで保持するように別途手配できる場合を除きます</span></li></ul></li><li><p><code>T*</code></p><ul><li data-translated="true"><span class="original-text"><code>Ref{T}</code>, where <code>T</code> is the Julia type corresponding to <code>T</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ref{T}</code>、ここで<code>T</code>は<code>T</code>に対応するJulia型です</span></li><li data-translated="true"><span class="original-text">argument value will be copied if it is an <code>inlinealloc</code> type (which includes <code>isbits</code> otherwise, the value must be a valid Julia object</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数の値は<code>inlinealloc</code>型の場合にコピーされます（<code>isbits</code>を含む）。そうでない場合、値は有効なJuliaオブジェクトでなければなりません</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>T (*)(...)</code> (e.g. a pointer to a function)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>T (*)(...)</code>（例えば、関数へのポインタ）</span></p><ul><li data-translated="true"><span class="original-text"><code>Ptr{Cvoid}</code> (you may need to use <a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a> explicitly to create this pointer)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ptr{Cvoid}</code>（このポインタを作成するために<a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a>を明示的に使用する必要があるかもしれません）</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>...</code> (e.g. a vararg)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>...</code>（例：可変引数）</span></p><ul><li data-translated="true"><span class="original-text">[for <code>ccall</code>]: <code>T...</code>, where <code>T</code> is the single Julia type of all remaining arguments</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">[<code>ccall</code>用]: <code>T...</code>、ここで<code>T</code>は残りのすべての引数の単一のJulia型です</span></li><li data-translated="true"><span class="original-text">[for <code>@ccall</code>]: <code>; va_arg1::T, va_arg2::S, etc</code>, where <code>T</code> and <code>S</code> are the Julia type (i.e. separate the regular arguments from varargs with a <code>;</code>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">[<code>@ccall</code>の場合]: <code>; va_arg1::T, va_arg2::S, etc</code>、ここで <code>T</code> と <code>S</code> はJuliaの型です（つまり、通常の引数と可変引数を <code>;</code> で区切ります）</span></li><li data-translated="true"><span class="original-text">currently unsupported by <code>@cfunction</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">現在 <code>@cfunction</code> ではサポートされていません</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>va_arg</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>va_arg</code></span></p><ul><li data-translated="true"><span class="original-text">not supported by <code>ccall</code> or <code>@cfunction</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ccall</code> または <code>@cfunction</code> ではサポートされていません</span></li></ul></li></ul><h3 id="@ccall-/-@cfunction-return-type-translation-guide" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#@ccall-/-@cfunction-return-type-translation-guide"><code>@ccall</code> / <code>@cfunction</code> return type translation guide</a><a id="@ccall-/-@cfunction-return-type-translation-guide-1"></a><a class="docs-heading-anchor-permalink" href="#@ccall-/-@cfunction-return-type-translation-guide" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#@ccall-/-@cfunction-return-type-translation-guide"><code>@ccall</code> / <code>@cfunction</code> 戻り値型翻訳ガイド</a><a id="@ccall-/-@cfunction-return-type-translation-guide-1"></a><a class="docs-heading-anchor-permalink" href="#@ccall-/-@cfunction-return-type-translation-guide" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">For translating a C return type to Julia:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cの戻り値型をJuliaに翻訳するためには:</span></p><ul><li><p data-translated="true"><span class="original-text"><code>void</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>void</code></span></p><ul><li data-translated="true"><span class="original-text"><code>Cvoid</code> (this will return the singleton instance <code>nothing::Cvoid</code>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Cvoid</code>（これはシングルトンインスタンス <code>nothing::Cvoid</code> を返します）</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>T</code>, where <code>T</code> is one of the primitive types: <code>char</code>, <code>int</code>, <code>long</code>, <code>short</code>, <code>float</code>, <code>double</code>, <code>complex</code>, <code>enum</code> or any of their <code>typedef</code> equivalents</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>T</code>、ここで <code>T</code> は原始型のいずれか: <code>char</code>、<code>int</code>、<code>long</code>、<code>short</code>、<code>float</code>、<code>double</code>、<code>complex</code>、<code>enum</code> またはそれらの <code>typedef</code> 等価物のいずれかです</span></p><ul><li data-translated="true"><span class="original-text">same as C argument list</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cの引数リストと同じ</span></li><li data-translated="true"><span class="original-text">argument value will be copied (returned by-value)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数の値はコピーされます（値渡しで返されます）</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>struct T</code> (including typedef to a struct)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>struct T</code>（構造体へのtypedefを含む）</span></p><ul><li data-translated="true"><span class="original-text">same as C argument list</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cの引数リストと同じ</span></li><li data-translated="true"><span class="original-text">argument value will be copied (returned by-value)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数の値はコピーされます（値渡しで返されます）</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>vector T</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>vector T</code></span></p><ul><li data-translated="true"><span class="original-text">same as C argument list</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cの引数リストと同じ</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>void*</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>void*</code></span></p><ul><li data-translated="true"><span class="original-text">depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このパラメータの使用方法によります。まず、これを意図されたポインタ型に変換し、その後、このリストの残りのルールを使用してJuliaの同等物を決定します。</span></li><li data-translated="true"><span class="original-text">this argument may be declared as <code>Ptr{Cvoid}</code> if it really is just an unknown pointer</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この引数は、実際に未知のポインタである場合、<code>Ptr{Cvoid}</code>として宣言できます。</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>jl_value_t*</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_value_t*</code></span></p><ul><li data-translated="true"><span class="original-text"><code>Any</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Any</code></span></li><li data-translated="true"><span class="original-text">argument value must be a valid Julia object</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数の値は有効なJuliaオブジェクトでなければなりません</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>jl_value_t**</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>jl_value_t**</code></span></p><ul><li data-translated="true"><span class="original-text"><code>Ptr{Any}</code> (<code>Ref{Any}</code> is invalid as a return type)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ptr{Any}</code>（<code>Ref{Any}</code>は戻り値の型として無効です）</span></li></ul></li><li><p><code>T*</code></p><ul><li><p data-translated="true"><span class="original-text">If the memory is already owned by Julia, or is an <code>isbits</code> type, and is known to be non-null:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メモリがすでにJuliaによって所有されている場合、または<code>isbits</code>型であり、非nullであることが知られている場合：</span></p><ul><li data-translated="true"><span class="original-text"><code>Ref{T}</code>, where <code>T</code> is the Julia type corresponding to <code>T</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ref{T}</code>、ここで<code>T</code>は<code>T</code>に対応するJulia型です</span></li><li data-translated="true"><span class="original-text">a return type of <code>Ref{Any}</code> is invalid, it should either be <code>Any</code> (corresponding to <code>jl_value_t*</code>) or <code>Ptr{Any}</code> (corresponding to <code>jl_value_t**</code>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ref{Any}</code>の戻り値の型は無効であり、<code>Any</code>（<code>jl_value_t*</code>に対応）または<code>Ptr{Any}</code>（<code>jl_value_t**</code>に対応）である必要があります</span></li><li data-translated="true"><span class="original-text">C <strong>MUST NOT</strong> modify the memory returned via <code>Ref{T}</code> if <code>T</code> is an <code>isbits</code> type</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cは、<code>T</code>が<code>isbits</code>型である場合、<code>Ref{T}</code>経由で返されたメモリを<strong>変更してはなりません</strong></span></li></ul></li><li><p data-translated="true"><span class="original-text">If the memory is owned by C:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メモリがCによって所有されている場合：</span></p><ul><li data-translated="true"><span class="original-text"><code>Ptr{T}</code>, where <code>T</code> is the Julia type corresponding to <code>T</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ptr{T}</code>、ここで<code>T</code>は<code>T</code>に対応するJulia型です</span></li></ul></li></ul></li><li><p data-translated="true"><span class="original-text"><code>T (*)(...)</code> (e.g. a pointer to a function)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>T (*)(...)</code>（例えば、関数へのポインタ）</span></p><ul><li data-translated="true"><span class="original-text"><code>Ptr{Cvoid}</code> to call this directly from Julia you will need to pass this as the first argument to <code>@ccall</code>. See <a href="#Indirect-Calls">Indirect Calls</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ptr{Cvoid}</code>を使用して、これをJuliaから直接呼び出すには、最初の引数として<code>@ccall</code>に渡す必要があります。詳細は<a href="#Indirect-Calls">間接呼び出し</a>を参照してください。</span></li></ul></li></ul><h3 id="Passing-Pointers-for-Modifying-Inputs" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Passing-Pointers-for-Modifying-Inputs">Passing Pointers for Modifying Inputs</a><a id="Passing-Pointers-for-Modifying-Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Passing-Pointers-for-Modifying-Inputs" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Passing-Pointers-for-Modifying-Inputs">入力を変更するためのポインタの渡し方</a><a id="Passing-Pointers-for-Modifying-Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Passing-Pointers-for-Modifying-Inputs" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a <code>@ccall</code>, you need to first encapsulate the value inside a <a href="../../base/c/index.html#Core.Ref"><code>Ref{T}</code></a> of the appropriate type. When you pass this <code>Ref</code> object as an argument, Julia will automatically pass a C pointer to the encapsulated data:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cは複数の戻り値をサポートしていないため、C関数はしばしば関数が変更するデータへのポインタを受け取ります。これを<code>@ccall</code>内で実現するには、まず適切な型の<a href="../../base/c/index.html#Core.Ref"><code>Ref{T}</code></a>の中に値をカプセル化する必要があります。この<code>Ref</code>オブジェクトを引数として渡すと、Juliaは自動的にカプセル化されたデータへのCポインタを渡します：</span></p><pre><code class="language-julia hljs">width = Ref{Cint}(0)
range = Ref{Cfloat}(0)
@ccall foo(width::Ref{Cint}, range::Ref{Cfloat})::Cvoid</code></pre><p data-translated="true"><span class="original-text">Upon return, the contents of <code>width</code> and <code>range</code> can be retrieved (if they were changed by <code>foo</code>) by <code>width[]</code> and <code>range[]</code>; that is, they act like zero-dimensional arrays.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">戻り値として、<code>width</code>と<code>range</code>の内容は（<code>foo</code>によって変更された場合）<code>width[]</code>と<code>range[]</code>で取得できます。つまり、これらはゼロ次元配列のように動作します。</span></p><h2 id="C-Wrapper-Examples" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#C-Wrapper-Examples">C Wrapper Examples</a><a id="C-Wrapper-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#C-Wrapper-Examples" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#C-Wrapper-Examples">Cラッパーの例</a><a id="C-Wrapper-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#C-Wrapper-Examples" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Let's start with a simple example of a C wrapper that returns a <code>Ptr</code> type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">まず、<code>Ptr</code>型を返すCラッパーの簡単な例から始めましょう：</span></p><pre><code class="language-julia hljs">mutable struct gsl_permutation
end

# The corresponding C signature is
#     gsl_permutation * gsl_permutation_alloc (size_t n);
function permutation_alloc(n::Integer)
    output_ptr = @ccall "libgsl".gsl_permutation_alloc(n::Csize_t)::Ptr{gsl_permutation}
    if output_ptr == C_NULL # Could not allocate memory
        throw(OutOfMemoryError())
    end
    return output_ptr
end</code></pre><p data-translated="true"><span class="original-text">The <a href="https://www.gnu.org/software/gsl/">GNU Scientific Library</a> (here assumed to be accessible through <code>:libgsl</code>) defines an opaque pointer, <code>gsl_permutation *</code>, as the return type of the C function <code>gsl_permutation_alloc</code>. As user code never has to look inside the <code>gsl_permutation</code> struct, the corresponding Julia wrapper simply needs a new type declaration, <code>gsl_permutation</code>, that has no internal fields and whose sole purpose is to be placed in the type parameter of a <code>Ptr</code> type. The return type of the <a href="../../base/c/index.html#ccall"><code>ccall</code></a> is declared as <code>Ptr{gsl_permutation}</code>, since the memory allocated and pointed to by <code>output_ptr</code> is controlled by C.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://www.gnu.org/software/gsl/">GNU科学ライブラリ</a>（ここでは<code>:libgsl</code>を通じてアクセス可能であると仮定します）は、C関数<code>gsl_permutation_alloc</code>の戻り値の型として不透明ポインタ<code>gsl_permutation *</code>を定義しています。ユーザーコードは<code>gsl_permutation</code>構造体の内部を確認する必要がないため、対応するJuliaラッパーは内部フィールドを持たず、<code>Ptr</code>型の型パラメータに配置されることを目的とした新しい型宣言<code>gsl_permutation</code>が必要です。<a href="../../base/c/index.html#ccall"><code>ccall</code></a>の戻り値の型は<code>Ptr{gsl_permutation}</code>として宣言されます。なぜなら、<code>output_ptr</code>によって制御されるメモリはCによって割り当てられ、指されるからです。</span></p><p data-translated="true"><span class="original-text">The input <code>n</code> is passed by value, and so the function's input signature is simply declared as <code>::Csize_t</code> without any <code>Ref</code> or <code>Ptr</code> necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature would instead be <code>::Ref{Csize_t}</code>, since Fortran variables are passed by pointers.) Furthermore, <code>n</code> can be any type that is convertible to a <code>Csize_t</code> integer; the <a href="../../base/c/index.html#ccall"><code>ccall</code></a> implicitly calls <a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert(Csize_t, n)</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">入力<code>n</code>は値として渡されるため、関数の入力シグネチャは単に<code>::Csize_t</code>として宣言され、<code>Ref</code>や<code>Ptr</code>は必要ありません。（ラッパーがFortran関数を呼び出す場合、対応する関数の入力シグネチャは<code>::Ref{Csize_t}</code>になります。なぜなら、Fortran変数はポインタで渡されるからです。）さらに、<code>n</code>は<code>Csize_t</code>整数に変換可能な任意の型であることができます；<a href="../../base/c/index.html#ccall"><code>ccall</code></a>は暗黙的に<a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert(Csize_t, n)</code></a>を呼び出します。</span></p><p data-translated="true"><span class="original-text">Here is a second example wrapping the corresponding destructor:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">こちらは、対応するデストラクタをラップする第二の例です：</span></p><pre><code class="language-julia hljs"># The corresponding C signature is
#     void gsl_permutation_free (gsl_permutation * p);
function permutation_free(p::Ptr{gsl_permutation})
    @ccall "libgsl".gsl_permutation_free(p::Ptr{gsl_permutation})::Cvoid
end</code></pre><p data-translated="true"><span class="original-text">Here is a third example passing Julia arrays:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここに、Julia配列を渡す第三の例があります：</span></p><pre><code class="language-julia hljs"># The corresponding C signature is
#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,
#                                double result_array[])
function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)
    if nmax &lt; nmin
        throw(DomainError())
    end
    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)
    errorcode = @ccall "libgsl".gsl_sf_bessel_Jn_array(
                    nmin::Cint, nmax::Cint, x::Cdouble, result_array::Ref{Cdouble})::Cint
    if errorcode != 0
        error("GSL error code $errorcode")
    end
    return result_array
end</code></pre><p data-translated="true"><span class="original-text">The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array <code>result_array</code>. This variable is declared as a <code>Ref{Cdouble}</code>, since its memory is allocated and managed by Julia. The implicit call to <a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert(Ref{Cdouble}, result_array)</code></a> unpacks the Julia pointer to a Julia array data structure into a form understandable by C.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ラップされたC関数は整数のエラーコードを返します。Bessel J関数の実際の評価の結果は、Julia配列<code>result_array</code>に格納されます。この変数は<code>Ref{Cdouble}</code>として宣言されており、そのメモリはJuliaによって割り当てられ、管理されます。<a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert(Ref{Cdouble}, result_array)</code></a>への暗黙の呼び出しは、JuliaポインタをJulia配列データ構造に展開し、Cが理解できる形式にします。</span></p><h2 id="Fortran-Wrapper-Example" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Fortran-Wrapper-Example">Fortran Wrapper Example</a><a id="Fortran-Wrapper-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Fortran-Wrapper-Example" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Fortran-Wrapper-Example">Fortranラッパーの例</a><a id="Fortran-Wrapper-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Fortran-Wrapper-Example" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The following example utilizes <code>ccall</code> to call a function in a common Fortran library (libBLAS) to compute a dot product. Notice that the argument mapping is a bit different here than above, as we need to map from Julia to Fortran. On every argument type, we specify <code>Ref</code> or <code>Ptr</code>. This mangling convention may be specific to your Fortran compiler and operating system and is likely undocumented. However, wrapping each in a <code>Ref</code> (or <code>Ptr</code>, where equivalent) is a frequent requirement of Fortran compiler implementations:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次の例では、<code>ccall</code>を使用して、一般的なFortranライブラリ（libBLAS）の関数を呼び出し、ドット積を計算します。引数のマッピングは、JuliaからFortranへのマッピングが必要なため、上記とは少し異なることに注意してください。すべての引数タイプに対して、<code>Ref</code>または<code>Ptr</code>を指定します。このマングリング規則は、あなたのFortranコンパイラやオペレーティングシステムに特有であり、文書化されていない可能性があります。しかし、各引数を<code>Ref</code>（または同等の<code>Ptr</code>）でラップすることは、Fortranコンパイラの実装において一般的な要件です。</span></p><pre><code class="language-julia hljs">function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})
    @assert length(DX) == length(DY)
    n = length(DX)
    incx = incy = 1
    product = @ccall "libLAPACK".ddot(
        n::Ref{Int32}, DX::Ptr{Float64}, incx::Ref{Int32}, DY::Ptr{Float64}, incy::Ref{Int32})::Float64
    return product
end</code></pre><h2 id="Garbage-Collection-Safety" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Garbage-Collection-Safety">Garbage Collection Safety</a><a id="Garbage-Collection-Safety-1"></a><a class="docs-heading-anchor-permalink" href="#Garbage-Collection-Safety" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Garbage-Collection-Safety">ガーベジコレクションの安全性</a><a id="Garbage-Collection-Safety-1"></a><a class="docs-heading-anchor-permalink" href="#Garbage-Collection-Safety" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">When passing data to a <code>@ccall</code>, it is best to avoid using the <a href="../../base/c/index.html#Base.pointer"><code>pointer</code></a> function. Instead define a <a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert</code></a> method and pass the variables directly to the <code>@ccall</code>. <code>@ccall</code> automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the <code>@ccall</code> returns, you must ensure that the object remains visible to the garbage collector. The suggested way to do this is to make a global variable of type <code>Vector{Ref}</code> to hold these values until the C library notifies you that it is finished with them.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@ccall</code>にデータを渡す際は、<a href="../../base/c/index.html#Base.pointer"><code>pointer</code></a>関数の使用を避けるのが最良です。代わりに、<a href="../../base/c/index.html#Base.cconvert"><code>Base.cconvert</code></a>メソッドを定義し、変数を直接<code>@ccall</code>に渡します。<code>@ccall</code>は、自動的にすべての引数が呼び出しが返るまでガーベジコレクションから保護されるように手配します。C APIがJuliaによって割り当てられたメモリへの参照を保存する場合、<code>@ccall</code>が返った後もオブジェクトがガーベジコレクタに見えるようにする必要があります。これを行うための推奨方法は、Cライブラリがそれらを使い終わったことを通知するまで、これらの値を保持するために<code>Vector{Ref}</code>型のグローバル変数を作成することです。</span></p><p data-translated="true"><span class="original-text">Whenever you have created a pointer to Julia data, you must ensure the original data exists until you have finished using the pointer. Many methods in Julia such as <a href="../../base/c/index.html#Base.unsafe_load"><code>unsafe_load</code></a> and <a href="../../base/strings/index.html#Core.String-Tuple{AbstractString}"><code>String</code></a> make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is <a href="../../base/c/index.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T}}, Type{Array{T, N}}}, Ptr{T}, NTuple{N, Int64}}} where {T, N}"><code>unsafe_wrap</code></a> which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaデータへのポインタを作成した場合は、ポインタの使用が終了するまで元のデータが存在することを確認する必要があります。<a href="../../base/c/index.html#Base.unsafe_load"><code>unsafe_load</code></a>や<a href="../../base/strings/index.html#Core.String-Tuple{AbstractString}"><code>String</code></a>など、Juliaの多くのメソッドは、バッファの所有権を取得するのではなくデータのコピーを作成するため、元のデータを解放（または変更）してもJuliaに影響を与えないように安全です。注目すべき例外は、パフォーマンス上の理由から基盤となるバッファを共有する（または所有権を取得するように指示できる）<a href="../../base/c/index.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T}}, Type{Array{T, N}}}, Ptr{T}, NTuple{N, Int64}}} where {T, N}"><code>unsafe_wrap</code></a>です。</span></p><p data-translated="true"><span class="original-text">The garbage collector does not guarantee any order of finalization. That is, if <code>a</code> contained a reference to <code>b</code> and both <code>a</code> and <code>b</code> are due for garbage collection, there is no guarantee that <code>b</code> would be finalized after <code>a</code>. If proper finalization of <code>a</code> depends on <code>b</code> being valid, it must be handled in other ways.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ガーベジコレクタは、ファイナライズの順序を保証しません。つまり、<code>a</code>が<code>b</code>への参照を含んでいて、<code>a</code>と<code>b</code>の両方がガーベジコレクションの対象である場合、<code>b</code>が<code>a</code>の後にファイナライズされる保証はありません。<code>a</code>の適切なファイナライズが<code>b</code>の有効性に依存する場合は、他の方法で処理する必要があります。</span></p><h2 id="Non-constant-Function-Specifications" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Non-constant-Function-Specifications">Non-constant Function Specifications</a><a id="Non-constant-Function-Specifications-1"></a><a class="docs-heading-anchor-permalink" href="#Non-constant-Function-Specifications" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Non-constant-Function-Specifications">非定数関数仕様</a><a id="Non-constant-Function-Specifications-1"></a><a class="docs-heading-anchor-permalink" href="#Non-constant-Function-Specifications" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">In some cases, the exact name or path of the needed library is not known in advance and must be computed at run time. To handle such cases, the library component specification can be a function call, e.g. <code>find_blas().dgemm</code>. The call expression will be executed when the <code>ccall</code> itself is executed. However, it is assumed that the library location does not change once it is determined, so the result of the call can be cached and reused. Therefore, the number of times the expression executes is unspecified, and returning different values for multiple calls results in unspecified behavior.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">必要なライブラリの正確な名前やパスが事前に知られていない場合があり、実行時に計算する必要があります。そのような場合を処理するために、ライブラリコンポーネント仕様は関数呼び出しであることができます。例えば、<code>find_blas().dgemm</code>のように。呼び出し式は、<code>ccall</code>自体が実行されるときに実行されます。ただし、ライブラリの場所は一度決定されると変更されないと仮定されるため、呼び出しの結果はキャッシュされて再利用できます。したがって、式が実行される回数は不明であり、複数回の呼び出しで異なる値を返すことは未定義の動作を引き起こします。</span></p><p data-translated="true"><span class="original-text">If even more flexibility is needed, it is possible to use computed values as function names by staging through <a href="../../base/base/index.html#eval"><code>eval</code></a> as follows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さらに柔軟性が必要な場合は、<a href="../../base/base/index.html#eval"><code>eval</code></a>を通じて計算された値を関数名として使用することが可能です。</span></p><pre><code class="language-julia hljs">@eval @ccall "lib".$(string("a", "b"))()::Cint</code></pre><p data-translated="true"><span class="original-text">This expression constructs a name using <code>string</code>, then substitutes this name into a new <code>@ccall</code> expression, which is then evaluated. Keep in mind that <code>eval</code> only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with <code>$</code>). For this reason, <code>eval</code> is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions. A similar example can be constructed for <a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この式は<code>string</code>を使用して名前を構築し、その後この名前を新しい<code>@ccall</code>式に置き換え、評価されます。<code>eval</code>はトップレベルでのみ動作するため、この式内ではローカル変数は利用できません（その値が<code>$</code>で置き換えられない限り）。このため、<code>eval</code>は通常、同様の関数が多数含まれるライブラリをラップする際など、トップレベルの定義を形成するためにのみ使用されます。<a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a>に対しても同様の例を構築できます。</span></p><p data-translated="true"><span class="original-text">However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently achieve a similar effect.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、これを行うと非常に遅くなり、メモリリークが発生するため、通常はこれを避け、代わりに読み続けるべきです。次のセクションでは、間接呼び出しを使用して効率的に同様の効果を達成する方法について説明します。</span></p><h2 id="Indirect-Calls" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Indirect-Calls">Indirect Calls</a><a id="Indirect-Calls-1"></a><a class="docs-heading-anchor-permalink" href="#Indirect-Calls" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Indirect-Calls">間接呼び出し</a><a id="Indirect-Calls-1"></a><a class="docs-heading-anchor-permalink" href="#Indirect-Calls" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The first argument to <code>@ccall</code> can also be an expression evaluated at run time. In this case, the expression must evaluate to a <code>Ptr</code>, which will be used as the address of the native function to call. This behavior occurs when the first <code>@ccall</code> argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@ccall</code>の最初の引数は、実行時に評価される式でも構いません。この場合、式は呼び出すネイティブ関数のアドレスとして使用される<code>Ptr</code>に評価される必要があります。この動作は、最初の<code>@ccall</code>引数がローカル変数、関数引数、または非定数のグローバル変数などの非定数への参照を含む場合に発生します。</span></p><p data-translated="true"><span class="original-text">For example, you might look up the function via <code>dlsym</code>, then cache it in a shared reference for that session. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、<code>dlsym</code>を介して関数を検索し、そのセッションのために共有参照にキャッシュすることができます。例えば：</span></p><pre><code class="language-julia hljs">macro dlsym(lib, func)
    z = Ref{Ptr{Cvoid}}(C_NULL)
    quote
        let zlocal = $z[]
            if zlocal == C_NULL
                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}
                $z[] = zlocal
            end
            zlocal
        end
    end
end

mylibvar = Libdl.dlopen("mylib")
@ccall $(@dlsym(mylibvar, "myfunc"))()::Cvoid</code></pre><h2 id="Closure-cfunctions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Closure-cfunctions">Closure cfunctions</a><a id="Closure-cfunctions-1"></a><a class="docs-heading-anchor-permalink" href="#Closure-cfunctions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Closure-cfunctions">クロージャ cfunctions</a><a id="Closure-cfunctions-1"></a><a class="docs-heading-anchor-permalink" href="#Closure-cfunctions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The first argument to <a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a> can be marked with a <code>$</code>, in which case the return value will instead be a <code>struct CFunction</code> which closes over the argument. You must ensure that this return object is kept alive until all uses of it are done. The contents and code at the cfunction pointer will be erased via a <a href="../../base/base/index.html#Base.finalizer"><code>finalizer</code></a> when this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don't provide a separate closure environment parameter.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a>の最初の引数は<code>$</code>でマークすることができ、その場合、戻り値は引数を閉じ込める<code>struct CFunction</code>になります。この戻りオブジェクトがすべての使用が完了するまで生存し続けることを確認する必要があります。この参照がドロップされると、<a href="../../base/base/index.html#Base.finalizer"><code>finalizer</code></a>を介してcfunctionポインタの内容とコードが消去されます。これは通常必要ありませんが、別のクロージャ環境パラメータを提供しない設計の悪いAPIを扱う際に便利です。</span></p><pre><code class="language-julia hljs">function qsort(a::Vector{T}, cmp) where T
    isbits(T) || throw(ArgumentError("this method can only qsort isbits arrays"))
    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})
    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}
    # (and protected against finalization) by the ccall
    @ccall qsort(a::Ptr{T}, length(a)::Csize_t, Base.elsize(a)::Csize_t, callback::Ptr{Cvoid})
    # We could instead use:
    #    GC.@preserve callback begin
    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))
    #    end
    # if we needed to use it outside of a `ccall`
    return a
end</code></pre><div class="admonition is-info" id="Note-63a8341d2542e976"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-63a8341d2542e976" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Closure <a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a> relies on LLVM trampolines, which are not available on all platforms (for example ARM and PowerPC).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">クロージャ<a href="../../base/c/index.html#Base.@cfunction"><code>@cfunction</code></a>は、すべてのプラットフォームで利用できるわけではないLLVMトランポリンに依存しています（例えばARMやPowerPCなど）。</span></p></div></div><h2 id="Closing-a-Library" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Closing-a-Library">Closing a Library</a><a id="Closing-a-Library-1"></a><a class="docs-heading-anchor-permalink" href="#Closing-a-Library" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Closing-a-Library">ライブラリの閉鎖</a><a id="Closing-a-Library-1"></a><a class="docs-heading-anchor-permalink" href="#Closing-a-Library" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">It is sometimes useful to close (unload) a library so that it can be reloaded. For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the <code>Libdl</code> functions to manage the library explicitly, such as:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ライブラリを閉じて（アンロード）再ロードできるようにすることは、時には便利です。たとえば、Juliaで使用するCコードを開発する際には、Cコードをコンパイルし、JuliaからCコードを呼び出し、その後ライブラリを閉じて編集を行い、再コンパイルして新しい変更をロードする必要があるかもしれません。Juliaを再起動するか、<code>Libdl</code>関数を使用してライブラリを明示的に管理することができます。たとえば、</span></p><pre><code class="language-julia hljs">lib = Libdl.dlopen("./my_lib.so") # Open the library explicitly.
sym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.
@ccall $sym(...) # Use the pointer `sym` instead of the library.symbol tuple.
Libdl.dlclose(lib) # Close the library explicitly.</code></pre><p data-translated="true"><span class="original-text">Note that when using <code>@ccall</code> with the input (e.g., <code>@ccall "./my_lib.so".my_fcn(...)::Cvoid</code>), the library is opened implicitly and it may not be explicitly closed.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">入力を使用して<code>@ccall</code>を使用する場合（例：<code>@ccall "./my_lib.so".my_fcn(...)::Cvoid</code>）、ライブラリは暗黙的に開かれ、明示的に閉じられない場合があります。</span></p><h2 id="Variadic-function-calls" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Variadic-function-calls">Variadic function calls</a><a id="Variadic-function-calls-1"></a><a class="docs-heading-anchor-permalink" href="#Variadic-function-calls" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Variadic-function-calls">可変引数関数呼び出し</a><a id="Variadic-function-calls-1"></a><a class="docs-heading-anchor-permalink" href="#Variadic-function-calls" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">To call variadic C functions a <code>semicolon</code> can be used in the argument list to separate required arguments from variadic arguments. An example with the <code>printf</code> function is given below:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">可変引数のC関数を呼び出すには、引数リスト内で<code>semicolon</code>を使用して必須引数と可変引数を区切ることができます。以下に<code>printf</code>関数の例を示します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @ccall printf("%s = %d\n"::Cstring ; "foo"::Cstring, foo::Cint)::Cint
foo = 3
8</code></pre><h2 id="ccall-interface" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#ccall-interface"><code>ccall</code> interface</a><a id="ccall-interface-1"></a><a class="docs-heading-anchor-permalink" href="#ccall-interface" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#ccall-interface"><code>ccall</code>インターフェース</a><a id="ccall-interface-1"></a><a class="docs-heading-anchor-permalink" href="#ccall-interface" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">There is another alternative interface to <code>@ccall</code>. This interface is slightly less convenient but it does allow one to specify a <a href="#calling-convention">calling convention</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@ccall</code>には別の代替インターフェースがあります。このインターフェースは少し便利さに欠けますが、<a href="#calling-convention">呼び出し規約</a>を指定することができます。</span></p><p data-translated="true"><span class="original-text">The arguments to <a href="../../base/c/index.html#ccall"><code>ccall</code></a> are:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/c/index.html#ccall"><code>ccall</code></a>への引数は：</span></p><ol><li><p data-translated="true"><span class="original-text">A <code>(:function, "library")</code> pair (most common),</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>(:function, "library")</code>ペア（最も一般的）、</span></p><p>OR</p><p data-translated="true"><span class="original-text">a <code>:function</code> name symbol or <code>"function"</code> name string (for symbols in the current process or libc),</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>:function</code>名のシンボルまたは<code>"function"</code>名の文字列（現在のプロセスまたはlibc内のシンボル用）、</span></p><p>OR</p><p data-translated="true"><span class="original-text">a function pointer (for example, from <code>dlsym</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数ポインタ（たとえば、<code>dlsym</code>から）。</span></p></li><li><p data-translated="true"><span class="original-text">The function's return type</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数の戻り値の型</span></p></li><li><p data-translated="true"><span class="original-text">A tuple of input types, corresponding to the function signature. One common mistake is forgetting that a 1-tuple of argument types must be written with a trailing comma.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数シグネチャに対応する入力型のタプル。一般的な間違いは、引数型の1タプルは末尾にカンマを付けて書かなければならないことを忘れることです。</span></p></li><li><p data-translated="true"><span class="original-text">The actual argument values to be passed to the function, if any; each is a separate parameter.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数に渡される実際の引数値（ある場合）；それぞれが別々のパラメータです。</span></p></li></ol><div class="admonition is-info" id="Note-4be766021eedd6fd"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4be766021eedd6fd" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">The <code>(:function, "library")</code> pair, return type, and input types must be literal constants (i.e., they can't be variables, but see <a href="#Non-constant-Function-Specifications">Non-constant Function Specifications</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>(:function, "library")</code> ペア、戻り値の型、および入力型はリテラル定数でなければなりません（つまり、変数ではなく、ただし <a href="#Non-constant-Function-Specifications">非定数関数仕様</a> を参照してください）。</span></p><p data-translated="true"><span class="original-text">The remaining parameters are evaluated at compile-time, when the containing method is defined.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">残りのパラメータは、含まれるメソッドが定義されるときにコンパイル時に評価されます。</span></p></div></div><p data-translated="true"><span class="original-text">A table of translations between the macro and function interfaces is given below.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マクロと関数インターフェース間の翻訳の表は以下に示されています。</span></p><table><tbody><tr><th style="text-align: right" data-translated="true"><span class="original-text"><code>@ccall</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@ccall</code></span></th><th style="text-align: right" data-translated="true"><span class="original-text"><code>ccall</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ccall</code></span></th></tr><tr><td style="text-align: right" data-translated="true"><span class="original-text"><code>@ccall clock()::Int32</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@ccall clock()::Int32</code></span></td><td style="text-align: right" data-translated="true"><span class="original-text"><code>ccall(:clock, Int32, ())</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ccall(:clock, Int32, ())</code></span></td></tr><tr><td style="text-align: right" data-translated="true"><span class="original-text"><code>@ccall f(a::Cint)::Cint</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@ccall f(a::Cint)::Cint</code></span></td><td style="text-align: right" data-translated="true"><span class="original-text"><code>ccall(:a, Cint, (Cint,), a)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ccall(:a, Cint, (Cint,), a)</code></span></td></tr><tr><td style="text-align: right" data-translated="true"><span class="original-text"><code>@ccall "mylib".f(a::Cint, b::Cdouble)::Cvoid</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@ccall "mylib".f(a::Cint, b::Cdouble)::Cvoid</code></span></td><td style="text-align: right" data-translated="true"><span class="original-text"><code>ccall((:f, "mylib"), Cvoid, (Cint, Cdouble), a, b)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ccall((:f, "mylib"), Cvoid, (Cint, Cdouble), a, b)</code></span></td></tr><tr><td style="text-align: right" data-translated="true"><span class="original-text"><code>@ccall $fptr.f()::Cvoid</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@ccall $fptr.f()::Cvoid</code></span></td><td style="text-align: right" data-translated="true"><span class="original-text"><code>ccall(fptr, f, Cvoid, ())</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ccall(fptr, f, Cvoid, ())</code></span></td></tr><tr><td style="text-align: right" data-translated="true"><span class="original-text"><code>@ccall printf("%s = %d\n"::Cstring ; "foo"::Cstring, foo::Cint)::Cint</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@ccall printf("%s = %d\n"::Cstring ; "foo"::Cstring, foo::Cint)::Cint</code></span></td><td style="text-align: right" data-translated="true"><span class="original-text"><code>&lt;unavailable&gt;</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>&lt;unavailable&gt;</code></span></td></tr><tr><td style="text-align: right" data-translated="true"><span class="original-text"><code>@ccall printf("%s = %s\n"::Cstring ; "2 + 2"::Cstring, "5"::Cstring)::Cint</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@ccall printf("%s = %s\n"::Cstring ; "2 + 2"::Cstring, "5"::Cstring)::Cint</code></span></td><td style="text-align: right" data-translated="true"><span class="original-text"><code>ccall(:printf, Cint, (Cstring, Cstring...), "%s = %s\n", "2 + 2", "5")</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ccall(:printf, Cint, (Cstring, Cstring...), "%s = %s\n", "2 + 2", "5")</code></span></td></tr><tr><td style="text-align: right" data-translated="true"><span class="original-text"><code>&lt;unavailable&gt;</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>&lt;unavailable&gt;</code></span></td><td style="text-align: right" data-translated="true"><span class="original-text"><code>ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))</code></span></td></tr></tbody></table><h2 id="calling-convention" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#calling-convention">Calling Convention</a><a id="calling-convention-1"></a><a class="docs-heading-anchor-permalink" href="#calling-convention" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#calling-convention">呼び出し規約</a><a id="calling-convention-1"></a><a class="docs-heading-anchor-permalink" href="#calling-convention" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The second argument to <code>ccall</code> (immediately preceding return type) can optionally be a calling convention specifier (the <code>@ccall</code> macro currently does not support giving a calling convention). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: <code>stdcall</code>, <code>cdecl</code>, <code>fastcall</code>, and <code>thiscall</code> (no-op on 64-bit Windows). For example (from <code>base/libc.jl</code>) we see the same <code>gethostname</code><code>ccall</code> as above, but with the correct signature for Windows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>ccall</code>への2番目の引数（戻り値の型の直前）は、オプションで呼び出し規約の指定子となることができます（現在のところ<code>@ccall</code>マクロは呼び出し規約を指定することをサポートしていません）。指定子がない場合、プラットフォームのデフォルトのC呼び出し規約が使用されます。他にサポートされている規約は、<code>stdcall</code>、<code>cdecl</code>、<code>fastcall</code>、および<code>thiscall</code>（64ビットWindowsでは無操作）です。例えば（<code>base/libc.jl</code>から）、上記と同じ<code>gethostname</code><code>ccall</code>が見られますが、Windows用の正しいシグネチャが付いています：</span></p><pre><code class="language-julia hljs">hn = Vector{UInt8}(undef, 256)
err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))</code></pre><p data-translated="true"><span class="original-text">For more information, please see the <a href="https://llvm.org/docs/LangRef.html#calling-conventions#calling-conventions">LLVM Language Reference</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">詳細については、<a href="https://llvm.org/docs/LangRef.html#calling-conventions#calling-conventions">LLVM言語リファレンス</a>を参照してください。</span></p><p data-translated="true"><span class="original-text">There is one additional special calling convention <a href="../../base/c/index.html#Core.Intrinsics.llvmcall"><code>llvmcall</code></a>, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for <a href="https://llvm.org/docs/NVPTXUsage.html">CUDA</a>, we need to be able to read the thread index:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">追加の特別な呼び出し規約として<a href="../../base/c/index.html#Core.Intrinsics.llvmcall"><code>llvmcall</code></a>があります。これはLLVMの内部関数への呼び出しを直接挿入することを可能にします。これは、GPGPUのような異常なプラットフォームをターゲットにする際に特に便利です。例えば、<a href="https://llvm.org/docs/NVPTXUsage.html">CUDA</a>の場合、スレッドインデックスを読み取る必要があります：</span></p><pre><code class="language-julia hljs">ccall("llvm.nvvm.read.ptx.sreg.tid.x", llvmcall, Int32, ())</code></pre><p data-translated="true"><span class="original-text">As with any <code>ccall</code>, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by <code>Core.Intrinsics</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">任意の<code>ccall</code>と同様に、引数のシグネチャを正確に取得することが重要です。また、<code>Core.Intrinsics</code>によって公開されている同等のJulia関数とは異なり、内部関数が現在のターゲットで意味を持ち、機能することを保証する互換性レイヤーは存在しないことに注意してください。</span></p><h2 id="Accessing-Global-Variables" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Accessing-Global-Variables">Accessing Global Variables</a><a id="Accessing-Global-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-Global-Variables" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Accessing-Global-Variables">グローバル変数へのアクセス</a><a id="Accessing-Global-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-Global-Variables" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Global variables exported by native libraries can be accessed by name using the <a href="../../base/c/index.html#Core.Intrinsics.cglobal"><code>cglobal</code></a> function. The arguments to <a href="../../base/c/index.html#Core.Intrinsics.cglobal"><code>cglobal</code></a> are a symbol specification identical to that used by <a href="../../base/c/index.html#ccall"><code>ccall</code></a>, and a type describing the value stored in the variable:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ネイティブライブラリによってエクスポートされたグローバル変数は、<a href="../../base/c/index.html#Core.Intrinsics.cglobal"><code>cglobal</code></a>関数を使用して名前でアクセスできます。<a href="../../base/c/index.html#Core.Intrinsics.cglobal"><code>cglobal</code></a>への引数は、<a href="../../base/c/index.html#ccall"><code>ccall</code></a>で使用されるのと同じシンボル仕様と、変数に格納されている値を説明する型です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; cglobal((:errno, :libc), Int32)
Ptr{Int32} @0x00007f418d0816b8</code></pre><p data-translated="true"><span class="original-text">The result is a pointer giving the address of the value. The value can be manipulated through this pointer using <a href="../../base/c/index.html#Base.unsafe_load"><code>unsafe_load</code></a> and <a href="../../base/c/index.html#Base.unsafe_store!"><code>unsafe_store!</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">結果は、値のアドレスを示すポインタです。このポインタを使用して、<a href="../../base/c/index.html#Base.unsafe_load"><code>unsafe_load</code></a>および<a href="../../base/c/index.html#Base.unsafe_store!"><code>unsafe_store!</code></a>を介して値を操作できます。</span></p><div class="admonition is-info" id="Note-b6ccc283b0b9c6a4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b6ccc283b0b9c6a4" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">This <code>errno</code> symbol may not be found in a library named "libc", as this is an implementation detail of your system compiler. Typically standard library symbols should be accessed just by name, allowing the compiler to fill in the correct one. Also, however, the <code>errno</code> symbol shown in this example is special in most compilers, and so the value seen here is probably not what you expect or want. Compiling the equivalent code in C on any multi-threaded-capable system would typically actually call a different function (via macro preprocessor overloading), and may give a different result than the legacy value printed here.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この <code>errno</code> シンボルは、"libc" という名前のライブラリには見つからないかもしれません。これは、システムコンパイラの実装の詳細です。通常、標準ライブラリのシンボルは名前だけでアクセスされ、コンパイラが正しいものを埋め込むことができます。しかし、この例に示されている <code>errno</code> シンボルはほとんどのコンパイラで特別なものであり、ここで見られる値はおそらくあなたが期待するものや望むものではありません。任意のマルチスレッド対応システムで同等のコードをCでコンパイルすると、通常は異なる関数が呼び出され（マクロプリプロセッサのオーバーロードを介して）、ここに表示されるレガシー値とは異なる結果が得られるかもしれません。</span></p></div></div><h2 id="Accessing-Data-through-a-Pointer" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Accessing-Data-through-a-Pointer">Accessing Data through a Pointer</a><a id="Accessing-Data-through-a-Pointer-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-Data-through-a-Pointer" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Accessing-Data-through-a-Pointer">ポインタを介してデータにアクセスする</a><a id="Accessing-Data-through-a-Pointer-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-Data-through-a-Pointer" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The following methods are described as "unsafe" because a bad pointer or type declaration can cause Julia to terminate abruptly.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">以下のメソッドは「安全でない」として説明されています。なぜなら、不正なポインタや型宣言があると、Juliaが突然終了する可能性があるからです。</span></p><p data-translated="true"><span class="original-text">Given a <code>Ptr{T}</code>, the contents of type <code>T</code> can generally be copied from the referenced memory into a Julia object using <code>unsafe_load(ptr, [index])</code>. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of <a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a> and <a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a> (e.g. <code>[]</code> access syntax).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Ptr{T}</code> が与えられた場合、型 <code>T</code> の内容は、<code>unsafe_load(ptr, [index])</code> を使用して参照されたメモリからJuliaオブジェクトにコピーできます。インデックス引数はオプションで（デフォルトは1）、Juliaの1ベースのインデックス付けの規約に従います。この関数は、<a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a> および <a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a>（例：<code>[]</code> アクセス構文）の動作に意図的に似ています。</span></p><p data-translated="true"><span class="original-text">The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">戻り値は、参照されたメモリの内容のコピーを含むように初期化された新しいオブジェクトになります。参照されたメモリは安全に解放または開放できます。</span></p><p data-translated="true"><span class="original-text">If <code>T</code> is <code>Any</code>, then the memory is assumed to contain a reference to a Julia object (a <code>jl_value_t*</code>), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector. If the <code>Ptr</code> itself is actually a <code>jl_value_t*</code>, it can be converted back to a Julia object reference by <a href="../../base/c/index.html#Base.unsafe_pointer_to_objref"><code>unsafe_pointer_to_objref(ptr)</code></a>. (Julia values <code>v</code> can be converted to <code>jl_value_t*</code> pointers, as <code>Ptr{Cvoid}</code>, by calling <a href="../../base/c/index.html#Base.pointer_from_objref"><code>pointer_from_objref(v)</code></a>.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もし <code>T</code> が <code>Any</code> であれば、メモリはJuliaオブジェクト（<code>jl_value_t*</code>）への参照を含むと見なされ、結果はこのオブジェクトへの参照となり、オブジェクトはコピーされません。この場合、オブジェクトが常にガーベジコレクタに見えることを確認する必要があります（ポインタはカウントされませんが、新しい参照はカウントされます）ので、メモリが早期に解放されないようにしてください。オブジェクトが元々Juliaによって割り当てられていない場合、新しいオブジェクトはJuliaのガーベジコレクタによって決して最終化されません。もし <code>Ptr</code> 自体が実際に <code>jl_value_t*</code> であれば、<a href="../../base/c/index.html#Base.unsafe_pointer_to_objref"><code>unsafe_pointer_to_objref(ptr)</code></a> によってJuliaオブジェクト参照に戻すことができます。（Juliaの値 <code>v</code> は、<code>Ptr{Cvoid}</code> として <code>jl_value_t*</code> ポインタに変換できます。これは <a href="../../base/c/index.html#Base.pointer_from_objref"><code>pointer_from_objref(v)</code></a> を呼び出すことによって行われます。）</span></p><p data-translated="true"><span class="original-text">The reverse operation (writing data to a <code>Ptr{T}</code>), can be performed using <a href="../../base/c/index.html#Base.unsafe_store!"><code>unsafe_store!(ptr, value, [index])</code></a>. Currently, this is only supported for primitive types or other pointer-free (<code>isbits</code>) immutable struct types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">逆の操作（<code>Ptr{T}</code> にデータを書き込むこと）は、<a href="../../base/c/index.html#Base.unsafe_store!"><code>unsafe_store!(ptr, value, [index])</code></a> を使用して実行できます。現在、これはプリミティブ型または他のポインタフリー（<code>isbits</code>）不変構造体型にのみサポートされています。</span></p><p data-translated="true"><span class="original-text">Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">エラーをスローする操作は、現在おそらく未実装であり、バグとして報告されるべきです。そうすれば解決できます。</span></p><p data-translated="true"><span class="original-text">If the pointer of interest is a plain-data array (primitive type or immutable struct), the function <a href="../../base/c/index.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T}}, Type{Array{T, N}}}, Ptr{T}, NTuple{N, Int64}}} where {T, N}"><code>unsafe_wrap(Array, ptr,dims, own = false)</code></a> may be more useful. The final parameter should be true if Julia should "take ownership" of the underlying buffer and call <code>free(ptr)</code> when the returned <code>Array</code> object is finalized. If the <code>own</code> parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">対象のポインタがプレーンデータ配列（プリミティブ型または不変構造体）の場合、関数 <a href="../../base/c/index.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T}}, Type{Array{T, N}}}, Ptr{T}, NTuple{N, Int64}}} where {T, N}"><code>unsafe_wrap(Array, ptr,dims, own = false)</code></a> の方が便利かもしれません。最終パラメータは、Juliaが基盤となるバッファの「所有権を取得」し、返された <code>Array</code> オブジェクトが最終化されるときに <code>free(ptr)</code> を呼び出すべきであればtrueにする必要があります。<code>own</code> パラメータが省略されるかfalseの場合、呼び出し元はすべてのアクセスが完了するまでバッファが存在し続けることを保証しなければなりません。</span></p><p data-translated="true"><span class="original-text">Arithmetic on the <code>Ptr</code> type in Julia (e.g. using <code>+</code>) does not behave the same as C's pointer arithmetic. Adding an integer to a <code>Ptr</code> in Julia always moves the pointer by some number of <em>bytes</em>, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの <code>Ptr</code> 型での算術（例：<code>+</code> を使用）は、Cのポインタ算術とは同じようには動作しません。Juliaの <code>Ptr</code> に整数を加えると、常にポインタがいくつかの <em>バイト</em> だけ移動します。これにより、ポインタ算術から得られるアドレス値はポインタの要素型に依存しません。</span></p><h2 id="Thread-safety" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Thread-safety">Thread-safety</a><a id="Thread-safety-1"></a><a class="docs-heading-anchor-permalink" href="#Thread-safety" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Thread-safety">スレッドセーフ</a><a id="Thread-safety-1"></a><a class="docs-heading-anchor-permalink" href="#Thread-safety" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Some C libraries execute their callbacks from a different thread, and since Julia isn't thread-safe you'll need to take some extra precautions. In particular, you'll need to set up a two-layered system: the C callback should only <em>schedule</em> (via Julia's event loop) the execution of your "real" callback. To do this, create an <a href="../../base/base/index.html#Base.AsyncCondition"><code>AsyncCondition</code></a> object and <a href="../../base/parallel/index.html#Base.wait"><code>wait</code></a> on it:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一部のCライブラリは異なるスレッドからコールバックを実行しますが、Juliaはスレッドセーフではないため、いくつかの追加の予防措置を講じる必要があります。特に、2層のシステムを設定する必要があります：Cコールバックは、あなたの「実際の」コールバックの実行を<em>スケジュール</em>するだけでなければなりません（Juliaのイベントループを介して）。これを行うには、<a href="../../base/base/index.html#Base.AsyncCondition"><code>AsyncCondition</code></a>オブジェクトを作成し、それに対して<a href="../../base/parallel/index.html#Base.wait"><code>wait</code></a>を呼び出します：</span></p><pre><code class="language-julia hljs">cond = Base.AsyncCondition()
wait(cond)</code></pre><p data-translated="true"><span class="original-text">The callback you pass to C should only execute a <a href="../../base/c/index.html#ccall"><code>ccall</code></a> to <code>:uv_async_send</code>, passing <code>cond.handle</code> as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cに渡すコールバックは、<a href="../../base/c/index.html#ccall"><code>ccall</code></a>を<code>:uv_async_send</code>に対して実行し、<code>cond.handle</code>を引数として渡す必要があります。Juliaランタイムとの割り当てやその他の相互作用を避けるように注意してください。</span></p><p data-translated="true"><span class="original-text">Note that events may be coalesced, so multiple calls to <code>uv_async_send</code> may result in a single wakeup notification to the condition.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">イベントは統合される可能性があるため、<code>uv_async_send</code>への複数の呼び出しが条件への単一のウェイクアップ通知を引き起こす可能性があることに注意してください。</span></p><h2 id="More-About-Callbacks" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#More-About-Callbacks">More About Callbacks</a><a id="More-About-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#More-About-Callbacks" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#More-About-Callbacks">コールバックについての詳細</a><a id="More-About-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#More-About-Callbacks" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">For more details on how to pass callbacks to C libraries, see this <a href="https://julialang.org/blog/2013/05/callback">blog post</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Cライブラリにコールバックを渡す方法の詳細については、この<a href="https://julialang.org/blog/2013/05/callback">ブログ記事</a>を参照してください。</span></p><h2 id="C" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#C">C++</a><a id="C-1"></a><a class="docs-heading-anchor-permalink" href="#C" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#C">C++</a><a id="C-1"></a><a class="docs-heading-anchor-permalink" href="#C" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">For tools to create C++ bindings, see the <a href="https://github.com/JuliaInterop/CxxWrap.jl">CxxWrap</a> package.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">C++バインディングを作成するためのツールについては、<a href="https://github.com/JuliaInterop/CxxWrap.jl">CxxWrap</a>パッケージを参照してください。</span></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1" data-translated="true"><span class="original-text"><a class="tag is-link" href="#citeref-1">1</a>Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. The point above is that the cost of actually doing foreign function call is about the same as doing a call in either native language.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tag is-link" href="#citeref-1">1</a>CおよびJuliaの両方の非ライブラリ関数呼び出しはインライン化できるため、共有ライブラリ関数への呼び出しよりもオーバーヘッドが少ない場合があります。上記のポイントは、実際に外部関数呼び出しを行うコストは、どちらのネイティブ言語での呼び出しとほぼ同じであるということです。</span></li><li class="footnote" id="footnote-2" data-translated="true"><span class="original-text"><a class="tag is-link" href="#citeref-2">2</a>The <a href="https://github.com/ihnorton/Clang.jl">Clang package</a> can be used to auto-generate Julia code from a C header file.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tag is-link" href="#citeref-2">2</a> <a href="https://github.com/ihnorton/Clang.jl">Clangパッケージ</a>は、CヘッダーファイルからJuliaコードを自動生成するために使用できます。</span></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../running-external-programs/index.html">« Running External Programs</a><a class="docs-footer-nextpage" href="../handling-operating-system-variation/index.html">Handling Operating System Variation »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>