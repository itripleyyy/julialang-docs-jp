<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Interfaces · The Julia Language</title><meta name="title" content="Interfaces · The Julia Language"><meta property="og:title" content="Interfaces · The Julia Language"><meta property="twitter:title" content="Interfaces · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/interfaces/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/interfaces/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bj0h2"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li class="is-active"><a class="tocitem" href="">Interfaces</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-interface-iteration"><span>Iteration</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-interface-iteration"><span>イテレーション</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Indexing"><span>Indexing</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Indexing"><span>インデクシング</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-interface-array"><span>Abstract Arrays</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-interface-array"><span>抽象配列</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-interface-strided-arrays"><span>Strided Arrays</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-interface-strided-arrays"><span>ストライド配列</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-interfaces-broadcasting"><span>Customizing broadcasting</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-interfaces-broadcasting"><span>ブロードキャスティングのカスタマイズ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-instance-properties"><span>Instance Properties</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-instance-properties"><span>インスタンスプロパティ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-rounding-interface"><span>Rounding</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-rounding-interface"><span>丸め</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">インターフェース</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">インターフェース</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/interfaces.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Interfaces" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Interfaces">インターフェース</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">A lot of the power and extensibility in Julia comes from a collection of informal interfaces.  By extending a few specific methods to work for a custom type, objects of that type not only receive those functionalities, but they are also able to be used in other methods that are written to generically build upon those behaviors.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの多くの力と拡張性は、一連の非公式インターフェースから来ています。特定のメソッドをカスタムタイプに対して拡張することで、そのタイプのオブジェクトはこれらの機能を受け取るだけでなく、それらの動作に基づいて一般的に構築された他のメソッドでも使用できるようになります。</span></p><h2 id="man-interface-iteration" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-interface-iteration">Iteration</a><a id="man-interface-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#man-interface-iteration" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-interface-iteration">反復</a><a id="man-interface-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#man-interface-iteration" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">There are two methods that are always required:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">常に必要なメソッドが2つあります：</span></p><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Required method</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">必要なメソッド</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Brief description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単な説明</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/collections/index.html#Base.iterate"><code>iterate(iter)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/collections/index.html#Base.iterate"><code>iterate(iter)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Returns either a tuple of the first item and initial state or <a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a> if empty</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初のアイテムと初期状態のタプルを返すか、空の場合は<a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a>を返します</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>iterate(iter, state)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>iterate(iter, state)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Returns either a tuple of the next item and next state or <code>nothing</code> if no items remain</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のアイテムと次の状態のタプルを返すか、アイテムが残っていない場合は<code>nothing</code>を返します</span></td></tr></tbody></table><p data-translated="true"><span class="original-text">There are several more methods that should be defined in some circumstances. Please note that you should always define at least one of <code>Base.IteratorSize(IterType)</code> and <code>length(iter)</code> because the default definition of <code>Base.IteratorSize(IterType)</code> is <code>Base.HasLength()</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">いくつかの状況では、さらにいくつかのメソッドを定義する必要があります。<code>Base.IteratorSize(IterType)</code>と<code>length(iter)</code>の少なくとも1つを常に定義する必要があることに注意してください。なぜなら、<code>Base.IteratorSize(IterType)</code>のデフォルト定義は<code>Base.HasLength()</code>だからです。</span></p><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Method</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メソッド</span></th><th style="text-align: left" data-translated="true"><span class="original-text">When should this method be defined?</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このメソッドはいつ定義されるべきですか？</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Default definition</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルト定義</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Brief description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単な説明</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/collections/index.html#Base.IteratorSize"><code>Base.IteratorSize(IterType)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/collections/index.html#Base.IteratorSize"><code>Base.IteratorSize(IterType)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">If default is not appropriate</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトが適切でない場合</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.HasLength()</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.HasLength()</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">One of <code>Base.HasLength()</code>, <code>Base.HasShape{N}()</code>, <code>Base.IsInfinite()</code>, or <code>Base.SizeUnknown()</code> as appropriate</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.HasLength()</code>、<code>Base.HasShape{N}()</code>、<code>Base.IsInfinite()</code>、または<code>Base.SizeUnknown()</code>のいずれかが適切です</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.length-Tuple{AbstractArray}"><code>length(iter)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.length-Tuple{AbstractArray}"><code>length(iter)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">If <code>Base.IteratorSize()</code> returns <code>Base.HasLength()</code> or <code>Base.HasShape{N}()</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.IteratorSize()</code>が<code>Base.HasLength()</code>または<code>Base.HasShape{N}()</code>を返す場合</span></td><td style="text-align: left" data-translated="true"><span class="original-text">(<em>undefined</em>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(<em>未定義</em>)</span></td><td style="text-align: left" data-translated="true"><span class="original-text">The number of items, if known</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">アイテムの数（既知の場合）</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.size"><code>size(iter, [dim])</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.size"><code>size(iter, [dim])</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">If <code>Base.IteratorSize()</code> returns <code>Base.HasShape{N}()</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.IteratorSize()</code> が <code>Base.HasShape{N}()</code> を返す場合</span></td><td style="text-align: left" data-translated="true"><span class="original-text">(<em>undefined</em>)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(<em>未定義</em>)</span></td><td style="text-align: left" data-translated="true"><span class="original-text">The number of items in each dimension, if known</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各次元のアイテムの数（既知の場合）</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/collections/index.html#Base.IteratorEltype"><code>Base.IteratorEltype(IterType)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/collections/index.html#Base.IteratorEltype"><code>Base.IteratorEltype(IterType)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">If default is not appropriate</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトが適切でない場合</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.HasEltype()</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.HasEltype()</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Either <code>Base.EltypeUnknown()</code> or <code>Base.HasEltype()</code> as appropriate</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">適切に <code>Base.EltypeUnknown()</code> または <code>Base.HasEltype()</code> のいずれか</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/collections/index.html#Base.eltype"><code>eltype(IterType)</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/collections/index.html#Base.eltype"><code>eltype(IterType)</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">If default is not appropriate</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトが適切でない場合</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Any</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Any</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">The type of the first entry of the tuple returned by <code>iterate()</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>iterate()</code>によって返されるタプルの最初のエントリの型</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/collections/index.html#Base.isdone"><code>Base.isdone(iter, [state])</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/collections/index.html#Base.isdone"><code>Base.isdone(iter, [state])</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><strong>Must</strong> be defined if iterator is stateful</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>必ず</strong>状態を持つイテレータの場合は定義されている必要があります</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>missing</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>missing</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Fast-path hint for iterator completion. If not defined for a stateful iterator then functions that check for done-ness, like <code>isempty()</code> and <code>zip()</code>, may mutate the iterator and cause buggy behaviour!</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">イテレータの完了に関するファストパスヒント。状態を持つイテレータに対して定義されていない場合、<code>isempty()</code>や<code>zip()</code>のような完了状態をチェックする関数がイテレータを変更し、バグの原因となる可能性があります！</span></td></tr></tbody></table><p data-translated="true"><span class="original-text">Sequential iteration is implemented by the <a href="../../base/collections/index.html#Base.iterate"><code>iterate</code></a> function. Instead of mutating objects as they are iterated over, Julia iterators may keep track of the iteration state externally from the object. The return value from iterate is always either a tuple of a value and a state, or <code>nothing</code> if no elements remain. The state object will be passed back to the iterate function on the next iteration and is generally considered an implementation detail private to the iterable object.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">逐次イテレーションは<a href="../../base/collections/index.html#Base.iterate"><code>iterate</code></a>関数によって実装されています。オブジェクトをイテレートする際に変更するのではなく、Juliaのイテレータはオブジェクトとは別にイテレーションの状態を追跡することができます。iterateからの返り値は常に値と状態のタプル、または要素が残っていない場合は<code>nothing</code>です。状態オブジェクトは次のイテレーションでiterate関数に渡され、一般的にはイテラブルオブジェクトに対する実装の詳細と見なされます。</span></p><p data-translated="true"><span class="original-text">Any object that defines this function is iterable and can be used in the <a href="../../base/collections/index.html#lib-collections-iteration">many functions that rely upon iteration</a>. It can also be used directly in a <a href="../../base/base/index.html#for"><code>for</code></a> loop since the syntax:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この関数を定義する任意のオブジェクトはイテラブルであり、<a href="../../base/collections/index.html#lib-collections-iteration">イテレーションに依存する多くの関数</a>で使用できます。また、<a href="../../base/base/index.html#for"><code>for</code></a>ループ内で直接使用することもでき、構文は次のように翻訳されます：</span></p><pre><code class="language-julia hljs">for item in iter   # or  "for item = iter"
    # body
end</code></pre><p data-translated="true"><span class="original-text">is translated into:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">は次のように翻訳されます：</span></p><pre><code class="language-julia hljs">next = iterate(iter)
while next !== nothing
    (item, state) = next
    # body
    next = iterate(iter, state)
end</code></pre><p data-translated="true"><span class="original-text">A simple example is an iterable sequence of square numbers with a defined length:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">単純な例は、定義された長さの平方数の反復可能なシーケンスです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct Squares
           count::Int
       end

julia&gt; Base.iterate(S::Squares, state=1) = state &gt; S.count ? nothing : (state*state, state+1)</code></pre><p data-translated="true"><span class="original-text">With only <a href="../../base/collections/index.html#Base.iterate"><code>iterate</code></a> definition, the <code>Squares</code> type is already pretty powerful. We can iterate over all the elements:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">わずかに<a href="../../base/collections/index.html#Base.iterate"><code>iterate</code></a>の定義だけで、<code>Squares</code>型はすでに非常に強力です。すべての要素を反復処理できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; for item in Squares(7)
           println(item)
       end
1
4
9
16
25
36
49</code></pre><p data-translated="true"><span class="original-text">We can use many of the builtin methods that work with iterables, like <a href="../../base/collections/index.html#Base.in"><code>in</code></a> or <a href="../../base/collections/index.html#Base.sum"><code>sum</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">私たちは、<a href="../../base/collections/index.html#Base.in"><code>in</code></a>や<a href="../../base/collections/index.html#Base.sum"><code>sum</code></a>のような、反復可能なものと一緒に動作する多くの組み込みメソッドを使用できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; 25 in Squares(10)
true

julia&gt; sum(Squares(100))
338350</code></pre><p data-translated="true"><span class="original-text">There are a few more methods we can extend to give Julia more information about this iterable collection. We know that the elements in a <code>Squares</code> sequence will always be <code>Int</code>. By extending the <a href="../../base/collections/index.html#Base.eltype"><code>eltype</code></a> method, we can give that information to Julia and help it make more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend <a href="../../base/collections/index.html#Base.length"><code>length</code></a>, too:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この反復可能なコレクションに関してJuliaにより多くの情報を提供するために拡張できるメソッドがいくつかあります。<code>Squares</code>シーケンスの要素は常に<code>Int</code>であることがわかっています。<a href="../../base/collections/index.html#Base.eltype"><code>eltype</code></a>メソッドを拡張することで、その情報をJuliaに提供し、より複雑なメソッドでより専門的なコードを生成するのを助けることができます。また、シーケンス内の要素数もわかっているので、<a href="../../base/collections/index.html#Base.length"><code>length</code></a>も拡張できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type

julia&gt; Base.length(S::Squares) = S.count</code></pre><p data-translated="true"><span class="original-text">Now, when we ask Julia to <a href="../../base/collections/index.html#Base.collect-Tuple{Any}"><code>collect</code></a> all the elements into an array it can preallocate a <code>Vector{Int}</code> of the right size instead of naively <a href="../../base/collections/index.html#Base.push!"><code>push!</code></a>ing each element into a <code>Vector{Any}</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">今、Juliaに<a href="../../base/collections/index.html#Base.collect-Tuple{Any}"><code>collect</code></a>を使ってすべての要素を配列に集めるように頼むと、各要素を<code>Vector{Any}</code>にナイーブに<code>push!</code>する代わりに、適切なサイズの<code>Vector{Int}</code>を事前に割り当てることができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; collect(Squares(4))
4-element Vector{Int64}:
  1
  4
  9
 16</code></pre><p data-translated="true"><span class="original-text">While we can rely upon generic implementations, we can also extend specific methods where we know there is a simpler algorithm. For example, there's a formula to compute the sum of squares, so we can override the generic iterative version with a more performant solution:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般的な実装に依存することもできますが、特定のメソッドを拡張して、より簡単なアルゴリズムがあることがわかっている場合もあります。たとえば、平方和を計算するための公式があるので、一般的な反復バージョンをよりパフォーマンスの良いソリューションでオーバーライドできます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)

julia&gt; sum(Squares(1803))
1955361914</code></pre><p data-translated="true"><span class="original-text">This is a very common pattern throughout Julia Base: a small set of required methods define an informal interface that enable many fancier behaviors. In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be used in their specific case.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これはJulia Base全体で非常に一般的なパターンです：必要なメソッドの小さなセットが、より洗練された動作を可能にする非公式のインターフェースを定義します。場合によっては、型は特定のケースでより効率的なアルゴリズムを使用できることがわかっているときに、追加の動作を特化させたいと考えることがあります。</span></p><p data-translated="true"><span class="original-text">It is also often useful to allow iteration over a collection in <em>reverse order</em> by iterating over <a href="../../base/iterators/index.html#Base.Iterators.reverse"><code>Iterators.reverse(iterator)</code></a>. To actually support reverse-order iteration, however, an iterator type <code>T</code> needs to implement <code>iterate</code> for <code>Iterators.Reverse{T}</code>. (Given <code>r::Iterators.Reverse{T}</code>, the underling iterator of type <code>T</code> is <code>r.itr</code>.) In our <code>Squares</code> example, we would implement <code>Iterators.Reverse{Squares}</code> methods:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コレクションを<em>逆順</em>で反復することを許可することもよく役立ちます。<a href="../../base/iterators/index.html#Base.Iterators.reverse"><code>Iterators.reverse(iterator)</code></a>を反復することで実現できます。ただし、逆順の反復を実際にサポートするには、イテレータ型<code>T</code>が<code>Iterators.Reverse{T}</code>のために<code>iterate</code>を実装する必要があります。（<code>r::Iterators.Reverse{T}</code>が与えられた場合、型<code>T</code>の基になるイテレータは<code>r.itr</code>です。）私たちの<code>Squares</code>の例では、<code>Iterators.Reverse{Squares}</code>メソッドを実装します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count) = state &lt; 1 ? nothing : (state*state, state-1)

julia&gt; collect(Iterators.reverse(Squares(4)))
4-element Vector{Int64}:
 16
  9
  4
  1</code></pre><h2 id="Indexing" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Indexing">Indexing</a><a id="Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Indexing">インデクシング</a><a id="Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing" title="Permalink"></a></span></h2><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Methods to implement</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実装するメソッド</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Brief description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単な説明</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>getindex(X, i)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>getindex(X, i)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>X[i]</code>, indexed access, non-scalar <code>i</code> should allocate a copy</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>X[i]</code>、インデックスアクセス、非スカラー <code>i</code> はコピーを割り当てる必要があります</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>setindex!(X, v, i)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>setindex!(X, v, i)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>X[i] = v</code>, indexed assignment</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>X[i] = v</code>、インデックス代入</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>firstindex(X)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>firstindex(X)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">The first index, used in <code>X[begin]</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>X[begin]</code> で使用される最初のインデックス</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>lastindex(X)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>lastindex(X)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">The last index, used in <code>X[end]</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>X[end]</code> で使用される最後のインデックス</span></td></tr></tbody></table><p data-translated="true"><span class="original-text">For the <code>Squares</code> iterable above, we can easily compute the <code>i</code>th element of the sequence by squaring it. We can expose this as an indexing expression <code>S[i]</code>. To opt into this behavior, <code>Squares</code> simply needs to define <a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記の <code>Squares</code> イテラブルに対して、私たちはそれを二乗することでシーケンスの <code>i</code> 番目の要素を簡単に計算できます。これをインデックス式 <code>S[i]</code> として公開できます。この動作を選択するには、<code>Squares</code> は単に <a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a> を定義する必要があります:</span></p><pre><code class="language-julia-repl hljs">julia&gt; function Base.getindex(S::Squares, i::Int)
           1 &lt;= i &lt;= S.count || throw(BoundsError(S, i))
           return i*i
       end

julia&gt; Squares(100)[23]
529</code></pre><p data-translated="true"><span class="original-text">Additionally, to support the syntax <code>S[begin]</code> and <code>S[end]</code>, we must define <a href="../../base/collections/index.html#Base.firstindex"><code>firstindex</code></a> and <a href="../../base/collections/index.html#Base.lastindex"><code>lastindex</code></a> to specify the first and last valid indices, respectively:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さらに、構文 <code>S[begin]</code> と <code>S[end]</code> をサポートするために、最初と最後の有効なインデックスをそれぞれ指定するために <a href="../../base/collections/index.html#Base.firstindex"><code>firstindex</code></a> と <a href="../../base/collections/index.html#Base.lastindex"><code>lastindex</code></a> を定義する必要があります。</span></p><pre><code class="language-julia-repl hljs">julia&gt; Base.firstindex(S::Squares) = 1

julia&gt; Base.lastindex(S::Squares) = length(S)

julia&gt; Squares(23)[end]
529</code></pre><p data-translated="true"><span class="original-text">For multi-dimensional <code>begin</code>/<code>end</code> indexing as in <code>a[3, begin, 7]</code>, for example, you should define <code>firstindex(a, dim)</code> and <code>lastindex(a, dim)</code> (which default to calling <code>first</code> and <code>last</code> on <code>axes(a, dim)</code>, respectively).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、<code>a[3, begin, 7]</code> のような多次元 <code>begin</code>/<code>end</code> インデクシングの場合、<code>firstindex(a, dim)</code> と <code>lastindex(a, dim)</code> を定義する必要があります（これらはそれぞれ <code>axes(a, dim)</code> に対して <code>first</code> と <code>last</code> を呼び出すことがデフォルトです）。</span></p><p data-translated="true"><span class="original-text">Note, though, that the above <em>only</em> defines <a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a> with one integer index. Indexing with anything other than an <code>Int</code> will throw a <a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a> saying that there was no matching method. In order to support indexing with ranges or vectors of <code>Int</code>s, separate methods must be written:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、上記は <em>のみ</em> 一つの整数インデックスを持つ <a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a> を定義します。<code>Int</code> 以外のものでインデクシングすると、マッチするメソッドがないという <a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a> が発生します。範囲や <code>Int</code> のベクトルでのインデクシングをサポートするためには、別のメソッドを記述する必要があります。</span></p><pre><code class="language-julia-repl hljs">julia&gt; Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]

julia&gt; Base.getindex(S::Squares, I) = [S[i] for i in I]

julia&gt; Squares(10)[[3,4.,5]]
3-element Vector{Int64}:
  9
 16
 25</code></pre><p data-translated="true"><span class="original-text">While this is starting to support more of the <a href="../arrays/index.html#man-array-indexing">indexing operations supported by some of the builtin types</a>, there's still quite a number of behaviors missing. This <code>Squares</code> sequence is starting to look more and more like a vector as we've added behaviors to it. Instead of defining all these behaviors ourselves, we can officially define it as a subtype of an <a href="../../base/arrays/index.html#Core.AbstractArray"><code>AbstractArray</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、いくつかの組み込み型によってサポートされている <a href="../arrays/index.html#man-array-indexing">インデクシング操作</a> のより多くをサポートし始めていますが、まだ多くの動作が欠けています。この <code>Squares</code> シーケンスは、私たちがそれに動作を追加するにつれて、ますますベクトルのように見えてきています。これらの動作をすべて自分たちで定義する代わりに、公式に <a href="../../base/arrays/index.html#Core.AbstractArray"><code>AbstractArray</code></a> のサブタイプとして定義することができます。</span></p><h2 id="man-interface-array" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-interface-array">Abstract Arrays</a><a id="man-interface-array-1"></a><a class="docs-heading-anchor-permalink" href="#man-interface-array" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-interface-array">抽象配列</a><a id="man-interface-array-1"></a><a class="docs-heading-anchor-permalink" href="#man-interface-array" title="Permalink"></a></span></h2><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Methods to implement</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実装するメソッド</span></th><th style="text-align: left"></th><th style="text-align: left" data-translated="true"><span class="original-text">Brief description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単な説明</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>size(A)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>size(A)</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text">Returns a tuple containing the dimensions of <code>A</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>A</code> の次元を含むタプルを返します。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>getindex(A, i::Int)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>getindex(A, i::Int)</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text">(if <code>IndexLinear</code>) Linear scalar indexing</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(if <code>IndexLinear</code>) 線形スカラーインデクシング</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>getindex(A, I::Vararg{Int, N})</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>getindex(A, I::Vararg{Int, N})</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text">(if <code>IndexCartesian</code>, where <code>N = ndims(A)</code>) N-dimensional scalar indexing</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(if <code>IndexCartesian</code>, where <code>N = ndims(A)</code>) N次元スカラーインデクシング</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><strong>Optional methods</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>オプションのメソッド</strong></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><strong>Default definition</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>デフォルト定義</strong></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><strong>Brief description</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>簡潔な説明</strong></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>IndexStyle(::Type)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>IndexStyle(::Type)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>IndexCartesian()</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>IndexCartesian()</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Returns either <code>IndexLinear()</code> or <code>IndexCartesian()</code>. See the description below.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>IndexLinear()</code> または <code>IndexCartesian()</code> のいずれかを返します。以下の説明を参照してください。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>setindex!(A, v, i::Int)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>setindex!(A, v, i::Int)</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text">(if <code>IndexLinear</code>) Scalar indexed assignment</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(もし <code>IndexLinear</code>) スカラーインデックスの代入</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>setindex!(A, v, I::Vararg{Int, N})</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>setindex!(A, v, I::Vararg{Int, N})</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text">(if <code>IndexCartesian</code>, where <code>N = ndims(A)</code>) N-dimensional scalar indexed assignment</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(もし <code>IndexCartesian</code> の場合、<code>N = ndims(A)</code> のとき) N次元スカラーインデックスの代入</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>getindex(A, I...)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>getindex(A, I...)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">defined in terms of scalar <code>getindex</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">スカラー<code>getindex</code>に基づいて定義される</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../arrays/index.html#man-array-indexing">Multidimensional and nonscalar indexing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../arrays/index.html#man-array-indexing">多次元および非スカラーインデックス</a></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>setindex!(A, X, I...)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>setindex!(A, X, I...)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">defined in terms of scalar <code>setindex!</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">スカラー <code>setindex!</code> に基づいて定義される</span></td><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../arrays/index.html#man-array-indexing">Multidimensional and nonscalar indexed assignment</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../arrays/index.html#man-array-indexing">多次元および非スカラーインデックスの代入</a></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>iterate</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>iterate</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">defined in terms of scalar <code>getindex</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">スカラー<code>getindex</code>に基づいて定義される</span></td><td style="text-align: left" data-translated="true"><span class="original-text">Iteration</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">反復</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>length(A)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>length(A)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>prod(size(A))</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>prod(size(A))</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Number of elements</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">要素の数</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>similar(A)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>similar(A)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>similar(A, eltype(A), size(A))</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>similar(A, eltype(A), size(A))</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Return a mutable array with the same shape and element type</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同じ形状と要素型を持つ可変配列を返す</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>similar(A, ::Type{S})</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>similar(A, ::Type{S})</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>similar(A, S, size(A))</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>similar(A, S, size(A))</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Return a mutable array with the same shape and the specified element type</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同じ形状と指定された要素型を持つ可変配列を返します</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>similar(A, dims::Dims)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>similar(A, dims::Dims)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>similar(A, eltype(A), dims)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>similar(A, eltype(A), dims)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Return a mutable array with the same element type and size <em>dims</em></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同じ要素型とサイズ<em>dims</em>を持つ可変配列を返します</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>similar(A, ::Type{S}, dims::Dims)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>similar(A, ::Type{S}, dims::Dims)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>Array{S}(undef, dims)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Array{S}(undef, dims)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Return a mutable array with the specified element type and size</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">指定された要素型とサイズを持つ可変配列を返します</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><strong>Non-traditional indices</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>非伝統的インデックス</strong></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><strong>Default definition</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>デフォルト定義</strong></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><strong>Brief description</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>簡潔な説明</strong></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>axes(A)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>axes(A)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>map(OneTo, size(A))</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>map(OneTo, size(A))</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Return a tuple of <code>AbstractUnitRange{&lt;:Integer}</code> of valid indices. The axes should be their own axes, that is <code>axes.(axes(A),1) == axes(A)</code> should be satisfied.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">有効なインデックスの <code>AbstractUnitRange{&lt;:Integer}</code> のタプルを返します。軸はそれ自体の軸であるべきであり、すなわち <code>axes.(axes(A),1) == axes(A)</code> が満たされる必要があります。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>similar(A, ::Type{S}, inds)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>similar(A, ::Type{S}, inds)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>similar(A, S, Base.to_shape(inds))</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>similar(A, S, Base.to_shape(inds))</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Return a mutable array with the specified indices <code>inds</code> (see below)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">指定されたインデックス <code>inds</code> を持つ可変配列を返します（下記参照）</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>similar(T::Union{Type,Function}, inds)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>similar(T::Union{Type,Function}, inds)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>T(Base.to_shape(inds))</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>T(Base.to_shape(inds))</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Return an array similar to <code>T</code> with the specified indices <code>inds</code> (see below)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">指定されたインデックス <code>inds</code> を持つ <code>T</code> に類似した配列を返します（下記参照）</span></td></tr></tbody></table><p data-translated="true"><span class="original-text">If a type is defined as a subtype of <code>AbstractArray</code>, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the <a href="../arrays/index.html#man-multi-dim-arrays">arrays manual page</a> and the <a href="../../base/arrays/index.html#lib-arrays">Julia Base section</a> for more supported methods.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型が <code>AbstractArray</code> のサブタイプとして定義されている場合、単一要素アクセスの上に構築された反復処理や多次元インデックス付けを含む非常に大きなセットの豊富な動作を継承します。詳細なメソッドについては、<a href="../arrays/index.html#man-multi-dim-arrays">配列マニュアルページ</a>および <a href="../../base/arrays/index.html#lib-arrays">Julia Baseセクション</a>を参照してください。</span></p><p data-translated="true"><span class="original-text">A key part in defining an <code>AbstractArray</code> subtype is <a href="../../base/arrays/index.html#Base.IndexStyle"><code>IndexStyle</code></a>. Since indexing is such an important part of an array and often occurs in hot loops, it's important to make both indexing and indexed assignment as efficient as possible. Array data structures are typically defined in one of two ways: either it most efficiently accesses its elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified for every dimension.  These two modalities are identified by Julia as <code>IndexLinear()</code> and <code>IndexCartesian()</code>.  Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-based mechanism to enable efficient generic code for all array types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">サブタイプの<code>AbstractArray</code>を定義する上での重要な要素は、<a href="../../base/arrays/index.html#Base.IndexStyle"><code>IndexStyle</code></a>です。インデックス付けは配列の重要な部分であり、しばしばホットループ内で発生するため、インデックス付けとインデックス付き代入をできるだけ効率的に行うことが重要です。配列データ構造は通常、要素に対して1つのインデックス（線形インデックス）を使用して最も効率的にアクセスするか、すべての次元に対して指定されたインデックスで要素に本質的にアクセスするかのいずれかの方法で定義されます。これらの2つのモダリティは、Juliaによって<code>IndexLinear()</code>と<code>IndexCartesian()</code>として識別されます。線形インデックスを複数のインデックスサブスクリプトに変換することは通常非常に高コストであるため、これはすべての配列タイプに対して効率的な汎用コードを可能にするための特性ベースのメカニズムを提供します。</span></p><p data-translated="true"><span class="original-text">This distinction determines which scalar indexing methods the type must define. <code>IndexLinear()</code> arrays are simple: just define <code>getindex(A::ArrayType, i::Int)</code>. When the array is subsequently indexed with a multidimensional set of indices, the fallback <code>getindex(A::AbstractArray, I...)</code> efficiently converts the indices into one linear index and then calls the above method. <code>IndexCartesian()</code> arrays, on the other hand, require methods to be defined for each supported dimensionality with <code>ndims(A)</code> <code>Int</code> indices. For example, <a href="../../stdlib/SparseArrays/index.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> from the <code>SparseArrays</code> standard library module, only supports two dimensions, so it just defines <code>getindex(A::SparseMatrixCSC, i::Int, j::Int)</code>. The same holds for <a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この区別は、型が定義しなければならないスカラーインデックスメソッドを決定します。<code>IndexLinear()</code>配列はシンプルです：<code>getindex(A::ArrayType, i::Int)</code>を定義するだけです。その後、配列が多次元のインデックスセットでインデックス付けされると、フォールバック<code>getindex(A::AbstractArray, I...)</code>はインデックスを1つの線形インデックスに効率的に変換し、上記のメソッドを呼び出します。一方、<code>IndexCartesian()</code>配列は、<code>ndims(A)</code> <code>Int</code>インデックスを持つ各サポートされる次元に対してメソッドを定義する必要があります。例えば、<a href="../../stdlib/SparseArrays/index.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a>は、<code>SparseArrays</code>標準ライブラリモジュールから、2次元のみをサポートしているため、<code>getindex(A::SparseMatrixCSC, i::Int, j::Int)</code>を定義するだけです。同様のことが<a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a>にも当てはまります。</span></p><p data-translated="true"><span class="original-text">Returning to the sequence of squares from above, we could instead define it as a subtype of an <code>AbstractArray{Int, 1}</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記の平方数の列に戻ると、<code>AbstractArray{Int, 1}</code>のサブタイプとして定義することもできます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct SquaresVector &lt;: AbstractArray{Int, 1}
           count::Int
       end

julia&gt; Base.size(S::SquaresVector) = (S.count,)

julia&gt; Base.IndexStyle(::Type{&lt;:SquaresVector}) = IndexLinear()

julia&gt; Base.getindex(S::SquaresVector, i::Int) = i*i</code></pre><p data-translated="true"><span class="original-text">Note that it's very important to specify the two parameters of the <code>AbstractArray</code>; the first defines the <a href="../../base/collections/index.html#Base.eltype"><code>eltype</code></a>, and the second defines the <a href="../../base/arrays/index.html#Base.ndims"><code>ndims</code></a>. That supertype and those three methods are all it takes for <code>SquaresVector</code> to be an iterable, indexable, and completely functional array:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この<code>AbstractArray</code>の2つのパラメータを指定することが非常に重要であることに注意してください。最初のパラメータは<a href="../../base/collections/index.html#Base.eltype"><code>eltype</code></a>を定義し、2番目のパラメータは<a href="../../base/arrays/index.html#Base.ndims"><code>ndims</code></a>を定義します。そのスーパークラスとこれら3つのメソッドがあれば、<code>SquaresVector</code>は反復可能でインデックス可能かつ完全に機能する配列になります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; s = SquaresVector(4)
4-element SquaresVector:
  1
  4
  9
 16

julia&gt; s[s .&gt; 8]
2-element Vector{Int64}:
  9
 16

julia&gt; s + s
4-element Vector{Int64}:
  2
  8
 18
 32

julia&gt; sin.(s)
4-element Vector{Float64}:
  0.8414709848078965
 -0.7568024953079282
  0.4121184852417566
 -0.2879033166650653</code></pre><p data-translated="true"><span class="original-text">As a more complicated example, let's define our own toy N-dimensional sparse-like array type built on top of <a href="../../base/collections/index.html#Base.Dict"><code>Dict</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より複雑な例として、<a href="../../base/collections/index.html#Base.Dict"><code>Dict</code></a>の上に構築された独自のトイN次元スパースライク配列型を定義してみましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct SparseArray{T,N} &lt;: AbstractArray{T,N}
           data::Dict{NTuple{N,Int}, T}
           dims::NTuple{N,Int}
       end

julia&gt; SparseArray(::Type{T}, dims::Int...) where {T} = SparseArray(T, dims);

julia&gt; SparseArray(::Type{T}, dims::NTuple{N,Int}) where {T,N} = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);

julia&gt; Base.size(A::SparseArray) = A.dims

julia&gt; Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)

julia&gt; Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))

julia&gt; Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)</code></pre><p data-translated="true"><span class="original-text">Notice that this is an <code>IndexCartesian</code> array, so we must manually define <a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a> and <a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a> at the dimensionality of the array. Unlike the <code>SquaresVector</code>, we are able to define <a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a>, and so we can mutate the array:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは<code>IndexCartesian</code>配列であるため、配列の次元において<a href="../../base/collections/index.html#Base.getindex"><code>getindex</code></a>と<a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a>を手動で定義する必要があります。<code>SquaresVector</code>とは異なり、<a href="../../base/collections/index.html#Base.setindex!"><code>setindex!</code></a>を定義できるため、配列を変更することができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = SparseArray(Float64, 3, 3)
3×3 SparseArray{Float64, 2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; fill!(A, 2)
3×3 SparseArray{Float64, 2}:
 2.0  2.0  2.0
 2.0  2.0  2.0
 2.0  2.0  2.0

julia&gt; A[:] = 1:length(A); A
3×3 SparseArray{Float64, 2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><p data-translated="true"><span class="original-text">The result of indexing an <code>AbstractArray</code> can itself be an array (for instance when indexing by an <code>AbstractRange</code>). The <code>AbstractArray</code> fallback methods use <a href="../../base/arrays/index.html#Base.similar"><code>similar</code></a> to allocate an <code>Array</code> of the appropriate size and element type, which is filled in using the basic indexing method described above. However, when implementing an array wrapper you often want the result to be wrapped as well:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>AbstractArray</code>のインデックス付けの結果は、<code>AbstractRange</code>でインデックス付けする場合など、配列自体である可能性があります。<code>AbstractArray</code>のフォールバックメソッドは、<a href="../../base/arrays/index.html#Base.similar"><code>similar</code></a>を使用して、適切なサイズと要素タイプの<code>Array</code>を割り当て、上記で説明した基本的なインデックス付けメソッドを使用して埋め込みます。ただし、配列ラッパーを実装する際には、結果もラップされることが望ましいことがよくあります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; A[1:2,:]
2×3 SparseArray{Float64, 2}:
 1.0  4.0  7.0
 2.0  5.0  8.0</code></pre><p data-translated="true"><span class="original-text">In this example it is accomplished by defining <code>Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where T</code> to create the appropriate wrapped array. (Note that while <code>similar</code> supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it's important that <code>SparseArray</code> is mutable (supports <code>setindex!</code>). Defining <code>similar</code>, <code>getindex</code> and <code>setindex!</code> for <code>SparseArray</code> also makes it possible to <a href="../../base/base/index.html#Base.copy"><code>copy</code></a> the array:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例では、<code>Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where T</code>を定義することで、適切なラップされた配列を作成します。（<code>similar</code>は1引数および2引数の形式をサポートしていますが、ほとんどの場合、3引数形式を特化させるだけで済みます。）これが機能するためには、<code>SparseArray</code>が可変である（<code>setindex!</code>をサポートしている）ことが重要です。<code>SparseArray</code>のために<code>similar</code>、<code>getindex</code>、および<code>setindex!</code>を定義することにより、配列を<a href="../../base/base/index.html#Base.copy"><code>copy</code></a>することも可能になります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; copy(A)
3×3 SparseArray{Float64, 2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><p data-translated="true"><span class="original-text">In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in Julia Base for <code>AbstractArrays</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記のすべての反復可能およびインデックス可能なメソッドに加えて、これらのタイプは互いに相互作用し、<code>AbstractArrays</code>のためにJulia Baseで定義されたほとんどのメソッドを使用することもできます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; A[SquaresVector(3)]
3-element SparseArray{Float64, 1}:
 1.0
 4.0
 9.0

julia&gt; sum(A)
45.0</code></pre><p data-translated="true"><span class="original-text">If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize <a href="../../base/arrays/index.html#Base.axes-Tuple{Any}"><code>axes</code></a>. You should also specialize <a href="../../base/arrays/index.html#Base.similar"><code>similar</code></a> so that the <code>dims</code> argument (ordinarily a <code>Dims</code> size-tuple) can accept <code>AbstractUnitRange</code> objects, perhaps range-types <code>Ind</code> of your own design. For more information, see <a href="../../devdocs/offset-arrays/index.html#man-custom-indices">Arrays with custom indices</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">非従来型インデックス（1以外の何かから始まるインデックス）を許可する配列型を定義する場合は、<a href="../../base/arrays/index.html#Base.axes-Tuple{Any}"><code>axes</code></a>を特化させる必要があります。また、<code>dims</code>引数（通常は<code>Dims</code>サイズタプル）が<code>AbstractUnitRange</code>オブジェクト、あるいは独自の設計の範囲タイプ<code>Ind</code>を受け入れることができるように、<a href="../../base/arrays/index.html#Base.similar"><code>similar</code></a>も特化させる必要があります。詳細については、<a href="../../devdocs/offset-arrays/index.html#man-custom-indices">カスタムインデックスを持つ配列</a>を参照してください。</span></p><h2 id="man-interface-strided-arrays" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-interface-strided-arrays">Strided Arrays</a><a id="man-interface-strided-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#man-interface-strided-arrays" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-interface-strided-arrays">ストライド配列</a><a id="man-interface-strided-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#man-interface-strided-arrays" title="Permalink"></a></span></h2><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Methods to implement</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実装するメソッド</span></th><th style="text-align: left"></th><th style="text-align: left" data-translated="true"><span class="original-text">Brief description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単な説明</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>strides(A)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>strides(A)</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text">Return the distance in memory (in number of elements) between adjacent elements in each dimension as a tuple. If <code>A</code> is an <code>AbstractArray{T,0}</code>, this should return an empty tuple.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各次元における隣接要素間のメモリ内の距離（要素数）をタプルとして返します。もし<code>A</code>が<code>AbstractArray{T,0}</code>であれば、空のタプルを返すべきです。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.unsafe_convert(::Type{Ptr{T}}, A)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.unsafe_convert(::Type{Ptr{T}}, A)</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text">Return the native address of an array.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列のネイティブアドレスを返します。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.elsize(::Type{&lt;:A})</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.elsize(::Type{&lt;:A})</code></span></td><td style="text-align: left"></td><td style="text-align: left" data-translated="true"><span class="original-text">Return the stride between consecutive elements in the array.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列内の連続する要素間のストライドを返します。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><strong>Optional methods</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>オプションのメソッド</strong></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><strong>Default definition</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>デフォルト定義</strong></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><strong>Brief description</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>簡潔な説明</strong></span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>stride(A, i::Int)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>stride(A, i::Int)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>strides(A)[i]</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>strides(A)[i]</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Return the distance in memory (in number of elements) between adjacent elements in dimension k.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次元kにおける隣接要素間のメモリ内の距離（要素数）を返します。</span></td></tr></tbody></table><p data-translated="true"><span class="original-text">A strided array is a subtype of <code>AbstractArray</code> whose entries are stored in memory with fixed strides. Provided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines for more efficient linear algebra routines. A typical example of a user-defined strided array is one that wraps a standard <code>Array</code> with additional structure.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ストライド配列は、固定ストライドでメモリに格納されたエントリを持つ<code>AbstractArray</code>のサブタイプです。配列の要素型がBLASと互換性がある場合、ストライド配列はBLASおよびLAPACKルーチンを利用して、より効率的な線形代数ルーチンを実行できます。ユーザー定義のストライド配列の典型的な例は、追加の構造を持つ標準<code>Array</code>をラップするものです。</span></p><p data-translated="true"><span class="original-text">Warning: do not implement these methods if the underlying storage is not actually strided, as it may lead to incorrect results or segmentation faults.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">警告: 基本ストレージが実際にストライドでない場合、これらのメソッドを実装しないでください。そうしないと、不正確な結果やセグメンテーションフォルトが発生する可能性があります。</span></p><p data-translated="true"><span class="original-text">Here are some examples to demonstrate which type of arrays are strided and which are not:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">どのタイプの配列がストライドであり、どれがそうでないかを示すいくつかの例を以下に示します：</span></p><pre><code class="language-julia hljs">1:5   # not strided (there is no storage associated with this array.)
Vector(1:5)  # is strided with strides (1,)
A = [1 5; 2 6; 3 7; 4 8]  # is strided with strides (1,4)
V = view(A, 1:2, :)   # is strided with strides (1,4)
V = view(A, 1:2:3, 1:2)   # is strided with strides (2,4)
V = view(A, [1,2,4], :)   # is not strided, as the spacing between rows is not fixed.</code></pre><h2 id="man-interfaces-broadcasting" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-interfaces-broadcasting">Customizing broadcasting</a><a id="man-interfaces-broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#man-interfaces-broadcasting" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-interfaces-broadcasting">ブロードキャスティングのカスタマイズ</a><a id="man-interfaces-broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#man-interfaces-broadcasting" title="パーマリンク"></a></span></h2><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Methods to implement</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実装するメソッド</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Brief description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単な説明</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.BroadcastStyle(::Type{SrcType}) = SrcStyle()</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.BroadcastStyle(::Type{SrcType}) = SrcStyle()</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Broadcasting behavior of <code>SrcType</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>SrcType</code>のブロードキャスト動作</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Allocation of output container</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">出力コンテナの割り当て</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><strong>Optional methods</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>オプションのメソッド</strong></span></td><td style="text-align: left"></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.BroadcastStyle(::Style1, ::Style2) = Style12()</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.BroadcastStyle(::Style1, ::Style2) = Style12()</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Precedence rules for mixing styles</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">スタイルを混合するための優先順位ルール</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.axes(x)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.axes(x)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Declaration of the indices of <code>x</code>, as per <a href="../../base/arrays/index.html#Base.axes-Tuple{Any}"><code>axes(x)</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>x</code>のインデックスの宣言、<a href="../../base/arrays/index.html#Base.axes-Tuple{Any}"><code>axes(x)</code></a>に従って。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.broadcastable(x)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.broadcastable(x)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Convert <code>x</code> to an object that has <code>axes</code> and supports indexing</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>x</code>を<code>axes</code>を持ち、インデクシングをサポートするオブジェクトに変換します</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><strong>Bypassing default machinery</strong></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>デフォルトの機構をバイパスする</strong></span></td><td style="text-align: left"></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.copy(bc::Broadcasted{DestStyle})</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.copy(bc::Broadcasted{DestStyle})</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Custom implementation of <code>broadcast</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>broadcast</code>のカスタム実装</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.copyto!(dest, bc::Broadcasted{DestStyle})</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.copyto!(dest, bc::Broadcasted{DestStyle})</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Custom implementation of <code>broadcast!</code>, specializing on <code>DestStyle</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>broadcast!</code>のカスタム実装、<code>DestStyle</code>に特化</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.copyto!(dest::DestType, bc::Broadcasted{Nothing})</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.copyto!(dest::DestType, bc::Broadcasted{Nothing})</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Custom implementation of <code>broadcast!</code>, specializing on <code>DestType</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>broadcast!</code>のカスタム実装、<code>DestType</code>に特化</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.Broadcast.broadcasted(f, args...)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.Broadcast.broadcasted(f, args...)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Override the default lazy behavior within a fused expression</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">融合された式内でのデフォルトの遅延動作をオーバーライドする</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>Base.Broadcast.instantiate(bc::Broadcasted{DestStyle})</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.Broadcast.instantiate(bc::Broadcasted{DestStyle})</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Override the computation of the lazy broadcast's axes</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">遅延ブロードキャストの軸の計算をオーバーライドする</span></td></tr></tbody></table><p data-translated="true"><span class="original-text"><a href="../arrays/index.html#Broadcasting">Broadcasting</a> is triggered by an explicit call to <code>broadcast</code> or <code>broadcast!</code>, or implicitly by "dot" operations like <code>A .+ b</code> or <code>f.(x, y)</code>. Any object that has <a href="../../base/arrays/index.html#Base.axes-Tuple{Any}"><code>axes</code></a> and supports indexing can participate as an argument in broadcasting, and by default the result is stored in an <code>Array</code>. This basic framework is extensible in three major ways:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../arrays/index.html#Broadcasting">ブロードキャスティング</a>は、<code>broadcast</code>または<code>broadcast!</code>への明示的な呼び出し、または<code>A .+ b</code>や<code>f.(x, y)</code>のような「ドット」操作によって暗黙的にトリガーされます。<a href="../../base/arrays/index.html#Base.axes-Tuple{Any}"><code>axes</code></a>を持ち、インデックス付けをサポートする任意のオブジェクトは、ブロードキャスティングの引数として参加でき、デフォルトでは結果は<code>Array</code>に格納されます。この基本的なフレームワークは、主に3つの方法で拡張可能です：</span></p><ul><li data-translated="true"><span class="original-text">Ensuring that all arguments support broadcast</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべての引数がブロードキャストをサポートすることを保証する</span></li><li data-translated="true"><span class="original-text">Selecting an appropriate output array for the given set of arguments</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">与えられた引数のセットに対して適切な出力配列を選択する</span></li><li data-translated="true"><span class="original-text">Selecting an efficient implementation for the given set of arguments</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">与えられた引数のセットに対して効率的な実装を選択する</span></li></ul><p data-translated="true"><span class="original-text">Not all types support <code>axes</code> and indexing, but many are convenient to allow in broadcast. The <a href="../../base/arrays/index.html#Base.Broadcast.broadcastable"><code>Base.broadcastable</code></a> function is called on each argument to broadcast, allowing it to return something different that supports <code>axes</code> and indexing. By default, this is the identity function for all <code>AbstractArray</code>s and <code>Number</code>s — they already support <code>axes</code> and indexing.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>axes</code>とインデックス付けをサポートしない型もありますが、多くはブロードキャストで許可するのが便利です。<a href="../../base/arrays/index.html#Base.Broadcast.broadcastable"><code>Base.broadcastable</code></a>関数は、ブロードキャストする各引数に対して呼び出され、<code>axes</code>とインデックス付けをサポートする異なるものを返すことができます。デフォルトでは、これはすべての<code>AbstractArray</code>と<code>Number</code>に対する恒等関数です — それらはすでに<code>axes</code>とインデックス付けをサポートしています。</span></p><p data-translated="true"><span class="original-text">If a type is intended to act like a "0-dimensional scalar" (a single object) rather than as a container for broadcasting, then the following method should be defined:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型がブロードキャスティングのコンテナではなく「0次元スカラー」（単一のオブジェクト）として機能することを意図している場合、次のメソッドを定義する必要があります：</span></p><pre><code class="language-julia hljs">Base.broadcastable(o::MyType) = Ref(o)</code></pre><p data-translated="true"><span class="original-text">that returns the argument wrapped in a 0-dimensional <a href="../../base/c/index.html#Core.Ref"><code>Ref</code></a> container. For example, such a wrapper method is defined for types themselves, functions, special singletons like <a href="../missing/index.html#missing"><code>missing</code></a> and <a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a>, and dates.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数を0次元の<a href="../../base/c/index.html#Core.Ref"><code>Ref</code></a>コンテナでラップして返します。たとえば、そのようなラッパーメソッドは、型自体、関数、<a href="../missing/index.html#missing"><code>missing</code></a>や<a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a>のような特別なシングルトン、日付に対して定義されています。</span></p><p data-translated="true"><span class="original-text">Custom array-like types can specialize <code>Base.broadcastable</code> to define their shape, but they should follow the convention that <code>collect(Base.broadcastable(x)) == collect(x)</code>. A notable exception is <code>AbstractString</code>; strings are special-cased to behave as scalars for the purposes of broadcast even though they are iterable collections of their characters (see <a href="../../devdocs/ast/index.html#Strings">Strings</a> for more).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">カスタムの配列のような型は、<code>Base.broadcastable</code>を特化させてその形状を定義できますが、<code>collect(Base.broadcastable(x)) == collect(x)</code>という規約に従う必要があります。注目すべき例外は<code>AbstractString</code>です。文字列は、その文字のイテラブルコレクションであるにもかかわらず、ブロードキャストの目的のためにスカラーとして振る舞うように特別扱いされています（詳細は<a href="../../devdocs/ast/index.html#Strings">Strings</a>を参照してください）。</span></p><p data-translated="true"><span class="original-text">The next two steps (selecting the output array and implementation) are dependent upon determining a single answer for a given set of arguments. Broadcast must take all the varied types of its arguments and collapse them down to just one output array and one implementation. Broadcast calls this single answer a "style". Every broadcastable object each has its own preferred style, and a promotion-like system is used to combine these styles into a single answer — the "destination style".</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次の2つのステップ（出力配列の選択と実装）は、与えられた引数のセットに対して単一の答えを決定することに依存しています。ブロードキャストは、引数のさまざまな型をすべて取り込み、それらを1つの出力配列と1つの実装にまとめる必要があります。ブロードキャストはこの単一の答えを「スタイル」と呼びます。すべてのブロードキャスト可能なオブジェクトはそれぞれ独自の好ましいスタイルを持ち、これらのスタイルを単一の答え—「宛先スタイル」に結合するためにプロモーションのようなシステムが使用されます。</span></p><h3 id="Broadcast-Styles" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Broadcast-Styles">Broadcast Styles</a><a id="Broadcast-Styles-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcast-Styles" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Broadcast-Styles">ブロードキャストスタイル</a><a id="Broadcast-Styles-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcast-Styles" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text"><code>Base.BroadcastStyle</code> is the abstract type from which all broadcast styles are derived. When used as a function it has two possible forms, unary (single-argument) and binary. The unary variant states that you intend to implement specific broadcasting behavior and/or output type, and do not wish to rely on the default fallback <a href="../../base/arrays/index.html#Base.Broadcast.DefaultArrayStyle"><code>Broadcast.DefaultArrayStyle</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.BroadcastStyle</code>は、すべてのブロードキャストスタイルが派生する抽象型です。関数として使用されるとき、2つの可能な形式、単項（単一引数）と双項があります。単項のバリアントは、特定のブロードキャスト動作および/または出力型を実装する意図があり、デフォルトのフォールバック<a href="../../base/arrays/index.html#Base.Broadcast.DefaultArrayStyle"><code>Broadcast.DefaultArrayStyle</code></a>に依存したくないことを示します。</span></p><p data-translated="true"><span class="original-text">To override these defaults, you can define a custom <code>BroadcastStyle</code> for your object:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらのデフォルトをオーバーライドするには、オブジェクトのためにカスタム<code>BroadcastStyle</code>を定義できます。</span></p><pre><code class="language-julia hljs">struct MyStyle &lt;: Broadcast.BroadcastStyle end
Base.BroadcastStyle(::Type{&lt;:MyType}) = MyStyle()</code></pre><p data-translated="true"><span class="original-text">In some cases it might be convenient not to have to define <code>MyStyle</code>, in which case you can leverage one of the general broadcast wrappers:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">場合によっては、<code>MyStyle</code>を定義する必要がない方が便利なことがあります。その場合、一般的なブロードキャストラッパーの1つを利用できます。</span></p><ul><li data-translated="true"><span class="original-text"><code>Base.BroadcastStyle(::Type{&lt;:MyType}) = Broadcast.Style{MyType}()</code> can be used for arbitrary types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.BroadcastStyle(::Type{&lt;:MyType}) = Broadcast.Style{MyType}()</code>は、任意の型に使用できます。</span></li><li data-translated="true"><span class="original-text"><code>Base.BroadcastStyle(::Type{&lt;:MyType}) = Broadcast.ArrayStyle{MyType}()</code> is preferred if <code>MyType</code> is an <code>AbstractArray</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.BroadcastStyle(::Type{&lt;:MyType}) = Broadcast.ArrayStyle{MyType}()</code>は、<code>MyType</code>が<code>AbstractArray</code>である場合に推奨されます。</span></li><li data-translated="true"><span class="original-text">For <code>AbstractArrays</code> that only support a certain dimensionality, create a subtype of <code>Broadcast.AbstractArrayStyle{N}</code> (see below).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>AbstractArrays</code>が特定の次元のみをサポートする場合は、<code>Broadcast.AbstractArrayStyle{N}</code>のサブタイプを作成します（以下を参照）。</span></li></ul><p data-translated="true"><span class="original-text">When your broadcast operation involves several arguments, individual argument styles get combined to determine a single <code>DestStyle</code> that controls the type of the output container. For more details, see <a href="#writing-binary-broadcasting-rules">below</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ブロードキャスト操作に複数の引数が関与する場合、個々の引数スタイルが組み合わされて出力コンテナの型を制御する単一の<code>DestStyle</code>が決定されます。詳細については、<a href="#writing-binary-broadcasting-rules">以下</a>を参照してください。</span></p><h3 id="Selecting-an-appropriate-output-array" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Selecting-an-appropriate-output-array">Selecting an appropriate output array</a><a id="Selecting-an-appropriate-output-array-1"></a><a class="docs-heading-anchor-permalink" href="#Selecting-an-appropriate-output-array" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Selecting-an-appropriate-output-array">適切な出力配列の選択</a><a id="Selecting-an-appropriate-output-array-1"></a><a class="docs-heading-anchor-permalink" href="#Selecting-an-appropriate-output-array" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The broadcast style is computed for every broadcasting operation to allow for dispatch and specialization. The actual allocation of the result array is handled by <code>similar</code>, using the Broadcasted object as its first argument.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ブロードキャストスタイルは、ディスパッチと特化を可能にするために、すべてのブロードキャスティング操作に対して計算されます。結果配列の実際の割り当ては、<code>similar</code>によって処理され、Broadcastedオブジェクトを最初の引数として使用します。</span></p><pre><code class="language-julia hljs">Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})</code></pre><p data-translated="true"><span class="original-text">The fallback definition is</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">フォールバック定義は</span></p><pre><code class="language-julia hljs">similar(bc::Broadcasted{DefaultArrayStyle{N}}, ::Type{ElType}) where {N,ElType} =
    similar(Array{ElType}, axes(bc))</code></pre><p data-translated="true"><span class="original-text">However, if needed you can specialize on any or all of these arguments. The final argument <code>bc</code> is a lazy representation of a (potentially fused) broadcast operation, a <code>Broadcasted</code> object. For these purposes, the most important fields of the wrapper are <code>f</code> and <code>args</code>, describing the function and argument list, respectively. Note that the argument list can — and often does — include other nested <code>Broadcasted</code> wrappers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、必要に応じてこれらの引数のいずれかまたはすべてに特化することができます。最終引数<code>bc</code>は、（潜在的に融合された）ブロードキャスト操作の遅延表現であり、<code>Broadcasted</code>オブジェクトです。この目的のために、ラッパーの最も重要なフィールドは<code>f</code>と<code>args</code>であり、それぞれ関数と引数リストを説明します。引数リストには、他のネストされた<code>Broadcasted</code>ラッパーが含まれる場合があることに注意してください。</span></p><p data-translated="true"><span class="original-text">For a complete example, let's say you have created a type, <code>ArrayAndChar</code>, that stores an array and a single character:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">完全な例として、配列と単一の文字を格納する型<code>ArrayAndChar</code>を作成したとしましょう。</span></p><pre><code class="language-julia hljs">struct ArrayAndChar{T,N} &lt;: AbstractArray{T,N}
    data::Array{T,N}
    char::Char
end
Base.size(A::ArrayAndChar) = size(A.data)
Base.getindex(A::ArrayAndChar{T,N}, inds::Vararg{Int,N}) where {T,N} = A.data[inds...]
Base.setindex!(A::ArrayAndChar{T,N}, val, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] = val
Base.showarg(io::IO, A::ArrayAndChar, toplevel) = print(io, typeof(A), " with char '", A.char, "'")</code></pre><p data-translated="true"><span class="original-text">You might want broadcasting to preserve the <code>char</code> "metadata". First we define</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ブロードキャストが<code>char</code>の「メタデータ」を保持することを望むかもしれません。まず、次のように定義します。</span></p><pre><code class="language-julia hljs">Base.BroadcastStyle(::Type{&lt;:ArrayAndChar}) = Broadcast.ArrayStyle{ArrayAndChar}()</code></pre><p data-translated="true"><span class="original-text">This means we must also define a corresponding <code>similar</code> method:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、対応する<code>similar</code>メソッドも定義しなければならないことを意味します。</span></p><pre><code class="language-julia hljs">function Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{ArrayAndChar}}, ::Type{ElType}) where ElType
    # Scan the inputs for the ArrayAndChar:
    A = find_aac(bc)
    # Use the char field of A to create the output
    ArrayAndChar(similar(Array{ElType}, axes(bc)), A.char)
end

"`A = find_aac(As)` returns the first ArrayAndChar among the arguments."
find_aac(bc::Base.Broadcast.Broadcasted) = find_aac(bc.args)
find_aac(args::Tuple) = find_aac(find_aac(args[1]), Base.tail(args))
find_aac(x) = x
find_aac(::Tuple{}) = nothing
find_aac(a::ArrayAndChar, rest) = a
find_aac(::Any, rest) = find_aac(rest)</code></pre><p data-translated="true"><span class="original-text">From these definitions, one obtains the following behavior:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの定義から、次のような動作が得られます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; a = ArrayAndChar([1 2; 3 4], 'x')
2×2 ArrayAndChar{Int64, 2} with char 'x':
 1  2
 3  4

julia&gt; a .+ 1
2×2 ArrayAndChar{Int64, 2} with char 'x':
 2  3
 4  5

julia&gt; a .+ [5,10]
2×2 ArrayAndChar{Int64, 2} with char 'x':
  6   7
 13  14</code></pre><h3 id="extending-in-place-broadcast" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#extending-in-place-broadcast">Extending broadcast with custom implementations</a><a id="extending-in-place-broadcast-1"></a><a class="docs-heading-anchor-permalink" href="#extending-in-place-broadcast" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#extending-in-place-broadcast">カスタム実装によるブロードキャストの拡張</a><a id="extending-in-place-broadcast-1"></a><a class="docs-heading-anchor-permalink" href="#extending-in-place-broadcast" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">In general, a broadcast operation is represented by a lazy <code>Broadcasted</code> container that holds onto the function to be applied alongside its arguments. Those arguments may themselves be more nested <code>Broadcasted</code> containers, forming a large expression tree to be evaluated. A nested tree of <code>Broadcasted</code> containers is directly constructed by the implicit dot syntax; <code>5 .+ 2.*x</code> is transiently represented by <code>Broadcasted(+, 5, Broadcasted(*, 2, x))</code>, for example. This is invisible to users as it is immediately realized through a call to <code>copy</code>, but it is this container that provides the basis for broadcast's extensibility for authors of custom types. The built-in broadcast machinery will then determine the result type and size based upon the arguments, allocate it, and then finally copy the realization of the <code>Broadcasted</code> object into it with a default <code>copyto!(::AbstractArray, ::Broadcasted)</code> method. The built-in fallback <code>broadcast</code> and <code>broadcast!</code> methods similarly construct a transient <code>Broadcasted</code> representation of the operation so they can follow the same codepath. This allows custom array implementations to provide their own <code>copyto!</code> specialization to customize and optimize broadcasting. This is again determined by the computed broadcast style. This is such an important part of the operation that it is stored as the first type parameter of the <code>Broadcasted</code> type, allowing for dispatch and specialization.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般に、ブロードキャスト操作は、適用される関数とその引数を保持する遅延<code>Broadcasted</code>コンテナによって表されます。これらの引数自体がさらにネストされた<code>Broadcasted</code>コンテナである場合があり、大きな式ツリーを形成して評価されます。ネストされた<code>Broadcasted</code>コンテナのツリーは、暗黙のドット構文によって直接構築されます。例えば、<code>5 .+ 2.*x</code>は一時的に<code>Broadcasted(+, 5, Broadcasted(*, 2, x))</code>として表されます。これは、<code>copy</code>への呼び出しを通じて即座に実現されるため、ユーザーには見えませんが、このコンテナがカスタム型の著者にとってブロードキャストの拡張性の基礎を提供します。組み込みのブロードキャスト機構は、引数に基づいて結果の型とサイズを決定し、それを割り当て、最後にデフォルトの<code>copyto!(::AbstractArray, ::Broadcasted)</code>メソッドを使用して<code>Broadcasted</code>オブジェクトの実現をそれにコピーします。組み込みのフォールバック<code>broadcast</code>および<code>broadcast!</code>メソッドも同様に、操作の一時的な<code>Broadcasted</code>表現を構築し、同じコードパスに従うことができます。これにより、カスタム配列実装は独自の<code>copyto!</code>特化を提供してブロードキャストをカスタマイズおよび最適化できます。これは再び計算されたブロードキャストスタイルによって決定されます。これは操作の非常に重要な部分であり、<code>Broadcasted</code>型の最初の型パラメータとして保存され、ディスパッチと特化を可能にします。</span></p><p data-translated="true"><span class="original-text">For some types, the machinery to "fuse" operations across nested levels of broadcasting is not available or could be done more efficiently incrementally. In such cases, you may need or want to evaluate <code>x .* (x .+ 1)</code> as if it had been written <code>broadcast(*, x, broadcast(+, x, 1))</code>, where the inner operation is evaluated before tackling the outer operation. This sort of eager operation is directly supported by a bit of indirection; instead of directly constructing <code>Broadcasted</code> objects, Julia lowers the fused expression <code>x .* (x .+ 1)</code> to <code>Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))</code>. Now, by default, <code>broadcasted</code> just calls the <code>Broadcasted</code> constructor to create the lazy representation of the fused expression tree, but you can choose to override it for a particular combination of function and arguments.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一部の型では、ネストされたブロードキャストのレベル間で操作を「融合」するための機構が利用できないか、または段階的により効率的に行うことができます。そのような場合、<code>x .* (x .+ 1)</code>を、内側の操作が外側の操作に取り組む前に評価されるかのように、<code>broadcast(*, x, broadcast(+, x, 1))</code>として評価する必要があるかもしれません。この種のイager操作は、少しの間接的なサポートによって直接サポートされています。Juliaは、<code>Broadcasted</code>オブジェクトを直接構築するのではなく、融合された式<code>x .* (x .+ 1)</code>を<code>Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))</code>に変換します。デフォルトでは、<code>broadcasted</code>は、融合された式ツリーの遅延表現を作成するために<code>Broadcasted</code>コンストラクタを呼び出すだけですが、特定の関数と引数の組み合わせに対してオーバーライドすることもできます。</span></p><p data-translated="true"><span class="original-text">As an example, the builtin <code>AbstractRange</code> objects use this machinery to optimize pieces of broadcasted expressions that can be eagerly evaluated purely in terms of the start, step, and length (or stop) instead of computing every single element. Just like all the other machinery, <code>broadcasted</code> also computes and exposes the combined broadcast style of its arguments, so instead of specializing on <code>broadcasted(f, args...)</code>, you can specialize on <code>broadcasted(::DestStyle, f, args...)</code> for any combination of style, function, and arguments.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、組み込みの<code>AbstractRange</code>オブジェクトは、この機構を使用して、開始、ステップ、および長さ（または停止）のみを基にして純粋に早期に評価できるブロードキャストされた式の部分を最適化します。他のすべての機構と同様に、<code>broadcasted</code>もその引数の組み合わせたブロードキャストスタイルを計算して公開します。したがって、<code>broadcasted(f, args...)</code>に特化する代わりに、任意のスタイル、関数、および引数の組み合わせに対して<code>broadcasted(::DestStyle, f, args...)</code>に特化することができます。</span></p><p data-translated="true"><span class="original-text">For example, the following definition supports the negation of ranges:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、次の定義は範囲の否定をサポートします：</span></p><pre><code class="language-julia hljs">broadcasted(::DefaultArrayStyle{1}, ::typeof(-), r::OrdinalRange) = range(-first(r), step=-step(r), length=length(r))</code></pre><h3 id="extending-in-place-broadcast-2" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#extending-in-place-broadcast-2">Extending in-place broadcasting</a><a class="docs-heading-anchor-permalink" href="#extending-in-place-broadcast-2" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#extending-in-place-broadcast-2">インプレースブロードキャストの拡張</a><a class="docs-heading-anchor-permalink" href="#extending-in-place-broadcast-2" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">In-place broadcasting can be supported by defining the appropriate <code>copyto!(dest, bc::Broadcasted)</code> method. Because you might want to specialize either on <code>dest</code> or the specific subtype of <code>bc</code>, to avoid ambiguities between packages we recommend the following convention.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">インプレースブロードキャストは、適切な<code>copyto!(dest, bc::Broadcasted)</code>メソッドを定義することでサポートできます。<code>dest</code>または<code>bc</code>の特定のサブタイプに特化したい場合、パッケージ間の曖昧さを避けるために、次の規約を推奨します。</span></p><p data-translated="true"><span class="original-text">If you wish to specialize on a particular style <code>DestStyle</code>, define a method for</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特定のスタイル<code>DestStyle</code>に特化したい場合は、次のようにメソッドを定義します。</span></p><pre><code class="language-julia hljs">copyto!(dest, bc::Broadcasted{DestStyle})</code></pre><p data-translated="true"><span class="original-text">Optionally, with this form you can also specialize on the type of <code>dest</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">オプションとして、この形式では<code>dest</code>の型にも特化できます。</span></p><p data-translated="true"><span class="original-text">If instead you want to specialize on the destination type <code>DestType</code> without specializing on <code>DestStyle</code>, then you should define a method with the following signature:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">代わりに、<code>DestStyle</code>に特化せずに宛先型<code>DestType</code>に特化したい場合は、次のシグネチャを持つメソッドを定義する必要があります：</span></p><pre><code class="language-julia hljs">copyto!(dest::DestType, bc::Broadcasted{Nothing})</code></pre><p data-translated="true"><span class="original-text">This leverages a fallback implementation of <code>copyto!</code> that converts the wrapper into a <code>Broadcasted{Nothing}</code>. Consequently, specializing on <code>DestType</code> has lower precedence than methods that specialize on <code>DestStyle</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、ラッパーを<code>Broadcasted{Nothing}</code>に変換する<code>copyto!</code>のフォールバック実装を活用します。その結果、<code>DestType</code>に特化することは、<code>DestStyle</code>に特化するメソッドよりも優先度が低くなります。</span></p><p data-translated="true"><span class="original-text">Similarly, you can completely override out-of-place broadcasting with a <code>copy(::Broadcasted)</code> method.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同様に、<code>copy(::Broadcasted)</code>メソッドを使用して、アウトオブプレースブロードキャストを完全にオーバーライドすることができます。</span></p><h4 id="Working-with-Broadcasted-objects" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Working-with-Broadcasted-objects">Working with <code>Broadcasted</code> objects</a><a id="Working-with-Broadcasted-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Broadcasted-objects" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Working-with-Broadcasted-objects"><code>Broadcasted</code> オブジェクトの操作</a><a id="Working-with-Broadcasted-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Broadcasted-objects" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">In order to implement such a <code>copy</code> or <code>copyto!</code>, method, of course, you must work with the <code>Broadcasted</code> wrapper to compute each element. There are two main ways of doing so:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このような <code>copy</code> または <code>copyto!</code> メソッドを実装するためには、もちろん、各要素を計算するために <code>Broadcasted</code> ラッパーを使用する必要があります。これを行う主な方法は二つあります：</span></p><ul><li data-translated="true"><span class="original-text"><code>Broadcast.flatten</code> recomputes the potentially nested operation into a single function and flat list of arguments. You are responsible for implementing the broadcasting shape rules yourself, but this may be helpful in limited situations.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Broadcast.flatten</code> は、潜在的にネストされた操作を単一の関数と平坦な引数リストに再計算します。ブロードキャスティングの形状ルールを自分で実装する責任がありますが、限られた状況では役立つかもしれません。</span></li><li data-translated="true"><span class="original-text">Iterating over the <code>CartesianIndices</code> of the <code>axes(::Broadcasted)</code> and using indexing with the resulting <code>CartesianIndex</code> object to compute the result.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>axes(::Broadcasted)</code> の <code>CartesianIndices</code> を反復処理し、結果の <code>CartesianIndex</code> オブジェクトを使用して結果を計算します。</span></li></ul><h3 id="writing-binary-broadcasting-rules" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#writing-binary-broadcasting-rules">Writing binary broadcasting rules</a><a id="writing-binary-broadcasting-rules-1"></a><a class="docs-heading-anchor-permalink" href="#writing-binary-broadcasting-rules" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#writing-binary-broadcasting-rules">二項ブロードキャスティングルールの記述</a><a id="writing-binary-broadcasting-rules-1"></a><a class="docs-heading-anchor-permalink" href="#writing-binary-broadcasting-rules" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The precedence rules are defined by binary <code>BroadcastStyle</code> calls:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">優先順位ルールは、二項 <code>BroadcastStyle</code> 呼び出しによって定義されます：</span></p><pre><code class="language-julia hljs">Base.BroadcastStyle(::Style1, ::Style2) = Style12()</code></pre><p data-translated="true"><span class="original-text">where <code>Style12</code> is the <code>BroadcastStyle</code> you want to choose for outputs involving arguments of <code>Style1</code> and <code>Style2</code>. For example,</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで <code>Style12</code> は、<code>Style1</code> と <code>Style2</code> の引数を含む出力に対して選択したい <code>BroadcastStyle</code> です。例えば、</span></p><pre><code class="language-julia hljs">Base.BroadcastStyle(::Broadcast.Style{Tuple}, ::Broadcast.AbstractArrayStyle{0}) = Broadcast.Style{Tuple}()</code></pre><p data-translated="true"><span class="original-text">indicates that <code>Tuple</code> "wins" over zero-dimensional arrays (the output container will be a tuple). It is worth noting that you do not need to (and should not) define both argument orders of this call; defining one is sufficient no matter what order the user supplies the arguments in.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Tuple</code> がゼロ次元配列に対して「勝つ」ことを示しています（出力コンテナはタプルになります）。この呼び出しの両方の引数の順序を定義する必要はなく（定義すべきではなく）、一方を定義するだけで十分です。ユーザーが引数をどの順序で提供しても問題ありません。</span></p><p data-translated="true"><span class="original-text">For <code>AbstractArray</code> types, defining a <code>BroadcastStyle</code> supersedes the fallback choice, <a href="../../base/arrays/index.html#Base.Broadcast.DefaultArrayStyle"><code>Broadcast.DefaultArrayStyle</code></a>. <code>DefaultArrayStyle</code> and the abstract supertype, <code>AbstractArrayStyle</code>, store the dimensionality as a type parameter to support specialized array types that have fixed dimensionality requirements.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>AbstractArray</code> 型の場合、<code>BroadcastStyle</code> を定義することは、フォールバック選択である <a href="../../base/arrays/index.html#Base.Broadcast.DefaultArrayStyle"><code>Broadcast.DefaultArrayStyle</code></a> を上書きします。<code>DefaultArrayStyle</code> と抽象スーパタイプである <code>AbstractArrayStyle</code> は、固定次元要件を持つ特殊化された配列型をサポートするために、次元性を型パラメータとして保存します。</span></p><p data-translated="true"><span class="original-text"><code>DefaultArrayStyle</code> "loses" to any other <code>AbstractArrayStyle</code> that has been defined because of the following methods:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>DefaultArrayStyle</code> は、以下のメソッドのために定義された他の <code>AbstractArrayStyle</code> に「負けます」:</span></p><pre><code class="language-julia hljs">BroadcastStyle(a::AbstractArrayStyle{Any}, ::DefaultArrayStyle) = a
BroadcastStyle(a::AbstractArrayStyle{N}, ::DefaultArrayStyle{N}) where N = a
BroadcastStyle(a::AbstractArrayStyle{M}, ::DefaultArrayStyle{N}) where {M,N} =
    typeof(a)(Val(max(M, N)))</code></pre><p data-translated="true"><span class="original-text">You do not need to write binary <code>BroadcastStyle</code> rules unless you want to establish precedence for two or more non-<code>DefaultArrayStyle</code> types.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">バイナリ <code>BroadcastStyle</code> ルールを書く必要はありませんが、2つ以上の非 <code>DefaultArrayStyle</code> タイプの優先順位を確立したい場合は別です。</span></p><p data-translated="true"><span class="original-text">If your array type does have fixed dimensionality requirements, then you should subtype <code>AbstractArrayStyle</code>. For example, the sparse array code has the following definitions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列タイプに固定次元要件がある場合は、<code>AbstractArrayStyle</code> をサブタイプ化する必要があります。例えば、スパース配列コードには以下の定義があります：</span></p><pre><code class="language-julia hljs">struct SparseVecStyle &lt;: Broadcast.AbstractArrayStyle{1} end
struct SparseMatStyle &lt;: Broadcast.AbstractArrayStyle{2} end
Base.BroadcastStyle(::Type{&lt;:SparseVector}) = SparseVecStyle()
Base.BroadcastStyle(::Type{&lt;:SparseMatrixCSC}) = SparseMatStyle()</code></pre><p data-translated="true"><span class="original-text">Whenever you subtype <code>AbstractArrayStyle</code>, you also need to define rules for combining dimensionalities, by creating a constructor for your style that takes a <code>Val(N)</code> argument. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>AbstractArrayStyle</code> をサブタイプ化する際は、<code>Val(N)</code> 引数を取るスタイルのコンストラクタを作成することで、次元の組み合わせに関するルールも定義する必要があります。例えば：</span></p><pre><code class="language-julia hljs">SparseVecStyle(::Val{0}) = SparseVecStyle()
SparseVecStyle(::Val{1}) = SparseVecStyle()
SparseVecStyle(::Val{2}) = SparseMatStyle()
SparseVecStyle(::Val{N}) where N = Broadcast.DefaultArrayStyle{N}()</code></pre><p data-translated="true"><span class="original-text">These rules indicate that the combination of a <code>SparseVecStyle</code> with 0- or 1-dimensional arrays yields another <code>SparseVecStyle</code>, that its combination with a 2-dimensional array yields a <code>SparseMatStyle</code>, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework. These rules allow broadcasting to keep the sparse representation for operations that result in one or two dimensional outputs, but produce an <code>Array</code> for any other dimensionality.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらのルールは、<code>SparseVecStyle</code> と0次元または1次元配列の組み合わせが別の <code>SparseVecStyle</code> を生成し、2次元配列との組み合わせが <code>SparseMatStyle</code> を生成し、より高次元のものは密な任意次元フレームワークに戻ることを示しています。これらのルールにより、ブロードキャストは1次元または2次元の出力を生成する操作に対してスパース表現を維持しますが、他の次元に対しては <code>Array</code> を生成します。</span></p><h2 id="man-instance-properties" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-instance-properties">Instance Properties</a><a id="man-instance-properties-1"></a><a class="docs-heading-anchor-permalink" href="#man-instance-properties" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-instance-properties">インスタンスプロパティ</a><a id="man-instance-properties-1"></a><a class="docs-heading-anchor-permalink" href="#man-instance-properties" title="Permalink"></a></span></h2><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Methods to implement</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実装するメソッド</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Default definition</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルト定義</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Brief description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単な説明</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>propertynames(x::ObjType, private::Bool=false)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>propertynames(x::ObjType, private::Bool=false)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>fieldnames(typeof(x))</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>fieldnames(typeof(x))</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Return a tuple of the properties (<code>x.property</code>) of an object <code>x</code>. If <code>private=true</code>, also return property names intended to be kept as private</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">オブジェクト<code>x</code>のプロパティ(<code>x.property</code>)のタプルを返します。<code>private=true</code>の場合、プライベートとして保持されることを意図したプロパティ名も返します。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>getproperty(x::ObjType, s::Symbol)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>getproperty(x::ObjType, s::Symbol)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>getfield(x, s)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>getfield(x, s)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Return property <code>s</code> of <code>x</code>. <code>x.s</code> calls <code>getproperty(x, :s)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>x</code>のプロパティ<code>s</code>を返します。<code>x.s</code>は<code>getproperty(x, :s)</code>を呼び出します。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>setproperty!(x::ObjType, s::Symbol, v)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>setproperty!(x::ObjType, s::Symbol, v)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>setfield!(x, s, v)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>setfield!(x, s, v)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Set property <code>s</code> of <code>x</code> to <code>v</code>. <code>x.s = v</code> calls <code>setproperty!(x, :s, v)</code>. Should return <code>v</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>x</code>のプロパティ<code>s</code>を<code>v</code>に設定します。<code>x.s = v</code>は<code>setproperty!(x, :s, v)</code>を呼び出します。<code>v</code>を返す必要があります。</span></td></tr></tbody></table><p data-translated="true"><span class="original-text">Sometimes, it is desirable to change how the end-user interacts with the fields of an object. Instead of granting direct access to type fields, an extra layer of abstraction between the user and the code can be provided by overloading <code>object.field</code>. Properties are what the user <em>sees of</em> the object, fields what the object <em>actually is</em>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">時には、エンドユーザーがオブジェクトのフィールドとどのように対話するかを変更することが望ましいです。型フィールドへの直接アクセスを許可する代わりに、ユーザーとコードの間に追加の抽象化レイヤーを提供することができます。<code>object.field</code>をオーバーロードすることによって。プロパティはユーザーがオブジェクトの<em>見るもの</em>であり、フィールドはオブジェクトが<em>実際に何であるか</em>です。</span></p><p data-translated="true"><span class="original-text">By default, properties and fields are the same. However, this behavior can be changed. For example, take this representation of a point in a plane in <a href="https://en.wikipedia.org/wiki/Polar_coordinate_system">polar coordinates</a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトでは、プロパティとフィールドは同じです。しかし、この動作は変更できます。例えば、<a href="https://en.wikipedia.org/wiki/Polar_coordinate_system">極座標</a>における平面上の点のこの表現を考えてみてください：</span></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Point
           r::Float64
           ϕ::Float64
       end

julia&gt; p = Point(7.0, pi/4)
Point(7.0, 0.7853981633974483)</code></pre><p data-translated="true"><span class="original-text">As described in the table above dot access <code>p.r</code> is the same as <code>getproperty(p, :r)</code> which is by default the same as <code>getfield(p, :r)</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上の表に記載されているように、ドットアクセス<code>p.r</code>は<code>getproperty(p, :r)</code>と同じであり、デフォルトでは<code>getfield(p, :r)</code>と同じです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; propertynames(p)
(:r, :ϕ)

julia&gt; getproperty(p, :r), getproperty(p, :ϕ)
(7.0, 0.7853981633974483)

julia&gt; p.r, p.ϕ
(7.0, 0.7853981633974483)

julia&gt; getfield(p, :r), getproperty(p, :ϕ)
(7.0, 0.7853981633974483)</code></pre><p data-translated="true"><span class="original-text">However, we may want users to be unaware that <code>Point</code> stores the coordinates as <code>r</code> and <code>ϕ</code> (fields), and instead interact with <code>x</code> and <code>y</code> (properties). The methods in the first column can be defined to add new functionality:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、ユーザーには<code>Point</code>が座標を<code>r</code>と<code>ϕ</code>（フィールド）として保存していることを知られたくない場合があり、その代わりに<code>x</code>と<code>y</code>（プロパティ）と対話することを望むかもしれません。最初の列のメソッドは、新しい機能を追加するために定義できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Base.propertynames(::Point, private::Bool=false) = private ? (:x, :y, :r, :ϕ) : (:x, :y)

julia&gt; function Base.getproperty(p::Point, s::Symbol)
           if s === :x
               return getfield(p, :r) * cos(getfield(p, :ϕ))
           elseif s === :y
               return getfield(p, :r) * sin(getfield(p, :ϕ))
           else
               # This allows accessing fields with p.r and p.ϕ
               return getfield(p, s)
           end
       end

julia&gt; function Base.setproperty!(p::Point, s::Symbol, f)
           if s === :x
               y = p.y
               setfield!(p, :r, sqrt(f^2 + y^2))
               setfield!(p, :ϕ, atan(y, f))
               return f
           elseif s === :y
               x = p.x
               setfield!(p, :r, sqrt(x^2 + f^2))
               setfield!(p, :ϕ, atan(f, x))
               return f
           else
               # This allow modifying fields with p.r and p.ϕ
               return setfield!(p, s, f)
           end
       end</code></pre><p data-translated="true"><span class="original-text">It is important that <code>getfield</code> and <code>setfield</code> are used inside <code>getproperty</code> and <code>setproperty!</code> instead of the dot syntax, since the dot syntax would make the functions recursive which can lead to type inference issues. We can now try out the new functionality:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>getfield</code>と<code>setfield</code>は、ドット構文の代わりに<code>getproperty</code>と<code>setproperty!</code>の内部で使用されることが重要です。ドット構文を使用すると、関数が再帰的になり、型推論の問題を引き起こす可能性があります。新しい機能を試してみましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; propertynames(p)
(:x, :y)

julia&gt; p.x
4.949747468305833

julia&gt; p.y = 4.0
4.0

julia&gt; p.r
6.363961030678928</code></pre><p data-translated="true"><span class="original-text">Finally, it is worth noting that adding instance properties like this is quite rarely done in Julia and should in general only be done if there is a good reason for doing so.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最後に、このようにインスタンスプロパティを追加することはJuliaでは非常に稀であり、一般的にはそれを行う良い理由がある場合にのみ行うべきであることに注意する価値があります。</span></p><h2 id="man-rounding-interface" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-rounding-interface">Rounding</a><a id="man-rounding-interface-1"></a><a class="docs-heading-anchor-permalink" href="#man-rounding-interface" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-rounding-interface">丸め</a><a id="man-rounding-interface-1"></a><a class="docs-heading-anchor-permalink" href="#man-rounding-interface" title="Permalink"></a></span></h2><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Methods to implement</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実装するメソッド</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Default definition</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルト定義</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Brief description</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単な説明</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>round(x::ObjType, r::RoundingMode)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>round(x::ObjType, r::RoundingMode)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">none</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">なし</span></td><td style="text-align: left" data-translated="true"><span class="original-text">Round <code>x</code> and return the result. If possible, round should return an object of the same type as <code>x</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>x</code>を丸めて結果を返します。可能であれば、丸めは<code>x</code>と同じ型のオブジェクトを返すべきです。</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><code>round(T::Type, x::ObjType, r::RoundingMode)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>round(T::Type, x::ObjType, r::RoundingMode)</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text"><code>convert(T, round(x, r))</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>convert(T, round(x, r))</code></span></td><td style="text-align: left" data-translated="true"><span class="original-text">Round <code>x</code>, returning the result as a <code>T</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>x</code>を丸めて、結果を<code>T</code>として返します。</span></td></tr></tbody></table><p data-translated="true"><span class="original-text">To support rounding on a new type it is typically sufficient to define the single method <code>round(x::ObjType, r::RoundingMode)</code>. The passed rounding mode determines in which direction the value should be rounded. The most commonly used rounding modes are <code>RoundNearest</code>, <code>RoundToZero</code>, <code>RoundDown</code>, and <code>RoundUp</code>, as these rounding modes are used in the definitions of the one argument <code>round</code>, method, and <code>trunc</code>, <code>floor</code>, and <code>ceil</code>, respectively.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">新しい型での丸めをサポートするには、通常、単一のメソッド<code>round(x::ObjType, r::RoundingMode)</code>を定義するだけで十分です。渡された丸めモードは、値がどの方向に丸められるべきかを決定します。最も一般的に使用される丸めモードは、<code>RoundNearest</code>、<code>RoundToZero</code>、<code>RoundDown</code>、および<code>RoundUp</code>であり、これらの丸めモードはそれぞれ、1つの引数の<code>round</code>メソッド、<code>trunc</code>、<code>floor</code>、および<code>ceil</code>の定義で使用されます。</span></p><p data-translated="true"><span class="original-text">In some cases, it is possible to define a three-argument <code>round</code> method that is more accurate or performant than the two-argument method followed by conversion. In this case it is acceptable to define the three argument method in addition to the two argument method. If it is impossible to represent the rounded result as an object of the type <code>T</code>, then the three argument method should throw an <code>InexactError</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">場合によっては、より正確またはパフォーマンスが向上する三引数の<code>round</code>メソッドを定義することが可能です。この場合、二引数のメソッドに加えて三引数のメソッドを定義することが許可されます。丸めた結果を型<code>T</code>のオブジェクトとして表現することが不可能な場合、三引数のメソッドは<code>InexactError</code>をスローするべきです。</span></p><p data-translated="true"><span class="original-text">For example, if we have an <code>Interval</code> type which represents a range of possible values similar to https://github.com/JuliaPhysics/Measurements.jl, we may define rounding on that type with the following</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、https://github.com/JuliaPhysics/Measurements.jlに似た可能性のある値の範囲を表す<code>Interval</code>型がある場合、その型での丸めを次のように定義できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct Interval{T}
           min::T
           max::T
       end

julia&gt; Base.round(x::Interval, r::RoundingMode) = Interval(round(x.min, r), round(x.max, r))

julia&gt; x = Interval(1.7, 2.2)
Interval{Float64}(1.7, 2.2)

julia&gt; round(x)
Interval{Float64}(2.0, 2.0)

julia&gt; floor(x)
Interval{Float64}(1.0, 2.0)

julia&gt; ceil(x)
Interval{Float64}(2.0, 3.0)

julia&gt; trunc(x)
Interval{Float64}(1.0, 2.0)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../conversion-and-promotion/index.html">« Conversion and Promotion</a><a class="docs-footer-nextpage" href="../modules/index.html">Modules »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>