<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Constructors · The Julia Language</title><meta name="title" content="Constructors · The Julia Language"><meta property="og:title" content="Constructors · The Julia Language"><meta property="twitter:title" content="Constructors · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/constructors/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/constructors/"><link rel="canonical" href="index.html"><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li class="is-active"><a class="tocitem" href="">Constructors</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-outer-constructor-methods"><span>Outer Constructor Methods</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-outer-constructor-methods"><span>外部コンストラクタメソッド</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-inner-constructor-methods"><span>Inner Constructor Methods</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-inner-constructor-methods"><span>内部コンストラクタメソッド</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Incomplete-Initialization"><span>Incomplete Initialization</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Incomplete-Initialization"><span>不完全な初期化</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Parametric-Constructors"><span>Parametric Constructors</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Parametric-Constructors"><span>パラメトリックコンストラクタ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Case-Study:-Rational"><span>Case Study: Rational</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Case-Study:-Rational"><span>ケーススタディ: 有理数</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Outer-only-constructors"><span>Outer-only constructors</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Outer-only-constructors"><span>外部のみのコンストラクタ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Constructors-are-just-callable-objects"><span>Constructors are just callable objects</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Constructors-are-just-callable-objects"><span>コンストラクタは単なる呼び出し可能なオブジェクトです</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">コンストラクタ</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">コンストラクタ</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/constructors.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-constructors" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-constructors">Constructors</a><a id="man-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#man-constructors" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-constructors">コンストラクタ</a><a id="man-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#man-constructors" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">Constructors <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup> are functions that create new objects – specifically, instances of <a href="../types/index.html#Composite-Types">Composite Types</a>. In Julia, type objects also serve as constructor functions: they create new instances of themselves when applied to an argument tuple as a function. This much was already mentioned briefly when composite types were introduced. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コンストラクタ <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup> は新しいオブジェクト、具体的には <a href="../types/index.html#Composite-Types">コンポジットタイプ</a> のインスタンスを作成する関数です。Juliaでは、型オブジェクトもコンストラクタ関数として機能します：引数タプルに対して関数として適用されると、自身の新しいインスタンスを作成します。このことは、コンポジットタイプが導入されたときに簡単に言及されました。例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct Foo
           bar
           baz
       end

julia&gt; foo = Foo(1, 2)
Foo(1, 2)

julia&gt; foo.bar
1

julia&gt; foo.baz
2</code></pre><p data-translated="true"><span class="original-text">For many types, forming new objects by binding their field values together is all that is ever needed to create instances. However, in some cases more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or by transforming them. <a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29#Recursive_data_structures_.28structural_recursion.29">Recursive data structures</a>, especially those that may be self-referential, often cannot be constructed cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from object creation. Sometimes, it's just convenient to be able to construct objects with fewer or different types of parameters than they have fields. Julia's system for object construction addresses all of these cases and more.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">多くのタイプにおいて、フィールド値を結びつけることで新しいオブジェクトを形成することが、インスタンスを作成するために必要なすべてです。しかし、コンポジットオブジェクトを作成する際には、より多くの機能が必要な場合もあります。時には、引数をチェックしたり変換したりすることで不変条件を強制する必要があります。<a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29#Recursive_data_structures_.28structural_recursion.29">再帰データ構造</a>、特に自己参照的なものは、最初に不完全な状態で作成され、その後プログラム的に完全なものに変更されるという別のステップなしには、クリーンに構築できないことがよくあります。時には、フィールドが持つパラメータよりも少ない、または異なるタイプのパラメータでオブジェクトを構築できることが便利です。Juliaのオブジェクト構築システムは、これらすべてのケースに対応しています。</span></p><h2 id="man-outer-constructor-methods" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-outer-constructor-methods">Outer Constructor Methods</a><a id="man-outer-constructor-methods-1"></a><a class="docs-heading-anchor-permalink" href="#man-outer-constructor-methods" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-outer-constructor-methods">外部コンストラクタメソッド</a><a id="man-outer-constructor-methods-1"></a><a class="docs-heading-anchor-permalink" href="#man-outer-constructor-methods" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let's say you want to add a constructor method for <code>Foo</code> objects that takes only one argument and uses the given value for both the <code>bar</code> and <code>baz</code> fields. This is simple:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コンストラクタは、Juliaの他の関数と同様に、その全体的な動作はメソッドの組み合わせによって定義されます。したがって、新しいメソッドを定義することで、コンストラクタに機能を追加できます。例えば、<code>Foo</code> オブジェクトのために、1つの引数だけを受け取り、与えられた値を <code>bar</code> と <code>baz</code> フィールドの両方に使用するコンストラクタメソッドを追加したいとしましょう。これは簡単です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Foo(x) = Foo(x,x)
Foo

julia&gt; Foo(1)
Foo(1, 1)</code></pre><p data-translated="true"><span class="original-text">You could also add a zero-argument <code>Foo</code> constructor method that supplies default values for both of the <code>bar</code> and <code>baz</code> fields:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、<code>bar</code> と <code>baz</code> フィールドの両方にデフォルト値を供給するゼロ引数の <code>Foo</code> コンストラクタメソッドを追加することもできます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Foo() = Foo(0)
Foo

julia&gt; Foo()
Foo(0, 0)</code></pre><p data-translated="true"><span class="original-text">Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called <em>outer</em> constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで、ゼロ引数のコンストラクタメソッドは、単一引数のコンストラクタメソッドを呼び出し、そのメソッドは自動的に提供される二引数のコンストラクタメソッドを呼び出します。すぐに明らかになる理由から、このように通常のメソッドとして宣言された追加のコンストラクタメソッドは <em>外部</em> コンストラクタメソッドと呼ばれます。外部コンストラクタメソッドは、他のコンストラクタメソッド、例えば自動的に提供されるデフォルトのものを呼び出すことによってのみ、新しいインスタンスを作成できます。</span></p><h2 id="man-inner-constructor-methods" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-inner-constructor-methods">Inner Constructor Methods</a><a id="man-inner-constructor-methods-1"></a><a class="docs-heading-anchor-permalink" href="#man-inner-constructor-methods" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-inner-constructor-methods">内部コンストラクタメソッド</a><a id="man-inner-constructor-methods-1"></a><a class="docs-heading-anchor-permalink" href="#man-inner-constructor-methods" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">While outer constructor methods succeed in addressing the problem of providing additional convenience methods for constructing objects, they fail to address the other two use cases mentioned in the introduction of this chapter: enforcing invariants, and allowing construction of self-referential objects. For these problems, one needs <em>inner</em> constructor methods. An inner constructor method is like an outer constructor method, except for two differences:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">外部コンストラクタメソッドは、オブジェクトを構築するための追加の便利なメソッドを提供する問題に対処することには成功していますが、この章の導入で言及された他の2つのユースケース、すなわち不変条件の強制と自己参照オブジェクトの構築を許可することには対処できません。これらの問題には、<em>内部</em> コンストラクタメソッドが必要です。内部コンストラクタメソッドは、外部コンストラクタメソッドと似ていますが、2つの違いがあります：</span></p><ol><li data-translated="true"><span class="original-text">It is declared inside the block of a type declaration, rather than outside of it like normal methods.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型宣言のブロック内で宣言され、通常のメソッドのように外部では宣言されません。</span></li><li data-translated="true"><span class="original-text">It has access to a special locally existent function called <a href="../../base/base/index.html#new"><code>new</code></a> that creates objects of the block's type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ブロックの型のオブジェクトを作成する特別なローカルに存在する関数 <a href="../../base/base/index.html#new"><code>new</code></a> にアクセスできます。</span></li></ol><p data-translated="true"><span class="original-text">For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、最初の数が2番目の数より大きくないという制約のもとで、実数のペアを保持する型を宣言したいとします。このように宣言することができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct OrderedPair
           x::Real
           y::Real
           OrderedPair(x,y) = x &gt; y ? error("out of order") : new(x,y)
       end</code></pre><p data-translated="true"><span class="original-text">Now <code>OrderedPair</code> objects can only be constructed such that <code>x &lt;= y</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これで、<code>OrderedPair</code>オブジェクトは<code>x &lt;= y</code>となるようにのみ構築できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; OrderedPair(1, 2)
OrderedPair(1, 2)

julia&gt; OrderedPair(2,1)
ERROR: out of order
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] OrderedPair(::Int64, ::Int64) at ./none:4
 [3] top-level scope</code></pre><p data-translated="true"><span class="original-text">If the type were declared <code>mutable</code>, you could reach in and directly change the field values to violate this invariant. Of course, messing around with an object's internals uninvited is bad practice. You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type's invariants.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型が<code>mutable</code>として宣言されている場合、フィールドの値を直接変更してこの不変条件を破ることができます。もちろん、オブジェクトの内部に無断で手を加えることは悪い習慣です。あなた（または他の誰か）が後で追加の外部コンストラクタメソッドを提供することもできますが、一度型が宣言されると、内部コンストラクタメソッドを追加する方法はありません。外部コンストラクタメソッドは他のコンストラクタメソッドを呼び出すことによってのみオブジェクトを作成できるため、最終的にはオブジェクトを作成するためにいくつかの内部コンストラクタが呼び出されなければなりません。これにより、宣言された型のすべてのオブジェクトは、型に提供された内部コンストラクタメソッドのいずれかを呼び出すことによって存在することが保証され、型の不変条件のある程度の強制が行われます。</span></p><p data-translated="true"><span class="original-text">If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object's fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to <code>new</code>, returning the resulting object:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">内部コンストラクタメソッドが定義されている場合、デフォルトコンストラクタメソッドは提供されません：必要なすべての内部コンストラクタを自分で用意したと見なされます。デフォルトコンストラクタは、オブジェクトのすべてのフィールドをパラメータとして受け取る独自の内部コンストラクタメソッドを書くことと同等であり（対応するフィールドが型を持つ場合は正しい型に制約され）、それらを<code>new</code>に渡して結果のオブジェクトを返します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct Foo
           bar
           baz
           Foo(bar,baz) = new(bar,baz)
       end
</code></pre><p data-translated="true"><span class="original-text">This declaration has the same effect as the earlier definition of the <code>Foo</code> type without an explicit inner constructor method. The following two types are equivalent – one with a default constructor, the other with an explicit constructor:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この宣言は、明示的な内部コンストラクタメソッドなしの<code>Foo</code>型の以前の定義と同じ効果があります。次の2つの型は等価です - 1つはデフォルトコンストラクタを持ち、もう1つは明示的なコンストラクタを持っています：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct T1
           x::Int64
       end

julia&gt; struct T2
           x::Int64
           T2(x) = new(x)
       end

julia&gt; T1(1)
T1(1)

julia&gt; T2(1)
T2(1)

julia&gt; T1(1.0)
T1(1)

julia&gt; T2(1.0)
T2(1)</code></pre><p data-translated="true"><span class="original-text">It is good practice to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is typically quite natural.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">内部コンストラクタメソッドはできるだけ少なく提供することが良い習慣です：すべての引数を明示的に受け取り、重要なエラーチェックと変換を強制するものだけです。デフォルト値や補助的な変換を提供する追加の便利なコンストラクタメソッドは、内部コンストラクタを呼び出して重い作業を行う外部コンストラクタとして提供されるべきです。この分離は通常非常に自然です。</span></p><h2 id="Incomplete-Initialization" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Incomplete-Initialization">Incomplete Initialization</a><a id="Incomplete-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Incomplete-Initialization" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Incomplete-Initialization">不完全な初期化</a><a id="Incomplete-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Incomplete-Initialization" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">The final problem which has still not been addressed is construction of self-referential objects, or more generally, recursive data structures. Since the fundamental difficulty may not be immediately obvious, let us briefly explain it. Consider the following recursive type declaration:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">まだ対処されていない最終的な問題は、自己参照オブジェクト、またはより一般的には再帰的データ構造の構築です。根本的な難しさはすぐには明らかでないかもしれないので、簡単に説明しましょう。次の再帰的型宣言を考えてみてください：</span></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct SelfReferential
           obj::SelfReferential
       end
</code></pre><p data-translated="true"><span class="original-text">This type may appear innocuous enough, until one considers how to construct an instance of it. If <code>a</code> is an instance of <code>SelfReferential</code>, then a second instance can be created by the call:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この型は無害に見えるかもしれませんが、インスタンスを構築する方法を考えるとそうではありません。もし<code>a</code>が<code>SelfReferential</code>のインスタンスであれば、2番目のインスタンスは次の呼び出しによって作成できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; b = SelfReferential(a)</code></pre><p data-translated="true"><span class="original-text">But how does one construct the first instance when no instance exists to provide as a valid value for its <code>obj</code> field? The only solution is to allow creating an incompletely initialized instance of <code>SelfReferential</code> with an unassigned <code>obj</code> field, and using that incomplete instance as a valid value for the <code>obj</code> field of another instance, such as, for example, itself.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、<code>obj</code>フィールドに対して有効な値を提供するインスタンスが存在しない場合、最初のインスタンスをどのように構築するのでしょうか？唯一の解決策は、未割り当ての<code>obj</code>フィールドを持つ不完全に初期化された<code>SelfReferential</code>インスタンスを作成し、その不完全なインスタンスを別のインスタンスの<code>obj</code>フィールドの有効な値として使用することです。例えば、それ自身のように。</span></p><p data-translated="true"><span class="original-text">To allow for the creation of incompletely initialized objects, Julia allows the <a href="../../base/base/index.html#new"><code>new</code></a> function to be called with fewer than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use the incomplete object, finishing its initialization before returning it. Here, for example, is another attempt at defining the <code>SelfReferential</code> type, this time using a zero-argument inner constructor returning instances having <code>obj</code> fields pointing to themselves:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">不完全に初期化されたオブジェクトの作成を許可するために、Juliaは<a href="../../base/base/index.html#new"><code>new</code></a>関数を、型が持つフィールドの数よりも少ない数で呼び出すことを許可し、指定されていないフィールドが初期化されていないオブジェクトを返します。内部コンストラクタメソッドは、その後、不完全なオブジェクトを使用して初期化を完了し、返すことができます。ここでは、例えば、<code>SelfReferential</code>型を定義する別の試みを示します。今回は、<code>obj</code>フィールドが自分自身を指すインスタンスを返すゼロ引数の内部コンストラクタを使用しています：</span></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct SelfReferential
           obj::SelfReferential
           SelfReferential() = (x = new(); x.obj = x)
       end
</code></pre><p data-translated="true"><span class="original-text">We can verify that this constructor works and constructs objects that are, in fact, self-referential:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このコンストラクタが機能し、実際に自己参照型のオブジェクトを構築することを確認できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = SelfReferential();

julia&gt; x === x
true

julia&gt; x === x.obj
true

julia&gt; x === x.obj.obj
true</code></pre><p data-translated="true"><span class="original-text">Although it is generally a good idea to return a fully initialized object from an inner constructor, it is possible to return incompletely initialized objects:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般的には、内部コンストラクタから完全に初期化されたオブジェクトを返すことが良いアイデアですが、不完全に初期化されたオブジェクトを返すことも可能です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Incomplete
           data
           Incomplete() = new()
       end

julia&gt; z = Incomplete();</code></pre><p data-translated="true"><span class="original-text">While you are allowed to create objects with uninitialized fields, any access to an uninitialized reference is an immediate error:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">初期化されていないフィールドを持つオブジェクトを作成することは許可されていますが、初期化されていない参照にアクセスすると即座にエラーが発生します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; z.data
ERROR: UndefRefError: access to undefined reference</code></pre><p data-translated="true"><span class="original-text">This avoids the need to continually check for <code>null</code> values. However, not all object fields are references. Julia considers some types to be "plain data", meaning all of their data is self-contained and does not reference other objects. The plain data types consist of primitive types (e.g. <code>Int</code>) and immutable structs of other plain data types (see also: <a href="../../base/base/index.html#Base.isbits"><code>isbits</code></a>, <a href="../../base/base/index.html#Base.isbitstype"><code>isbitstype</code></a>). The initial contents of a plain data type is undefined:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これにより、<code>null</code>値を継続的にチェックする必要がなくなります。ただし、すべてのオブジェクトフィールドが参照であるわけではありません。Juliaは、いくつかの型を「プレーンデータ」と見なしており、これはすべてのデータが自己完結しており、他のオブジェクトを参照しないことを意味します。プレーンデータ型は、プリミティブ型（例：<code>Int</code>）や他のプレーンデータ型の不変構造体で構成されています（参照：<a href="../../base/base/index.html#Base.isbits"><code>isbits</code></a>、<a href="../../base/base/index.html#Base.isbitstype"><code>isbitstype</code></a>）。プレーンデータ型の初期内容は未定義です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct HasPlain
           n::Int
           HasPlain() = new()
       end

julia&gt; HasPlain()
HasPlain(438103441441)</code></pre><p data-translated="true"><span class="original-text">Arrays of plain data types exhibit the same behavior.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プレーンデータ型の配列も同様の動作を示します。</span></p><p data-translated="true"><span class="original-text">You can pass incomplete objects to other functions from inner constructors to delegate their completion:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">内部コンストラクタから他の関数に不完全なオブジェクトを渡して、その完了を委任することができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Lazy
           data
           Lazy(v) = complete_me(new(), v)
       end</code></pre><p data-translated="true"><span class="original-text">As with incomplete objects returned from constructors, if <code>complete_me</code> or any of its callees try to access the <code>data</code> field of the <code>Lazy</code> object before it has been initialized, an error will be thrown immediately.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コンストラクタから返された不完全なオブジェクトと同様に、<code>complete_me</code>またはその呼び出し先が、<code>Lazy</code>オブジェクトの<code>data</code>フィールドに初期化される前にアクセスしようとすると、即座にエラーが発生します。</span></p><h2 id="Parametric-Constructors" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Parametric-Constructors">Parametric Constructors</a><a id="Parametric-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Constructors" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Parametric-Constructors">パラメトリックコンストラクタ</a><a id="Parametric-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Constructors" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Parametric types add a few wrinkles to the constructor story. Recall from <a href="../types/index.html#Parametric-Types">Parametric Types</a> that, by default, instances of parametric composite types can be constructed either with explicitly given type parameters or with type parameters implied by the types of the arguments given to the constructor. Here are some examples:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パラメトリック型は、コンストラクタの話にいくつかの複雑さを加えます。<a href="../types/index.html#Parametric-Types">パラメトリック型</a>から思い出してください。デフォルトでは、パラメトリック合成型のインスタンスは、明示的に与えられた型パラメータまたはコンストラクタに与えられた引数の型によって暗示された型パラメータのいずれかで構築できます。以下はいくつかの例です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct Point{T&lt;:Real}
           x::T
           y::T
       end

julia&gt; Point(1,2) ## implicit T ##
Point{Int64}(1, 2)

julia&gt; Point(1.0,2.5) ## implicit T ##
Point{Float64}(1.0, 2.5)

julia&gt; Point(1,2.5) ## implicit T ##
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
The type `Point` exists, but no method is defined for this combination of argument types when trying to construct it.

Closest candidates are:
  Point(::T, ::T) where T&lt;:Real at none:2

julia&gt; Point{Int64}(1, 2) ## explicit T ##
Point{Int64}(1, 2)

julia&gt; Point{Int64}(1.0,2.5) ## explicit T ##
ERROR: InexactError: Int64(2.5)
Stacktrace:
[...]

julia&gt; Point{Float64}(1.0, 2.5) ## explicit T ##
Point{Float64}(1.0, 2.5)

julia&gt; Point{Float64}(1,2) ## explicit T ##
Point{Float64}(1.0, 2.0)</code></pre><p data-translated="true"><span class="original-text">As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: <code>Point{Int64}(1,2)</code> works, but <code>Point{Int64}(1.0,2.5)</code> raises an <a href="../../base/base/index.html#Core.InexactError"><code>InexactError</code></a> when converting <code>2.5</code> to <a href="../../base/numbers/index.html#Core.Int64"><code>Int64</code></a>. When the type is implied by the arguments to the constructor call, as in <code>Point(1,2)</code>, then the types of the arguments must agree – otherwise the <code>T</code> cannot be determined – but any pair of real arguments with matching type may be given to the generic <code>Point</code> constructor.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ご覧の通り、明示的な型パラメータを持つコンストラクタ呼び出しでは、引数が暗黙のフィールド型に変換されます：<code>Point{Int64}(1,2)</code> は動作しますが、<code>Point{Int64}(1.0,2.5)</code> は <a href="../../base/base/index.html#Core.InexactError"><code>InexactError</code></a> を引き起こします。これは <code>2.5</code> を <a href="../../base/numbers/index.html#Core.Int64"><code>Int64</code></a> に変換する際に発生します。コンストラクタ呼び出しの引数によって型が暗黙的に決定される場合、例えば <code>Point(1,2)</code> のように、引数の型は一致する必要があります。そうでないと <code>T</code> を決定できませんが、型が一致する任意の実数のペアを一般的な <code>Point</code> コンストラクタに渡すことができます。</span></p><p data-translated="true"><span class="original-text">What's really going on here is that <code>Point</code>, <code>Point{Float64}</code> and <code>Point{Int64}</code> are all different constructor functions. In fact, <code>Point{T}</code> is a distinct constructor function for each type <code>T</code>. Without any explicitly provided inner constructors, the declaration of the composite type <code>Point{T&lt;:Real}</code> automatically provides an inner constructor, <code>Point{T}</code>, for each possible type <code>T&lt;:Real</code>, that behaves just like non-parametric default inner constructors do. It also provides a single general outer <code>Point</code> constructor that takes pairs of real arguments, which must be of the same type. This automatic provision of constructors is equivalent to the following explicit declaration:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで実際に起こっていることは、<code>Point</code>、<code>Point{Float64}</code>、および <code>Point{Int64}</code> がすべて異なるコンストラクタ関数であるということです。実際、<code>Point{T}</code> は各型 <code>T</code> に対して異なるコンストラクタ関数です。明示的に提供された内部コンストラクタがない場合、合成型 <code>Point{T&lt;:Real}</code> の宣言は、自動的に各可能な型 <code>T&lt;:Real</code> に対して内部コンストラクタ <code>Point{T}</code> を提供し、これは非パラメトリックなデフォルト内部コンストラクタと同様に動作します。また、同じ型の実数引数のペアを受け取る一般的な外部 <code>Point</code> コンストラクタも提供されます。このコンストラクタの自動提供は、次の明示的な宣言に相当します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct Point{T&lt;:Real}
           x::T
           y::T
           Point{T}(x,y) where {T&lt;:Real} = new(x,y)
       end

julia&gt; Point(x::T, y::T) where {T&lt;:Real} = Point{T}(x,y);</code></pre><p data-translated="true"><span class="original-text">Notice that each definition looks like the form of constructor call that it handles. The call <code>Point{Int64}(1,2)</code> will invoke the definition <code>Point{T}(x,y)</code> inside the <code>struct</code> block. The outer constructor declaration, on the other hand, defines a method for the general <code>Point</code> constructor which only applies to pairs of values of the same real type. This declaration makes constructor calls without explicit type parameters, like <code>Point(1,2)</code> and <code>Point(1.0,2.5)</code>, work. Since the method declaration restricts the arguments to being of the same type, calls like <code>Point(1,2.5)</code>, with arguments of different types, result in "no method" errors.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各定義が処理するコンストラクタ呼び出しの形式に似ていることに注意してください。呼び出し <code>Point{Int64}(1,2)</code> は、<code>struct</code> ブロック内の定義 <code>Point{T}(x,y)</code> を呼び出します。一方、外部コンストラクタの宣言は、同じ実数型の値のペアにのみ適用される一般的な <code>Point</code> コンストラクタのメソッドを定義します。この宣言により、<code>Point(1,2)</code> や <code>Point(1.0,2.5)</code> のような明示的な型パラメータなしのコンストラクタ呼び出しが機能します。メソッド宣言が引数を同じ型に制限するため、異なる型の引数を持つ呼び出し <code>Point(1,2.5)</code> は「メソッドなし」エラーになります。</span></p><p data-translated="true"><span class="original-text">Suppose we wanted to make the constructor call <code>Point(1,2.5)</code> work by "promoting" the integer value <code>1</code> to the floating-point value <code>1.0</code>. The simplest way to achieve this is to define the following additional outer constructor method:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">整数値 <code>1</code> を浮動小数点値 <code>1.0</code> に「昇格」させることで、コンストラクタ呼び出し <code>Point(1,2.5)</code> を機能させたいとします。これを達成する最も簡単な方法は、次の追加の外部コンストラクタメソッドを定義することです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Point(x::Int64, y::Float64) = Point(convert(Float64,x),y);</code></pre><p data-translated="true"><span class="original-text">This method uses the <a href="../../base/base/index.html#Base.convert"><code>convert</code></a> function to explicitly convert <code>x</code> to <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> and then delegates construction to the general constructor for the case where both arguments are <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>. With this method definition what was previously a <a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a> now successfully creates a point of type <code>Point{Float64}</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このメソッドは、<a href="../../base/base/index.html#Base.convert"><code>convert</code></a> 関数を使用して <code>x</code> を明示的に <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> に変換し、その後、両方の引数が <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> である場合の一般的なコンストラクタに委譲します。このメソッド定義により、以前は <a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a> だったものが、今では <code>Point{Float64}</code> 型のポイントを正常に作成します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; p = Point(1,2.5)
Point{Float64}(1.0, 2.5)

julia&gt; typeof(p)
Point{Float64}</code></pre><p data-translated="true"><span class="original-text">However, other similar calls still don't work:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、他の類似の呼び出しはまだ機能しません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Point(1.5,2)
ERROR: MethodError: no method matching Point(::Float64, ::Int64)
The type `Point` exists, but no method is defined for this combination of argument types when trying to construct it.

Closest candidates are:
  Point(::T, !Matched::T) where T&lt;:Real
   @ Main none:1
  Point(!Matched::Int64, !Matched::Float64)
   @ Main none:1

Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">For a more general way to make all such calls work sensibly, see <a href="../conversion-and-promotion/index.html#conversion-and-promotion">Conversion and Promotion</a>. At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general <code>Point</code> constructor work as one would expect:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべてのそのような呼び出しを適切に機能させるためのより一般的な方法については、<a href="../conversion-and-promotion/index.html#conversion-and-promotion">変換と昇格</a>を参照してください。サスペンスを台無しにするリスクを冒して、ここで明らかにできるのは、一般的な <code>Point</code> コンストラクタへのすべての呼び出しを期待通りに機能させるためには、次の外部メソッド定義が必要であるということです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Point(x::Real, y::Real) = Point(promote(x,y)...);</code></pre><p data-translated="true"><span class="original-text">The <code>promote</code> function converts all its arguments to a common type – in this case <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>. With this method definition, the <code>Point</code> constructor promotes its arguments the same way that numeric operators like <a href="../../base/math/#Base.:+#Base.:+"><code>+</code></a> do, and works for all kinds of real numbers:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>promote</code> 関数は、すべての引数を共通の型に変換します。この場合は <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> です。このメソッド定義により、<code>Point</code> コンストラクタは、<a href="../../base/math/#Base.:+#Base.:+"><code>+</code></a> のような数値演算子と同じ方法で引数を昇格させ、すべての種類の実数に対して機能します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Point(1.5,2)
Point{Float64}(1.5, 2.0)

julia&gt; Point(1,1//2)
Point{Rational{Int64}}(1//1, 1//2)

julia&gt; Point(1.0,1//2)
Point{Float64}(1.0, 0.5)</code></pre><p data-translated="true"><span class="original-text">Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior is typically quite simple.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、Julia にデフォルトで提供される暗黙の型パラメータコンストラクタはかなり厳格ですが、よりリラックスしたが合理的な方法で動作させることは非常に簡単です。さらに、コンストラクタは型システム、メソッド、および多重ディスパッチのすべての力を活用できるため、洗練された動作を定義することは通常非常に簡単です。</span></p><h2 id="Case-Study:-Rational" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Case-Study:-Rational">Case Study: Rational</a><a id="Case-Study:-Rational-1"></a><a class="docs-heading-anchor-permalink" href="#Case-Study:-Rational" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Case-Study:-Rational">ケーススタディ：Rational</a><a id="Case-Study:-Rational-1"></a><a class="docs-heading-anchor-permalink" href="#Case-Study:-Rational" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Perhaps the best way to tie all these pieces together is to present a real world example of a parametric composite type and its constructor methods. To that end, we implement our own rational number type <code>OurRational</code>, similar to Julia's built-in <a href="../../base/numbers/index.html#Base.Rational"><code>Rational</code></a> type, defined in <a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl"><code>rational.jl</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの要素をすべて結びつける最良の方法は、パラメトリックコンポジット型とそのコンストラクタメソッドの実世界の例を示すことです。そのために、私たち自身の有理数型<code>OurRational</code>を実装します。これは、Juliaの組み込み<a href="../../base/numbers/index.html#Base.Rational"><code>Rational</code></a>型に似ています。これは<a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl"><code>rational.jl</code></a>で定義されています。</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct OurRational{T&lt;:Integer} &lt;: Real
           num::T
           den::T
           function OurRational{T}(num::T, den::T) where T&lt;:Integer
               if num == 0 &amp;&amp; den == 0
                    error("invalid rational: 0//0")
               end
               num = flipsign(num, den)
               den = flipsign(den, den)
               g = gcd(num, den)
               num = div(num, g)
               den = div(den, g)
               new(num, den)
           end
       end

julia&gt; OurRational(n::T, d::T) where {T&lt;:Integer} = OurRational{T}(n,d)
OurRational

julia&gt; OurRational(n::Integer, d::Integer) = OurRational(promote(n,d)...)
OurRational

julia&gt; OurRational(n::Integer) = OurRational(n,one(n))
OurRational

julia&gt; ⊘(n::Integer, d::Integer) = OurRational(n,d)
⊘ (generic function with 1 method)

julia&gt; ⊘(x::OurRational, y::Integer) = x.num ⊘ (x.den*y)
⊘ (generic function with 2 methods)

julia&gt; ⊘(x::Integer, y::OurRational) = (x*y.den) ⊘ y.num
⊘ (generic function with 3 methods)

julia&gt; ⊘(x::Complex, y::Real) = complex(real(x) ⊘ y, imag(x) ⊘ y)
⊘ (generic function with 4 methods)

julia&gt; ⊘(x::Real, y::Complex) = (x*y') ⊘ real(y*y')
⊘ (generic function with 5 methods)

julia&gt; function ⊘(x::Complex, y::Complex)
           xy = x*y'
           yy = real(y*y')
           complex(real(xy) ⊘ yy, imag(xy) ⊘ yy)
       end
⊘ (generic function with 6 methods)</code></pre><p data-translated="true"><span class="original-text">The first line – <code>struct OurRational{T&lt;:Integer} &lt;: Real</code> – declares that <code>OurRational</code> takes one type parameter of an integer type, and is itself a real type. The field declarations <code>num::T</code> and <code>den::T</code> indicate that the data held in a <code>OurRational{T}</code> object are a pair of integers of type <code>T</code>, one representing the rational value's numerator and the other representing its denominator.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初の行 – <code>struct OurRational{T&lt;:Integer} &lt;: Real</code> – は、<code>OurRational</code>が整数型の1つの型パラメータを取ることを宣言し、かつそれ自体が実数型であることを示しています。フィールド宣言<code>num::T</code>と<code>den::T</code>は、<code>OurRational{T}</code>オブジェクトに保持されるデータが、1つは有理数の分子を、もう1つは分母を表す型<code>T</code>の整数のペアであることを示しています。</span></p><p data-translated="true"><span class="original-text">Now things get interesting. <code>OurRational</code> has a single inner constructor method which checks that <code>num</code> and <code>den</code> aren't both zero and ensures that every rational is constructed in "lowest terms" with a non-negative denominator. This is accomplished by first flipping the signs of numerator and denominator if the denominator is negative. Then, both are divided by their greatest common divisor (<code>gcd</code> always returns a non-negative number, regardless of the sign of its arguments). Because this is the only inner constructor for <code>OurRational</code>, we can be certain that <code>OurRational</code> objects are always constructed in this normalized form.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さて、興味深いことが起こります。<code>OurRational</code>には、<code>num</code>と<code>den</code>が両方ともゼロでないことを確認し、すべての有理数が分母が非負の「最小項」で構築されることを保証する単一の内部コンストラクタメソッドがあります。これは、分母が負の場合に分子と分母の符号を反転させることから始まります。その後、両方を最大公約数で割ります（<code>gcd</code>は常に引数の符号に関係なく非負の数を返します）。これは<code>OurRational</code>の唯一の内部コンストラクタであるため、<code>OurRational</code>オブジェクトが常にこの正規化された形式で構築されることが確実です。</span></p><p data-translated="true"><span class="original-text"><code>OurRational</code> also provides several outer constructor methods for convenience. The first is the "standard" general constructor that infers the type parameter <code>T</code> from the type of the numerator and denominator when they have the same type. The second applies when the given numerator and denominator values have different types: it promotes them to a common type and then delegates construction to the outer constructor for arguments of matching type. The third outer constructor turns integer values into rationals by supplying a value of <code>1</code> as the denominator.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>OurRational</code>は、便利さのためにいくつかの外部コンストラクタメソッドも提供しています。最初は、分子と分母が同じ型を持つ場合に型パラメータ<code>T</code>を推論する「標準」一般コンストラクタです。2番目は、与えられた分子と分母の値が異なる型を持つ場合に適用されます：それらを共通の型に昇格させ、その後、型が一致する引数の外部コンストラクタに構築を委任します。3番目の外部コンストラクタは、整数値を有理数に変換するために、分母として<code>1</code>の値を提供します。</span></p><p data-translated="true"><span class="original-text">Following the outer constructor definitions, we defined a number of methods for the <code>⊘</code> operator, which provides a syntax for writing rationals (e.g. <code>1 ⊘ 2</code>). Julia's <code>Rational</code> type uses the <a href="../../base/math/#Base.://#Base.://"><code>//</code></a> operator for this purpose. Before these definitions, <code>⊘</code> is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in <a href="../complex-and-rational-numbers/index.html#Rational-Numbers">Rational Numbers</a> – its entire behavior is defined in these few lines. Note that the infix use of <code>⊘</code> works because Julia has a set of symbols that are recognized to be infix operators. The first and most basic definition just makes <code>a ⊘ b</code> construct a <code>OurRational</code> by applying the <code>OurRational</code> constructor to <code>a</code> and <code>b</code> when they are integers. When one of the operands of <code>⊘</code> is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer. Finally, applying <code>⊘</code> to complex integral values creates an instance of <code>Complex{&lt;:OurRational}</code> – a complex number whose real and imaginary parts are rationals:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">外部コンストラクタの定義に続いて、<code>⊘</code>演算子のためにいくつかのメソッドを定義しました。これは、有理数を書くための構文を提供します（例：<code>1 ⊘ 2</code>）。Juliaの<code>Rational</code>型は、この目的のために<a href="../../base/math/#Base.://#Base.://"><code>//</code></a>演算子を使用します。これらの定義の前では、<code>⊘</code>は完全に未定義の演算子であり、構文のみで意味はありません。その後、<a href="../complex-and-rational-numbers/index.html#Rational-Numbers">有理数</a>で説明されているように振る舞います – その全体の動作はこれらの数行で定義されています。<code>⊘</code>の中置使用が機能するのは、Juliaが中置演算子として認識されるシンボルのセットを持っているためです。最初の基本的な定義は、<code>a ⊘ b</code>が整数であるときに<code>OurRational</code>を構築することを単に行います。<code>⊘</code>のオペランドの1つがすでに有理数である場合、結果の比率のために新しい有理数を少し異なる方法で構築します。この動作は、実際には整数との有理数の除算と同じです。最後に、<code>⊘</code>を複素整数値に適用すると、<code>Complex{&lt;:OurRational}</code>のインスタンスが作成されます – 実部と虚部が有理数である複素数です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; z = (1 + 2im) ⊘ (1 - 2im);

julia&gt; typeof(z)
Complex{OurRational{Int64}}

julia&gt; typeof(z) &lt;: Complex{&lt;:OurRational}
true</code></pre><p data-translated="true"><span class="original-text">Thus, although the <code>⊘</code> operator usually returns an instance of <code>OurRational</code>, if either of its arguments are complex integers, it will return an instance of <code>Complex{&lt;:OurRational}</code> instead. The interested reader should consider perusing the rest of <a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl"><code>rational.jl</code></a>: it is short, self-contained, and implements an entire basic Julia type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、<code>⊘</code>演算子は通常<code>OurRational</code>のインスタンスを返しますが、引数のいずれかが複素整数である場合は、代わりに<code>Complex{&lt;:OurRational}</code>のインスタンスを返します。興味のある読者は、<a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl"><code>rational.jl</code></a>の残りを読むことを検討すべきです：それは短く、自己完結しており、基本的なJulia型全体を実装しています。</span></p><h2 id="Outer-only-constructors" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Outer-only-constructors">Outer-only constructors</a><a id="Outer-only-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Outer-only-constructors" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Outer-only-constructors">外部専用コンストラクタ</a><a id="Outer-only-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Outer-only-constructors" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to <code>Point{Int}</code> but not to <code>Point</code>. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a <code>Point{Int}</code> from the call <code>Point(1,2)</code>. Outer constructors call inner constructors to actually make instances. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ご覧のように、典型的なパラメトリック型には、型パラメータが既知のときに呼び出される内部コンストラクタがあります。例えば、<code>Point{Int}</code>には適用されますが、<code>Point</code>には適用されません。オプションで、型パラメータを自動的に決定する外部コンストラクタを追加することができます。例えば、<code>Point(1,2)</code>から<code>Point{Int}</code>を構築することができます。外部コンストラクタは、実際にインスタンスを作成するために内部コンストラクタを呼び出します。しかし、場合によっては、特定の型パラメータを手動で要求できないように、内部コンストラクタを提供しない方が良いことがあります。</span></p><p data-translated="true"><span class="original-text">For example, say we define a type that stores a vector along with an accurate representation of its sum:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、ベクトルとその合計の正確な表現を保存する型を定義するとしましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct SummedArray{T&lt;:Number,S&lt;:Number}
           data::Vector{T}
           sum::S
       end

julia&gt; SummedArray(Int32[1; 2; 3], Int32(6))
SummedArray{Int32, Int32}(Int32[1, 2, 3], 6)</code></pre><p data-translated="true"><span class="original-text">The problem is that we want <code>S</code> to be a larger type than <code>T</code>, so that we can sum many elements with less information loss. For example, when <code>T</code> is <a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a>, we would like <code>S</code> to be <a href="../../base/numbers/index.html#Core.Int64"><code>Int64</code></a>. Therefore we want to avoid an interface that allows the user to construct instances of the type <code>SummedArray{Int32,Int32}</code>. One way to do this is to provide a constructor only for <code>SummedArray</code>, but inside the <code>struct</code> definition block to suppress generation of default constructors:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">問題は、<code>S</code>が<code>T</code>よりも大きな型である必要があるため、情報損失を少なくして多くの要素を合計できるようにしたいということです。例えば、<code>T</code>が<a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a>である場合、<code>S</code>は<a href="../../base/numbers/index.html#Core.Int64"><code>Int64</code></a>であることを望みます。したがって、ユーザーが型<code>SummedArray{Int32,Int32}</code>のインスタンスを構築できるインターフェースを避けたいのです。これを行う1つの方法は、<code>SummedArray</code>のためのコンストラクタのみを提供し、<code>struct</code>定義ブロック内でデフォルトコンストラクタの生成を抑制することです。</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct SummedArray{T&lt;:Number,S&lt;:Number}
           data::Vector{T}
           sum::S
           function SummedArray(a::Vector{T}) where T
               S = widen(T)
               new{T,S}(a, sum(S, a))
           end
       end

julia&gt; SummedArray(Int32[1; 2; 3], Int32(6))
ERROR: MethodError: no method matching SummedArray(::Vector{Int32}, ::Int32)
The type `SummedArray` exists, but no method is defined for this combination of argument types when trying to construct it.

Closest candidates are:
  SummedArray(::Vector{T}) where T
   @ Main none:4

Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">This constructor will be invoked by the syntax <code>SummedArray(a)</code>. The syntax <code>new{T,S}</code> allows specifying parameters for the type to be constructed, i.e. this call will return a <code>SummedArray{T,S}</code>. <code>new{T,S}</code> can be used in any constructor definition, but for convenience the parameters to <code>new{}</code> are automatically derived from the type being constructed when possible.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このコンストラクタは、構文 <code>SummedArray(a)</code> によって呼び出されます。構文 <code>new{T,S}</code> は、構築される型のパラメータを指定することを可能にします。つまり、この呼び出しは <code>SummedArray{T,S}</code> を返します。<code>new{T,S}</code> は任意のコンストラクタ定義で使用できますが、便利さのために <code>new{}</code> のパラメータは、可能な場合に構築される型から自動的に導出されます。</span></p><h2 id="Constructors-are-just-callable-objects" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Constructors-are-just-callable-objects">Constructors are just callable objects</a><a id="Constructors-are-just-callable-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors-are-just-callable-objects" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Constructors-are-just-callable-objects">コンストラクタは単なる呼び出し可能なオブジェクトです</a><a id="Constructors-are-just-callable-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors-are-just-callable-objects" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">An object of any type may be <a href="../methods/index.html#Function-like-objects">made callable</a> by defining a method. This includes types, i.e., objects of type <a href="../../base/base/index.html#Core.Type"><code>Type</code></a>; and constructors may, in fact, be viewed as just callable type objects. For example, there are many methods defined on <code>Bool</code> and various supertypes of it:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">任意の型のオブジェクトは、メソッドを定義することによって <a href="../methods/index.html#Function-like-objects">呼び出し可能にする</a> ことができます。これには型、すなわち <a href="../../base/base/index.html#Core.Type"><code>Type</code></a> 型のオブジェクトが含まれます。また、コンストラクタは実際には単なる呼び出し可能な型オブジェクトとして見ることができます。例えば、<code>Bool</code> およびそのさまざまなスーパタイプに対して多くのメソッドが定義されています。</span></p><pre><code class="language-julia-repl hljs">julia&gt; methods(Bool)
# 10 methods for type constructor:
  [1] Bool(x::BigFloat)
     @ Base.MPFR mpfr.jl:393
  [2] Bool(x::Float16)
     @ Base float.jl:338
  [3] Bool(x::Rational)
     @ Base rational.jl:138
  [4] Bool(x::Real)
     @ Base float.jl:233
  [5] (dt::Type{&lt;:Integer})(ip::Sockets.IPAddr)
     @ Sockets ~/tmp/jl/jl/julia-nightly-assert/share/julia/stdlib/v1.11/Sockets/src/IPAddr.jl:11
  [6] (::Type{T})(x::Enum{T2}) where {T&lt;:Integer, T2&lt;:Integer}
     @ Base.Enums Enums.jl:19
  [7] (::Type{T})(z::Complex) where T&lt;:Real
     @ Base complex.jl:44
  [8] (::Type{T})(x::Base.TwicePrecision) where T&lt;:Number
     @ Base twiceprecision.jl:265
  [9] (::Type{T})(x::T) where T&lt;:Number
     @ boot.jl:894
 [10] (::Type{T})(x::AbstractChar) where T&lt;:Union{AbstractChar, Number}
     @ char.jl:50</code></pre><p data-translated="true"><span class="original-text">The usual constructor syntax is exactly equivalent to the function-like object syntax, so trying to define a method with each syntax will cause the first method to be overwritten by the next one:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">通常のコンストラクタ構文は、関数のようなオブジェクト構文と正確に同等であるため、各構文でメソッドを定義しようとすると、最初のメソッドが次のメソッドによって上書きされます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct S
           f::Int
       end

julia&gt; S() = S(7)
S

julia&gt; (::Type{S})() = S(8)  # overwrites the previous constructor method

julia&gt; S()
S(8)</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1" data-translated="true"><span class="original-text"><a class="tag is-link" href="#citeref-1">1</a>Nomenclature: while the term "constructor" generally refers to the entire function which constructs objects of a type, it is common to abuse terminology slightly and refer to specific constructor methods as "constructors". In such situations, it is generally clear from the context that the term is used to mean "constructor method" rather than "constructor function", especially as it is often used in the sense of singling out a particular method of the constructor from all of the others.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tag is-link" href="#citeref-1">1</a>用語: "コンストラクタ" という用語は一般的に型のオブジェクトを構築する全体の関数を指しますが、特定のコンストラクタメソッドを "コンストラクタ" と呼ぶために用語を少し乱用することが一般的です。そのような状況では、文脈からその用語が "コンストラクタ関数" ではなく "コンストラクタメソッド" を意味するために使用されていることが一般的に明確です。特に、コンストラクタの他のすべてのメソッドから特定のメソッドを特定する意味で使用されることが多いためです。</span></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../methods/index.html">« Methods</a><a class="docs-footer-nextpage" href="../conversion-and-promotion/index.html">Conversion and Promotion »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>