<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Performance Tips · The Julia Language</title><meta name="title" content="Performance Tips · The Julia Language"><meta property="og:title" content="Performance Tips · The Julia Language"><meta property="twitter:title" content="Performance Tips · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/performance-tips/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/performance-tips/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bi1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li class="is-active"><a class="tocitem" href="">Performance Tips</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-performance-tips-toc"><span>Table of contents</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-performance-tips-toc"><span>目次</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#General-advice"><span>General advice</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#General-advice"><span>一般的なアドバイス</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Type-inference"><span>Type inference</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Type-inference"><span>型推論</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Memory-management-and-arrays"><span>Memory management and arrays</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Memory-management-and-arrays"><span>メモリ管理と配列</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Execution-latency,-package-loading-and-package-precompiling-time"><span>Execution latency, package loading and package precompiling time</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Execution-latency,-package-loading-and-package-precompiling-time"><span>実行遅延、パッケージの読み込みとパッケージの事前コンパイル時間</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Miscellaneous"><span>その他</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">パフォーマンスのヒント</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">パフォーマンスのヒント</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/performance-tips.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-performance-tips" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-performance-tips">Performance Tips</a><a id="man-performance-tips-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-tips" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-performance-tips">パフォーマンスのヒント</a><a id="man-performance-tips-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-tips" title="パーマリンク"></a></span></h1><p data-translated="true"><span class="original-text">In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">以下のセクションでは、あなたのJuliaコードをできるだけ速く実行するために役立ついくつかのテクニックを簡単に紹介します。</span></p><h2 id="man-performance-tips-toc" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-performance-tips-toc">Table of contents</a><a id="man-performance-tips-toc-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-tips-toc" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-performance-tips-toc">目次</a><a id="man-performance-tips-toc-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-tips-toc" title="パーマリンク"></a></span></h2><ul><li data-translated="true"><span class="original-text"><a href="#man-performance-tips">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-performance-tips">パフォーマンスのヒント</a></span></li><li class="no-marker"><ul><li data-translated="true"><span class="original-text"><a href="#man-performance-tips-toc">Table of contents</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-performance-tips-toc">目次</a></span></li><li data-translated="true"><span class="original-text"><a href="#General-advice">General advice</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#General-advice">一般的なアドバイス</a></span></li><li class="no-marker"><ul><li data-translated="true"><span class="original-text"><a href="#Performance-critical-code-should-be-inside-a-function">Performance critical code should be inside a function</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Performance-critical-code-should-be-inside-a-function">パフォーマンスクリティカルなコードは関数内に置くべき</a></span></li><li data-translated="true"><span class="original-text"><a href="#Avoid-untyped-global-variables">Avoid untyped global variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Avoid-untyped-global-variables">型指定のないグローバル変数を避ける</a></span></li><li data-translated="true"><span class="original-text"><a href="#Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation">Measure performance with <code>@time</code> and pay attention to memory allocation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation"><code>@time</code>を使ってパフォーマンスを測定し、メモリ割り当てに注意を払う</a></span></li><li data-translated="true"><span class="original-text"><a href="#Break-functions-into-multiple-definitions">Break functions into multiple definitions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Break-functions-into-multiple-definitions">関数を複数の定義に分ける</a></span></li><li data-translated="true"><span class="original-text"><a href="#tools">Tools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#tools">ツール</a></span></li></ul></li><li data-translated="true"><span class="original-text"><a href="#Type-inference">Type inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Type-inference">型推論</a></span></li><li class="no-marker"><ul><li data-translated="true"><span class="original-text"><a href="#man-performance-abstract-container">Avoid containers with abstract type parameters</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-performance-abstract-container">抽象型パラメータを持つコンテナを避ける</a></span></li><li data-translated="true"><span class="original-text"><a href="#Avoid-fields-with-abstract-type">Avoid fields with abstract type</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Avoid-fields-with-abstract-type">抽象型を持つフィールドを避ける</a></span></li><li data-translated="true"><span class="original-text"><a href="#Avoid-fields-with-abstract-containers">Avoid fields with abstract containers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Avoid-fields-with-abstract-containers">抽象コンテナを持つフィールドを避ける</a></span></li><li data-translated="true"><span class="original-text"><a href="#Annotate-values-taken-from-untyped-locations">Annotate values taken from untyped locations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Annotate-values-taken-from-untyped-locations">型未指定の場所から取得した値に注釈を付ける</a></span></li><li data-translated="true"><span class="original-text"><a href="#Be-aware-of-when-Julia-avoids-specializing">Be aware of when Julia avoids specializing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Be-aware-of-when-Julia-avoids-specializing">Juliaが特化を避けるタイミングに注意する</a></span></li><li data-translated="true"><span class="original-text"><a href="#Write-&quot;type-stable&quot;-functions">Write "type-stable" functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Write-&quot;type-stable&quot;-functions">「型安定」な関数を書く</a></span></li><li data-translated="true"><span class="original-text"><a href="#Avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Avoid-changing-the-type-of-a-variable">変数の型を変更することを避ける</a></span></li><li data-translated="true"><span class="original-text"><a href="#kernel-functions">Separate kernel functions (aka, function barriers)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#kernel-functions">カーネル関数を分離する（別名、関数バリア）</a></span></li><li data-translated="true"><span class="original-text"><a href="#man-code-warntype"><code>@code_warntype</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-code-warntype"><code>@code_warntype</code></a></span></li><li data-translated="true"><span class="original-text"><a href="#man-performance-captured">Performance of captured variable</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-performance-captured">キャプチャされた変数のパフォーマンス</a></span></li><li data-translated="true"><span class="original-text"><a href="#man-performance-value-type">Types with values-as-parameters</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-performance-value-type">値をパラメータとする型</a></span></li><li data-translated="true"><span class="original-text"><a href="#The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)">複数ディスパッチの乱用の危険性（別名、値をパラメータとする型についての詳細）</a></span></li></ul></li><li data-translated="true"><span class="original-text"><a href="#Memory-management-and-arrays">Memory management and arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Memory-management-and-arrays">メモリ管理と配列</a></span></li><li class="no-marker"><ul><li data-translated="true"><span class="original-text"><a href="#Pre-allocate-outputs">Pre-allocate outputs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Pre-allocate-outputs">出力の事前割り当て</a></span></li><li data-translated="true"><span class="original-text"><a href="#man-performance-views">Consider using views for slices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-performance-views">スライスにビューを使用することを検討する</a></span></li><li data-translated="true"><span class="original-text"><a href="#Consider-StaticArrays.jl-for-small-fixed-size-vector/matrix-operations">Consider StaticArrays.jl for small fixed-size vector/matrix operations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Consider-StaticArrays.jl-for-small-fixed-size-vector/matrix-operations">小さな固定サイズのベクトル/行列演算にはStaticArrays.jlを検討する</a></span></li><li data-translated="true"><span class="original-text"><a href="#More-dots:-Fuse-vectorized-operations">More dots: Fuse vectorized operations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#More-dots:-Fuse-vectorized-operations">より多くのドット：ベクトル化された操作を融合する</a></span></li><li data-translated="true"><span class="original-text"><a href="#man-performance-unfuse">Fewer dots: Unfuse certain intermediate broadcasts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-performance-unfuse">ドットを減らす：特定の中間ブロードキャストを非融合化する</a></span></li><li data-translated="true"><span class="original-text"><a href="#man-performance-column-major">Access arrays in memory order, along columns</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-performance-column-major">メモリ順に配列にアクセスする、列に沿って</a></span></li><li data-translated="true"><span class="original-text"><a href="#Copying-data-is-not-always-bad">Copying data is not always bad</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Copying-data-is-not-always-bad">データのコピーは必ずしも悪いわけではない</a></span></li><li data-translated="true"><span class="original-text"><a href="#man-multithreading-linear-algebra">Multithreading and linear algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-multithreading-linear-algebra">マルチスレッドと線形代数</a></span></li><li data-translated="true"><span class="original-text"><a href="#man-backends-linear-algebra">Alternative linear algebra backends</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-backends-linear-algebra">代替の線形代数バックエンド</a></span></li></ul></li><li data-translated="true"><span class="original-text"><a href="#Execution-latency,-package-loading-and-package-precompiling-time">Execution latency, package loading and package precompiling time</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Execution-latency,-package-loading-and-package-precompiling-time">実行レイテンシ、パッケージの読み込みとパッケージの事前コンパイル時間</a></span></li><li class="no-marker"><ul><li data-translated="true"><span class="original-text"><a href="#Reducing-time-to-first-plot-etc.">Reducing time to first plot etc.</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Reducing-time-to-first-plot-etc.">最初のプロットまでの時間を短縮するなど</a></span></li><li data-translated="true"><span class="original-text"><a href="#Reducing-package-loading-time">Reducing package loading time</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Reducing-package-loading-time">パッケージの読み込み時間を短縮する</a></span></li><li data-translated="true"><span class="original-text"><a href="#Reducing-precompilation-time">Reducing precompilation time</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Reducing-precompilation-time">事前コンパイル時間を短縮する</a></span></li></ul></li><li data-translated="true"><span class="original-text"><a href="#Miscellaneous">Miscellaneous</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Miscellaneous">その他</a></span></li><li class="no-marker"><ul><li data-translated="true"><span class="original-text"><a href="#Tweaks">Tweaks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Tweaks">調整</a></span></li><li data-translated="true"><span class="original-text"><a href="#Fix-deprecation-warnings">Fix deprecation warnings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Fix-deprecation-warnings">非推奨警告を修正する</a></span></li><li data-translated="true"><span class="original-text"><a href="#man-performance-annotations">Performance Annotations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-performance-annotations">パフォーマンス注釈</a></span></li><li data-translated="true"><span class="original-text"><a href="#Treat-Subnormal-Numbers-as-Zeros">Treat Subnormal Numbers as Zeros</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Treat-Subnormal-Numbers-as-Zeros">非正規数をゼロとして扱う</a></span></li><li data-translated="true"><span class="original-text"><a href="#Avoid-string-interpolation-for-I/O">Avoid string interpolation for I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Avoid-string-interpolation-for-I/O">I/Oのための文字列補間を避ける</a></span></li><li data-translated="true"><span class="original-text"><a href="#Avoid-eager-string-materialization">Avoid eager string materialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Avoid-eager-string-materialization">早期の文字列マテリアライゼーションを避ける</a></span></li><li data-translated="true"><span class="original-text"><a href="#Optimize-network-I/O-during-parallel-execution">Optimize network I/O during parallel execution</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#Optimize-network-I/O-during-parallel-execution">並列実行中のネットワークI/Oを最適化する</a></span></li><li data-translated="true"><span class="original-text"><a href="#man-perftips-mutablearithmetics">Use <code>MutableArithmetics</code> for more control over allocation for mutable arithmetic types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-perftips-mutablearithmetics"><code>MutableArithmetics</code>を使用して、可変算術型の割り当てをより制御する</a></span></li></ul></li></ul></li></ul><h2 id="General-advice" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#General-advice">General advice</a><a id="General-advice-1"></a><a class="docs-heading-anchor-permalink" href="#General-advice" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#General-advice">一般的なアドバイス</a><a id="General-advice-1"></a><a class="docs-heading-anchor-permalink" href="#General-advice" title="Permalink"></a></span></h2><h3 id="Performance-critical-code-should-be-inside-a-function" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Performance-critical-code-should-be-inside-a-function">Performance critical code should be inside a function</a><a id="Performance-critical-code-should-be-inside-a-function-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-critical-code-should-be-inside-a-function" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Performance-critical-code-should-be-inside-a-function">パフォーマンスクリティカルなコードは関数内にあるべき</a><a id="Performance-critical-code-should-be-inside-a-function-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-critical-code-should-be-inside-a-function" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Any code that is performance critical should be inside a function. Code inside functions tends to run much faster than top level code, due to how Julia's compiler works.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パフォーマンスクリティカルなコードはすべて関数内にあるべきです。関数内のコードは、Juliaのコンパイラの動作により、トップレベルのコードよりもはるかに速く実行される傾向があります。</span></p><p data-translated="true"><span class="original-text">The use of functions is not only important for performance: functions are more reusable and testable, and clarify what steps are being done and what their inputs and outputs are, <a href="../style-guide/index.html#Write-functions,-not-just-scripts">Write functions, not just scripts</a> is also a recommendation of Julia's Styleguide.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数の使用はパフォーマンスだけでなく重要です。関数は再利用可能でテスト可能であり、どのステップが実行されているか、入力と出力が何であるかを明確にします。<a href="../style-guide/index.html#Write-functions,-not-just-scripts">関数を書くこと、単なるスクリプトではなく</a>は、Juliaのスタイルガイドの推奨事項でもあります。</span></p><p data-translated="true"><span class="original-text">The functions should take arguments, instead of operating directly on global variables, see the next point.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数は引数を受け取るべきであり、グローバル変数に直接作用するべきではありません。次のポイントを参照してください。</span></p><h3 id="Avoid-untyped-global-variables" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Avoid-untyped-global-variables">Avoid untyped global variables</a><a id="Avoid-untyped-global-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-untyped-global-variables" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Avoid-untyped-global-variables">型指定されていないグローバル変数を避ける</a><a id="Avoid-untyped-global-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-untyped-global-variables" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The value of an untyped global variable might change at any point, possibly leading to a change of its type. This makes it difficult for the compiler to optimize code using global variables. This also applies to type-valued variables, i.e. type aliases on the global level. Variables should be local, or passed as arguments to functions, whenever possible.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型指定されていないグローバル変数の値はいつでも変わる可能性があり、その結果、型が変わる可能性があります。これにより、コンパイラがグローバル変数を使用するコードを最適化するのが難しくなります。これは、型エイリアスがグローバルレベルにある型値の変数にも当てはまります。変数は可能な限りローカルであるべきであり、関数に引数として渡すべきです。</span></p><p data-translated="true"><span class="original-text">We find that global names are frequently constants, and declaring them as such greatly improves performance:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバル名は頻繁に定数であることがわかっており、それをそのように宣言することでパフォーマンスが大幅に向上します：</span></p><pre><code class="language-julia hljs">const DEFAULT_VAL = 0</code></pre><p data-translated="true"><span class="original-text">If a non-constant global is known to always be of the same type, <a href="../variables-and-scoping/index.html#man-typed-globals">the type should be annotated</a>; <code>const</code> globals need not be annotated because their type is inferred from their initialization value.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">非定数のグローバルが常に同じ型であることが知られている場合、<a href="../variables-and-scoping/index.html#man-typed-globals">型を注釈するべきです</a>; <code>const</code> グローバルは初期化値から型が推論されるため、注釈を付ける必要はありません。</span></p><p data-translated="true"><span class="original-text">Uses of untyped globals can be optimized by annotating their types at the point of use:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型指定されていないグローバルの使用は、使用時にその型を注釈することで最適化できます：</span></p><pre><code class="language-julia hljs">global x = rand(1000)

function loop_over_global()
    s = 0.0
    for i in x::Vector{Float64}
        s += i
    end
    return s
end</code></pre><p data-translated="true"><span class="original-text">Passing arguments to functions is better style. It leads to more reusable code and clarifies what the inputs and outputs are.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数に引数を渡すことはより良いスタイルです。それはより再利用可能なコードにつながり、入力と出力が何であるかを明確にします。</span></p><div class="admonition is-info" id="Note-35189990afa5b637"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-35189990afa5b637" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">All code in the REPL is evaluated in global scope, so a variable defined and assigned at top level will be a <strong>global</strong> variable. Variables defined at top level scope inside modules are also global.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">REPL内のすべてのコードはグローバルスコープで評価されるため、トップレベルで定義され、割り当てられた変数は<strong>グローバル</strong>変数になります。モジュール内のトップレベルスコープで定義された変数もグローバルです。</span></p></div></div><p data-translated="true"><span class="original-text">In the following REPL session:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のREPLセッションでは：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = 1.0</code></pre><p data-translated="true"><span class="original-text">is equivalent to:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">は次のように等価です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; global x = 1.0</code></pre><p data-translated="true"><span class="original-text">so all the performance issues discussed previously apply.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、以前に議論されたすべてのパフォーマンスの問題が適用されます。</span></p><h3 id="Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation">Measure performance with </a><a href="../profile/index.html#@time"><code>@time</code></a> and pay attention to memory allocation<a id="Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation-1"></a><a class="docs-heading-anchor-permalink" href="#Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation">パフォーマンスを測定するには</a><a href="../profile/index.html#@time"><code>@time</code></a>とメモリ割り当てに注意を払う<a id="Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation-1"></a><a class="docs-heading-anchor-permalink" href="#Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">A useful tool for measuring performance is the <a href="../profile/index.html#@time"><code>@time</code></a> macro. We here repeat the example with the global variable above, but this time with the type annotation removed:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パフォーマンスを測定するための便利なツールは、<a href="../profile/index.html#@time"><code>@time</code></a>マクロです。ここでは、上記のグローバル変数を使った例を繰り返しますが、今回は型アノテーションを削除しています：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(1000);

julia&gt; function sum_global()
           s = 0.0
           for i in x
               s += i
           end
           return s
       end;

julia&gt; @time sum_global()
  0.011539 seconds (9.08 k allocations: 373.386 KiB, 98.69% compilation time)
523.0007221951678

julia&gt; @time sum_global()
  0.000091 seconds (3.49 k allocations: 70.156 KiB)
523.0007221951678</code></pre><p data-translated="true"><span class="original-text">On the first call (<code>@time sum_global()</code>) the function gets compiled. (If you've not yet used <a href="../profile/index.html#@time"><code>@time</code></a> in this session, it will also compile functions needed for timing.)  You should not take the results of this run seriously. For the second run, note that in addition to reporting the time, it also indicated that a significant amount of memory was allocated. We are here just computing a sum over all elements in a vector of 64-bit floats so there should be no need to allocate (heap) memory.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初の呼び出し（<code>@time sum_global()</code>）では、関数がコンパイルされます。（このセッションでまだ<a href="../profile/index.html#@time"><code>@time</code></a>を使用していない場合、タイミングに必要な関数もコンパイルされます。）この実行の結果を真剣に受け取るべきではありません。2回目の実行では、時間を報告するだけでなく、かなりの量のメモリが割り当てられたことも示しています。ここでは、64ビット浮動小数点数のベクトル内のすべての要素の合計を計算しているだけなので、（ヒープ）メモリを割り当てる必要はないはずです。</span></p><p data-translated="true"><span class="original-text">We should clarify that what <code>@time</code> reports is specifically <em>heap</em> allocations, which are typically needed for either mutable objects or for creating/growing variable-sized containers (such as <code>Array</code> or <code>Dict</code>, strings, or "type-unstable" objects whose type is only known at runtime). Allocating (or deallocating) such blocks of memory may require an expensive function call to libc (e.g. via <code>malloc</code> in C), and they must be tracked for garbage collection. In contrast, immutable values like numbers (except bignums), tuples, and immutable <code>struct</code>s can be stored much more cheaply, e.g. in stack or CPU-register memory, so one doesn’t typically worry about the performance cost of "allocating" them.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@time</code>が報告するのは特に<em>ヒープ</em>割り当てであり、これは通常、可変オブジェクトや可変サイズのコンテナ（<code>Array</code>や<code>Dict</code>、文字列、または実行時にのみ型が知られる「型不安定」オブジェクト）を作成または成長させるために必要です。このようなメモリブロックを割り当てる（または解放する）には、libcへの高価な関数呼び出し（Cの<code>malloc</code>など）が必要になる場合があり、ガーベジコレクションのために追跡する必要があります。対照的に、数値（ビッグナムを除く）、タプル、および不変の<code>struct</code>のような不変値は、スタックやCPUレジスタメモリに格納できるため、通常は「割り当てる」ことのパフォーマンスコストを心配する必要はありません。</span></p><p data-translated="true"><span class="original-text">Unexpected memory allocation is almost always a sign of some problem with your code, usually a problem with type-stability or creating many small temporary arrays. Consequently, in addition to the allocation itself, it's very likely that the code generated for your function is far from optimal. Take such indications seriously and follow the advice below.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">予期しないメモリ割り当ては、ほぼ常にコードに何らかの問題がある兆候であり、通常は型の安定性の問題や多くの小さな一時配列を作成する問題です。したがって、割り当て自体に加えて、関数のために生成されたコードが最適から遠い可能性が非常に高いです。このような兆候を真剣に受け止め、以下のアドバイスに従ってください。</span></p><p data-translated="true"><span class="original-text">For more information about memory management and garbage collection in Julia, see <a href="../memory-management/index.html#man-memory-management">Memory Management and Garbage Collection</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaにおけるメモリ管理とガーベジコレクションに関する詳細は、<a href="../memory-management/index.html#man-memory-management">メモリ管理とガーベジコレクション</a>を参照してください。</span></p><p data-translated="true"><span class="original-text">In this particular case, the memory allocation is due to the usage of a type-unstable global variable <code>x</code>, so if we instead pass <code>x</code> as an argument to the function it no longer allocates memory (the remaining allocation reported below is due to running the <code>@time</code> macro in global scope) and is significantly faster after the first call:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この特定のケースでは、メモリ割り当ては型不安定なグローバル変数<code>x</code>の使用によるものであるため、代わりに<code>x</code>を関数の引数として渡すと、メモリを割り当てなくなります（以下に報告される残りの割り当ては、グローバルスコープで<code>@time</code>マクロを実行したためです）し、最初の呼び出し後は大幅に速くなります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(1000);

julia&gt; function sum_arg(x)
           s = 0.0
           for i in x
               s += i
           end
           return s
       end;

julia&gt; @time sum_arg(x)
  0.007551 seconds (3.98 k allocations: 200.548 KiB, 99.77% compilation time)
523.0007221951678

julia&gt; @time sum_arg(x)
  0.000006 seconds (1 allocation: 16 bytes)
523.0007221951678</code></pre><p data-translated="true"><span class="original-text">The 1 allocation seen is from running the <code>@time</code> macro itself in global scope. If we instead run the timing in a function, we can see that indeed no allocations are performed:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">見られる1回の割り当ては、グローバルスコープで<code>@time</code>マクロを実行したことによるものです。代わりに関数内でタイミングを実行すると、実際に割り当てが行われていないことがわかります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; time_sum(x) = @time sum_arg(x);

julia&gt; time_sum(x)
  0.000002 seconds
523.0007221951678</code></pre><p data-translated="true"><span class="original-text">In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the <a href="#tools">tools</a> below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see <a href="../../base/math/#Base.:--Tuple{Any, Any}#Base.:--Tuple{Any, Any}">Pre-allocating outputs</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">いくつかの状況では、関数がその操作の一部としてメモリを割り当てる必要があり、これが上記の単純な図を複雑にすることがあります。そのような場合は、問題を診断するために以下の<a href="#tools">ツール</a>のいずれかを使用するか、割り当てをアルゴリズム的な側面から分離する関数のバージョンを書くことを検討してください（<a href="../../base/math/#Base.:--Tuple{Any, Any}#Base.:--Tuple{Any, Any}">出力の事前割り当て</a>を参照）。</span></p><div class="admonition is-info" id="Note-711b974dfc626522"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-711b974dfc626522" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">For more serious benchmarking, consider the <a href="https://github.com/JuliaCI/BenchmarkTools.jl">BenchmarkTools.jl</a> package which among other things evaluates the function multiple times in order to reduce noise.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より真剣なベンチマーキングには、<a href="https://github.com/JuliaCI/BenchmarkTools.jl">BenchmarkTools.jl</a>パッケージを検討してください。これは、ノイズを減らすために関数を複数回評価するなどの機能があります。</span></p></div></div><h3 id="Break-functions-into-multiple-definitions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Break-functions-into-multiple-definitions">Break functions into multiple definitions</a><a id="Break-functions-into-multiple-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Break-functions-into-multiple-definitions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Break-functions-into-multiple-definitions">関数を複数の定義に分割する</a><a id="Break-functions-into-multiple-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Break-functions-into-multiple-definitions" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Writing a function as many small definitions allows the compiler to directly call the most applicable code, or even inline it.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数を多くの小さな定義として書くことで、コンパイラは最も適切なコードを直接呼び出すことができ、さらにはインライン化することも可能です。</span></p><p data-translated="true"><span class="original-text">Here is an example of a "compound function" that should really be written as multiple definitions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">以下は、実際には複数の定義として書くべき「複合関数」の例です：</span></p><pre><code class="language-julia hljs">using LinearAlgebra

function mynorm(A)
    if isa(A, Vector)
        return sqrt(real(dot(A,A)))
    elseif isa(A, Matrix)
        return maximum(svdvals(A))
    else
        error("mynorm: invalid argument")
    end
end</code></pre><p data-translated="true"><span class="original-text">This can be written more concisely and efficiently as:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、より簡潔かつ効率的に次のように書くことができます：</span></p><pre><code class="language-julia hljs">mynorm(x::Vector) = sqrt(real(dot(x, x)))
mynorm(A::Matrix) = maximum(svdvals(A))</code></pre><p data-translated="true"><span class="original-text">It should however be noted that the compiler is quite efficient at optimizing away the dead branches in code written as the <code>mynorm</code> example.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、コンパイラは<code>mynorm</code>の例として書かれたコード内のデッドブランチを最適化するのが非常に得意であることに注意すべきです。</span></p><h3 id="tools" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#tools">Tools</a><a id="tools-1"></a><a class="docs-heading-anchor-permalink" href="#tools" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#tools">ツール</a><a id="tools-1"></a><a class="docs-heading-anchor-permalink" href="#tools" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaとそのパッケージエコシステムには、問題を診断し、コードのパフォーマンスを向上させるのに役立つツールが含まれています：</span></p><ul><li data-translated="true"><span class="original-text"><a href="../profile/index.html#Profiling">Profiling</a> allows you to measure the performance of your running code and identify lines that serve as bottlenecks. For complex projects, the <a href="https://github.com/timholy/ProfileView.jl">ProfileView</a> package can help you visualize your profiling results.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../profile/index.html#Profiling">プロファイリング</a>を使用すると、実行中のコードのパフォーマンスを測定し、ボトルネックとなる行を特定できます。複雑なプロジェクトの場合、<a href="https://github.com/timholy/ProfileView.jl">ProfileView</a>パッケージを使用すると、プロファイリング結果を視覚化するのに役立ちます。</span></li><li data-translated="true"><span class="original-text">The <a href="https://github.com/aviatesk/JET.jl">JET</a> package can help you find common performance problems in your code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/aviatesk/JET.jl">JET</a>パッケージは、コード内の一般的なパフォーマンス問題を見つけるのに役立ちます。</span></li><li data-translated="true"><span class="original-text">Unexpectedly-large memory allocations–as reported by <a href="../profile/index.html#@time"><code>@time</code></a>, <a href="../../base/base/index.html#Base.@allocated"><code>@allocated</code></a>, or the profiler (through calls to the garbage-collection routines)–hint that there might be issues with your code. If you don't see another reason for the allocations, suspect a type problem.  You can also start Julia with the <code>--track-allocation=user</code> option and examine the resulting <code>*.mem</code> files to see information about where those allocations occur. See <a href="../profile/index.html#Memory-allocation-analysis">Memory allocation analysis</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">予期しない大きなメモリ割り当ては、<a href="../profile/index.html#@time"><code>@time</code></a>、<a href="../../base/base/index.html#Base.@allocated"><code>@allocated</code></a>、またはプロファイラ（ガーベジコレクションルーチンへの呼び出しを通じて）によって報告され、コードに問題がある可能性を示唆します。割り当ての他の理由が見当たらない場合は、型の問題を疑ってください。また、<code>--track-allocation=user</code>オプションを使用してJuliaを起動し、結果の<code>*.mem</code>ファイルを調べることで、これらの割り当てが発生する場所に関する情報を確認できます。詳細は<a href="../profile/index.html#Memory-allocation-analysis">メモリ割り当て分析</a>を参照してください。</span></li><li data-translated="true"><span class="original-text"><code>@code_warntype</code> generates a representation of your code that can be helpful in finding expressions that result in type uncertainty. See <a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a> below.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@code_warntype</code> は、型の不確実性をもたらす式を見つけるのに役立つコードの表現を生成します。以下の<a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a>を参照してください。</span></li></ul><h2 id="Type-inference" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Type-inference">Type inference</a><a id="Type-inference-1"></a><a class="docs-heading-anchor-permalink" href="#Type-inference" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Type-inference">型推論</a><a id="Type-inference-1"></a><a class="docs-heading-anchor-permalink" href="#Type-inference" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is <em>not</em> the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">オプションの型宣言がある多くの言語では、宣言を追加することがコードを速く実行する主な方法です。しかし、これはJuliaでは<em>当てはまりません</em>。Juliaでは、コンパイラは一般的にすべての関数引数、ローカル変数、および式の型を知っています。ただし、宣言が役立つ特定のケースがいくつかあります。</span></p><h3 id="man-performance-abstract-container" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-performance-abstract-container">Avoid containers with abstract type parameters</a><a id="man-performance-abstract-container-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-abstract-container" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-performance-abstract-container">抽象型パラメータを持つコンテナを避ける</a><a id="man-performance-abstract-container-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-abstract-container" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">When working with parameterized types, including arrays, it is best to avoid parameterizing with abstract types where possible.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パラメータ化された型、特に配列を扱う場合は、可能な限り抽象型でパラメータ化することを避けるのが最善です。</span></p><p data-translated="true"><span class="original-text">Consider the following:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のことを考えてみてください：</span></p><pre><code class="language-julia-repl hljs">julia&gt; a = Real[]
Real[]

julia&gt; push!(a, 1); push!(a, 2.0); push!(a, π)
3-element Vector{Real}:
 1
 2.0
 π = 3.1415926535897...</code></pre><p data-translated="true"><span class="original-text">Because <code>a</code> is an array of abstract type <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a>, it must be able to hold any <code>Real</code> value. Since <code>Real</code> objects can be of arbitrary size and structure, <code>a</code> must be represented as an array of pointers to individually allocated <code>Real</code> objects. However, if we instead only allow numbers of the same type, e.g. <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>, to be stored in <code>a</code> these can be stored more efficiently:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>a</code> が抽象型 <a href="../../base/numbers/index.html#Core.Real"><code>Real</code></a> の配列であるため、任意の <code>Real</code> 値を保持できる必要があります。<code>Real</code> オブジェクトは任意のサイズと構造を持つ可能性があるため、<code>a</code> は個別に割り当てられた <code>Real</code> オブジェクトへのポインタの配列として表現されなければなりません。しかし、もし同じ型の数値、例えば <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> のみを <code>a</code> に格納することを許可すれば、これらはより効率的に格納できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; a = Float64[]
Float64[]

julia&gt; push!(a, 1); push!(a, 2.0); push!(a,  π)
3-element Vector{Float64}:
 1.0
 2.0
 3.141592653589793</code></pre><p data-translated="true"><span class="original-text">Assigning numbers into <code>a</code> will now convert them to <code>Float64</code> and <code>a</code> will be stored as a contiguous block of 64-bit floating-point values that can be manipulated efficiently.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>a</code> に数値を割り当てると、それらは <code>Float64</code> に変換され、<code>a</code> は効率的に操作できる64ビット浮動小数点値の連続ブロックとして格納されます。</span></p><p data-translated="true"><span class="original-text">If you cannot avoid containers with abstract value types, it is sometimes better to parametrize with <code>Any</code> to avoid runtime type checking. E.g. <code>IdDict{Any, Any}</code> performs better than <code>IdDict{Type, Vector}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">抽象値型を持つコンテナを避けられない場合は、ランタイム型チェックを避けるために <code>Any</code> でパラメータ化する方が良いことがあります。例えば、<code>IdDict{Any, Any}</code> は <code>IdDict{Type, Vector}</code> よりもパフォーマンスが良いです。</span></p><p data-translated="true"><span class="original-text">See also the discussion under <a href="../types/index.html#Parametric-Types">Parametric Types</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../types/index.html#Parametric-Types">パラメトリック型</a>に関する議論も参照してください。</span></p><h3 id="Avoid-fields-with-abstract-type" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Avoid-fields-with-abstract-type">Avoid fields with abstract type</a><a id="Avoid-fields-with-abstract-type-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-fields-with-abstract-type" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Avoid-fields-with-abstract-type">抽象型のフィールドを避ける</a><a id="Avoid-fields-with-abstract-type-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-fields-with-abstract-type" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Types can be declared without specifying the types of their fields:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型はフィールドの型を指定せずに宣言することができます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct MyAmbiguousType
           a
       end</code></pre><p data-translated="true"><span class="original-text">This allows <code>a</code> to be of any type. This can often be useful, but it does have a downside: for objects of type <code>MyAmbiguousType</code>, the compiler will not be able to generate high-performance code. The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type <code>MyAmbiguousType</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これにより、<code>a</code>は任意の型になる可能性があります。これはしばしば便利ですが、欠点もあります: <code>MyAmbiguousType</code>型のオブジェクトの場合、コンパイラは高性能なコードを生成できません。その理由は、コンパイラがオブジェクトの値ではなく型を使用してコードの構築方法を決定するからです。残念ながら、<code>MyAmbiguousType</code>型のオブジェクトについては、非常に少ない情報しか推測できません:</span></p><pre><code class="language-julia-repl hljs">julia&gt; b = MyAmbiguousType("Hello")
MyAmbiguousType("Hello")

julia&gt; c = MyAmbiguousType(17)
MyAmbiguousType(17)

julia&gt; typeof(b)
MyAmbiguousType

julia&gt; typeof(c)
MyAmbiguousType</code></pre><p data-translated="true"><span class="original-text">The values of <code>b</code> and <code>c</code> have the same type, yet their underlying representation of data in memory is very different. Even if you stored just numeric values in field <code>a</code>, the fact that the memory representation of a <a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a> differs from a <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> also means that the CPU needs to handle them using two different kinds of instructions. Since the required information is not available in the type, such decisions have to be made at run-time. This slows performance.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>b</code>と<code>c</code>の値は同じ型ですが、メモリ内のデータの基礎となる表現は非常に異なります。たとえフィールド<code>a</code>に数値のみを格納しても、<a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a>のメモリ表現が<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>のそれと異なるため、CPUはそれらを2種類の異なる命令で処理する必要があります。必要な情報が型に含まれていないため、そのような決定は実行時に行わなければなりません。これによりパフォーマンスが低下します。</span></p><p data-translated="true"><span class="original-text">You can do better by declaring the type of <code>a</code>. Here, we are focused on the case where <code>a</code> might be any one of several types, in which case the natural solution is to use parameters. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>a</code>の型を宣言することで、より良い結果が得られます。ここでは、<code>a</code>がいくつかの型のいずれかである可能性がある場合に焦点を当てており、その場合の自然な解決策はパラメータを使用することです。例えば:</span></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct MyType{T&lt;:AbstractFloat}
           a::T
       end</code></pre><p data-translated="true"><span class="original-text">This is a better choice than</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、</span></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct MyStillAmbiguousType
           a::AbstractFloat
       end</code></pre><p data-translated="true"><span class="original-text">because the first version specifies the type of <code>a</code> from the type of the wrapper object. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">よりも良い選択です。なぜなら、最初のバージョンはラッパーオブジェクトの型から<code>a</code>の型を指定しているからです。例えば:</span></p><pre><code class="language-julia-repl hljs">julia&gt; m = MyType(3.2)
MyType{Float64}(3.2)

julia&gt; t = MyStillAmbiguousType(3.2)
MyStillAmbiguousType(3.2)

julia&gt; typeof(m)
MyType{Float64}

julia&gt; typeof(t)
MyStillAmbiguousType</code></pre><p data-translated="true"><span class="original-text">The type of field <code>a</code> can be readily determined from the type of <code>m</code>, but not from the type of <code>t</code>. Indeed, in <code>t</code> it's possible to change the type of the field <code>a</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">フィールド<code>a</code>の型は<code>m</code>の型から容易に決定できますが、<code>t</code>の型からは決定できません。実際、<code>t</code>ではフィールド<code>a</code>の型を変更することが可能です:</span></p><pre><code class="language-julia-repl hljs">julia&gt; typeof(t.a)
Float64

julia&gt; t.a = 4.5f0
4.5f0

julia&gt; typeof(t.a)
Float32</code></pre><p data-translated="true"><span class="original-text">In contrast, once <code>m</code> is constructed, the type of <code>m.a</code> cannot change:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">対照的に、<code>m</code>が構築されると、<code>m.a</code>の型は変更できません:</span></p><pre><code class="language-julia-repl hljs">julia&gt; m.a = 4.5f0
4.5f0

julia&gt; typeof(m.a)
Float64</code></pre><p data-translated="true"><span class="original-text">The fact that the type of <code>m.a</code> is known from <code>m</code>'s type—coupled with the fact that its type cannot change mid-function—allows the compiler to generate highly-optimized code for objects like <code>m</code> but not for objects like <code>t</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>m.a</code>の型が<code>m</code>の型から知られているという事実と、その型が関数の途中で変更できないという事実は、コンパイラが<code>m</code>のようなオブジェクトに対して高度に最適化されたコードを生成できることを可能にしますが、<code>t</code>のようなオブジェクトにはできません。</span></p><p data-translated="true"><span class="original-text">Of course, all of this is true only if we construct <code>m</code> with a concrete type. We can break this by explicitly constructing it with an abstract type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もちろん、これはすべて <code>m</code> を具体的な型で構築した場合にのみ当てはまります。抽象型で明示的に構築することでこれを破ることができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; m = MyType{AbstractFloat}(3.2)
MyType{AbstractFloat}(3.2)

julia&gt; typeof(m.a)
Float64

julia&gt; m.a = 4.5f0
4.5f0

julia&gt; typeof(m.a)
Float32</code></pre><p data-translated="true"><span class="original-text">For all practical purposes, such objects behave identically to those of <code>MyStillAmbiguousType</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実用的な目的のために、これらのオブジェクトは <code>MyStillAmbiguousType</code> のものと同様に振る舞います。</span></p><p data-translated="true"><span class="original-text">It's quite instructive to compare the sheer amount of code generated for a simple function</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">単純な関数のために生成されるコードの量を比較することは非常に有益です</span></p><pre><code class="language-julia hljs">func(m::MyType) = m.a+1</code></pre><p data-translated="true"><span class="original-text">using</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">使用して</span></p><pre><code class="language-julia hljs">code_llvm(func, Tuple{MyType{Float64}})
code_llvm(func, Tuple{MyType{AbstractFloat}})</code></pre><p data-translated="true"><span class="original-text">For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn't need to generate any code to resolve the type at run-time. This results in shorter and faster code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">長さの理由から結果はここに示されていませんが、あなた自身で試してみることをお勧めします。最初のケースでは型が完全に指定されているため、コンパイラは実行時に型を解決するためのコードを生成する必要がありません。これにより、より短く、より高速なコードが得られます。</span></p><p data-translated="true"><span class="original-text">One should also keep in mind that not-fully-parameterized types behave like abstract types. For example, even though a fully specified <code>Array{T,n}</code> is concrete, <code>Array</code> itself with no parameters given is not concrete:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">完全にパラメータ化されていない型は抽象型のように振る舞うことも考慮すべきです。たとえば、完全に指定された <code>Array{T,n}</code> は具体的ですが、パラメータが与えられていない <code>Array</code> 自体は具体的ではありません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; !isconcretetype(Array), !isabstracttype(Array), isstructtype(Array), !isconcretetype(Array{Int}), isconcretetype(Array{Int,1})
(true, true, true, true, true)</code></pre><p data-translated="true"><span class="original-text">In this case, it would be better to avoid declaring <code>MyType</code> with a field <code>a::Array</code> and instead declare the field as <code>a::Array{T,N}</code> or as <code>a::A</code>, where <code>{T,N}</code> or <code>A</code> are parameters of <code>MyType</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この場合、<code>MyType</code> をフィールド <code>a::Array</code> で宣言するのではなく、フィールドを <code>a::Array{T,N}</code> または <code>a::A</code> として宣言する方が良いでしょう。ここで <code>{T,N}</code> または <code>A</code> は <code>MyType</code> のパラメータです。</span></p><p data-translated="true"><span class="original-text">The previous advice is especially useful when the fields of a struct are meant to be functions, or more generally callable objects. It is very tempting to define a struct as follows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">前述のアドバイスは、構造体のフィールドが関数、またはより一般的には呼び出し可能なオブジェクトである場合に特に有用です。次のように構造体を定義することは非常に魅力的です：</span></p><pre><code class="language-julia hljs">struct MyCallableWrapper
    f::Function
end</code></pre><p data-translated="true"><span class="original-text">But since <code>Function</code> is an abstract type, every call to <code>wrapper.f</code> will require dynamic dispatch, due to the type instability of accessing the field <code>f</code>. Instead, you should write something like:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、<code>Function</code> は抽象型であるため、<code>wrapper.f</code> へのすべての呼び出しは、フィールド <code>f</code> へのアクセスの型不安定性のために動的ディスパッチを必要とします。代わりに、次のように書くべきです：</span></p><pre><code class="language-julia hljs">struct MyCallableWrapper{F}
    f::F
end</code></pre><p data-translated="true"><span class="original-text">which has nearly identical behavior but will be much faster (because the type instability is eliminated). Note that we do not impose <code>F&lt;:Function</code>: this means callable objects which do not subtype <code>Function</code> are also allowed for the field <code>f</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これはほぼ同じ動作をしますが、はるかに高速になります（型不安定性が排除されるため）。<code>F&lt;:Function</code> を課さないことに注意してください：これは、<code>Function</code> をサブタイプとしない呼び出し可能なオブジェクトもフィールド <code>f</code> に許可されることを意味します。</span></p><h3 id="Avoid-fields-with-abstract-containers" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Avoid-fields-with-abstract-containers">Avoid fields with abstract containers</a><a id="Avoid-fields-with-abstract-containers-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-fields-with-abstract-containers" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Avoid-fields-with-abstract-containers">抽象コンテナを持つフィールドを避ける</a><a id="Avoid-fields-with-abstract-containers-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-fields-with-abstract-containers" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The same best practices also work for container types:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同じベストプラクティスはコンテナタイプにも適用されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct MySimpleContainer{A&lt;:AbstractVector}
           a::A
       end

julia&gt; struct MyAmbiguousContainer{T}
           a::AbstractVector{T}
       end

julia&gt; struct MyAlsoAmbiguousContainer
           a::Array
       end</code></pre><p data-translated="true"><span class="original-text">For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば:</span></p><pre><code class="language-julia-repl hljs">julia&gt; c = MySimpleContainer(1:3);

julia&gt; typeof(c)
MySimpleContainer{UnitRange{Int64}}

julia&gt; c = MySimpleContainer([1:3;]);

julia&gt; typeof(c)
MySimpleContainer{Vector{Int64}}

julia&gt; b = MyAmbiguousContainer(1:3);

julia&gt; typeof(b)
MyAmbiguousContainer{Int64}

julia&gt; b = MyAmbiguousContainer([1:3;]);

julia&gt; typeof(b)
MyAmbiguousContainer{Int64}

julia&gt; d = MyAlsoAmbiguousContainer(1:3);

julia&gt; typeof(d), typeof(d.a)
(MyAlsoAmbiguousContainer, Vector{Int64})

julia&gt; d = MyAlsoAmbiguousContainer(1:1.0:3);

julia&gt; typeof(d), typeof(d.a)
(MyAlsoAmbiguousContainer, Vector{Float64})
</code></pre><p data-translated="true"><span class="original-text">For <code>MySimpleContainer</code>, the object is fully-specified by its type and parameters, so the compiler can generate optimized functions. In most instances, this will probably suffice.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>MySimpleContainer</code>の場合、オブジェクトはそのタイプとパラメータによって完全に指定されるため、コンパイラは最適化された関数を生成できます。ほとんどの場合、これで十分でしょう。</span></p><p data-translated="true"><span class="original-text">While the compiler can now do its job perfectly well, there are cases where <em>you</em> might wish that your code could do different things depending on the <em>element type</em> of <code>a</code>. Usually the best way to achieve this is to wrap your specific operation (here, <code>foo</code>) in a separate function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コンパイラは今やその仕事を完璧にこなせますが、<em>あなた</em>が<code>a</code>の<em>要素タイプ</em>に応じてコードが異なる動作をすることを望む場合もあります。通常、これを達成する最良の方法は、特定の操作（ここでは<code>foo</code>）を別の関数にラップすることです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function sumfoo(c::MySimpleContainer)
           s = 0
           for x in c.a
               s += foo(x)
           end
           s
       end
sumfoo (generic function with 1 method)

julia&gt; foo(x::Integer) = x
foo (generic function with 1 method)

julia&gt; foo(x::AbstractFloat) = round(x)
foo (generic function with 2 methods)</code></pre><p data-translated="true"><span class="original-text">This keeps things simple, while allowing the compiler to generate optimized code in all cases.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これにより、すべてのケースでコンパイラが最適化されたコードを生成できるようにしつつ、シンプルさを保つことができます。</span></p><p data-translated="true"><span class="original-text">However, there are cases where you may need to declare different versions of the outer function for different element types or types of the <code>AbstractVector</code> of the field <code>a</code> in <code>MySimpleContainer</code>. You could do it like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、<code>MySimpleContainer</code>のフィールド<code>a</code>の異なる要素タイプや<code>AbstractVector</code>の異なるバージョンの外部関数を宣言する必要がある場合もあります。次のように行うことができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function myfunc(c::MySimpleContainer{&lt;:AbstractArray{&lt;:Integer}})
           return c.a[1]+1
       end
myfunc (generic function with 1 method)

julia&gt; function myfunc(c::MySimpleContainer{&lt;:AbstractArray{&lt;:AbstractFloat}})
           return c.a[1]+2
       end
myfunc (generic function with 2 methods)

julia&gt; function myfunc(c::MySimpleContainer{Vector{T}}) where T &lt;: Integer
           return c.a[1]+3
       end
myfunc (generic function with 3 methods)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; myfunc(MySimpleContainer(1:3))
2

julia&gt; myfunc(MySimpleContainer(1.0:3))
3.0

julia&gt; myfunc(MySimpleContainer([1:3;]))
4</code></pre><h3 id="Annotate-values-taken-from-untyped-locations" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Annotate-values-taken-from-untyped-locations">Annotate values taken from untyped locations</a><a id="Annotate-values-taken-from-untyped-locations-1"></a><a class="docs-heading-anchor-permalink" href="#Annotate-values-taken-from-untyped-locations" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Annotate-values-taken-from-untyped-locations">型未指定の場所から取得した値に注釈を付ける</a><a id="Annotate-values-taken-from-untyped-locations-1"></a><a class="docs-heading-anchor-permalink" href="#Annotate-values-taken-from-untyped-locations" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">It is often convenient to work with data structures that may contain values of any type (arrays of type <code>Array{Any}</code>). But, if you're using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">任意のタイプの値を含む可能性のあるデータ構造（<code>Array{Any}</code>型の配列）を扱うことはしばしば便利です。しかし、これらの構造の1つを使用していて、要素のタイプがわかっている場合は、その知識をコンパイラと共有することが役立ちます：</span></p><pre><code class="language-julia hljs">function foo(a::Array{Any,1})
    x = a[1]::Int32
    b = x+1
    ...
end</code></pre><p data-translated="true"><span class="original-text">Here, we happened to know that the first element of <code>a</code> would be an <a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a>. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、<code>a</code>の最初の要素が<a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a>であることがわかっていました。このように注釈を付けることで、期待されるタイプでない場合にランタイムエラーが発生し、特定のバグを早期に検出できるという追加の利点があります。</span></p><p data-translated="true"><span class="original-text">In the case that the type of <code>a[1]</code> is not known precisely, <code>x</code> can be declared via <code>x = convert(Int32, a[1])::Int32</code>. The use of the <a href="../../base/base/index.html#Base.convert"><code>convert</code></a> function allows <code>a[1]</code> to be any object convertible to an <code>Int32</code> (such as <code>UInt8</code>), thus increasing the genericity of the code by loosening the type requirement. Notice that <code>convert</code> itself needs a type annotation in this context in order to achieve type stability. This is because the compiler cannot deduce the type of the return value of a function, even <code>convert</code>, unless the types of all the function's arguments are known.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>a[1]</code>のタイプが正確にわからない場合は、<code>x</code>を<code>x = convert(Int32, a[1])::Int32</code>として宣言できます。<a href="../../base/base/index.html#Base.convert"><code>convert</code></a>関数を使用することで、<code>a[1]</code>は<code>Int32</code>に変換可能な任意のオブジェクト（例えば<code>UInt8</code>）であることができ、タイプ要件を緩めることでコードの一般性が向上します。この文脈では、<code>convert</code>自体がタイプ安定性を達成するためにタイプ注釈を必要とすることに注意してください。これは、コンパイラが関数の戻り値のタイプを推測できないためです。たとえ<code>convert</code>であっても、すべての関数の引数のタイプが知られていない限り、戻り値のタイプを推測することはできません。</span></p><p data-translated="true"><span class="original-text">Type annotation will not enhance (and can actually hinder) performance if the type is abstract, or constructed at run-time. This is because the compiler cannot use the annotation to specialize the subsequent code, and the type-check itself takes time. For example, in the code:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型注釈は、型が抽象的であるか、実行時に構築される場合、パフォーマンスを向上させることはなく（実際には妨げることさえあります）、これはコンパイラが注釈を使用してその後のコードを特化できず、型チェック自体に時間がかかるためです。例えば、次のコードでは、</span></p><pre><code class="language-julia hljs">function nr(a, prec)
    ctype = prec == 32 ? Float32 : Float64
    b = Complex{ctype}(a)
    c = (b + 1.0f0)::Complex{ctype}
    abs(c)
end</code></pre><p data-translated="true"><span class="original-text">the annotation of <code>c</code> harms performance. To write performant code involving types constructed at run-time, use the <a href="#kernel-functions">function-barrier technique</a> discussed below, and ensure that the constructed type appears among the argument types of the kernel function so that the kernel operations are properly specialized by the compiler. For example, in the above snippet, as soon as <code>b</code> is constructed, it can be passed to another function <code>k</code>, the kernel. If, for example, function <code>k</code> declares <code>b</code> as an argument of type <code>Complex{T}</code>, where <code>T</code> is a type parameter, then a type annotation appearing in an assignment statement within <code>k</code> of the form:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>c</code>の注釈はパフォーマンスを損ないます。実行時に構築された型を含むパフォーマンスの良いコードを書くには、以下で説明する<a href="#kernel-functions">関数バリア技術</a>を使用し、構築された型がカーネル関数の引数型の中に現れるようにして、コンパイラがカーネル操作を適切に特化できるようにします。例えば、上記のスニペットでは、<code>b</code>が構築されるとすぐに、別の関数<code>k</code>、すなわちカーネルに渡すことができます。例えば、関数<code>k</code>が<code>b</code>を型<code>Complex{T}</code>の引数として宣言している場合、<code>k</code>内の次のような代入文に現れる型注釈は、</span></p><pre><code class="language-julia hljs">c = (b + 1.0f0)::Complex{T}</code></pre><p data-translated="true"><span class="original-text">does not hinder performance (but does not help either) since the compiler can determine the type of <code>c</code> at the time <code>k</code> is compiled.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パフォーマンスを妨げることはありません（しかし、助けにもなりません）なぜなら、コンパイラは<code>k</code>がコンパイルされる時点で<code>c</code>の型を決定できるからです。</span></p><h3 id="Be-aware-of-when-Julia-avoids-specializing" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Be-aware-of-when-Julia-avoids-specializing">Be aware of when Julia avoids specializing</a><a id="Be-aware-of-when-Julia-avoids-specializing-1"></a><a class="docs-heading-anchor-permalink" href="#Be-aware-of-when-Julia-avoids-specializing" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Be-aware-of-when-Julia-avoids-specializing">Juliaが特化を避ける場合に注意してください</a><a id="Be-aware-of-when-Julia-avoids-specializing-1"></a><a class="docs-heading-anchor-permalink" href="#Be-aware-of-when-Julia-avoids-specializing" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">As a heuristic, Julia avoids automatically <a href="../methods/index.html#man-method-specializations">specializing</a> on argument type parameters in three specific cases: <code>Type</code>, <code>Function</code>, and <code>Vararg</code>. Julia will always specialize when the argument is used within the method, but not if the argument is just passed through to another function. This usually has no performance impact at runtime and <a href="../../devdocs/functions/index.html#compiler-efficiency-issues">improves compiler performance</a>. If you find it does have a performance impact at runtime in your case, you can trigger specialization by adding a type parameter to the method declaration. Here are some examples:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ヒューリスティックとして、Juliaは特定の3つのケース、すなわち<code>Type</code>、<code>Function</code>、および<code>Vararg</code>において、引数型パラメータに自動的に<a href="../methods/index.html#man-method-specializations">特化することを避けます</a>。Juliaは引数がメソッド内で使用される場合には常に特化しますが、引数が別の関数に単に渡されるだけの場合には特化しません。これは通常、実行時にパフォーマンスに影響を与えず、<a href="../../devdocs/functions/index.html#compiler-efficiency-issues">コンパイラのパフォーマンスを向上させます</a>。もしあなたのケースで実行時にパフォーマンスに影響がある場合は、メソッド宣言に型パラメータを追加することで特化をトリガーできます。以下にいくつかの例を示します：</span></p><p data-translated="true"><span class="original-text">This will not specialize:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは特化しません：</span></p><pre><code class="language-julia hljs">function f_type(t)  # or t::Type
    x = ones(t, 10)
    return sum(map(sin, x))
end</code></pre><p data-translated="true"><span class="original-text">but this will:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、これは次のようになります：</span></p><pre><code class="language-julia hljs">function g_type(t::Type{T}) where T
    x = ones(T, 10)
    return sum(map(sin, x))
end</code></pre><p data-translated="true"><span class="original-text">These will not specialize:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらは特化しません：</span></p><pre><code class="language-julia hljs">f_func(f, num) = ntuple(f, div(num, 2))
g_func(g::Function, num) = ntuple(g, div(num, 2))</code></pre><p data-translated="true"><span class="original-text">but this will:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、これは次のようになります：</span></p><pre><code class="language-julia hljs">h_func(h::H, num) where {H} = ntuple(h, div(num, 2))</code></pre><p data-translated="true"><span class="original-text">This will not specialize:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは特化しません：</span></p><pre><code class="language-julia hljs">f_vararg(x::Int...) = tuple(x...)</code></pre><p data-translated="true"><span class="original-text">but this will:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、これは次のようになります：</span></p><pre><code class="language-julia hljs">g_vararg(x::Vararg{Int, N}) where {N} = tuple(x...)</code></pre><p data-translated="true"><span class="original-text">One only needs to introduce a single type parameter to force specialization, even if the other types are unconstrained. For example, this will also specialize, and is useful when the arguments are not all of the same type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特化を強制するためには、単一の型パラメータを導入するだけで済みます。他の型が制約されていなくてもです。例えば、これも特化され、引数がすべて同じ型でない場合に便利です：</span></p><pre><code class="language-julia hljs">h_vararg(x::Vararg{Any, N}) where {N} = tuple(x...)</code></pre><p data-translated="true"><span class="original-text">Note that <a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_typed"><code>@code_typed</code></a> and friends will always show you specialized code, even if Julia would not normally specialize that method call. You need to check the <a href="../../devdocs/ast/index.html#ast-lowered-method">method internals</a> if you want to see whether specializations are generated when argument types are changed, i.e., if <code>Base.specializations(@which f(...))</code> contains specializations for the argument in question.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">注意してください、<a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_typed"><code>@code_typed</code></a> およびその仲間は、Juliaが通常そのメソッド呼び出しを特化しない場合でも、常に特化されたコードを表示します。引数の型が変更されたときに特化が生成されるかどうかを確認したい場合は、<a href="../../devdocs/ast/index.html#ast-lowered-method">メソッド内部</a>を確認する必要があります。つまり、<code>Base.specializations(@which f(...))</code> が問題の引数に対する特化を含んでいるかどうかです。</span></p><h3 id="Write-&quot;type-stable&quot;-functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Write-&quot;type-stable&quot;-functions">Write "type-stable" functions</a><a id="Write-&quot;type-stable&quot;-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Write-&quot;type-stable&quot;-functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Write-&quot;type-stable&quot;-functions">"型安定"な関数を書く</a><a id="Write-&quot;type-stable&quot;-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Write-&quot;type-stable&quot;-functions" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">When possible, it helps to ensure that a function always returns a value of the same type. Consider the following definition:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">可能な場合は、関数が常に同じ型の値を返すことを保証するのが役立ちます。次の定義を考えてみてください：</span></p><pre><code class="language-julia hljs">pos(x) = x &lt; 0 ? 0 : x</code></pre><p data-translated="true"><span class="original-text">Although this seems innocent enough, the problem is that <code>0</code> is an integer (of type <code>Int</code>) and <code>x</code> might be of any type. Thus, depending on the value of <code>x</code>, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは無害に見えますが、問題は<code>0</code>が整数（型<code>Int</code>）であり、<code>x</code>が任意の型である可能性があることです。したがって、<code>x</code>の値に応じて、この関数は2つの型のいずれかの値を返す可能性があります。この動作は許可されており、場合によっては望ましいこともあります。しかし、次のように簡単に修正できます：</span></p><pre><code class="language-julia hljs">pos(x) = x &lt; 0 ? zero(x) : x</code></pre><p data-translated="true"><span class="original-text">There is also a <a href="../../base/numbers/index.html#Base.oneunit"><code>oneunit</code></a> function, and a more general <a href="../../base/base/index.html#Base.oftype"><code>oftype(x, y)</code></a> function, which returns <code>y</code> converted to the type of <code>x</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、<a href="../../base/numbers/index.html#Base.oneunit"><code>oneunit</code></a>関数や、<a href="../../base/base/index.html#Base.oftype"><code>oftype(x, y)</code></a>関数もあり、これは<code>y</code>を<code>x</code>の型に変換して返します。</span></p><h3 id="Avoid-changing-the-type-of-a-variable" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a><a id="Avoid-changing-the-type-of-a-variable-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-changing-the-type-of-a-variable" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Avoid-changing-the-type-of-a-variable">変数の型を変更しないようにする</a><a id="Avoid-changing-the-type-of-a-variable-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-changing-the-type-of-a-variable" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">An analogous "type-stability" problem exists for variables used repeatedly within a function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数内で繰り返し使用される変数にも類似の「型安定性」問題があります：</span></p><pre><code class="language-julia hljs">function foo()
    x = 1
    for i = 1:10
        x /= rand()
    end
    return x
end</code></pre><p data-translated="true"><span class="original-text">Local variable <code>x</code> starts as an integer, and after one loop iteration becomes a floating-point number (the result of <a href="../../base/math/#Base.:/#Base.:/"><code>/</code></a> operator). This makes it more difficult for the compiler to optimize the body of the loop. There are several possible fixes:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ローカル変数<code>x</code>は整数として始まり、1回のループ反復後に浮動小数点数（<a href="../../base/math/#Base.:/#Base.:/"><code>/</code></a>演算子の結果）になります。これにより、コンパイラがループの本体を最適化するのが難しくなります。いくつかの修正方法があります：</span></p><ul><li data-translated="true"><span class="original-text">Initialize <code>x</code> with <code>x = 1.0</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>x</code>を<code>x = 1.0</code>で初期化します</span></li><li data-translated="true"><span class="original-text">Declare the type of <code>x</code> explicitly as <code>x::Float64 = 1</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>x</code>の型を明示的に<code>x::Float64 = 1</code>として宣言します</span></li><li data-translated="true"><span class="original-text">Use an explicit conversion by <code>x = oneunit(Float64)</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>x = oneunit(Float64)</code>による明示的な変換を使用します</span></li><li data-translated="true"><span class="original-text">Initialize with the first loop iteration, to <code>x = 1 / rand()</code>, then loop <code>for i = 2:10</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初のループの反復で<code>x = 1 / rand()</code>として初期化し、その後<code>for i = 2:10</code>でループします</span></li></ul><h3 id="kernel-functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#kernel-functions">Separate kernel functions (aka, function barriers)</a><a id="kernel-functions-1"></a><a class="docs-heading-anchor-permalink" href="#kernel-functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#kernel-functions">カーネル関数（別名、関数バリア）を分離する</a><a id="kernel-functions-1"></a><a class="docs-heading-anchor-permalink" href="#kernel-functions" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Many functions follow a pattern of performing some set-up work, and then running many iterations to perform a core computation. Where possible, it is a good idea to put these core computations in separate functions. For example, the following contrived function returns an array of a randomly-chosen type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">多くの関数は、いくつかのセットアップ作業を行い、その後コア計算を実行する多くの反復を行うパターンに従います。可能な限り、これらのコア計算を別の関数に置くことが良いアイデアです。例えば、以下の作成した関数はランダムに選ばれた型の配列を返します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function strange_twos(n)
           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)
           for i = 1:n
               a[i] = 2
           end
           return a
       end;

julia&gt; strange_twos(3)
3-element Vector{Int64}:
 2
 2
 2</code></pre><p data-translated="true"><span class="original-text">This should be written as:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは次のように書くべきです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function fill_twos!(a)
           for i = eachindex(a)
               a[i] = 2
           end
       end;

julia&gt; function strange_twos(n)
           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)
           fill_twos!(a)
           return a
       end;

julia&gt; strange_twos(3)
3-element Vector{Int64}:
 2
 2
 2</code></pre><p data-translated="true"><span class="original-text">Julia's compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of <code>a</code> during the loop (since it is chosen randomly). Therefore the second version is generally faster since the inner loop can be recompiled as part of <code>fill_twos!</code> for different types of <code>a</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaのコンパイラは関数境界で引数の型に特化したコードを生成するため、元の実装ではループ中に<code>a</code>の型を知りません（ランダムに選ばれるため）。したがって、内側のループは異なる型の<code>a</code>に対して<code>fill_twos!</code>の一部として再コンパイルできるため、2番目のバージョンは一般的に速くなります。</span></p><p data-translated="true"><span class="original-text">The second form is also often better style and can lead to more code reuse.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">2番目の形式は、スタイルとしても優れていることが多く、より多くのコード再利用につながる可能性があります。</span></p><p data-translated="true"><span class="original-text">This pattern is used in several places in Julia Base. For example, see <code>vcat</code> and <code>hcat</code> in <a href="https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206#L1205-L1206"><code>abstractarray.jl</code></a>, or the <a href="../../base/arrays/index.html#Base.fill!"><code>fill!</code></a> function, which we could have used instead of writing our own <code>fill_twos!</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このパターンはJulia Baseのいくつかの場所で使用されています。例えば、<a href="https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206#L1205-L1206"><code>abstractarray.jl</code></a>の<code>vcat</code>や<code>hcat</code>、または私たちが独自の<code>fill_twos!</code>を書く代わりに使用できた<a href="../../base/arrays/index.html#Base.fill!"><code>fill!</code></a>関数などです。</span></p><p data-translated="true"><span class="original-text">Functions like <code>strange_twos</code> occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">不確定な型のデータを扱うとき、例えば整数、浮動小数点数、文字列、またはその他のものが含まれている可能性のある入力ファイルから読み込まれたデータの場合、<code>strange_twos</code>のような関数が発生します。</span></p><h3 id="man-code-warntype" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-code-warntype"></a><a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a><a id="man-code-warntype-1"></a><a class="docs-heading-anchor-permalink" href="#man-code-warntype" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-code-warntype"></a><a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a><a id="man-code-warntype-1"></a><a class="docs-heading-anchor-permalink" href="#man-code-warntype" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The macro <a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a> (or its function variant <a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.code_warntype"><code>code_warntype</code></a>) can sometimes be helpful in diagnosing type-related problems. Here's an example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マクロ<a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a>（またはその関数バリアント<a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.code_warntype"><code>code_warntype</code></a>）は、型に関連する問題を診断するのに役立つことがあります。以下はその例です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @noinline pos(x) = x &lt; 0 ? 0 : x;

julia&gt; function f(x)
           y = pos(x)
           return sin(y*x + 1)
       end;

julia&gt; @code_warntype f(3.2)
MethodInstance for f(::Float64)
  from f(x) @ Main REPL[9]:1
Arguments
  #self#::Core.Const(f)
  x::Float64
Locals
  y::Union{Float64, Int64}
Body::Float64
1 ─      (y = Main.pos(x))
│   %2 = (y * x)::Float64
│   %3 = (%2 + 1)::Float64
│   %4 = Main.sin(%3)::Float64
└──      return %4</code></pre><p data-translated="true"><span class="original-text">Interpreting the output of <a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a>, like that of its cousins <a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_lowered"><code>@code_lowered</code></a>, <a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_typed"><code>@code_typed</code></a>, <a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_llvm"><code>@code_llvm</code></a>, and <a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_native"><code>@code_native</code></a>, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the <code>::T</code> (where <code>T</code> might be <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>, for example). The most important characteristic of <a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a> is that non-concrete types are displayed in red; since this document is written in Markdown, which has no color, in this document, red text is denoted by uppercase.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a>の出力を解釈することは、<a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_lowered"><code>@code_lowered</code></a>、<a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_typed"><code>@code_typed</code></a>、<a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_llvm"><code>@code_llvm</code></a>、および<a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_native"><code>@code_native</code></a>のような親戚の出力を解釈することは、少し練習が必要です。あなたのコードは、コンパイルされた機械コードを生成する過程で大きく消化された形で提示されています。ほとんどの式には型が注釈されており、<code>::T</code>で示されています（ここで<code>T</code>は例えば<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>かもしれません）。<a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a>の最も重要な特徴は、非具体的な型が赤で表示されることです。このドキュメントはMarkdownで書かれているため、色はありませんが、このドキュメントでは赤いテキストは大文字で示されています。</span></p><p data-translated="true"><span class="original-text">At the top, the inferred return type of the function is shown as <code>Body::Float64</code>. The next lines represent the body of <code>f</code> in Julia's SSA IR form. The numbered boxes are labels and represent targets for jumps (via <code>goto</code>) in your code. Looking at the body, you can see that the first thing that happens is that <code>pos</code> is called and the return value has been inferred as the <code>Union</code> type <code>Union{Float64, Int64}</code> shown in uppercase since it is a non-concrete type. This means that we cannot know the exact return type of <code>pos</code> based on the input types. However, the result of <code>y*x</code>is a <code>Float64</code> no matter if <code>y</code> is a <code>Float64</code> or <code>Int64</code> The net result is that <code>f(x::Float64)</code> will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最上部には、関数の推論された戻り型が<code>Body::Float64</code>として表示されています。次の行は、JuliaのSSA IR形式での<code>f</code>の本体を表しています。番号付きのボックスはラベルであり、あなたのコード内のジャンプ（<code>goto</code>を介して）のターゲットを表しています。本体を見てみると、最初に行われることは<code>pos</code>が呼び出され、その戻り値が非具体的な型であるため、大文字で示された<code>Union</code>型<code>Union{Float64, Int64}</code>として推論されていることがわかります。これは、入力型に基づいて<code>pos</code>の正確な戻り型を知ることができないことを意味します。しかし、<code>y*x</code>の結果は、<code>y</code>が<code>Float64</code>であろうと<code>Int64</code>であろうと、常に<code>Float64</code>です。最終的な結果は、<code>f(x::Float64)</code>がその出力において型不安定でないことです。たとえ中間計算のいくつかが型不安定であっても。</span></p><p data-translated="true"><span class="original-text">How you use this information is up to you. Obviously, it would be far and away best to fix <code>pos</code> to be type-stable: if you did so, all of the variables in <code>f</code> would be concrete, and its performance would be optimal. However, there are circumstances where this kind of <em>ephemeral</em> type instability might not matter too much: for example, if <code>pos</code> is never used in isolation, the fact that <code>f</code>'s output is type-stable (for <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> inputs) will shield later code from the propagating effects of type instability. This is particularly relevant in cases where fixing the type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the "damage" from type instability. Also, note that even Julia Base has functions that are type unstable. For example, the function <a href="../../base/arrays/index.html#Base.findfirst-Tuple{Any}"><code>findfirst</code></a> returns the index into an array where a key is found, or <code>nothing</code> if it is not found, a clear type instability. In order to make it easier to find the type instabilities that are likely to be important, <code>Union</code>s containing either <code>missing</code> or <code>nothing</code> are color highlighted in yellow, instead of red.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この情報をどのように使用するかはあなた次第です。明らかに、<code>pos</code>を型安定に修正するのが最も良いでしょう。そうすれば、<code>f</code>内のすべての変数が具体的になり、そのパフォーマンスは最適になります。しかし、この種の<em>一時的</em>な型不安定があまり重要でない場合もあります。例えば、<code>pos</code>が孤立して使用されない場合、<code>f</code>の出力が型安定である（<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>入力の場合）ことは、後のコードが型不安定の影響を受けるのを防ぎます。これは、型不安定を修正するのが難しいまたは不可能な場合に特に関連します。そのような場合、上記のヒント（例えば、型注釈を追加することや関数を分割すること）は、型不安定からの「損害」を抑えるための最良のツールです。また、Julia Baseにも型不安定な関数があることに注意してください。例えば、関数<a href="../../base/arrays/index.html#Base.findfirst-Tuple{Any}"><code>findfirst</code></a>は、キーが見つかった配列のインデックスを返すか、見つからなかった場合は<code>nothing</code>を返します。これは明確な型不安定です。重要である可能性のある型不安定を見つけやすくするために、<code>missing</code>または<code>nothing</code>を含む<code>Union</code>は赤ではなく黄色で強調表示されます。</span></p><p data-translated="true"><span class="original-text">The following examples may help you interpret expressions marked as containing non-concrete types:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">以下の例は、非具体的な型を含むとマークされた式を解釈するのに役立つかもしれません：</span></p><ul><li><p data-translated="true"><span class="original-text">Function body starting with <code>Body::Union{T1,T2})</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数本体が<code>Body::Union{T1,T2})</code>で始まる</span></p><ul><li data-translated="true"><span class="original-text">Interpretation: function with unstable return type</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">解釈：不安定な戻り型の関数</span></li><li data-translated="true"><span class="original-text">Suggestion: make the return value type-stable, even if you have to annotate it</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">提案：戻り値を型安定にする、たとえ注釈を付ける必要があっても</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>invoke Main.g(%%x::Int64)::Union{Float64, Int64}</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>invoke Main.g(%%x::Int64)::Union{Float64, Int64}</code></span></p><ul><li data-translated="true"><span class="original-text">Interpretation: call to a type-unstable function <code>g</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">解釈: 型が不安定な関数 <code>g</code> への呼び出し。</span></li><li data-translated="true"><span class="original-text">Suggestion: fix the function, or if necessary annotate the return value</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">提案: 関数を修正するか、必要に応じて戻り値に注釈を付ける。</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>invoke Base.getindex(%%x::Array{Any,1}, 1::Int64)::Any</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>invoke Base.getindex(%%x::Array{Any,1}, 1::Int64)::Any</code></span></p><ul><li data-translated="true"><span class="original-text">Interpretation: accessing elements of poorly-typed arrays</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">解釈: 型が不適切な配列の要素にアクセスしている。</span></li><li data-translated="true"><span class="original-text">Suggestion: use arrays with better-defined types, or if necessary annotate the type of individual element accesses</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">提案: より明確に定義された型の配列を使用するか、必要に応じて個々の要素アクセスの型に注釈を付ける。</span></li></ul></li><li><p data-translated="true"><span class="original-text"><code>Base.getfield(%%x, :(:data))::Array{Float64,N} where N</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Base.getfield(%%x, :(:data))::Array{Float64,N} where N</code></span></p><ul><li data-translated="true"><span class="original-text">Interpretation: getting a field that is of non-concrete type. In this case, the type of <code>x</code>, say <code>ArrayContainer</code>, had a field <code>data::Array{T}</code>. But <code>Array</code> needs the dimension <code>N</code>, too, to be a concrete type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">解釈: 非具体的な型のフィールドを取得している。この場合、<code>x</code> の型、例えば <code>ArrayContainer</code> にはフィールド <code>data::Array{T}</code> があった。しかし、<code>Array</code> は具体的な型であるために次元 <code>N</code> も必要である。</span></li><li data-translated="true"><span class="original-text">Suggestion: use concrete types like <code>Array{T,3}</code> or <code>Array{T,N}</code>, where <code>N</code> is now a parameter of <code>ArrayContainer</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">提案: <code>Array{T,3}</code> や <code>Array{T,N}</code> のような具体的な型を使用する。ここで <code>N</code> は現在 <code>ArrayContainer</code> のパラメータである。</span></li></ul></li></ul><h3 id="man-performance-captured" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-performance-captured">Performance of captured variable</a><a id="man-performance-captured-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-captured" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-performance-captured">キャプチャされた変数のパフォーマンス</a><a id="man-performance-captured-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-captured" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Consider the following example that defines an inner function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次の例を考えてみましょう。これは内部関数を定義しています：</span></p><pre><code class="language-julia hljs">function abmult(r::Int)
    if r &lt; 0
        r = -r
    end
    f = x -&gt; x * r
    return f
end</code></pre><p data-translated="true"><span class="original-text">Function <code>abmult</code> returns a function <code>f</code> that multiplies its argument by the absolute value of <code>r</code>. The inner function assigned to <code>f</code> is called a "closure". Inner functions are also used by the language for <code>do</code>-blocks and for generator expressions.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数 <code>abmult</code> は、引数を <code>r</code> の絶対値で乗算する関数 <code>f</code> を返します。<code>f</code> に割り当てられた内部関数は「クロージャ」と呼ばれます。内部関数は、<code>do</code> ブロックやジェネレーター式のために言語によっても使用されます。</span></p><p data-translated="true"><span class="original-text">This style of code presents performance challenges for the language. The parser, when translating it into lower-level instructions, substantially reorganizes the above code by extracting the inner function to a separate code block.  "Captured" variables such as <code>r</code> that are shared by inner functions and their enclosing scope are also extracted into a heap-allocated "box" accessible to both inner and outer functions because the language specifies that <code>r</code> in the inner scope must be identical to <code>r</code> in the outer scope even after the outer scope (or another inner function) modifies <code>r</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このスタイルのコードは、言語にとってパフォーマンス上の課題を提示します。パーサーは、これを低レベルの命令に変換する際に、内部関数を別のコードブロックに抽出することによって、上記のコードを大幅に再編成します。「キャプチャされた」変数（<code>r</code> など）は、内部関数とその囲むスコープによって共有されるため、内部関数と外部関数の両方からアクセス可能なヒープに割り当てられた「ボックス」にも抽出されます。これは、言語が内部スコープの <code>r</code> が外部スコープの <code>r</code> と同一でなければならないと指定しているためです。たとえ外部スコープ（または別の内部関数）が <code>r</code> を変更した後でも。</span></p><p data-translated="true"><span class="original-text">The discussion in the preceding paragraph referred to the "parser", that is, the phase of compilation that takes place when the module containing <code>abmult</code> is first loaded, as opposed to the later phase when it is first invoked. The parser does not "know" that <code>Int</code> is a fixed type, or that the statement <code>r = -r</code> transforms an <code>Int</code> to another <code>Int</code>. The magic of type inference takes place in the later phase of compilation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">前の段落での議論は「パーサー」に言及しており、これは <code>abmult</code> を含むモジュールが最初にロードされるときに発生するコンパイルのフェーズを指します。最初に呼び出されるときの後のフェーズとは対照的です。パーサーは、<code>Int</code> が固定型であることや、<code>r = -r</code> という文が <code>Int</code> を別の <code>Int</code> に変換することを「知りません」。型推論の魔法は、コンパイルの後のフェーズで発生します。</span></p><p data-translated="true"><span class="original-text">Thus, the parser does not know that <code>r</code> has a fixed type (<code>Int</code>). Nor that <code>r</code> does not change value once the inner function is created (so that the box is unneeded). Therefore, the parser emits code for box that holds an object with an abstract type such as <code>Any</code>, which requires run-time type dispatch for each occurrence of <code>r</code>. This can be verified by applying <code>@code_warntype</code> to the above function. Both the boxing and the run-time type dispatch can cause loss of performance.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、パーサーは <code>r</code> が固定型（<code>Int</code>）であることを知りません。また、内部関数が作成された後に <code>r</code> の値が変わらないこと（そのためボックスは不要であること）も知りません。したがって、パーサーは、<code>r</code> の各出現に対してランタイム型ディスパッチを必要とする抽象型のオブジェクトを保持するボックスのコードを出力します。これは、上記の関数に <code>@code_warntype</code> を適用することで確認できます。ボクシングとランタイム型ディスパッチの両方がパフォーマンスの低下を引き起こす可能性があります。</span></p><p data-translated="true"><span class="original-text">If captured variables are used in a performance-critical section of the code, then the following tips help ensure that their use is performant. First, if it is known that a captured variable does not change its type, then this can be declared explicitly with a type annotation (on the variable, not the right-hand side):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キャプチャされた変数がパフォーマンスに重要なコードセクションで使用される場合、次のヒントがその使用をパフォーマンス的に確保するのに役立ちます。まず、キャプチャされた変数がその型を変更しないことが分かっている場合、これは型注釈（変数に対して、右辺ではなく）で明示的に宣言できます：</span></p><pre><code class="language-julia hljs">function abmult2(r0::Int)
    r::Int = r0
    if r &lt; 0
        r = -r
    end
    f = x -&gt; x * r
    return f
end</code></pre><p data-translated="true"><span class="original-text">The type annotation partially recovers lost performance due to capturing because the parser can associate a concrete type to the object in the box. Going further, if the captured variable does not need to be boxed at all (because it will not be reassigned after the closure is created), this can be indicated with <code>let</code> blocks as follows.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型注釈は、パーサーがボックス内のオブジェクトに具体的な型を関連付けることができるため、キャプチャによって失われたパフォーマンスを部分的に回復します。さらに、キャプチャされた変数が全くボクシングされる必要がない場合（クロージャが作成された後に再代入されないため）、これは次のように <code>let</code> ブロックで示すことができます。</span></p><pre><code class="language-julia hljs">function abmult3(r::Int)
    if r &lt; 0
        r = -r
    end
    f = let r = r
            x -&gt; x * r
    end
    return f
end</code></pre><p data-translated="true"><span class="original-text">The <code>let</code> block creates a new variable <code>r</code> whose scope is only the inner function. The second technique recovers full language performance in the presence of captured variables. Note that this is a rapidly evolving aspect of the compiler, and it is likely that future releases will not require this degree of programmer annotation to attain performance. In the mean time, some user-contributed packages like <a href="https://github.com/c42f/FastClosures.jl">FastClosures</a> automate the insertion of <code>let</code> statements as in <code>abmult3</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>let</code> ブロックは、スコープが内部関数のみの新しい変数 <code>r</code> を作成します。2番目の技術は、キャプチャされた変数が存在する場合に完全な言語パフォーマンスを回復します。これはコンパイラの急速に進化している側面であり、将来のリリースではパフォーマンスを達成するためにこの程度のプログラマー注釈が必要なくなる可能性が高いです。その間、<a href="https://github.com/c42f/FastClosures.jl">FastClosures</a> のようなユーザー提供のパッケージが、<code>abmult3</code> のように <code>let</code> 文の挿入を自動化します。</span></p><h3 id="man-performance-value-type" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-performance-value-type">Types with values-as-parameters</a><a id="man-performance-value-type-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-value-type" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-performance-value-type">値をパラメータとして持つ型</a><a id="man-performance-value-type-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-value-type" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Let's say you want to create an <code>N</code>-dimensional array that has size 3 along each axis. Such arrays can be created like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、各軸のサイズが3の <code>N</code> 次元配列を作成したいとします。このような配列は次のように作成できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(5.0, (3, 3))
3×3 Matrix{Float64}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0</code></pre><p data-translated="true"><span class="original-text">This approach works very well: the compiler can figure out that <code>A</code> is an <code>Array{Float64,2}</code> because it knows the type of the fill value (<code>5.0::Float64</code>) and the dimensionality (<code>(3, 3)::NTuple{2,Int}</code>). This implies that the compiler can generate very efficient code for any future usage of <code>A</code> in the same function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このアプローチは非常にうまく機能します：コンパイラは、<code>A</code>が<code>Array{Float64,2}</code>であることを判断できます。なぜなら、フィル値の型（<code>5.0::Float64</code>）と次元（<code>(3, 3)::NTuple{2,Int}</code>）を知っているからです。これは、コンパイラが同じ関数内での<code>A</code>の将来の使用に対して非常に効率的なコードを生成できることを意味します。</span></p><p data-translated="true"><span class="original-text">But now let's say you want to write a function that creates a 3×3×... array in arbitrary dimensions; you might be tempted to write a function</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、今、任意の次元で3×3×...の配列を作成する関数を書きたいとしましょう；あなたは関数を書くことを考えるかもしれません。</span></p><pre><code class="language-julia-repl hljs">julia&gt; function array3(fillval, N)
           fill(fillval, ntuple(d-&gt;3, N))
       end
array3 (generic function with 1 method)

julia&gt; array3(5.0, 2)
3×3 Matrix{Float64}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0</code></pre><p data-translated="true"><span class="original-text">This works, but (as you can verify for yourself using <code>@code_warntype array3(5.0, 2)</code>) the problem is that the output type cannot be inferred: the argument <code>N</code> is a <em>value</em> of type <code>Int</code>, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of <code>A</code>; such code will be very slow.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは機能しますが（<code>@code_warntype array3(5.0, 2)</code>を使用して自分で確認できます）、問題は出力型を推測できないことです：引数<code>N</code>は<em>値</em>としての型<code>Int</code>であり、型推論はその値を事前に予測することはできません。これは、この関数の出力を使用するコードが保守的でなければならず、<code>A</code>への各アクセスで型をチェックしなければならないことを意味します；そのようなコードは非常に遅くなります。</span></p><p data-translated="true"><span class="original-text">Now, one very good way to solve such problems is by using the <a href="#kernel-functions">function-barrier technique</a>. However, in some cases you might want to eliminate the type-instability altogether. In such cases, one approach is to pass the dimensionality as a parameter, for example through <code>Val{T}()</code> (see <a href="../types/index.html#&quot;Value-types&quot;">"Value types"</a>):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">今、このような問題を解決する非常に良い方法の一つは、<a href="#kernel-functions">関数バリア技術</a>を使用することです。しかし、場合によっては、型の不安定性を完全に排除したいこともあります。そのような場合の一つのアプローチは、次元をパラメータとして渡すことです。例えば、<code>Val{T}()</code>を通じて（<a href="../types/index.html#&quot;Value-types&quot;">"値型"</a>を参照）：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function array3(fillval, ::Val{N}) where N
           fill(fillval, ntuple(d-&gt;3, Val(N)))
       end
array3 (generic function with 1 method)

julia&gt; array3(5.0, Val(2))
3×3 Matrix{Float64}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0</code></pre><p data-translated="true"><span class="original-text">Julia has a specialized version of <code>ntuple</code> that accepts a <code>Val{::Int}</code> instance as the second parameter; by passing <code>N</code> as a type-parameter, you make its "value" known to the compiler. Consequently, this version of <code>array3</code> allows the compiler to predict the return type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaには、第二引数として<code>Val{::Int}</code>インスタンスを受け入れる<code>ntuple</code>の特化版があります；<code>N</code>を型パラメータとして渡すことで、その「値」をコンパイラに知らしめます。したがって、このバージョンの<code>array3</code>は、コンパイラが戻り値の型を予測できるようにします。</span></p><p data-translated="true"><span class="original-text">However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called <code>array3</code> from a function like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、このような技術を利用することは驚くほど微妙です。例えば、次のような関数から<code>array3</code>を呼び出しても役に立ちません：</span></p><pre><code class="language-julia hljs">function call_array3(fillval, n)
    A = array3(fillval, Val(n))
end</code></pre><p data-translated="true"><span class="original-text">Here, you've created the same problem all over again: the compiler can't guess what <code>n</code> is, so it doesn't know the <em>type</em> of <code>Val(n)</code>. Attempting to use <code>Val</code>, but doing so incorrectly, can easily make performance <em>worse</em> in many situations. (Only in situations where you're effectively combining <code>Val</code> with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、同じ問題を再び作成しています：コンパイラは<code>n</code>が何であるかを推測できないため、<code>Val(n)</code>の<em>型</em>を知りません。<code>Val</code>を使用しようとするが、誤って行うと、多くの状況でパフォーマンスが<em>悪化</em>する可能性があります。（<code>Val</code>を関数バリアトリックと組み合わせてカーネル関数をより効率的にする場合にのみ、上記のようなコードを使用すべきです。）</span></p><p data-translated="true"><span class="original-text">An example of correct usage of <code>Val</code> would be:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Val</code>の正しい使用例は次のとおりです：</span></p><pre><code class="language-julia hljs">function filter3(A::AbstractArray{T,N}) where {T,N}
    kernel = array3(1, Val(N))
    filter(A, kernel)
end</code></pre><p data-translated="true"><span class="original-text">In this example, <code>N</code> is passed as a parameter, so its "value" is known to the compiler. Essentially, <code>Val(T)</code> works only when <code>T</code> is either hard-coded/literal (<code>Val(3)</code>) or already specified in the type-domain.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例では、<code>N</code>がパラメータとして渡されているため、その「値」がコンパイラに知られています。本質的に、<code>Val(T)</code>は、<code>T</code>がハードコーディングされたリテラル（<code>Val(3)</code>）であるか、すでに型ドメインで指定されている場合にのみ機能します。</span></p><h3 id="The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a><a id="The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)-1"></a><a class="docs-heading-anchor-permalink" href="#The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)">複数のディスパッチを悪用する危険性（別名、値をパラメータとして持つ型に関する詳細）</a><a id="The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)-1"></a><a class="docs-heading-anchor-permalink" href="#The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Once one learns to appreciate multiple dispatch, there's an understandable tendency to go overboard and try to use it for everything. For example, you might imagine using it to store information, e.g.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複数のディスパッチを評価することを学ぶと、すべてにそれを使用しようとする理解できる傾向があります。例えば、情報を保存するためにそれを使用することを想像するかもしれません。例えば、</span></p><pre><code class="nohighlight hljs">struct Car{Make, Model}
    year::Int
    ...more fields...
end</code></pre><p data-translated="true"><span class="original-text">and then dispatch on objects like <code>Car{:Honda,:Accord}(year, args...)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そして、<code>Car{:Honda,:Accord}(year, args...)</code>のようなオブジェクトにディスパッチすることです。</span></p><p data-translated="true"><span class="original-text">This might be worthwhile when either of the following are true:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、次のいずれかが真である場合に価値があります：</span></p><ul><li data-translated="true"><span class="original-text">You require CPU-intensive processing on each <code>Car</code>, and it becomes vastly more efficient if you know the <code>Make</code> and <code>Model</code> at compile time and the total number of different <code>Make</code> or <code>Model</code> that will be used is not too large.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Car</code>ごとにCPU集約型の処理が必要であり、コンパイル時に<code>Make</code>と<code>Model</code>を知っていると、使用される異なる<code>Make</code>または<code>Model</code>の総数がそれほど大きくない場合、はるかに効率的になります。</span></li><li data-translated="true"><span class="original-text">You have homogeneous lists of the same type of <code>Car</code> to process, so that you can store them all in an <code>Array{Car{:Honda,:Accord},N}</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同じタイプの<code>Car</code>の均質なリストを処理する必要がある場合、すべてを<code>Array{Car{:Honda,:Accord},N}</code>に格納できます。</span></li></ul><p data-translated="true"><span class="original-text">When the latter holds, a function processing such a homogeneous array can be productively specialized: Julia knows the type of each element in advance (all objects in the container have the same concrete type), so Julia can "look up" the correct method calls when the function is being compiled (obviating the need to check at run-time) and thereby emit efficient code for processing the whole list.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">後者が成り立つ場合、そのような均質な配列を処理する関数は生産的に特化できます：Juliaは各要素の型を事前に知っているため（コンテナ内のすべてのオブジェクトが同じ具体的な型を持つ）、関数がコンパイルされるときに正しいメソッド呼び出しを「検索」できるため（実行時にチェックする必要がなく）、リスト全体を処理するための効率的なコードを生成できます。</span></p><p data-translated="true"><span class="original-text">When these do not hold, then it's likely that you'll get no benefit; worse, the resulting "combinatorial explosion of types" will be counterproductive. If <code>items[i+1]</code> has a different type than <code>item[i]</code>, Julia has to look up the type at run-time, search for the appropriate method in method tables, decide (via type intersection) which one matches, determine whether it has been JIT-compiled yet (and do so if not), and then make the call. In essence, you're asking the full type- system and JIT-compilation machinery to basically execute the equivalent of a switch statement or dictionary lookup in your own code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらが成り立たない場合、利益を得られない可能性が高く、さらに悪いことに、結果として得られる「型の組み合わせ爆発」は逆効果になります。もし<code>items[i+1]</code>が<code>item[i]</code>とは異なる型を持つ場合、Juliaは実行時に型を検索し、メソッドテーブルで適切なメソッドを探し、どれが一致するかを（型の交差を通じて）決定し、それがまだJITコンパイルされているかどうかを判断し（そうでない場合はそうします）、そして呼び出しを行います。要するに、あなたは完全な型システムとJITコンパイルの仕組みに、自分のコード内でスイッチ文や辞書の検索に相当するものを実行させようとしているのです。</span></p><p data-translated="true"><span class="original-text">Some run-time benchmarks comparing (1) type dispatch, (2) dictionary lookup, and (3) a "switch" statement can be found <a href="https://groups.google.com/forum/#!msg/julia-users/jUMu9A3QKQQ/qjgVWr7vAwAJ#!msg/julia-users/jUMu9A3QKQQ/qjgVWr7vAwAJ">on the mailing list</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(1) 型ディスパッチ、(2) 辞書の検索、(3) 「スイッチ」文を比較したいくつかの実行時ベンチマークは、<a href="https://groups.google.com/forum/#!msg/julia-users/jUMu9A3QKQQ/qjgVWr7vAwAJ#!msg/julia-users/jUMu9A3QKQQ/qjgVWr7vAwAJ">メーリングリスト</a>で見つけることができます。</span></p><p data-translated="true"><span class="original-text">Perhaps even worse than the run-time impact is the compile-time impact: Julia will compile specialized functions for each different <code>Car{Make, Model}</code>; if you have hundreds or thousands of such types, then every function that accepts such an object as a parameter (from a custom <code>get_year</code> function you might write yourself, to the generic <code>push!</code> function in Julia Base) will have hundreds or thousands of variants compiled for it. Each of these increases the size of the cache of compiled code, the length of internal lists of methods, etc. Excess enthusiasm for values-as-parameters can easily waste enormous resources.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実行時の影響よりもさらに悪いのはコンパイル時の影響です：Juliaは各異なる<code>Car{Make, Model}</code>のために特化した関数をコンパイルします；もしそのような型が何百も何千もある場合、カスタム<code>get_year</code>関数から、Julia Baseの一般的な<code>push!</code>関数まで、そのようなオブジェクトをパラメータとして受け入れるすべての関数には何百も何千もバリアントがコンパイルされます。これらの各々は、コンパイルされたコードのキャッシュのサイズ、メソッドの内部リストの長さなどを増加させます。パラメータとしての値に対する過剰な熱意は、簡単に膨大なリソースを浪費する可能性があります。</span></p><h2 id="Memory-management-and-arrays" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Memory-management-and-arrays">Memory management and arrays</a><a id="Memory-management-and-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-management-and-arrays" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Memory-management-and-arrays">メモリ管理と配列</a><a id="Memory-management-and-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-management-and-arrays" title="Permalink"></a></span></h2><h3 id="Pre-allocate-outputs" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Pre-allocate-outputs">Pre-allocate outputs</a><a id="Pre-allocate-outputs-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-allocate-outputs" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Pre-allocate-outputs">出力の事前割り当て</a><a id="Pre-allocate-outputs-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-allocate-outputs" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">If your function returns an <code>Array</code> or some other complex type, it may have to allocate memory. Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数が <code>Array</code> やその他の複雑な型を返す場合、メモリを割り当てる必要があるかもしれません。残念ながら、割り当てとその逆であるガーベジコレクションは、しばしば大きなボトルネックとなります。</span></p><p data-translated="true"><span class="original-text">Sometimes you can circumvent the need to allocate memory on each function call by preallocating the output. As a trivial example, compare</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">時には、出力を事前に割り当てることで、各関数呼び出しでメモリを割り当てる必要を回避できます。単純な例として、次を比較してください。</span></p><pre><code class="language-julia-repl hljs">julia&gt; function xinc(x)
           return [x + i for i  in 1:3000]
       end;

julia&gt; function loopinc()
           y = 0
           for i = 1:10^5
               ret = xinc(i)
               y += ret[2]
           end
           return y
       end;</code></pre><p data-translated="true"><span class="original-text">with</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">と</span></p><pre><code class="language-julia-repl hljs">julia&gt; function xinc!(ret::AbstractVector{T}, x::T) where T
           for i in 1:3000
               ret[i] = x+i
           end
           nothing
       end;

julia&gt; function loopinc_prealloc()
           ret = Vector{Int}(undef, 3000)
           y = 0
           for i = 1:10^5
               xinc!(ret, i)
               y += ret[2]
           end
           return y
       end;</code></pre><p data-translated="true"><span class="original-text">Timing results:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">タイミング結果：</span></p><pre><code class="language-julia-repl hljs">julia&gt; @time loopinc()
  0.297454 seconds (200.00 k allocations: 2.239 GiB, 39.80% gc time)
5000250000

julia&gt; @time loopinc_prealloc()
  0.009410 seconds (2 allocations: 23.477 KiB)
5000250000</code></pre><p data-translated="true"><span class="original-text">Preallocation has other advantages, for example by allowing the caller to control the "output" type from an algorithm. In the example above, we could have passed a <code>SubArray</code> rather than an <a href="../../base/arrays/index.html#Core.Array"><code>Array</code></a>, had we so desired.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">事前割り当てには他の利点もあります。たとえば、呼び出し元がアルゴリズムからの「出力」型を制御できるようにします。上記の例では、希望すれば <code>Array</code> の代わりに <code>SubArray</code> を渡すことができました。</span></p><p data-translated="true"><span class="original-text">Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some judgment may be required. However, for "vectorized" (element-wise) functions, the convenient syntax <code>x .= f.(y)</code> can be used for in-place operations with fused loops and no temporary arrays (see the <a href="../functions/index.html#man-vectorized">dot syntax for vectorizing functions</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">極端に言えば、事前割り当てはコードを見栄えが悪くする可能性があるため、パフォーマンス測定といくつかの判断が必要です。しかし、「ベクトル化された」（要素ごとの）関数の場合、便利な構文 <code>x .= f.(y)</code> を使用して、テンポラリ配列なしで融合ループによるインプレース操作が可能です（<a href="../functions/index.html#man-vectorized">関数のベクトル化のためのドット構文</a>を参照）。</span></p><h3 id="man-performance-views" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-performance-views">Consider using views for slices</a><a id="man-performance-views-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-views" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-performance-views">スライスのためにビューを使用することを検討してください</a><a id="man-performance-views-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-views" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">In Julia, an array "slice" expression like <code>array[1:5, :]</code> creates a copy of that data (except on the left-hand side of an assignment, where <code>array[1:5, :] = ...</code> assigns in-place to that portion of <code>array</code>). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaでは、<code>array[1:5, :]</code> のような配列「スライス」式は、そのデータのコピーを作成します（代入の左辺では、<code>array[1:5, :] = ...</code> がその部分にインプレースで代入します）。スライスに対して多くの操作を行う場合、元の配列にインデックスを付けるよりも小さな連続したコピーで作業する方が効率的なため、パフォーマンスに良い影響を与えることがあります。一方、スライスに対していくつかの単純な操作を行うだけの場合、割り当てとコピー操作のコストがかなり大きくなる可能性があります。</span></p><p data-translated="true"><span class="original-text">An alternative is to create a "view" of the array, which is an array object (a <code>SubArray</code>) that actually references the data of the original array in-place, without making a copy. (If you write to a view, it modifies the original array's data as well.) This can be done for individual slices by calling <a href="../../base/arrays/index.html#Base.view"><code>view</code></a>, or more simply for a whole expression or block of code by putting <a href="../../base/arrays/index.html#Base.@views"><code>@views</code></a> in front of that expression. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">代替手段として、配列の「ビュー」を作成することができます。これは、実際に元の配列のデータをインプレースで参照する配列オブジェクト（<code>SubArray</code>）です。ビューに書き込むと、元の配列のデータも変更されます。これは、<a href="../../base/arrays/index.html#Base.view"><code>view</code></a> を呼び出すことで個々のスライスに対して行うことができ、またはその式の前に <a href="../../base/arrays/index.html#Base.@views"><code>@views</code></a> を置くことで、全体の式やコードブロックに対してより簡単に行うことができます。例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; fcopy(x) = sum(x[2:end-1]);

julia&gt; @views fview(x) = sum(x[2:end-1]);

julia&gt; x = rand(10^6);

julia&gt; @time fcopy(x);
  0.003051 seconds (3 allocations: 7.629 MB)

julia&gt; @time fview(x);
  0.001020 seconds (1 allocation: 16 bytes)</code></pre><p data-translated="true"><span class="original-text">Notice both the 3× speedup and the decreased memory allocation of the <code>fview</code> version of the function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数の <code>fview</code> バージョンの3倍のスピードアップとメモリ割り当ての減少の両方に注意してください。</span></p><h3 id="Consider-StaticArrays.jl-for-small-fixed-size-vector/matrix-operations" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Consider-StaticArrays.jl-for-small-fixed-size-vector/matrix-operations">Consider StaticArrays.jl for small fixed-size vector/matrix operations</a><a id="Consider-StaticArrays.jl-for-small-fixed-size-vector/matrix-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Consider-StaticArrays.jl-for-small-fixed-size-vector/matrix-operations" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Consider-StaticArrays.jl-for-small-fixed-size-vector/matrix-operations">小さな固定サイズのベクトル/行列操作には StaticArrays.jl を検討してください</a><a id="Consider-StaticArrays.jl-for-small-fixed-size-vector/matrix-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Consider-StaticArrays.jl-for-small-fixed-size-vector/matrix-operations" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">If your application involves many small (<code>&lt; 100</code> element) arrays of fixed sizes (i.e. the size is known prior to execution), then you might want to consider using the <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl package</a>. This package allows you to represent such arrays in a way that avoids unnecessary heap allocations and allows the compiler to specialize code for the <em>size</em> of the array, e.g. by completely unrolling vector operations (eliminating the loops) and storing elements in CPU registers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">アプリケーションが多くの小さな (<code>&lt; 100</code> 要素) 固定サイズの配列を含む場合 (つまり、サイズが実行前に知られている場合)、<a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl パッケージ</a>の使用を検討することをお勧めします。このパッケージは、そのような配列を不必要なヒープ割り当てを避ける方法で表現でき、コンパイラが配列の <em>サイズ</em> に特化したコードを生成できるようにします。例えば、ベクトル操作を完全に展開して (ループを排除し) 要素を CPU レジスタに格納することができます。</span></p><p data-translated="true"><span class="original-text">For example, if you are doing computations with 2d geometries, you might have many computations with 2-component vectors. By using the <code>SVector</code> type from StaticArrays.jl, you can use convenient vector notation and operations like <code>norm(3v - w)</code> on vectors <code>v</code> and <code>w</code>, while allowing the compiler to unroll the code to a minimal computation equivalent to <code>@inbounds hypot(3v[1]-w[1], 3v[2]-w[2])</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、2次元の幾何学で計算を行っている場合、2成分ベクトルで多くの計算を行うことがあります。StaticArrays.jl の <code>SVector</code> 型を使用することで、ベクトル <code>v</code> と <code>w</code> に対して <code>norm(3v - w)</code> のような便利なベクトル表記と操作を使用でき、コンパイラがコードを最小限の計算に展開できるようになります。これは <code>@inbounds hypot(3v[1]-w[1], 3v[2]-w[2])</code> に相当します。</span></p><h3 id="More-dots:-Fuse-vectorized-operations" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#More-dots:-Fuse-vectorized-operations">More dots: Fuse vectorized operations</a><a id="More-dots:-Fuse-vectorized-operations-1"></a><a class="docs-heading-anchor-permalink" href="#More-dots:-Fuse-vectorized-operations" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#More-dots:-Fuse-vectorized-operations">より多くのドット: ベクトル化された操作を融合する</a><a id="More-dots:-Fuse-vectorized-operations-1"></a><a class="docs-heading-anchor-permalink" href="#More-dots:-Fuse-vectorized-operations" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Julia has a special <a href="../functions/index.html#man-vectorized">dot syntax</a> that converts any scalar function into a "vectorized" function call, and any operator into a "vectorized" operator, with the special property that nested "dot calls" are <em>fusing</em>: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use <code>.=</code> and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia には、任意のスカラー関数を「ベクトル化された」関数呼び出しに変換し、任意の演算子を「ベクトル化された」演算子に変換する特別な <a href="../functions/index.html#man-vectorized">ドット構文</a>があります。この特別なプロパティは、ネストされた「ドット呼び出し」が <em>融合</em> されることです: それらは構文レベルで単一のループに結合され、一時的な配列を割り当てることなく実行されます。<code>.=</code> や類似の代入演算子を使用すると、結果は事前に割り当てられた配列にそのまま格納することもできます (上記を参照)。</span></p><p data-translated="true"><span class="original-text">In a linear-algebra context, this means that even though operations like <code>vector + vector</code> and <code>vector * scalar</code> are defined, it can be advantageous to instead use <code>vector .+ vector</code> and <code>vector .* scalar</code> because the resulting loops can be fused with surrounding computations. For example, consider the two functions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">線形代数の文脈では、<code>vector + vector</code> や <code>vector * scalar</code> のような操作が定義されているにもかかわらず、<code>vector .+ vector</code> や <code>vector .* scalar</code> を使用する方が有利な場合があります。なぜなら、結果として得られるループは周囲の計算と融合できるからです。例えば、次の2つの関数を考えてみてください:</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = 3x.^2 + 4x + 7x.^3;

julia&gt; fdot(x) = @. 3x^2 + 4x + 7x^3; # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3</code></pre><p data-translated="true"><span class="original-text">Both <code>f</code> and <code>fdot</code> compute the same thing. However, <code>fdot</code> (defined with the help of the <a href="../../base/arrays/index.html#Base.Broadcast.@__dot__"><code>@.</code></a> macro) is significantly faster when applied to an array:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>f</code> と <code>fdot</code> の両方は同じことを計算します。しかし、<code>fdot</code> (特別な <a href="../../base/arrays/index.html#Base.Broadcast.@__dot__"><code>@.</code></a> マクロの助けを借りて定義された) は、配列に適用したときに大幅に高速です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(10^6);

julia&gt; @time f(x);
  0.019049 seconds (16 allocations: 45.777 MiB, 18.59% gc time)

julia&gt; @time fdot(x);
  0.002790 seconds (6 allocations: 7.630 MiB)

julia&gt; @time f.(x);
  0.002626 seconds (8 allocations: 7.630 MiB)</code></pre><p data-translated="true"><span class="original-text">That is, <code>fdot(x)</code> is ten times faster and allocates 1/6 the memory of <code>f(x)</code>, because each <code>*</code> and <code>+</code> operation in <code>f(x)</code> allocates a new temporary array and executes in a separate loop. In this example <code>f.(x)</code> is as fast as <code>fdot(x)</code> but in many contexts it is more convenient to sprinkle some dots in your expressions than to define a separate function for each vectorized operation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">つまり、<code>fdot(x)</code> は <code>f(x)</code> の10倍の速さで、メモリを1/6しか割り当てません。なぜなら、<code>f(x)</code> の各 <code>*</code> および <code>+</code> 操作は新しい一時配列を割り当て、別のループで実行されるからです。この例では <code>f.(x)</code> は <code>fdot(x)</code> と同じくらい速いですが、多くの文脈では、各ベクトル化された操作のために別の関数を定義するよりも、式にいくつかのドットを散りばめる方が便利です。</span></p><h3 id="man-performance-unfuse" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-performance-unfuse">Fewer dots: Unfuse certain intermediate broadcasts</a><a id="man-performance-unfuse-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-unfuse" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-performance-unfuse">ドットを減らす: 特定の中間ブロードキャストを融合解除する</a><a id="man-performance-unfuse-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-unfuse" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The dot loop fusion mentioned above enables concise and idiomatic code to express highly performant operations. However, it is important to remember that the fused operation will be computed at every iteration of the broadcast. This means that in some situations, particularly in the presence of composed or multidimensional broadcasts, an expression with dot calls may be computing a function more times than intended. As an example, say we want to build a random matrix whose rows have Euclidean norm one. We might write something like the following:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記のドットループ融合は、高性能な操作を表現するための簡潔で慣用的なコードを可能にします。しかし、融合された操作はブロードキャストの各イテレーションで計算されることを忘れないことが重要です。これは、特に合成または多次元ブロードキャストが存在する場合、ドット呼び出しを含む式が意図したよりも多くの回数関数を計算している可能性があることを意味します。例えば、行のユークリッドノルムが1のランダム行列を構築したいとしましょう。次のように書くことができます：</span></p><pre><code class="nohighlight hljs">julia&gt; x = rand(1000, 1000);

julia&gt; d = sum(abs2, x; dims=2);

julia&gt; @time x ./= sqrt.(d);
  0.002049 seconds (4 allocations: 96 bytes)</code></pre><p data-translated="true"><span class="original-text">This will work. However, this expression will actually recompute <code>sqrt(d[i])</code> for <em>every</em> element in the row <code>x[i, :]</code>, meaning that many more square roots are computed than necessary. To see precisely over which indices the broadcast will iterate, we can call <code>Broadcast.combine_axes</code> on the arguments of the fused expression. This will return a tuple of ranges whose entries correspond to the axes of iteration; the product of lengths of these ranges will be the total number of calls to the fused operation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは機能します。しかし、この式は実際には行 <code>x[i, :]</code> の<em>すべての</em>要素に対して <code>sqrt(d[i])</code> を再計算するため、必要以上に多くの平方根が計算されることになります。ブロードキャストがどのインデックスをイテレートするかを正確に確認するために、融合された式の引数に対して <code>Broadcast.combine_axes</code> を呼び出すことができます。これにより、イテレーションの軸に対応する範囲のタプルが返されます。これらの範囲の長さの積は、融合された操作への呼び出しの総数になります。</span></p><p data-translated="true"><span class="original-text">It follows that when some components of the broadcast expression are constant along an axis—like the <code>sqrt</code> along the second dimension in the preceding example—there is potential for a performance improvement by forcibly "unfusing" those components, i.e. allocating the result of the broadcasted operation in advance and reusing the cached value along its constant axis. Some such potential approaches are to use temporary variables, wrap components of a dot expression in <code>identity</code>, or use an equivalent intrinsically vectorized (but non-fused) function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、ブロードキャスト式の一部のコンポーネントが軸に沿って定数である場合—前の例の第二次元に沿った <code>sqrt</code> のように—それらのコンポーネントを強制的に「未融合」にすることでパフォーマンスの改善の可能性があります。つまり、ブロードキャストされた操作の結果を事前に割り当て、その定数軸に沿ってキャッシュされた値を再利用することです。このようなアプローチのいくつかは、一時変数を使用すること、ドット式のコンポーネントを <code>identity</code> でラップすること、または同等の内在的にベクトル化された（しかし非融合の）関数を使用することです。</span></p><pre><code class="nohighlight hljs">julia&gt; @time let s = sqrt.(d); x ./= s end;
  0.000809 seconds (5 allocations: 8.031 KiB)

julia&gt; @time x ./= identity(sqrt.(d));
  0.000608 seconds (5 allocations: 8.031 KiB)

julia&gt; @time x ./= map(sqrt, d);
  0.000611 seconds (4 allocations: 8.016 KiB)</code></pre><p data-translated="true"><span class="original-text">Any of these options yields approximately a three-fold speedup at the cost of an allocation; for large broadcastables this speedup can be asymptotically very large.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらのオプションのいずれも、割り当てのコストで約3倍のスピードアップをもたらします。大きなブロードキャスト可能なデータに対しては、このスピードアップは漸近的に非常に大きくなる可能性があります。</span></p><h3 id="man-performance-column-major" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-performance-column-major">Access arrays in memory order, along columns</a><a id="man-performance-column-major-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-column-major" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-performance-column-major">メモリ順序で配列にアクセスする、列に沿って</a><a id="man-performance-column-major-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-column-major" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Multidimensional arrays in Julia are stored in column-major order. This means that arrays are stacked one column at a time. This can be verified using the <code>vec</code> function or the syntax <code>[:]</code> as shown below (notice that the array is ordered <code>[1 3 2 4]</code>, not <code>[1 2 3 4]</code>):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの多次元配列は列優先順序で格納されます。これは、配列が1列ずつ積み重ねられることを意味します。これは、以下に示すように <code>vec</code> 関数または構文 <code>[:]</code> を使用して確認できます（配列が <code>[1 3 2 4]</code> の順序であることに注意してください。<code>[1 2 3 4]</code> ではありません）：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; x[:]
4-element Vector{Int64}:
 1
 3
 2
 4</code></pre><p data-translated="true"><span class="original-text">This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (<code>numpy</code>) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression. Keep in mind that indexing an array with <code>:</code> is an implicit loop that iteratively accesses all elements within a particular dimension; it can be faster to extract columns than rows, for example.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この配列の順序付けの慣習は、Fortran、Matlab、Rなどの多くの言語で一般的です。列優先順序の代替は行優先順序であり、これはCやPython（<code>numpy</code>）などの他の言語で採用されている慣習です。配列の順序を覚えておくことは、配列をループする際に重要なパフォーマンス効果を持つ可能性があります。覚えておくべきルールは、列優先配列では最初のインデックスが最も急速に変化するということです。基本的に、内側のループインデックスがスライス式に最初に現れる場合、ループは速くなります。例えば、<code>:</code> で配列にインデックスを付けることは、特定の次元内のすべての要素に逐次アクセスする暗黙のループであることを考慮してください。列を抽出する方が行を抽出するよりも速い場合があります。</span></p><p data-translated="true"><span class="original-text">Consider the following contrived example. Imagine we wanted to write a function that accepts a <a href="../../base/arrays/index.html#Base.Vector"><code>Vector</code></a> and returns a square <a href="../../base/arrays/index.html#Base.Matrix"><code>Matrix</code></a> with either the rows or the columns filled with copies of the input vector. Assume that it is not important whether rows or columns are filled with these copies (perhaps the rest of the code can be easily adapted accordingly). We could conceivably do this in at least four ways (in addition to the recommended call to the built-in <a href="../../base/arrays/index.html#Base.repeat"><code>repeat</code></a>):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のような作り話の例を考えてみましょう。<a href="../../base/arrays/index.html#Base.Vector"><code>Vector</code></a> を受け取り、入力ベクトルのコピーで行または列を埋めた正方形の<a href="../../base/arrays/index.html#Base.Matrix"><code>Matrix</code></a> を返す関数を書きたいとします。行または列がこれらのコピーで埋められるかどうかは重要ではないと仮定します（おそらく残りのコードはそれに応じて簡単に適応できます）。少なくとも4つの方法（組み込みの<a href="../../base/arrays/index.html#Base.repeat"><code>repeat</code></a>への推奨呼び出しに加えて）でこれを実行できると考えられます：</span></p><pre><code class="language-julia hljs">function copy_cols(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for i = inds
        out[:, i] = x
    end
    return out
end

function copy_rows(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for i = inds
        out[i, :] = x
    end
    return out
end

function copy_col_row(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for col = inds, row = inds
        out[row, col] = x[row]
    end
    return out
end

function copy_row_col(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for row = inds, col = inds
        out[row, col] = x[col]
    end
    return out
end</code></pre><p data-translated="true"><span class="original-text">Now we will time each of these functions using the same random <code>10000</code> by <code>1</code> input vector:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さて、同じランダムな <code>10000</code> x <code>1</code> の入力ベクトルを使用して、これらの関数のそれぞれの時間を計測します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = randn(10000);

julia&gt; fmt(f) = println(rpad(string(f)*": ", 14, ' '), @elapsed f(x))

julia&gt; map(fmt, [copy_cols, copy_rows, copy_col_row, copy_row_col]);
copy_cols:    0.331706323
copy_rows:    1.799009911
copy_col_row: 0.415630047
copy_row_col: 1.721531501</code></pre><p data-translated="true"><span class="original-text">Notice that <code>copy_cols</code> is much faster than <code>copy_rows</code>. This is expected because <code>copy_cols</code> respects the column-based memory layout of the <code>Matrix</code> and fills it one column at a time. Additionally, <code>copy_col_row</code> is much faster than <code>copy_row_col</code> because it follows our rule of thumb that the first element to appear in a slice expression should be coupled with the inner-most loop.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">注意すべきは、<code>copy_cols</code> が <code>copy_rows</code> よりもはるかに速いことです。これは予想通りで、<code>copy_cols</code> は <code>Matrix</code> の列ベースのメモリレイアウトを尊重し、1列ずつ埋めるからです。さらに、<code>copy_col_row</code> は <code>copy_row_col</code> よりもはるかに速いです。なぜなら、スライス式に最初に現れる要素は内側のループと結びつけるべきという私たちのルールを遵守しているからです。</span></p><h3 id="Copying-data-is-not-always-bad" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Copying-data-is-not-always-bad">Copying data is not always bad</a><a id="Copying-data-is-not-always-bad-1"></a><a class="docs-heading-anchor-permalink" href="#Copying-data-is-not-always-bad" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Copying-data-is-not-always-bad">データのコピーは常に悪いわけではない</a><a id="Copying-data-is-not-always-bad-1"></a><a class="docs-heading-anchor-permalink" href="#Copying-data-is-not-always-bad" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Arrays are stored contiguously in memory, lending themselves to CPU vectorization and fewer memory accesses due to caching. These are the same reasons that it is recommended to access arrays in column-major order (see above). Irregular access patterns and non-contiguous views can drastically slow down computations on arrays because of non-sequential memory access.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">配列はメモリに連続して格納されており、CPUのベクトル化やキャッシュによるメモリアクセスの削減に寄与します。これらは、配列に列優先順序でアクセスすることが推奨される理由と同じです（上記参照）。不規則なアクセスパターンや非連続的なビューは、非連続メモリアクセスのために配列の計算を大幅に遅くする可能性があります。</span></p><p data-translated="true"><span class="original-text">Copying irregularly-accessed data into a contiguous array before repeatedly accessing it can result in a large speedup, such as in the example below. Here, a matrix is being accessed at randomly-shuffled indices before being multiplied. Copying into plain arrays speeds up the multiplication even with the added cost of copying and allocation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">不規則にアクセスされたデータを連続した配列にコピーしてから繰り返しアクセスすることで、大きな速度向上が得られる場合があります。以下の例では、行列がランダムにシャッフルされたインデックスでアクセスされた後に掛け算されます。プレーンな配列にコピーすることで、コピーと割り当ての追加コストがあっても掛け算が速くなります。</span></p><pre><code class="language-julia-repl hljs">julia&gt; using Random

julia&gt; A = randn(3000, 3000);

julia&gt; x = randn(2000);

julia&gt; inds = shuffle(1:3000)[1:2000];

julia&gt; function iterated_neural_network(A, x, depth)
           for _ in 1:depth
               x .= max.(0, A * x)
           end
           argmax(x)
       end

julia&gt; @time iterated_neural_network(view(A, inds, inds), x, 10)
  0.324903 seconds (12 allocations: 157.562 KiB)
1569

julia&gt; @time iterated_neural_network(A[inds, inds], x, 10)
  0.054576 seconds (13 allocations: 30.671 MiB, 13.33% gc time)
1569</code></pre><p data-translated="true"><span class="original-text">Provided there is enough memory, the cost of copying the view to an array is outweighed by the speed boost from doing the repeated matrix multiplications on a contiguous array.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">十分なメモリがある場合、ビューを配列にコピーするコストは、連続した配列での繰り返し行列掛け算から得られる速度向上によって相殺されます。</span></p><h3 id="man-multithreading-linear-algebra" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-multithreading-linear-algebra">Multithreading and linear algebra</a><a id="man-multithreading-linear-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#man-multithreading-linear-algebra" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-multithreading-linear-algebra">マルチスレッドと線形代数</a><a id="man-multithreading-linear-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#man-multithreading-linear-algebra" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">This section applies to multithreaded Julia code which, in each thread, performs linear algebra operations. Indeed, these linear algebra operations involve BLAS / LAPACK calls, which are themselves multithreaded. In this case, one must ensure that cores aren't oversubscribed due to the two different types of multithreading.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このセクションは、各スレッドで線形代数演算を行うマルチスレッドのJuliaコードに適用されます。実際、これらの線形代数演算はBLAS / LAPACK呼び出しを含み、これ自体がマルチスレッドです。この場合、2種類のマルチスレッドによってコアが過剰に使用されないようにする必要があります。</span></p><p data-translated="true"><span class="original-text">Julia compiles and uses its own copy of OpenBLAS for linear algebra, whose number of threads is controlled by the environment variable <code>OPENBLAS_NUM_THREADS</code>. It can either be set as a command line option when launching Julia, or modified during the Julia session with <code>BLAS.set_num_threads(N)</code> (the submodule <code>BLAS</code> is exported by <code>using LinearAlgebra</code>). Its current value can be accessed with <code>BLAS.get_num_threads()</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは線形代数のために独自のOpenBLASのコピーをコンパイルして使用し、そのスレッド数は環境変数<code>OPENBLAS_NUM_THREADS</code>によって制御されます。これは、Juliaを起動する際のコマンドラインオプションとして設定するか、Juliaセッション中に<code>BLAS.set_num_threads(N)</code>で変更できます（サブモジュール<code>BLAS</code>は<code>using LinearAlgebra</code>によってエクスポートされます）。現在の値は<code>BLAS.get_num_threads()</code>でアクセスできます。</span></p><p data-translated="true"><span class="original-text">When the user does not specify anything, Julia tries to choose a reasonable value for the number of OpenBLAS threads (e.g. based on the platform, the Julia version, etc.). However, it is generally recommended to check and set the value manually. The OpenBLAS behavior is as follows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ユーザーが何も指定しない場合、JuliaはOpenBLASスレッド数の合理的な値を選ぼうとします（例：プラットフォーム、Juliaのバージョンなどに基づいて）。ただし、一般的には手動で値を確認して設定することが推奨されます。OpenBLASの動作は以下の通りです：</span></p><ul><li data-translated="true"><span class="original-text">If <code>OPENBLAS_NUM_THREADS=1</code>, OpenBLAS uses the calling Julia thread(s), i.e. it "lives in" the Julia thread that runs the computation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もし<code>OPENBLAS_NUM_THREADS=1</code>の場合、OpenBLASは呼び出し元のJuliaスレッドを使用します。つまり、計算を実行するJuliaスレッドの中に「存在します」。</span></li><li data-translated="true"><span class="original-text">If <code>OPENBLAS_NUM_THREADS=N&gt;1</code>, OpenBLAS creates and manages its own pool of threads (<code>N</code> in total). There is just one OpenBLAS thread pool shared among all Julia threads.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もし<code>OPENBLAS_NUM_THREADS=N&gt;1</code>の場合、OpenBLASは独自のスレッドプールを作成し管理します（合計<code>N</code>）。すべてのJuliaスレッドで共有される1つのOpenBLASスレッドプールがあります。</span></li></ul><p data-translated="true"><span class="original-text">When you start Julia in multithreaded mode with <code>JULIA_NUM_THREADS=X</code>, it is generally recommended to set <code>OPENBLAS_NUM_THREADS=1</code>. Given the behavior described above, increasing the number of BLAS threads to <code>N&gt;1</code> can very easily lead to worse performance, in particular when <code>N&lt;&lt;X</code>. However this is just a rule of thumb, and the best way to set each number of threads is to experiment on your specific application.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">マルチスレッドモードで <code>JULIA_NUM_THREADS=X</code> を使用してJuliaを起動する場合、一般的には <code>OPENBLAS_NUM_THREADS=1</code> に設定することが推奨されます。上記の動作を考慮すると、BLASスレッドの数を <code>N&gt;1</code> に増やすと、特に <code>N&lt;&lt;X</code> の場合にパフォーマンスが悪化する可能性が非常に高いです。ただし、これはあくまで経験則であり、各スレッド数を設定する最良の方法は、特定のアプリケーションで実験することです。</span></p><h3 id="man-backends-linear-algebra" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-backends-linear-algebra">Alternative linear algebra backends</a><a id="man-backends-linear-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#man-backends-linear-algebra" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-backends-linear-algebra">代替の線形代数バックエンド</a><a id="man-backends-linear-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#man-backends-linear-algebra" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">As an alternative to OpenBLAS, there exist several other backends that can help with linear algebra performance. Prominent examples include <a href="https://github.com/JuliaLinearAlgebra/MKL.jl">MKL.jl</a> and <a href="https://github.com/JuliaMath/AppleAccelerate.jl">AppleAccelerate.jl</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">OpenBLASの代替として、線形代数のパフォーマンスを向上させるための他のバックエンドがいくつか存在します。代表的な例としては、<a href="https://github.com/JuliaLinearAlgebra/MKL.jl">MKL.jl</a> と <a href="https://github.com/JuliaMath/AppleAccelerate.jl">AppleAccelerate.jl</a> があります。</span></p><p data-translated="true"><span class="original-text">These are external packages, so we will not discuss them in detail here. Please refer to their respective documentations (especially because they have different behaviors than OpenBLAS with respect to multithreading).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらは外部パッケージであるため、ここでは詳細については説明しません。それぞれのドキュメントを参照してください（特に、マルチスレッドに関してOpenBLASとは異なる動作をするため）。</span></p><h2 id="Execution-latency,-package-loading-and-package-precompiling-time" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Execution-latency,-package-loading-and-package-precompiling-time">Execution latency, package loading and package precompiling time</a><a id="Execution-latency,-package-loading-and-package-precompiling-time-1"></a><a class="docs-heading-anchor-permalink" href="#Execution-latency,-package-loading-and-package-precompiling-time" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Execution-latency,-package-loading-and-package-precompiling-time">実行レイテンシ、パッケージの読み込みおよびパッケージの事前コンパイル時間</a><a id="Execution-latency,-package-loading-and-package-precompiling-time-1"></a><a class="docs-heading-anchor-permalink" href="#Execution-latency,-package-loading-and-package-precompiling-time" title="Permalink"></a></span></h2><h3 id="Reducing-time-to-first-plot-etc." data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Reducing-time-to-first-plot-etc.">Reducing time to first plot etc.</a><a id="Reducing-time-to-first-plot-etc.-1"></a><a class="docs-heading-anchor-permalink" href="#Reducing-time-to-first-plot-etc." title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Reducing-time-to-first-plot-etc.">最初のプロットまでの時間を短縮するなど</a><a id="Reducing-time-to-first-plot-etc.-1"></a><a class="docs-heading-anchor-permalink" href="#Reducing-time-to-first-plot-etc." title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The first time a julia method is called it (and any methods it calls, or ones that can be statically determined) will be compiled. The <a href="../profile/index.html#@time"><code>@time</code></a> macro family illustrates this.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">juliaメソッドが初めて呼び出されると、それ（およびそれが呼び出すメソッドや静的に決定できるメソッド）はコンパイルされます。<a href="../profile/index.html#@time"><code>@time</code></a> マクロファミリーがこれを示しています。</span></p><pre><code class="nohighlight hljs">julia&gt; foo() = rand(2,2) * rand(2,2)
foo (generic function with 1 method)

julia&gt; @time @eval foo();
  0.252395 seconds (1.12 M allocations: 56.178 MiB, 2.93% gc time, 98.12% compilation time)

julia&gt; @time @eval foo();
  0.000156 seconds (63 allocations: 2.453 KiB)</code></pre><p data-translated="true"><span class="original-text">Note that <code>@time @eval</code> is better for measuring compilation time because without <a href="../../base/base/index.html#Base.@eval"><code>@eval</code></a>, some compilation may already be done before timing starts.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コンパイル時間を測定するには <code>@time @eval</code> の方が良いことに注意してください。なぜなら、<a href="../../base/base/index.html#Base.@eval"><code>@eval</code></a> がないと、タイミングが始まる前に一部のコンパイルがすでに行われている可能性があるからです。</span></p><p data-translated="true"><span class="original-text">When developing a package, you may be able to improve the experience of your users with <em>precompilation</em> so that when they use the package, the code they use is already compiled. To precompile package code effectively, it's recommended to use <a href="https://julialang.github.io/PrecompileTools.jl/stable/"><code>PrecompileTools.jl</code></a> to run a "precompile workload" during precompilation time that is representative of typical package usage, which will cache the native compiled code into the package <code>pkgimage</code> cache, greatly reducing "time to first execution" (often referred to as TTFX) for such usage.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パッケージを開発する際には、<em>事前コンパイル</em> を使用することで、ユーザーの体験を向上させることができるかもしれません。これにより、ユーザーがパッケージを使用する際に、使用するコードがすでにコンパイルされています。パッケージコードを効果的に事前コンパイルするには、<a href="https://julialang.github.io/PrecompileTools.jl/stable/"><code>PrecompileTools.jl</code></a> を使用して、事前コンパイル時間中に典型的なパッケージ使用を代表する「事前コンパイルワークロード」を実行することが推奨されます。これにより、ネイティブコンパイルされたコードがパッケージの <code>pkgimage</code> キャッシュにキャッシュされ、「最初の実行までの時間」（TTFXと呼ばれることが多い）を大幅に短縮します。</span></p><p data-translated="true"><span class="original-text">Note that <a href="https://julialang.github.io/PrecompileTools.jl/stable/"><code>PrecompileTools.jl</code></a> workloads can be disabled and sometimes configured via Preferences if you do not want to spend the extra time precompiling, which may be the case during development of a package.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://julialang.github.io/PrecompileTools.jl/stable/"><code>PrecompileTools.jl</code></a> のワークロードは無効にすることができ、時にはPreferencesを通じて構成することもできます。これは、パッケージの開発中に事前コンパイルに余分な時間をかけたくない場合に該当するかもしれません。</span></p><h3 id="Reducing-package-loading-time" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Reducing-package-loading-time">Reducing package loading time</a><a id="Reducing-package-loading-time-1"></a><a class="docs-heading-anchor-permalink" href="#Reducing-package-loading-time" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Reducing-package-loading-time">パッケージの読み込み時間の短縮</a><a id="Reducing-package-loading-time-1"></a><a class="docs-heading-anchor-permalink" href="#Reducing-package-loading-time" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Keeping the time taken to load the package down is usually helpful. General good practice for package developers includes:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パッケージの読み込みにかかる時間を短く保つことは通常有益です。パッケージ開発者にとっての一般的な良い実践には以下が含まれます：</span></p><ol><li data-translated="true"><span class="original-text">Reduce your dependencies to those you really need. Consider using <a href="../../base/math/#Base.:--Tuple{Any, Any}#Base.:--Tuple{Any, Any}">package extensions</a> to support interoperability with other packages without bloating your essential dependencies.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">本当に必要な依存関係に絞りましょう。他のパッケージとの相互運用性をサポートするために、<a href="../../base/math/#Base.:--Tuple{Any, Any}#Base.:--Tuple{Any, Any}">パッケージ拡張</a>の使用を検討してください。これにより、必須の依存関係が膨れ上がることを防げます。</span></li><li data-translated="true"><span class="original-text">Avoid use of <a href="../../base/base/index.html#__init__"><code>__init__()</code></a> functions unless there is no alternative, especially those which might trigger a lot of compilation, or just take a long time to execute.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#__init__"><code>__init__()</code></a> 関数の使用は、代替手段がない場合を除いて避けましょう。特に、多くのコンパイルを引き起こす可能性があるものや、実行に時間がかかるものは注意が必要です。</span></li><li data-translated="true"><span class="original-text">Where possible, fix <a href="https://julialang.org/blog/2020/08/invalidations/">invalidations</a> among your dependencies and from your package code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">可能な限り、依存関係やパッケージコード内の<a href="https://julialang.org/blog/2020/08/invalidations/">無効化</a>を修正しましょう。</span></li></ol><p data-translated="true"><span class="original-text">The tool <a href="../../stdlib/InteractiveUtils/index.html#Base.@time_imports"><code>@time_imports</code></a> can be useful in the REPL to review the above factors.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ツール<a href="../../stdlib/InteractiveUtils/index.html#Base.@time_imports"><code>@time_imports</code></a>は、REPLで上記の要因を確認するのに役立ちます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; @time @time_imports using Plots
      0.5 ms  Printf
     16.4 ms  Dates
      0.7 ms  Statistics
               ┌ 23.8 ms SuiteSparse_jll.__init__() 86.11% compilation time (100% recompilation)
     90.1 ms  SuiteSparse_jll 91.57% compilation time (82% recompilation)
      0.9 ms  Serialization
               ┌ 39.8 ms SparseArrays.CHOLMOD.__init__() 99.47% compilation time (100% recompilation)
    166.9 ms  SparseArrays 23.74% compilation time (100% recompilation)
      0.4 ms  Statistics → SparseArraysExt
      0.5 ms  TOML
      8.0 ms  Preferences
      0.3 ms  PrecompileTools
      0.2 ms  Reexport
... many deps omitted for example ...
      1.4 ms  Tar
               ┌ 73.8 ms p7zip_jll.__init__() 99.93% compilation time (100% recompilation)
     79.4 ms  p7zip_jll 92.91% compilation time (100% recompilation)
               ┌ 27.7 ms GR.GRPreferences.__init__() 99.77% compilation time (100% recompilation)
     43.0 ms  GR 64.26% compilation time (100% recompilation)
               ┌ 2.1 ms Plots.__init__() 91.80% compilation time (100% recompilation)
    300.9 ms  Plots 0.65% compilation time (100% recompilation)
  1.795602 seconds (3.33 M allocations: 190.153 MiB, 7.91% gc time, 39.45% compilation time: 97% of which was recompilation)
</code></pre><p data-translated="true"><span class="original-text">Notice that in this example there are multiple packages loaded, some with <code>__init__()</code> functions, some of which cause compilation of which some is recompilation. Recompilation is caused by earlier packages invalidating methods, then in these cases when the following packages run their <code>__init__()</code> function some hit recompilation before the code can be run.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例では、複数のパッケージが読み込まれており、その中には<code>__init__()</code>関数を持つものもあり、いくつかはコンパイルを引き起こし、その中には再コンパイルも含まれています。再コンパイルは、以前のパッケージがメソッドを無効化することによって引き起こされます。そのため、次のパッケージが<code>__init__()</code>関数を実行する際に、コードを実行する前に再コンパイルが発生することがあります。</span></p><p data-translated="true"><span class="original-text">Further, note the <code>Statistics</code> extension <code>SparseArraysExt</code> has been activated because <code>SparseArrays</code> is in the dependency tree. i.e. see <code>0.4 ms  Statistics → SparseArraysExt</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">さらに、<code>Statistics</code>拡張<code>SparseArraysExt</code>が有効化されていることに注意してください。これは<code>SparseArrays</code>が依存関係ツリーに含まれているためです。すなわち、<code>0.4 ms  Statistics → SparseArraysExt</code>を参照してください。</span></p><p data-translated="true"><span class="original-text">This report gives a good opportunity to review whether the cost of dependency load time is worth the functionality it brings. Also the <code>Pkg</code> utility <code>why</code> can be used to report why a an indirect dependency exists.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このレポートは、依存関係の読み込み時間のコストがその機能に見合う価値があるかどうかを見直す良い機会を提供します。また、<code>Pkg</code>ユーティリティの<code>why</code>を使用して、間接依存関係が存在する理由を報告することもできます。</span></p><pre><code class="nohighlight hljs">(CustomPackage) pkg&gt; why FFMPEG_jll
  Plots → FFMPEG → FFMPEG_jll
  Plots → GR → GR_jll → FFMPEG_jll</code></pre><p data-translated="true"><span class="original-text">or to see the indirect dependencies that a package brings in, you can <code>pkg&gt; rm</code> the package, see the deps that are removed from the manifest, then revert the change with <code>pkg&gt; undo</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、パッケージが持ち込む間接依存関係を確認するには、<code>pkg&gt; rm</code>コマンドでパッケージを削除し、マニフェストから削除された依存関係を確認した後、<code>pkg&gt; undo</code>で変更を元に戻すことができます。</span></p><p data-translated="true"><span class="original-text">If loading time is dominated by slow <code>__init__()</code> methods having compilation, one verbose way to identify what is being compiled is to use the julia args <code>--trace-compile=stderr --trace-compile-timing</code> which will report a <a href="../../base/base/index.html#Base.precompile"><code>precompile</code></a> statement each time a method is compiled, along with how long compilation took. The InteractiveUtils macro <a href="../../stdlib/InteractiveUtils/index.html#Base.@trace_compile"><code>@trace_compile</code></a> provides a way to enable those args for a specific call. So a call for a complete report report would look like:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もし読み込み時間が遅い <code>__init__()</code> メソッドのコンパイルによって支配されている場合、何がコンパイルされているかを特定するための冗長な方法の一つは、julia args <code>--trace-compile=stderr --trace-compile-timing</code> を使用することです。これにより、メソッドがコンパイルされるたびに <a href="../../base/base/index.html#Base.precompile"><code>precompile</code></a> ステートメントが報告され、コンパイルにかかった時間も表示されます。InteractiveUtils マクロ <a href="../../stdlib/InteractiveUtils/index.html#Base.@trace_compile"><code>@trace_compile</code></a> は、特定の呼び出しに対してこれらの引数を有効にする方法を提供します。したがって、完全なレポートのための呼び出しは次のようになります:</span></p><pre><code class="nohighlight hljs">julia&gt; @time @time_imports @trace_compile using CustomPackage
...</code></pre><p data-translated="true"><span class="original-text">Note the <code>--startup-file=no</code> which helps isolate the test from packages you may have in your <code>startup.jl</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで注意すべきは <code>--startup-file=no</code> で、これはあなたの <code>startup.jl</code> にあるパッケージからテストを隔離するのに役立ちます。</span></p><p data-translated="true"><span class="original-text">More analysis of the reasons for recompilation can be achieved with the <a href="https://github.com/timholy/SnoopCompile.jl"><code>SnoopCompile</code></a> package.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">再コンパイルの理由についてのさらなる分析は、<a href="https://github.com/timholy/SnoopCompile.jl"><code>SnoopCompile</code></a> パッケージを使用することで達成できます。</span></p><h3 id="Reducing-precompilation-time" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Reducing-precompilation-time">Reducing precompilation time</a><a id="Reducing-precompilation-time-1"></a><a class="docs-heading-anchor-permalink" href="#Reducing-precompilation-time" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Reducing-precompilation-time">プリコンパイル時間の短縮</a><a id="Reducing-precompilation-time-1"></a><a class="docs-heading-anchor-permalink" href="#Reducing-precompilation-time" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">If package precompilation is taking a long time, one option is to set the following internal and then precompile.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もしパッケージのプリコンパイルに時間がかかっている場合、次の内部設定を行い、その後プリコンパイルするオプションがあります。</span></p><pre><code class="nohighlight hljs">julia&gt; Base.PRECOMPILE_TRACE_COMPILE[] = "stderr"

pkg&gt; precompile</code></pre><p data-translated="true"><span class="original-text">This has the effect of setting <code>--trace-compile=stderr --trace-compile-timing</code> in the precompilation processes themselves, so will show which methods are precompiled and how long they took to precompile.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、プリコンパイルプロセス自体に <code>--trace-compile=stderr --trace-compile-timing</code> を設定する効果があり、どのメソッドがプリコンパイルされ、どれくらいの時間がかかったかを示します。</span></p><p data-translated="true"><span class="original-text">There are also profiling options such as <a href="../../devdocs/external_profilers/index.html#Profiling-package-precompilation-with-Tracy">using the external profiler Tracy to profile the precompilation process</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、<a href="../../devdocs/external_profilers/index.html#Profiling-package-precompilation-with-Tracy">外部プロファイラ Tracy を使用してプリコンパイルプロセスをプロファイリングする</a> などのプロファイリングオプションもあります。</span></p><h2 id="Miscellaneous" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Miscellaneous">その他</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></span></h2><h3 id="Tweaks" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Tweaks">Tweaks</a><a id="Tweaks-1"></a><a class="docs-heading-anchor-permalink" href="#Tweaks" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Tweaks">調整</a><a id="Tweaks-1"></a><a class="docs-heading-anchor-permalink" href="#Tweaks" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">These are some minor points that might help in tight inner loops.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらは、タイトな内部ループで役立つかもしれないいくつかの小さなポイントです。</span></p><ul><li data-translated="true"><span class="original-text">Avoid unnecessary arrays. For example, instead of <a href="../../base/collections/index.html#Base.sum"><code>sum([x,y,z])</code></a> use <code>x+y+z</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">不必要な配列を避けてください。例えば、<a href="../../base/collections/index.html#Base.sum"><code>sum([x,y,z])</code></a>の代わりに<code>x+y+z</code>を使用してください。</span></li><li data-translated="true"><span class="original-text">Use <a href="../../base/math/index.html#Base.abs2"><code>abs2(z)</code></a> instead of <a href="../../base/math/#Base.:^-Tuple{Number, Number}#Base.:^-Tuple{Number, Number}"><code>abs(z)^2</code></a> for complex <code>z</code>. In general, try to rewrite code to use <a href="../../base/math/index.html#Base.abs2"><code>abs2</code></a> instead of <a href="../../base/math/index.html#Base.abs"><code>abs</code></a> for complex arguments.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/math/index.html#Base.abs2"><code>abs2(z)</code></a>を使用し、<a href="../../base/math/#Base.:^-Tuple{Number, Number}#Base.:^-Tuple{Number, Number}"><code>abs(z)^2</code></a>は避けてください。一般的に、複素数引数に対しては<a href="../../base/math/index.html#Base.abs2"><code>abs2</code></a>を使用するようにコードを書き換えてください。</span></li><li data-translated="true"><span class="original-text">Use <a href="../../base/math/index.html#Base.div"><code>div(x,y)</code></a> for truncating division of integers instead of <a href="../../base/math/index.html#Base.trunc"><code>trunc(x/y)</code></a>, <a href="../../base/math/index.html#Base.fld"><code>fld(x,y)</code></a> instead of <a href="../../base/math/index.html#Base.floor"><code>floor(x/y)</code></a>, and <a href="../../base/math/index.html#Base.cld"><code>cld(x,y)</code></a> instead of <a href="../../base/math/index.html#Base.ceil"><code>ceil(x/y)</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/math/index.html#Base.div"><code>div(x,y)</code></a>を使用して整数の切り捨て除算を行い、<a href="../../base/math/index.html#Base.trunc"><code>trunc(x/y)</code></a>の代わりに、<a href="../../base/math/index.html#Base.fld"><code>fld(x,y)</code></a>を使用し、<a href="../../base/math/index.html#Base.floor"><code>floor(x/y)</code></a>の代わりに、<a href="../../base/math/index.html#Base.cld"><code>cld(x,y)</code></a>を使用してください。</span></li></ul><h3 id="Fix-deprecation-warnings" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Fix-deprecation-warnings">Fix deprecation warnings</a><a id="Fix-deprecation-warnings-1"></a><a class="docs-heading-anchor-permalink" href="#Fix-deprecation-warnings" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Fix-deprecation-warnings">非推奨警告を修正する</a><a id="Fix-deprecation-warnings-1"></a><a class="docs-heading-anchor-permalink" href="#Fix-deprecation-warnings" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">非推奨の関数は、関連する警告を一度だけ表示するために内部でルックアップを行います。この追加のルックアップは、パフォーマンスを著しく低下させる可能性があるため、非推奨の関数のすべての使用は警告に従って修正する必要があります。</span></p><h3 id="man-performance-annotations" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-performance-annotations">Performance Annotations</a><a id="man-performance-annotations-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-annotations" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-performance-annotations">パフォーマンス注釈</a><a id="man-performance-annotations-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-annotations" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Sometimes you can enable better optimization by promising certain program properties.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">時には、特定のプログラムの特性を約束することで、より良い最適化を有効にすることができます。</span></p><ul><li data-translated="true"><span class="original-text">Use <a href="../../base/base/index.html#Base.@inbounds"><code>@inbounds</code></a> to eliminate array bounds checking within expressions. Be certain before doing this. If the indices are ever out of bounds, you may suffer crashes or silent corruption.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Base.@inbounds"><code>@inbounds</code></a>を使用して、式内の配列境界チェックを排除します。これを行う前に確信を持ってください。インデックスが境界外になることがある場合、クラッシュや静かな破損が発生する可能性があります。</span></li><li data-translated="true"><span class="original-text">Use <a href="../../base/math/index.html#Base.FastMath.@fastmath"><code>@fastmath</code></a> to allow floating point optimizations that are correct for real numbers, but lead to differences for IEEE numbers. Be careful when doing this, as this may change numerical results. This corresponds to the <code>-ffast-math</code> option of clang.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/math/index.html#Base.FastMath.@fastmath"><code>@fastmath</code></a>を使用して、実数に対して正しい浮動小数点最適化を許可しますが、IEEE数に対しては違いが生じる可能性があります。これを行う際は注意が必要です。数値結果が変わる可能性があります。これはclangの<code>-ffast-math</code>オプションに対応します。</span></li><li data-translated="true"><span class="original-text">Write <a href="../../base/base/index.html#Base.SimdLoop.@simd"><code>@simd</code></a> in front of <code>for</code> loops to promise that the iterations are independent and may be reordered. Note that in many cases, Julia can automatically vectorize code without the <code>@simd</code> macro; it is only beneficial in cases where such a transformation would otherwise be illegal, including cases like allowing floating-point re-associativity and ignoring dependent memory accesses (<code>@simd ivdep</code>). Again, be very careful when asserting <code>@simd</code> as erroneously annotating a loop with dependent iterations may result in unexpected results. In particular, note that <code>setindex!</code> on some <code>AbstractArray</code> subtypes is inherently dependent upon iteration order. <strong>This feature is experimental</strong> and could change or disappear in future versions of Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#Base.SimdLoop.@simd"><code>@simd</code></a>を<code>for</code>ループの前に書いて、反復が独立しており、順序を変更できることを約束します。多くの場合、Juliaは<code>@simd</code>マクロなしで自動的にコードをベクトル化できます; これは、そのような変換がそうでなければ違法になる場合にのみ有益です。浮動小数点の再結合を許可し、依存メモリアクセスを無視する場合（<code>@simd ivdep</code>など）を含みます。<code>@simd</code>を主張する際は非常に注意してください。依存する反復を持つループに誤って注釈を付けると、予期しない結果が生じる可能性があります。特に、いくつかの<code>AbstractArray</code>サブタイプに対する<code>setindex!</code>は、反復順序に本質的に依存しています。<strong>この機能は実験的です</strong>であり、将来のJuliaのバージョンで変更または消失する可能性があります。</span></li></ul><p data-translated="true"><span class="original-text">The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing, and may cause a segmentation fault if bounds checking is turned off. Use <code>LinearIndices(x)</code> or <code>eachindex(x)</code> instead (see also <a href="../../devdocs/offset-arrays/index.html#man-custom-indices">Arrays with custom indices</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">AbstractArrayに1:nを使ってインデックスを付ける一般的な慣用句は、配列が非標準のインデックスを使用している場合、安全ではなく、境界チェックがオフになっているとセグメンテーションフォルトを引き起こす可能性があります。代わりに<code>LinearIndices(x)</code>または<code>eachindex(x)</code>を使用してください（詳細は<a href="../../devdocs/offset-arrays/index.html#man-custom-indices">カスタムインデックスを持つ配列</a>を参照）。</span></p><div class="admonition is-info" id="Note-bfdafbe19a6e2064"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-bfdafbe19a6e2064" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">While <code>@simd</code> needs to be placed directly in front of an innermost <code>for</code> loop, both <code>@inbounds</code> and <code>@fastmath</code> can be applied to either single expressions or all the expressions that appear within nested blocks of code, e.g., using <code>@inbounds begin</code> or <code>@inbounds for ...</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@simd</code>は最も内側の<code>for</code>ループの直前に配置する必要がありますが、<code>@inbounds</code>と<code>@fastmath</code>は、単一の式またはネストされたコードブロック内に現れるすべての式に適用できます。例えば、<code>@inbounds begin</code>や<code>@inbounds for ...</code>を使用します。</span></p></div></div><p data-translated="true"><span class="original-text">Here is an example with both <code>@inbounds</code> and <code>@simd</code> markup (we here use <code>@noinline</code> to prevent the optimizer from trying to be too clever and defeat our benchmark):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、<code>@inbounds</code>と<code>@simd</code>のマークアップを両方使用した例を示します（ここでは、最適化プログラムがあまり賢くなりすぎないように<code>@noinline</code>を使用しています）：</span></p><pre><code class="language-julia hljs">@noinline function inner(x, y)
    s = zero(eltype(x))
    for i in eachindex(x, y)
        @inbounds s += x[i]*y[i]
    end
    return s
end

@noinline function innersimd(x, y)
    s = zero(eltype(x))
    @simd for i in eachindex(x, y)
        @inbounds s += x[i] * y[i]
    end
    return s
end

function timeit(n, reps)
    x = rand(Float32, n)
    y = rand(Float32, n)
    s = zero(Float64)
    time = @elapsed for j in 1:reps
        s += inner(x, y)
    end
    println("GFlop/sec        = ", 2n*reps / time*1E-9)
    time = @elapsed for j in 1:reps
        s += innersimd(x, y)
    end
    println("GFlop/sec (SIMD) = ", 2n*reps / time*1E-9)
end

timeit(1000, 1000)</code></pre><p data-translated="true"><span class="original-text">On a computer with a 2.4GHz Intel Core i5 processor, this produces:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">2.4GHzのIntel Core i5プロセッサを搭載したコンピュータでは、次のようになります：</span></p><pre><code class="nohighlight hljs">GFlop/sec        = 1.9467069505224963
GFlop/sec (SIMD) = 17.578554163920018</code></pre><p data-translated="true"><span class="original-text">(<code>GFlop/sec</code> measures the performance, and larger numbers are better.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">(<code>GFlop/sec</code>はパフォーマンスを測定し、大きな数値がより良いことを示します。)</span></p><p data-translated="true"><span class="original-text">Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、3種類のマークアップすべてを使用した例を示します。このプログラムは、まず1次元配列の有限差分を計算し、その後結果のL2ノルムを評価します：</span></p><pre><code class="language-julia hljs">function init!(u::Vector)
    n = length(u)
    dx = 1.0 / (n-1)
    @fastmath @inbounds @simd for i in 1:n #by asserting that `u` is a `Vector` we can assume it has 1-based indexing
        u[i] = sin(2pi*dx*i)
    end
end

function deriv!(u::Vector, du)
    n = length(u)
    dx = 1.0 / (n-1)
    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx
    @fastmath @inbounds @simd for i in 2:n-1
        du[i] = (u[i+1] - u[i-1]) / (2*dx)
    end
    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx
end

function mynorm(u::Vector)
    n = length(u)
    T = eltype(u)
    s = zero(T)
    @fastmath @inbounds @simd for i in 1:n
        s += u[i]^2
    end
    @fastmath @inbounds return sqrt(s)
end

function main()
    n = 2000
    u = Vector{Float64}(undef, n)
    init!(u)
    du = similar(u)

    deriv!(u, du)
    nu = mynorm(du)

    @time for i in 1:10^6
        deriv!(u, du)
        nu = mynorm(du)
    end

    println(nu)
end

main()</code></pre><p data-translated="true"><span class="original-text">On a computer with a 2.7 GHz Intel Core i7 processor, this produces:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">2.7 GHzのIntel Core i7プロセッサを搭載したコンピュータでは、次のようになります：</span></p><pre><code class="nohighlight hljs">$ julia wave.jl;
  1.207814709 seconds
4.443986180758249

$ julia --math-mode=ieee wave.jl;
  4.487083643 seconds
4.443986180758249</code></pre><p data-translated="true"><span class="original-text">Here, the option <code>--math-mode=ieee</code> disables the <code>@fastmath</code> macro, so that we can compare results.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、オプション<code>--math-mode=ieee</code>が<code>@fastmath</code>マクロを無効にするため、結果を比較できます。</span></p><p data-translated="true"><span class="original-text">In this case, the speedup due to <code>@fastmath</code> is a factor of about 3.7. This is unusually large – in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result – in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この場合、<code>@fastmath</code>によるスピードアップは約3.7倍です。これは異常に大きいです – 一般的には、スピードアップは小さくなります。（この特定の例では、ベンチマークの作業セットがプロセッサのL1キャッシュに収まるほど小さいため、メモリアクセスのレイテンシは影響せず、計算時間はCPU使用率によって支配されます。多くの実世界のプログラムでは、これは当てはまりません。）また、この場合、この最適化は結果を変更しません – 一般的には、結果はわずかに異なります。特に数値的に不安定なアルゴリズムの場合、結果は非常に異なることがあります。</span></p><p data-translated="true"><span class="original-text">The annotation <code>@fastmath</code> re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression <code>1 / (2*dx)</code> in the function <code>deriv</code> is hoisted out of the loop (i.e. calculated outside the loop), as if one had written <code>idx = 1 / (2*dx)</code>. In the loop, the expression <code>... / (2*dx)</code> then becomes <code>... * idx</code>, which is much faster to evaluate. Of course, both the actual optimization that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by using Julia's <a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.code_native"><code>code_native</code></a> function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">アノテーション<code>@fastmath</code>は浮動小数点式を再配置します。例えば、評価の順序を変更したり、特定の特別なケース（inf、nan）が発生しないと仮定したりします。この場合（およびこの特定のコンピュータ上では）、主な違いは、関数<code>deriv</code>内の式<code>1 / (2*dx)</code>がループの外に持ち上げられることです（つまり、ループの外で計算されます）。ループ内では、式<code>... / (2*dx)</code>は<code>... * idx</code>となり、評価がはるかに速くなります。もちろん、コンパイラによって適用される実際の最適化と結果として得られるスピードアップは、ハードウェアに大きく依存します。生成されたコードの変更を調べるには、Juliaの<a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.code_native"><code>code_native</code></a>関数を使用できます。</span></p><p data-translated="true"><span class="original-text">Note that <code>@fastmath</code> also assumes that <code>NaN</code>s will not occur during the computation, which can lead to surprising behavior:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>@fastmath</code> は計算中に <code>NaN</code> が発生しないことを前提としているため、驚くべき動作を引き起こす可能性があることに注意してください：</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = isnan(x);

julia&gt; f(NaN)
true

julia&gt; f_fast(x) = @fastmath isnan(x);

julia&gt; f_fast(NaN)
false</code></pre><h3 id="Treat-Subnormal-Numbers-as-Zeros" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Treat-Subnormal-Numbers-as-Zeros">Treat Subnormal Numbers as Zeros</a><a id="Treat-Subnormal-Numbers-as-Zeros-1"></a><a class="docs-heading-anchor-permalink" href="#Treat-Subnormal-Numbers-as-Zeros" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Treat-Subnormal-Numbers-as-Zeros">非正規数をゼロとして扱う</a><a id="Treat-Subnormal-Numbers-as-Zeros-1"></a><a class="docs-heading-anchor-permalink" href="#Treat-Subnormal-Numbers-as-Zeros" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Subnormal numbers, formerly called <a href="https://en.wikipedia.org/wiki/Denormal_number">denormal numbers</a>, are useful in many contexts, but incur a performance penalty on some hardware. A call <a href="../../base/numbers/index.html#Base.Rounding.set_zero_subnormals"><code>set_zero_subnormals(true)</code></a> grants permission for floating-point operations to treat subnormal inputs or outputs as zeros, which may improve performance on some hardware. A call <a href="../../base/numbers/index.html#Base.Rounding.set_zero_subnormals"><code>set_zero_subnormals(false)</code></a> enforces strict IEEE behavior for subnormal numbers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">非正規数（以前は<a href="https://en.wikipedia.org/wiki/Denormal_number">非正規数</a>と呼ばれていた）は、多くの文脈で有用ですが、一部のハードウェアではパフォーマンスのペナルティが発生します。<a href="../../base/numbers/index.html#Base.Rounding.set_zero_subnormals"><code>set_zero_subnormals(true)</code></a> を呼び出すことで、浮動小数点演算が非正規の入力または出力をゼロとして扱うことを許可し、一部のハードウェアでパフォーマンスが向上する可能性があります。<a href="../../base/numbers/index.html#Base.Rounding.set_zero_subnormals"><code>set_zero_subnormals(false)</code></a> を呼び出すことで、非正規数に対して厳密なIEEEの動作が強制されます。</span></p><p data-translated="true"><span class="original-text">Below is an example where subnormals noticeably impact performance on some hardware:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">以下は、非正規数が一部のハードウェアでパフォーマンスに顕著な影響を与える例です：</span></p><pre><code class="language-julia hljs">function timestep(b::Vector{T}, a::Vector{T}, Δt::T) where T
    @assert length(a)==length(b)
    n = length(b)
    b[1] = 1                            # Boundary condition
    for i=2:n-1
        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * Δt
    end
    b[n] = 0                            # Boundary condition
end

function heatflow(a::Vector{T}, nstep::Integer) where T
    b = similar(a)
    for t=1:div(nstep,2)                # Assume nstep is even
        timestep(b,a,T(0.1))
        timestep(a,b,T(0.1))
    end
end

heatflow(zeros(Float32,10),2)           # Force compilation
for trial=1:6
    a = zeros(Float32,1000)
    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic
    @time heatflow(a,1000)
end</code></pre><p data-translated="true"><span class="original-text">This gives an output similar to</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、次のような出力を生成します</span></p><pre><code class="nohighlight hljs">  0.002202 seconds (1 allocation: 4.063 KiB)
  0.001502 seconds (1 allocation: 4.063 KiB)
  0.002139 seconds (1 allocation: 4.063 KiB)
  0.001454 seconds (1 allocation: 4.063 KiB)
  0.002115 seconds (1 allocation: 4.063 KiB)
  0.001455 seconds (1 allocation: 4.063 KiB)</code></pre><p data-translated="true"><span class="original-text">Note how each even iteration is significantly faster.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各偶数イテレーションが著しく速いことに注意してください。</span></p><p data-translated="true"><span class="original-text">This example generates many subnormal numbers because the values in <code>a</code> become an exponentially decreasing curve, which slowly flattens out over time.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例では、<code>a</code> の値が指数的に減少する曲線になり、時間とともに徐々に平坦化するため、多くの非正規数が生成されます。</span></p><p data-translated="true"><span class="original-text">Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as <code>x-y == 0</code> implies <code>x == y</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">非正規数をゼロとして扱うことは注意して行うべきです。なぜなら、そうすることで <code>x-y == 0</code> が <code>x == y</code> を意味するといういくつかの同一性が破られるからです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = 3f-38; y = 2f-38;

julia&gt; set_zero_subnormals(true); (x - y, x == y)
(0.0f0, false)

julia&gt; set_zero_subnormals(false); (x - y, x == y)
(1.0000001f-38, false)</code></pre><p data-translated="true"><span class="original-text">In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise.  For example, instead of initializing <code>a</code> with zeros, initialize it with:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一部のアプリケーションでは、非正規数をゼロにする代わりに、わずかなノイズを注入することが代替手段となります。たとえば、<code>a</code> をゼロで初期化する代わりに、次のように初期化します：</span></p><pre><code class="language-julia hljs">a = rand(Float32,1000) * 1.f-9</code></pre><h3 id="Avoid-string-interpolation-for-I/O" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Avoid-string-interpolation-for-I/O">Avoid string interpolation for I/O</a><a id="Avoid-string-interpolation-for-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-string-interpolation-for-I/O" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Avoid-string-interpolation-for-I/O">I/Oのための文字列補間を避ける</a><a id="Avoid-string-interpolation-for-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-string-interpolation-for-I/O" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">When writing data to a file (or other I/O device), forming extra intermediate strings is a source of overhead. Instead of:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ファイル（または他のI/Oデバイス）にデータを書き込む際、余分な中間文字列を形成することはオーバーヘッドの原因となります。次のようにする代わりに：</span></p><pre><code class="language-julia hljs">println(file, "$a $b")</code></pre><p data-translated="true"><span class="original-text">use:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のようにしてください：</span></p><pre><code class="language-julia hljs">println(file, a, " ", b)</code></pre><p data-translated="true"><span class="original-text">The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コードの最初のバージョンは文字列を形成し、それをファイルに書き込みますが、2番目のバージョンは値を直接ファイルに書き込みます。また、場合によっては文字列の補間が読みづらくなることにも注意してください。考えてみてください：</span></p><pre><code class="language-julia hljs">println(file, "$(f(a))$(f(b))")</code></pre><p data-translated="true"><span class="original-text">versus:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">対して：</span></p><pre><code class="language-julia hljs">println(file, f(a), f(b))</code></pre><h3 id="Avoid-eager-string-materialization" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Avoid-eager-string-materialization">Avoid eager string materialization</a><a id="Avoid-eager-string-materialization-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-eager-string-materialization" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Avoid-eager-string-materialization">早期文字列生成を避ける</a><a id="Avoid-eager-string-materialization-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-eager-string-materialization" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">In settings where a string representation of an object is only needed conditionally (e.g. in error paths of functions or conditional warnings such as deprecations), it is advisable to avoid the overhead of eagerly materializing the string. Since Julia 1.8, this can be achieved via <a href="../../base/strings/index.html#Base.LazyString"><code>LazyString</code></a> and the corresponding string macro <a href="../../base/strings/index.html#Base.@lazy_str"><code>@lazy_str</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">オブジェクトの文字列表現が条件付きでのみ必要な設定（例えば、関数のエラーパスや非推奨のような条件付き警告）では、文字列を早期に生成するオーバーヘッドを避けることが推奨されます。Julia 1.8以降、これは<a href="../../base/strings/index.html#Base.LazyString"><code>LazyString</code></a>と対応する文字列マクロ<a href="../../base/strings/index.html#Base.@lazy_str"><code>@lazy_str</code></a>を使用することで実現できます。</span></p><p data-translated="true"><span class="original-text">For example, instead of:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、次のようにする代わりに：</span></p><pre><code class="language-julia hljs">Base.depwarn("`foo` is deprecated for type $(typeof(x))", :bar)</code></pre><p data-translated="true"><span class="original-text">use:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次のようにしてください：</span></p><pre><code class="language-julia hljs">Base.depwarn(lazy"`foo` is deprecated for type $(typeof(x))", :bar)</code></pre><p data-translated="true"><span class="original-text">or the equivalent macro-free version:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">または同等のマクロなしのバージョン：</span></p><pre><code class="language-julia hljs">Base.depwarn(LazyString("`foo` is deprecated for type ", typeof(x)), :bar)</code></pre><p data-translated="true"><span class="original-text">Through this approach, the interpolated string will only be constructed when it is actually displayed.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このアプローチを通じて、補間された文字列は実際に表示されるときにのみ構築されます。</span></p><h3 id="Optimize-network-I/O-during-parallel-execution" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Optimize-network-I/O-during-parallel-execution">Optimize network I/O during parallel execution</a><a id="Optimize-network-I/O-during-parallel-execution-1"></a><a class="docs-heading-anchor-permalink" href="#Optimize-network-I/O-during-parallel-execution" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Optimize-network-I/O-during-parallel-execution">並列実行中のネットワークI/Oの最適化</a><a id="Optimize-network-I/O-during-parallel-execution-1"></a><a class="docs-heading-anchor-permalink" href="#Optimize-network-I/O-during-parallel-execution" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">When executing a remote function in parallel:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リモート関数を並列で実行する場合、</span></p><pre><code class="language-julia hljs">using Distributed

responses = Vector{Any}(undef, nworkers())
@sync begin
    for (idx, pid) in enumerate(workers())
        Threads.@spawn responses[idx] = remotecall_fetch(foo, pid, args...)
    end
end</code></pre><p data-translated="true"><span class="original-text">is faster than:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">はより速いです:</span></p><pre><code class="language-julia hljs">using Distributed

refs = Vector{Any}(undef, nworkers())
for (idx, pid) in enumerate(workers())
    refs[idx] = @spawnat pid foo(args...)
end
responses = [fetch(r) for r in refs]</code></pre><p data-translated="true"><span class="original-text">The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the <a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a> and the second due to the <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> (or even a <a href="../../base/parallel/index.html#Base.wait"><code>wait</code></a>). The <a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a>/<a href="../../base/parallel/index.html#Base.wait"><code>wait</code></a> is also being executed serially resulting in an overall poorer performance.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">前者は各ワーカーへのネットワークの往復が1回で済むのに対し、後者は2回のネットワーク呼び出しが発生します - 最初は<a href="../../stdlib/Distributed/index.html#Distributed.@spawnat"><code>@spawnat</code></a>によるもので、2回目は<a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a>（または<a href="../../base/parallel/index.html#Base.wait"><code>wait</code></a>）によるものです。<a href="../../base/parallel/index.html#Base.fetch-Tuple{Task}"><code>fetch</code></a>/<a href="../../base/parallel/index.html#Base.wait"><code>wait</code></a>も直列で実行されるため、全体的にパフォーマンスが低下します。</span></p><h3 id="man-perftips-mutablearithmetics" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-perftips-mutablearithmetics">Use <code>MutableArithmetics</code> for more control over allocation for mutable arithmetic types</a><a id="man-perftips-mutablearithmetics-1"></a><a class="docs-heading-anchor-permalink" href="#man-perftips-mutablearithmetics" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-perftips-mutablearithmetics">可変算術型のメモリ割り当てをより制御するために<code>MutableArithmetics</code>を使用する</a><a id="man-perftips-mutablearithmetics-1"></a><a class="docs-heading-anchor-permalink" href="#man-perftips-mutablearithmetics" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Some <a href="../../base/numbers/index.html#Core.Number"><code>Number</code></a> subtypes, such as <a href="../../base/numbers/index.html#Base.GMP.BigInt"><code>BigInt</code></a> or <a href="../../base/numbers/index.html#Base.MPFR.BigFloat"><code>BigFloat</code></a>, may be implemented as <a href="../../base/base/index.html#mutable struct"><code>mutable struct</code></a> types, or they may have mutable components. The arithmetic interfaces in Julia <code>Base</code> usually opt for convenience over efficiency in such cases, so using them in a naive manner may result in suboptimal performance. The abstractions of the <a href="https://juliahub.com/ui/Packages/General/MutableArithmetics"><code>MutableArithmetics</code></a> package, on the other hand, make it possible to exploit the mutability of such types for writing fast code that allocates only as much as necessary. <code>MutableArithmetics</code> also makes it possible to copy values of mutable arithmetic types explicitly when necessary. <code>MutableArithmetics</code> is a user package and is not affiliated with the Julia project.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一部の<a href="../../base/numbers/index.html#Core.Number"><code>Number</code></a>のサブタイプ、例えば<a href="../../base/numbers/index.html#Base.GMP.BigInt"><code>BigInt</code></a>や<a href="../../base/numbers/index.html#Base.MPFR.BigFloat"><code>BigFloat</code></a>は、<a href="../../base/base/index.html#mutable struct"><code>mutable struct</code></a>型として実装されるか、可変コンポーネントを持つ場合があります。Juliaの算術インターフェースは、こうした場合に効率よりも便利さを選ぶことが多いため、単純な方法で使用すると最適でないパフォーマンスになる可能性があります。一方、<a href="https://juliahub.com/ui/Packages/General/MutableArithmetics"><code>MutableArithmetics</code></a>パッケージの抽象化は、こうした型の可変性を利用して、必要な分だけメモリを割り当てる高速なコードを書くことを可能にします。<code>MutableArithmetics</code>は、必要に応じて可変算術型の値を明示的にコピーすることも可能にします。<code>MutableArithmetics</code>はユーザーパッケージであり、Juliaプロジェクトとは提携していません。</span></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../memory-management/index.html">« Memory Management and Garbage Collection</a><a class="docs-footer-nextpage" href="../workflow-tips/index.html">Workflow Tips »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>