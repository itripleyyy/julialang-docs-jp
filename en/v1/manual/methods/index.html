<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Methods · The Julia Language</title><meta name="title" content="Methods · The Julia Language"><meta property="og:title" content="Methods · The Julia Language"><meta property="twitter:title" content="Methods · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/methods/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/methods/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bi1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li class="is-active"><a class="tocitem" href="">Methods</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Defining-Methods"><span>Defining Methods</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Defining-Methods"><span>メソッドの定義</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-method-specializations"><span>Method specializations</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-method-specializations"><span>メソッドの特化</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-ambiguities"><span>Method Ambiguities</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-ambiguities"><span>メソッドの曖昧さ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Parametric-Methods"><span>Parametric Methods</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Parametric-Methods"><span>パラメトリックメソッド</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Redefining-Methods"><span>Redefining Methods</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Redefining-Methods"><span>メソッドの再定義</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Design-Patterns-with-Parametric-Methods"><span>Design Patterns with Parametric Methods</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Design-Patterns-with-Parametric-Methods"><span>パラメトリックメソッドを用いたデザインパターン</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Parametrically-constrained-Varargs-methods"><span>Parametrically-constrained Varargs methods</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Parametrically-constrained-Varargs-methods"><span>パラメトリック制約付きVarargsメソッド</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Note-on-Optional-and-keyword-Arguments"><span>Note on Optional and keyword Arguments</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Note-on-Optional-and-keyword-Arguments"><span>オプションおよびキーワード引数に関する注意</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Function-like-objects"><span>Function-like objects</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Function-like-objects"><span>関数のようなオブジェクト</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Empty-generic-functions"><span>Empty generic functions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Empty-generic-functions"><span>空のジェネリック関数</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-method-design-ambiguities"><span>Method design and the avoidance of ambiguities</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-method-design-ambiguities"><span>メソッド設計と曖昧さの回避</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Defining-methods-in-local-scope"><span>Defining methods in local scope</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Defining-methods-in-local-scope"><span>ローカルスコープでのメソッドの定義</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">メソッド</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">メソッド</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Methods" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Methods">メソッド</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">Recall from <a href="../functions/index.html#man-functions">Functions</a> that a function is an object that maps a tuple of arguments to a return value, or throws an exception if no appropriate value can be returned. It is common for the same conceptual function or operation to be implemented quite differently for different types of arguments: adding two integers is very different from adding two floating-point numbers, both of which are distinct from adding an integer to a floating-point number. Despite their implementation differences, these operations all fall under the general concept of "addition". Accordingly, in Julia, these behaviors all belong to a single object: the <code>+</code> function.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数は引数のタプルを戻り値にマッピングするオブジェクトであり、適切な値を返せない場合は例外をスローすることを、<a href="../functions/index.html#man-functions">関数</a>から思い出してください。同じ概念的な関数や操作が、異なる引数の型に対してかなり異なる方法で実装されることは一般的です：2つの整数を加算することは、2つの浮動小数点数を加算することとは非常に異なり、整数と浮動小数点数を加算することとも異なります。実装の違いにもかかわらず、これらの操作はすべて「加算」という一般的な概念に属します。したがって、Juliaでは、これらの動作はすべて単一のオブジェクト、すなわち<code>+</code>関数に属します。</span></p><p data-translated="true"><span class="original-text">To facilitate using many different implementations of the same concept smoothly, functions need not be defined all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of argument types and counts. A definition of one possible behavior for a function is called a <em>method</em>. Thus far, we have presented only examples of functions defined with a single method, applicable to all types of arguments. However, the signatures of method definitions can be annotated to indicate the types of arguments in addition to their number, and more than a single method definition may be provided. When a function is applied to a particular tuple of arguments, the most specific method applicable to those arguments is applied. Thus, the overall behavior of a function is a patchwork of the behaviors of its various method definitions. If the patchwork is well designed, even though the implementations of the methods may be quite different, the outward behavior of the function will appear seamless and consistent.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同じ概念の多くの異なる実装をスムーズに使用できるようにするために、関数は一度にすべて定義する必要はなく、特定の引数の型と数の組み合わせに対して特定の動作を提供することで部分的に定義できます。関数の可能な動作の1つの定義は<em>メソッド</em>と呼ばれます。これまでのところ、すべての引数の型に適用可能な単一のメソッドで定義された関数の例のみを示してきました。しかし、メソッド定義のシグネチャには、数に加えて引数の型を示すための注釈を付けることができ、複数のメソッド定義を提供することもできます。関数が特定の引数のタプルに適用されると、その引数に適用可能な最も特定的なメソッドが適用されます。したがって、関数の全体的な動作は、そのさまざまなメソッド定義の動作のパッチワークです。パッチワークが適切に設計されていれば、メソッドの実装がかなり異なっていても、関数の外部の動作はシームレスで一貫しているように見えます。</span></p><p data-translated="true"><span class="original-text">The choice of which method to execute when a function is applied is called <em>dispatch</em>. Julia allows the dispatch process to choose which of a function's methods to call based on the number of arguments given, and on the types of all of the function's arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument. <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup> Using all of a function's arguments to choose which method should be invoked, rather than just the first, is known as <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">multiple dispatch</a>. Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to "belong" to one argument more than any of the others: does the addition operation in <code>x + y</code> belong to <code>x</code> any more than it does to <code>y</code>? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数が適用されたときにどのメソッドを実行するかの選択は<em>ディスパッチ</em>と呼ばれます。Juliaは、与えられた引数の数と関数のすべての引数の型に基づいて、どのメソッドを呼び出すかを選択するディスパッチプロセスを許可します。これは、ディスパッチが最初の引数のみに基づいて行われる従来のオブジェクト指向言語とは異なります。従来の言語では、最初の引数には特別な引数構文があることが多く、明示的に引数として書かれるのではなく、暗黙的に示されることがあります。<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup> 最初の引数だけでなく、関数のすべての引数を使用してどのメソッドを呼び出すかを選択することは、<a href="https://en.wikipedia.org/wiki/Multiple_dispatch">複数のディスパッチ</a>として知られています。複数のディスパッチは、数学的なコードに特に便利であり、操作がどの引数にも「属する」と見なすことはあまり意味がありません：<code>x + y</code>の加算操作は、<code>x</code>に属するのか、<code>y</code>に属するのか？数学的演算子の実装は、一般的にそのすべての引数の型に依存します。しかし、数学的な操作を超えて、複数のディスパッチはプログラムを構造化し整理するための強力で便利なパラダイムとなります。</span></p><div class="admonition is-info" id="Note-b2cc321559f3029f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b2cc321559f3029f" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">All the examples in this chapter assume that you are defining methods for a function in the <em>same</em> module. If you want to add methods to a function in <em>another</em> module, you have to <code>import</code> it or use the name qualified with module names. See the section on <a href="../modules/index.html#namespace-management">namespace management</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この章のすべての例は、<em>同じ</em>モジュール内の関数に対してメソッドを定義していると仮定しています。<em>別の</em>モジュールの関数にメソッドを追加したい場合は、それを<code>import</code>するか、モジュール名で修飾された名前を使用する必要があります。<a href="../modules/index.html#namespace-management">名前空間管理</a>に関するセクションを参照してください。</span></p></div></div><h2 id="Defining-Methods" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Defining-Methods">Defining Methods</a><a id="Defining-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Methods" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Defining-Methods">メソッドの定義</a><a id="Defining-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Methods" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Until now, we have, in our examples, defined only functions with a single method having unconstrained argument types. Such functions behave just like they would in traditional dynamically typed languages. Nevertheless, we have used multiple dispatch and methods almost continually without being aware of it: all of Julia's standard functions and operators, like the aforementioned <code>+</code> function, have many methods defining their behavior over various possible combinations of argument type and count.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これまでの例では、引数の型に制約のない単一のメソッドを持つ関数のみを定義してきました。このような関数は、従来の動的型付け言語と同様に動作します。それにもかかわらず、私たちはほとんど常に複数のディスパッチとメソッドを使用しており、それに気づいていませんでした。Juliaの標準関数や演算子、例えば前述の<code>+</code>関数は、さまざまな引数の型と数の組み合わせに対する動作を定義する多くのメソッドを持っています。</span></p><p data-translated="true"><span class="original-text">When defining a function, one can optionally constrain the types of parameters it is applicable to, using the <code>::</code> type-assertion operator, introduced in the section on <a href="../types/index.html#Composite-Types">Composite Types</a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数を定義する際、<code>::</code>型アサーション演算子を使用して、適用可能なパラメータの型をオプションで制約することができます。この演算子は、<a href="../types/index.html#Composite-Types">Composite Types</a>のセクションで紹介されました。</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(x::Float64, y::Float64) = 2x + y
f (generic function with 1 method)</code></pre><p data-translated="true"><span class="original-text">This function definition applies only to calls where <code>x</code> and <code>y</code> are both values of type <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この関数定義は、<code>x</code>と<code>y</code>の両方が<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>型の値である呼び出しにのみ適用されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(2.0, 3.0)
7.0</code></pre><p data-translated="true"><span class="original-text">Applying it to any other types of arguments will result in a <a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">他の型の引数に適用すると、<a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a>が発生します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(2.0, 3)
ERROR: MethodError: no method matching f(::Float64, ::Int64)
The function `f` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  f(::Float64, !Matched::Float64)
   @ Main none:1

Stacktrace:
[...]

julia&gt; f(Float32(2.0), 3.0)
ERROR: MethodError: no method matching f(::Float32, ::Float64)
The function `f` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  f(!Matched::Float64, ::Float64)
   @ Main none:1

Stacktrace:
[...]

julia&gt; f(2.0, "3.0")
ERROR: MethodError: no method matching f(::Float64, ::String)
The function `f` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  f(::Float64, !Matched::Float64)
   @ Main none:1

Stacktrace:
[...]

julia&gt; f("2.0", "3.0")
ERROR: MethodError: no method matching f(::String, ::String)
The function `f` exists, but no method is defined for this combination of argument types.</code></pre><p data-translated="true"><span class="original-text">As you can see, the arguments must be precisely of type <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>. Other numeric types, such as integers or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because <code>Float64</code> is a concrete type and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type <code>Float64</code>. It may often be useful, however, to write more general methods where the declared parameter types are abstract:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ご覧の通り、引数は正確に<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>型でなければなりません。他の数値型、例えば整数や32ビット浮動小数点値は、自動的に64ビット浮動小数点に変換されることはなく、文字列が数値として解析されることもありません。<code>Float64</code>は具体的な型であり、具体的な型はJuliaではサブクラス化できないため、このような定義は正確に<code>Float64</code>型の引数にのみ適用できます。しかし、宣言されたパラメータ型が抽象であるより一般的なメソッドを書くことはしばしば有用です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(x::Number, y::Number) = 2x - y
f (generic function with 2 methods)

julia&gt; f(2.0, 3)
1.0</code></pre><p data-translated="true"><span class="original-text">This method definition applies to any pair of arguments that are instances of <a href="../../base/numbers/index.html#Core.Number"><code>Number</code></a>. They need not be of the same type, so long as they are each numeric values. The problem of handling disparate numeric types is delegated to the arithmetic operations in the expression <code>2x - y</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このメソッド定義は、<a href="../../base/numbers/index.html#Core.Number"><code>Number</code></a>のインスタンスである任意の引数のペアに適用されます。同じ型である必要はなく、各々が数値であれば問題ありません。異なる数値型を扱う問題は、式<code>2x - y</code>の算術演算に委任されます。</span></p><p data-translated="true"><span class="original-text">To define a function with multiple methods, one simply defines the function multiple times, with different numbers and types of arguments. The first method definition for a function creates the function object, and subsequent method definitions add new methods to the existing function object. The most specific method definition matching the number and types of the arguments will be executed when the function is applied. Thus, the two method definitions above, taken together, define the behavior for <code>f</code> over all pairs of instances of the abstract type <code>Number</code> – but with a different behavior specific to pairs of <a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a> values. If one of the arguments is a 64-bit float but the other one is not, then the <code>f(Float64,Float64)</code> method cannot be called and the more general <code>f(Number,Number)</code> method must be used:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複数のメソッドを持つ関数を定義するには、異なる数と型の引数で関数を複数回定義するだけです。関数の最初のメソッド定義は関数オブジェクトを作成し、その後のメソッド定義は既存の関数オブジェクトに新しいメソッドを追加します。引数の数と型に最も特化したメソッド定義が、関数が適用されるときに実行されます。したがって、上記の2つのメソッド定義は、抽象型<code>Number</code>のすべてのインスタンスのペアに対する<code>f</code>の動作を定義しますが、<a href="../../base/numbers/index.html#Core.Float64"><code>Float64</code></a>値のペアに特有の異なる動作を持っています。引数の1つが64ビット浮動小数点で、もう1つがそうでない場合、<code>f(Float64,Float64)</code>メソッドは呼び出せず、より一般的な<code>f(Number,Number)</code>メソッドを使用しなければなりません。</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(2.0, 3.0)
7.0

julia&gt; f(2, 3.0)
1.0

julia&gt; f(2.0, 3)
1.0

julia&gt; f(2, 3)
1</code></pre><p data-translated="true"><span class="original-text">The <code>2x + y</code> definition is only used in the first case, while the <code>2x - y</code> definition is used in the others. No automatic casting or conversion of function arguments is ever performed: all conversion in Julia is non-magical and completely explicit. <a href="../conversion-and-promotion/index.html#conversion-and-promotion">Conversion and Promotion</a>, however, shows how clever application of sufficiently advanced technology can be indistinguishable from magic. <sup class="footnote-reference"><a id="citeref-Clarke61" href="#footnote-Clarke61" class="footnote-ref">[Clarke61]</a><span class="footnote-preview" id="fn-Clarke61"></span></sup></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>2x + y</code>の定義は最初のケースでのみ使用され、<code>2x - y</code>の定義は他のケースで使用されます。関数引数の自動キャストや変換は決して行われません。Juliaではすべての変換は非魔法的で完全に明示的です。ただし、<a href="../conversion-and-promotion/index.html#conversion-and-promotion">Conversion and Promotion</a>では、十分に高度な技術の巧妙な適用が魔法と区別がつかないことを示しています。<sup class="footnote-reference"><a id="citeref-Clarke61" href="#footnote-Clarke61" class="footnote-ref">[Clarke61]</a><span class="footnote-preview" id="fn-Clarke61"></span></sup></span></p><p data-translated="true"><span class="original-text">For non-numeric values, and for fewer or more than two arguments, the function <code>f</code> remains undefined, and applying it will still result in a <a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">数値以外の値や、引数が2つ未満または2つ以上の場合、関数<code>f</code>は未定義のままであり、それを適用すると依然として<a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a>が発生します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; f("foo", 3)
ERROR: MethodError: no method matching f(::String, ::Int64)
The function `f` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  f(!Matched::Number, ::Number)
   @ Main none:1
  f(!Matched::Float64, !Matched::Float64)
   @ Main none:1

Stacktrace:
[...]

julia&gt; f()
ERROR: MethodError: no method matching f()
The function `f` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  f(!Matched::Float64, !Matched::Float64)
   @ Main none:1
  f(!Matched::Number, !Matched::Number)
   @ Main none:1

Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">You can easily see which methods exist for a function by entering the function object itself in an interactive session:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">インタラクティブセッションで関数オブジェクト自体を入力することで、関数に存在するメソッドを簡単に確認できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; f
f (generic function with 2 methods)</code></pre><p data-translated="true"><span class="original-text">This output tells us that <code>f</code> is a function object with two methods. To find out what the signatures of those methods are, use the <a href="../../base/base/index.html#Base.methods"><code>methods</code></a> function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この出力は、<code>f</code>が2つのメソッドを持つ関数オブジェクトであることを示しています。それらのメソッドのシグネチャを確認するには、<a href="../../base/base/index.html#Base.methods"><code>methods</code></a>関数を使用します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; methods(f)
# 2 methods for generic function "f" from Main:
 [1] f(x::Float64, y::Float64)
     @ none:1
 [2] f(x::Number, y::Number)
     @ none:1</code></pre><p data-translated="true"><span class="original-text">which shows that <code>f</code> has two methods, one taking two <code>Float64</code> arguments and one taking arguments of type <code>Number</code>. It also indicates the file and line number where the methods were defined: because these methods were defined at the REPL, we get the apparent line number <code>none:1</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、<code>f</code>が2つのメソッドを持ち、一つは2つの<code>Float64</code>引数を取り、もう一つは<code>Number</code>型の引数を取ることを示しています。また、メソッドが定義されたファイルと行番号も示しています：これらのメソッドはREPLで定義されたため、見かけ上の行番号<code>none:1</code>が得られます。</span></p><p data-translated="true"><span class="original-text">In the absence of a type declaration with <code>::</code>, the type of a method parameter is <code>Any</code> by default, meaning that it is unconstrained since all values in Julia are instances of the abstract type <code>Any</code>. Thus, we can define a catch-all method for <code>f</code> like so:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型宣言が<code>::</code>でない場合、メソッドパラメータの型はデフォルトで<code>Any</code>となり、これはすべての値がJuliaの抽象型<code>Any</code>のインスタンスであるため、制約がないことを意味します。したがって、次のように<code>f</code>のためのキャッチオールメソッドを定義できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; f(x,y) = println("Whoa there, Nelly.")
f (generic function with 3 methods)

julia&gt; methods(f)
# 3 methods for generic function "f" from Main:
 [1] f(x::Float64, y::Float64)
     @ none:1
 [2] f(x::Number, y::Number)
     @ none:1
 [3] f(x, y)
     @ none:1

julia&gt; f("foo", 1)
Whoa there, Nelly.</code></pre><p data-translated="true"><span class="original-text">This catch-all is less specific than any other possible method definition for a pair of parameter values, so it will only be called on pairs of arguments to which no other method definition applies.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このキャッチオールは、パラメータ値のペアに対する他の可能なメソッド定義よりも具体性が低いため、他のメソッド定義が適用されない引数のペアに対してのみ呼び出されます。</span></p><p data-translated="true"><span class="original-text">Note that in the signature of the third method, there is no type specified for the arguments <code>x</code> and <code>y</code>. This is a shortened way of expressing <code>f(x::Any, y::Any)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">第三のメソッドのシグネチャには、引数<code>x</code>と<code>y</code>の型が指定されていないことに注意してください。これは、<code>f(x::Any, y::Any)</code>を表現する短縮形です。</span></p><p data-translated="true"><span class="original-text">Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language. Core operations typically have dozens of methods:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">単純な概念のように思えますが、値の型に基づく多重ディスパッチは、Julia言語の最も強力で中心的な機能の一つです。コア操作は通常、数十のメソッドを持っています。</span></p><pre><code class="language-julia-repl hljs">julia&gt; methods(+)
# 180 methods for generic function "+":
[1] +(x::Bool, z::Complex{Bool}) in Base at complex.jl:227
[2] +(x::Bool, y::Bool) in Base at bool.jl:89
[3] +(x::Bool) in Base at bool.jl:86
[4] +(x::Bool, y::T) where T&lt;:AbstractFloat in Base at bool.jl:96
[5] +(x::Bool, z::Complex) in Base at complex.jl:234
[6] +(a::Float16, b::Float16) in Base at float.jl:373
[7] +(x::Float32, y::Float32) in Base at float.jl:375
[8] +(x::Float64, y::Float64) in Base at float.jl:376
[9] +(z::Complex{Bool}, x::Bool) in Base at complex.jl:228
[10] +(z::Complex{Bool}, x::Real) in Base at complex.jl:242
[11] +(x::Char, y::Integer) in Base at char.jl:40
[12] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:307
[13] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:392
[14] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:391
[15] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:390
[16] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:361
[17] +(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:398
...
[180] +(a, b, c, xs...) in Base at operators.jl:424</code></pre><p data-translated="true"><span class="original-text">Multiple dispatch together with the flexible parametric type system give Julia its ability to abstractly express high-level algorithms decoupled from implementation details.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">多重ディスパッチと柔軟なパラメトリック型システムが組み合わさることで、Juliaは実装の詳細から切り離された高レベルのアルゴリズムを抽象的に表現する能力を持っています。</span></p><h2 id="man-method-specializations" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-method-specializations">Method specializations</a><a id="man-method-specializations-1"></a><a class="docs-heading-anchor-permalink" href="#man-method-specializations" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-method-specializations">メソッドの特化</a><a id="man-method-specializations-1"></a><a class="docs-heading-anchor-permalink" href="#man-method-specializations" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">When you create multiple methods of the same function, this is sometimes called "specialization." In this case, you're specializing the <em>function</em> by adding additional methods to it: each new method is a new specialization of the function. As shown above, these specializations are returned by <code>methods</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">同じ関数の複数のメソッドを作成すると、これを「特化」と呼ぶことがあります。この場合、追加のメソッドを加えることで<em>関数</em>を特化しています：各新しいメソッドは関数の新しい特化です。上記のように、これらの特化は<code>methods</code>によって返されます。</span></p><p data-translated="true"><span class="original-text">There's another kind of specialization that occurs without programmer intervention: Julia's compiler can automatically specialize the <em>method</em> for the specific argument types used. Such specializations are <em>not</em> listed by <code>methods</code>, as this doesn't create new <code>Method</code>s, but tools like <a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_typed"><code>@code_typed</code></a> allow you to inspect such specializations.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">プログラマーの介入なしに発生する別の種類の特化があります：Juliaのコンパイラは、使用される特定の引数型に対して<em>メソッド</em>を自動的に特化できます。このような特化は<code>methods</code>によってリストされることはなく、新しい<code>Method</code>を作成しないためですが、<a href="../../stdlib/InteractiveUtils/index.html#InteractiveUtils.@code_typed"><code>@code_typed</code></a>のようなツールを使用すると、そのような特化を検査できます。</span></p><p data-translated="true"><span class="original-text">For example, if you create a method</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、メソッドを作成すると</span></p><pre><code class="nohighlight hljs">mysum(x::Real, y::Real) = x + y</code></pre><p data-translated="true"><span class="original-text">you've given the function <code>mysum</code> one new method (possibly its only method), and that method takes any pair of <code>Real</code> number inputs. But if you then execute</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数 <code>mysum</code> に新しいメソッド（おそらく唯一のメソッド）を与え、そのメソッドは任意のペアの <code>Real</code> 数値入力を受け取ります。しかし、その後に実行すると</span></p><pre><code class="language-julia-repl hljs">julia&gt; mysum(1, 2)
3

julia&gt; mysum(1.0, 2.0)
3.0</code></pre><p data-translated="true"><span class="original-text">Julia will compile <code>mysum</code> twice, once for <code>x::Int, y::Int</code> and again for <code>x::Float64, y::Float64</code>. The point of compiling twice is performance: the methods that get called for <code>+</code> (which <code>mysum</code> uses) vary depending on the specific types of <code>x</code> and <code>y</code>, and by compiling different specializations Julia can do all the method lookup ahead of time. This allows the program to run much more quickly, since it does not have to bother with method lookup while it is running. Julia's automatic specialization allows you to write generic algorithms and expect that the compiler will generate efficient, specialized code to handle each case you need.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia は <code>mysum</code> を二回コンパイルします。一度は <code>x::Int, y::Int</code> 用、もう一度は <code>x::Float64, y::Float64</code> 用です。二回コンパイルする目的はパフォーマンスです：<code>+</code> に対して呼び出されるメソッドは <code>x</code> と <code>y</code> の特定の型によって異なり、異なる特化をコンパイルすることで、Julia は事前にすべてのメソッドルックアップを行うことができます。これにより、プログラムは実行中にメソッドルックアップを気にする必要がなくなり、はるかに迅速に実行されます。Julia の自動特化により、汎用アルゴリズムを書くことができ、コンパイラが必要な各ケースを処理するために効率的で特化したコードを生成することを期待できます。</span></p><p data-translated="true"><span class="original-text">In cases where the number of potential specializations might be effectively unlimited, Julia may avoid this default specialization. See <a href="../performance-tips/index.html#Be-aware-of-when-Julia-avoids-specializing">Be aware of when Julia avoids specializing</a> for more information.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">潜在的な特化の数が実質的に無限である場合、Julia はこのデフォルトの特化を避けることがあります。詳細については、<a href="../performance-tips/index.html#Be-aware-of-when-Julia-avoids-specializing">Julia が特化を避ける場合に注意してください</a>を参照してください。</span></p><h2 id="man-ambiguities" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-ambiguities">Method Ambiguities</a><a id="man-ambiguities-1"></a><a class="docs-heading-anchor-permalink" href="#man-ambiguities" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-ambiguities">メソッドの曖昧さ</a><a id="man-ambiguities-1"></a><a class="docs-heading-anchor-permalink" href="#man-ambiguities" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">引数の組み合わせに対して適用可能な唯一の最も特定的なメソッドが存在しないような関数メソッドのセットを定義することが可能です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; g(x::Float64, y) = 2x + y
g (generic function with 1 method)

julia&gt; g(x, y::Float64) = x + 2y
g (generic function with 2 methods)

julia&gt; g(2.0, 3)
7.0

julia&gt; g(2, 3.0)
8.0

julia&gt; g(2.0, 3.0)
ERROR: MethodError: g(::Float64, ::Float64) is ambiguous.

Candidates:
  g(x, y::Float64)
    @ Main none:1
  g(x::Float64, y)
    @ Main none:1

Possible fix, define
  g(::Float64, ::Float64)

Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">Here the call <code>g(2.0, 3.0)</code> could be handled by either the <code>g(::Float64, ::Any)</code> or the <code>g(::Any, ::Float64)</code> method. The order in which the methods are defined does not matter and neither is more specific than the other. In such cases, Julia raises a <a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a> rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで、呼び出し <code>g(2.0, 3.0)</code> は <code>g(::Float64, ::Any)</code> または <code>g(::Any, ::Float64)</code> メソッドのいずれかで処理される可能性があります。メソッドが定義される順序は重要ではなく、どちらも他のものより特定的ではありません。このような場合、Julia は任意にメソッドを選択するのではなく、<a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a> を発生させます。交差ケースに対して適切なメソッドを指定することで、メソッドの曖昧さを回避できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; g(x::Float64, y::Float64) = 2x + 2y
g (generic function with 3 methods)

julia&gt; g(2.0, 3)
7.0

julia&gt; g(2, 3.0)
8.0

julia&gt; g(2.0, 3.0)
10.0</code></pre><p data-translated="true"><span class="original-text">It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if transiently, until the more specific method is defined.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">曖昧さが存在するため、曖昧さを解消するメソッドは最初に定義することをお勧めします。そうしないと、より特定的なメソッドが定義されるまで、曖昧さが一時的に存在します。</span></p><p data-translated="true"><span class="original-text">In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further <a href="#man-method-design-ambiguities">below</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より複雑なケースでは、メソッドの曖昧さを解決するには一定の設計要素が関与します。このトピックは<a href="#man-method-design-ambiguities">以下</a>でさらに探求されます。</span></p><h2 id="Parametric-Methods" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Parametric-Methods">Parametric Methods</a><a id="Parametric-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Methods" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Parametric-Methods">パラメトリックメソッド</a><a id="Parametric-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Methods" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Method definitions can optionally have type parameters qualifying the signature:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メソッド定義には、署名を修飾する型パラメータをオプションで持たせることができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; same_type(x::T, y::T) where {T} = true
same_type (generic function with 1 method)

julia&gt; same_type(x,y) = false
same_type (generic function with 2 methods)</code></pre><p data-translated="true"><span class="original-text">The first method applies whenever both arguments are of the same concrete type, regardless of what type that is, while the second method acts as a catch-all, covering all other cases. Thus, overall, this defines a boolean function that checks whether its two arguments are of the same type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初のメソッドは、両方の引数が同じ具体的な型である場合に適用され、型が何であれ関係ありません。一方、2番目のメソッドは、他のすべてのケースをカバーするキャッチオールとして機能します。したがって、全体として、これは2つの引数が同じ型であるかどうかをチェックするブール関数を定義します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; same_type(1, 2)
true

julia&gt; same_type(1, 2.0)
false

julia&gt; same_type(1.0, 2.0)
true

julia&gt; same_type("foo", 2.0)
false

julia&gt; same_type("foo", "bar")
true

julia&gt; same_type(Int32(1), Int64(2))
false</code></pre><p data-translated="true"><span class="original-text">Such definitions correspond to methods whose type signatures are <code>UnionAll</code> types (see <a href="../types/index.html#UnionAll-Types">UnionAll Types</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このような定義は、型シグネチャが <code>UnionAll</code> 型であるメソッドに対応します（<a href="../types/index.html#UnionAll-Types">UnionAll Types</a>を参照）。</span></p><p data-translated="true"><span class="original-text">This kind of definition of function behavior by dispatch is quite common – idiomatic, even – in Julia. Method type parameters are not restricted to being used as the types of arguments: they can be used anywhere a value would be in the signature of the function or body of the function. Here's an example where the method type parameter <code>T</code> is used as the type parameter to the parametric type <code>Vector{T}</code> in the method signature:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数の動作をディスパッチによって定義するこの種の定義は、Juliaでは非常に一般的であり、慣用的です。メソッドの型パラメータは、引数の型として使用されることに制限されず、関数のシグネチャや本体の値が必要な場所で使用できます。以下は、メソッドシグネチャ内で型パラメータ <code>T</code> がパラメトリック型 <code>Vector{T}</code> の型パラメータとして使用される例です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function myappend(v::Vector{T}, x::T) where {T}
           return [v..., x]
       end
myappend (generic function with 1 method)</code></pre><p data-translated="true"><span class="original-text">The type parameter <code>T</code> in this example ensures that the added element <code>x</code> is a subtype of the existing eltype of the vector <code>v</code>. The <code>where</code> keyword introduces a list of those constraints after the method signature definition. This works the same for one-line definitions, as seen above, and must appear <em>before</em> the <a href="../functions/index.html#man-functions-return-type">return type declaration</a>, if present, as illustrated below:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例の型パラメータ <code>T</code> は、追加される要素 <code>x</code> がベクター <code>v</code> の既存の eltype のサブタイプであることを保証します。<code>where</code> キーワードは、メソッドシグネチャ定義の後にそれらの制約のリストを導入します。これは、上記のように1行の定義でも同様に機能し、<a href="../functions/index.html#man-functions-return-type">戻り値の宣言</a>が存在する場合は、以下に示すように、<em>前に</em>現れなければなりません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; (myappend(v::Vector{T}, x::T)::Vector) where {T} = [v..., x]
myappend (generic function with 1 method)

julia&gt; myappend([1,2,3],4)
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; myappend([1,2,3],2.5)
ERROR: MethodError: no method matching myappend(::Vector{Int64}, ::Float64)
The function `myappend` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  myappend(::Vector{T}, !Matched::T) where T
   @ Main none:1

Stacktrace:
[...]

julia&gt; myappend([1.0,2.0,3.0],4.0)
4-element Vector{Float64}:
 1.0
 2.0
 3.0
 4.0

julia&gt; myappend([1.0,2.0,3.0],4)
ERROR: MethodError: no method matching myappend(::Vector{Float64}, ::Int64)
The function `myappend` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  myappend(::Vector{T}, !Matched::T) where T
   @ Main none:1

Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">If the type of the appended element does not match the element type of the vector it is appended to, a <a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a> is raised. In the following example, the method's type parameter <code>T</code> is used as the return value:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">追加される要素の型が追加されるベクターの要素型と一致しない場合、<a href="../../base/base/index.html#Core.MethodError"><code>MethodError</code></a> が発生します。以下の例では、メソッドの型パラメータ <code>T</code> が戻り値として使用されています：</span></p><pre><code class="language-julia-repl hljs">julia&gt; mytypeof(x::T) where {T} = T
mytypeof (generic function with 1 method)

julia&gt; mytypeof(1)
Int64

julia&gt; mytypeof(1.0)
Float64</code></pre><p data-translated="true"><span class="original-text">Just as you can put subtype constraints on type parameters in type declarations (see <a href="../types/index.html#Parametric-Types">Parametric Types</a>), you can also constrain type parameters of methods:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型宣言における型パラメータにサブタイプ制約を付けることができるのと同様に（<a href="../types/index.html#Parametric-Types">Parametric Types</a>を参照）、メソッドの型パラメータにも制約を付けることができます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; same_type_numeric(x::T, y::T) where {T&lt;:Number} = true
same_type_numeric (generic function with 1 method)

julia&gt; same_type_numeric(x::Number, y::Number) = false
same_type_numeric (generic function with 2 methods)

julia&gt; same_type_numeric(1, 2)
true

julia&gt; same_type_numeric(1, 2.0)
false

julia&gt; same_type_numeric(1.0, 2.0)
true

julia&gt; same_type_numeric("foo", 2.0)
ERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)
The function `same_type_numeric` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  same_type_numeric(!Matched::T, ::T) where T&lt;:Number
   @ Main none:1
  same_type_numeric(!Matched::Number, ::Number)
   @ Main none:1

Stacktrace:
[...]

julia&gt; same_type_numeric("foo", "bar")
ERROR: MethodError: no method matching same_type_numeric(::String, ::String)
The function `same_type_numeric` exists, but no method is defined for this combination of argument types.

julia&gt; same_type_numeric(Int32(1), Int64(2))
false</code></pre><p data-translated="true"><span class="original-text">The <code>same_type_numeric</code> function behaves much like the <code>same_type</code> function defined above, but is only defined for pairs of numbers.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>same_type_numeric</code> 関数は、上で定義された <code>same_type</code> 関数と非常に似た動作をしますが、数のペアに対してのみ定義されています。</span></p><p data-translated="true"><span class="original-text">Parametric methods allow the same syntax as <code>where</code> expressions used to write types (see <a href="../types/index.html#UnionAll-Types">UnionAll Types</a>). If there is only a single parameter, the enclosing curly braces (in <code>where {T}</code>) can be omitted, but are often preferred for clarity. Multiple parameters can be separated with commas, e.g. <code>where {T, S&lt;:Real}</code>, or written using nested <code>where</code>, e.g. <code>where S&lt;:Real where T</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">パラメトリックメソッドは、型を書くために使用される <code>where</code> 式と同じ構文を許可します（<a href="../types/index.html#UnionAll-Types">UnionAll Types</a>を参照）。単一のパラメータしかない場合、囲む波括弧（<code>where {T}</code>内）は省略できますが、明確さのために好まれることが多いです。複数のパラメータはカンマで区切ることができ、例えば <code>where {T, S&lt;:Real}</code> のように、またはネストされた <code>where</code> を使用して <code>where S&lt;:Real where T</code> のように書くことができます。</span></p><h2 id="Redefining-Methods" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Redefining-Methods">Redefining Methods</a><a id="Redefining-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Redefining-Methods" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Redefining-Methods">メソッドの再定義</a><a id="Redefining-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Redefining-Methods" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">When redefining a method or adding new methods, it is important to realize that these changes don't take effect immediately. This is key to Julia's ability to statically infer and compile code to run fast, without the usual JIT tricks and overhead. Indeed, any new method definition won't be visible to the current runtime environment, including Tasks and Threads (and any previously defined <code>@generated</code> functions). Let's start with an example to see what this means:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メソッドを再定義したり新しいメソッドを追加したりする際には、これらの変更が即座に反映されないことを理解することが重要です。これは、Juliaがコードを静的に推論し、通常のJITトリックやオーバーヘッドなしで高速に実行する能力の鍵です。実際、新しいメソッド定義は、現在のランタイム環境、タスクやスレッド（および以前に定義された<code>@generated</code>関数を含む）には見えません。これが何を意味するのかを理解するために、例を見てみましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function tryeval()
           @eval newfun() = 1
           newfun()
       end
tryeval (generic function with 1 method)

julia&gt; tryeval()
ERROR: MethodError: no method matching newfun()
The applicable method may be too new: running in world age xxxx1, while current world is xxxx2.
Closest candidates are:
  newfun() at none:1 (method too new to be called from this world context.)
 in tryeval() at none:1
 ...

julia&gt; newfun()
1</code></pre><p data-translated="true"><span class="original-text">In this example, observe that the new definition for <code>newfun</code> has been created, but can't be immediately called. The new global is immediately visible to the <code>tryeval</code> function, so you could write <code>return newfun</code> (without parentheses). But neither you, nor any of your callers, nor the functions they call, or etc. can call this new method definition!</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例では、<code>newfun</code>の新しい定義が作成されたことに注意してください。しかし、すぐには呼び出すことができません。新しいグローバルは<code>tryeval</code>関数に即座に見えるため、<code>return newfun</code>（括弧なし）を書くことができます。しかし、あなた自身も、あなたの呼び出し元も、呼び出される関数も、なども、この新しいメソッド定義を呼び出すことはできません！</span></p><p data-translated="true"><span class="original-text">But there's an exception: future calls to <code>newfun</code> <em>from the REPL</em> work as expected, being able to both see and call the new definition of <code>newfun</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、例外があります：<code>newfun</code>への将来の呼び出しは<em>REPLから</em>期待通りに動作し、新しい定義の<code>newfun</code>を見て呼び出すことができます。</span></p><p data-translated="true"><span class="original-text">However, future calls to <code>tryeval</code> will continue to see the definition of <code>newfun</code> as it was <em>at the previous statement at the REPL</em>, and thus before that call to <code>tryeval</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、<code>tryeval</code>への将来の呼び出しは、<em>REPLの前のステートメントでの</em><code>newfun</code>の定義を引き続き見ることになり、そのため<code>tryeval</code>への呼び出しの前の状態になります。</span></p><p data-translated="true"><span class="original-text">You may want to try this for yourself to see how it works.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これがどのように機能するかを自分で試してみたいかもしれません。</span></p><p data-translated="true"><span class="original-text">The implementation of this behavior is a "world age counter", which is further described in the <a href="../../base/math/#Base.:--Tuple{Any, Any}#Base.:--Tuple{Any, Any}">Worldage</a> manual chapter.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この動作の実装は「ワールドエイジカウンター」であり、<a href="../../base/math/#Base.:--Tuple{Any, Any}#Base.:--Tuple{Any, Any}">Worldage</a>マニュアルの章でさらに詳しく説明されています。</span></p><h2 id="Design-Patterns-with-Parametric-Methods" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Design-Patterns-with-Parametric-Methods">Design Patterns with Parametric Methods</a><a id="Design-Patterns-with-Parametric-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Design-Patterns-with-Parametric-Methods" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Design-Patterns-with-Parametric-Methods">パラメトリックメソッドによるデザインパターン</a><a id="Design-Patterns-with-Parametric-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Design-Patterns-with-Parametric-Methods" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">While complex dispatch logic is not required for performance or usability, sometimes it can be the best way to express some algorithm. Here are a few common design patterns that come up sometimes when using dispatch in this way.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複雑なディスパッチロジックはパフォーマンスや使いやすさには必要ありませんが、時にはアルゴリズムを表現する最良の方法になることがあります。ここでは、この方法でディスパッチを使用する際に時々現れる一般的なデザインパターンをいくつか紹介します。</span></p><h3 id="Extracting-the-type-parameter-from-a-super-type" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Extracting-the-type-parameter-from-a-super-type">Extracting the type parameter from a super-type</a><a id="Extracting-the-type-parameter-from-a-super-type-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-the-type-parameter-from-a-super-type" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Extracting-the-type-parameter-from-a-super-type">スーパタイプから型パラメータを抽出する</a><a id="Extracting-the-type-parameter-from-a-super-type-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-the-type-parameter-from-a-super-type" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Here is a correct code template for returning the element-type <code>T</code> of any arbitrary subtype of <code>AbstractArray</code> that has well-defined element type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここに、要素型が明確に定義された<code>AbstractArray</code>の任意のサブタイプの要素型<code>T</code>を返すための正しいコードテンプレートがあります：</span></p><pre><code class="language-julia hljs">abstract type AbstractArray{T, N} end
eltype(::Type{&lt;:AbstractArray{T}}) where {T} = T</code></pre><p data-translated="true"><span class="original-text">using so-called triangular dispatch. Note that <code>UnionAll</code> types, for example <code>eltype(AbstractArray{T} where T &lt;: Integer)</code>, do not match the above method. The implementation of <code>eltype</code> in <code>Base</code> adds a fallback method to <code>Any</code> for such cases.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">いわゆる三角ディスパッチを使用しています。例えば、<code>eltype(AbstractArray{T} where T &lt;: Integer)</code>のような<code>UnionAll</code>型は、上記のメソッドには一致しないことに注意してください。<code>Base</code>における<code>eltype</code>の実装は、そのような場合に<code>Any</code>へのフォールバックメソッドを追加します。</span></p><p data-translated="true"><span class="original-text">One common mistake is to try and get the element-type by using introspection:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一般的な間違いの一つは、イントロスペクションを使用して要素型を取得しようとすることです：</span></p><pre><code class="language-julia hljs">eltype_wrong(::Type{A}) where {A&lt;:AbstractArray} = A.parameters[1]</code></pre><p data-translated="true"><span class="original-text">However, it is not hard to construct cases where this will fail:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし、これが失敗するケースを構築するのは難しくありません：</span></p><pre><code class="language-julia hljs">struct BitVector &lt;: AbstractArray{Bool, 1}; end</code></pre><p data-translated="true"><span class="original-text">Here we have created a type <code>BitVector</code> which has no parameters, but where the element-type is still fully specified, with <code>T</code> equal to <code>Bool</code>!</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、パラメータを持たない型<code>BitVector</code>を作成しましたが、要素型は<code>T</code>が<code>Bool</code>に等しいことによって完全に指定されています！</span></p><p data-translated="true"><span class="original-text">Another mistake is to try to walk up the type hierarchy using <code>supertype</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もう一つの間違いは、<code>supertype</code>を使用して型階層を上に歩こうとすることです：</span></p><pre><code class="language-julia hljs">eltype_wrong(::Type{AbstractArray{T}}) where {T} = T
eltype_wrong(::Type{AbstractArray{T, N}}) where {T, N} = T
eltype_wrong(::Type{A}) where {A&lt;:AbstractArray} = eltype_wrong(supertype(A))</code></pre><p data-translated="true"><span class="original-text">While this works for declared types, it fails for types without supertypes:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは宣言された型には機能しますが、スーパタイプを持たない型には失敗します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; eltype_wrong(Union{Vector{Int}, Matrix{Int}})
ERROR: MethodError: no method matching supertype(::Type{VecOrMat{Int64}})

Closest candidates are:
  supertype(::UnionAll)
   @ Base operators.jl:44
  supertype(::DataType)
   @ Base operators.jl:43</code></pre><h3 id="Building-a-similar-type-with-a-different-type-parameter" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Building-a-similar-type-with-a-different-type-parameter">Building a similar type with a different type parameter</a><a id="Building-a-similar-type-with-a-different-type-parameter-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-similar-type-with-a-different-type-parameter" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Building-a-similar-type-with-a-different-type-parameter">異なる型パラメータを持つ類似の型を構築する</a><a id="Building-a-similar-type-with-a-different-type-parameter-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-similar-type-with-a-different-type-parameter" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">When building generic code, there is often a need for constructing a similar object with some change made to the layout of the type, also necessitating a change of the type parameters. For instance, you might have some sort of abstract array with an arbitrary element type and want to write your computation on it with a specific element type. We must implement a method for each <code>AbstractArray{T}</code> subtype that describes how to compute this type transform. There is no general transform of one subtype into another subtype with a different parameter.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ジェネリックコードを構築する際には、型のレイアウトに変更を加えた類似のオブジェクトを構築する必要があることがよくあります。これには型パラメータの変更も必要です。例えば、任意の要素型を持つ抽象配列があり、特定の要素型でその上で計算を行いたい場合があります。この型変換を計算する方法を記述するために、各<code>AbstractArray{T}</code>サブタイプのためのメソッドを実装する必要があります。異なるパラメータを持つ別のサブタイプへの一般的な変換は存在しません。</span></p><p data-translated="true"><span class="original-text">The subtypes of <code>AbstractArray</code> typically implement two methods to achieve this: A method to convert the input array to a subtype of a specific <code>AbstractArray{T, N}</code> abstract type; and a method to make a new uninitialized array with a specific element type. Sample implementations of these can be found in Julia Base. Here is a basic example usage of them, guaranteeing that <code>input</code> and <code>output</code> are of the same type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>AbstractArray</code>のサブタイプは、通常、これを達成するために2つのメソッドを実装します：特定の<code>AbstractArray{T, N}</code>抽象型のサブタイプに入力配列を変換するメソッドと、特定の要素型を持つ新しい未初期化配列を作成するメソッドです。これらのサンプル実装はJulia Baseに見つけることができます。以下は、<code>input</code>と<code>output</code>が同じ型であることを保証する基本的な使用例です：</span></p><pre><code class="language-julia hljs">input = convert(AbstractArray{Eltype}, input)
output = similar(input, Eltype)</code></pre><p data-translated="true"><span class="original-text">As an extension of this, in cases where the algorithm needs a copy of the input array, <a href="../../base/base/index.html#Base.convert"><code>convert</code></a> is insufficient as the return value may alias the original input. Combining <a href="../../base/arrays/index.html#Base.similar"><code>similar</code></a> (to make the output array) and <a href="../../base/c/index.html#Base.copyto!"><code>copyto!</code></a> (to fill it with the input data) is a generic way to express the requirement for a mutable copy of the input argument:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これを拡張すると、アルゴリズムが入力配列のコピーを必要とする場合、<a href="../../base/base/index.html#Base.convert"><code>convert</code></a>は不十分です。なぜなら、戻り値が元の入力とエイリアスする可能性があるからです。<a href="../../base/arrays/index.html#Base.similar"><code>similar</code></a>（出力配列を作成するため）と<a href="../../base/c/index.html#Base.copyto!"><code>copyto!</code></a>（入力データで埋めるため）を組み合わせることは、入力引数の可変コピーの要件を表現する一般的な方法です：</span></p><pre><code class="language-julia hljs">copy_with_eltype(input, Eltype) = copyto!(similar(input, Eltype), input)</code></pre><h3 id="Iterated-dispatch" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Iterated-dispatch">Iterated dispatch</a><a id="Iterated-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Iterated-dispatch" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Iterated-dispatch">反復ディスパッチ</a><a id="Iterated-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Iterated-dispatch" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch into distinct functions. This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複数レベルのパラメトリック引数リストをディスパッチするためには、各ディスパッチレベルを異なる関数に分けるのが最良であることが多いです。これはシングルディスパッチと似たアプローチに聞こえるかもしれませんが、以下で見るように、依然としてより柔軟です。</span></p><p data-translated="true"><span class="original-text">For example, trying to dispatch on the element-type of an array will often run into ambiguous situations. Instead, common code will dispatch first on the container type, then recurse down to a more specific method based on <code>eltype</code>. In most cases, the algorithms lend themselves conveniently to this hierarchical approach, while in other cases, this rigor must be resolved manually. This dispatching branching can be observed, for example, in the logic to sum two matrices:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、配列の要素型に基づいてディスパッチしようとすると、しばしば曖昧な状況に直面します。代わりに、共通のコードは最初にコンテナ型に基づいてディスパッチし、その後<code>eltype</code>に基づいてより具体的なメソッドに再帰します。ほとんどの場合、アルゴリズムはこの階層的アプローチに便利に適合しますが、他の場合にはこの厳密さを手動で解決する必要があります。このディスパッチの分岐は、例えば2つの行列を合計するロジックにおいて観察できます。</span></p><pre><code class="language-julia hljs"># First dispatch selects the map algorithm for element-wise summation.
+(a::Matrix, b::Matrix) = map(+, a, b)
# Then dispatch handles each element and selects the appropriate
# common element type for the computation.
+(a, b) = +(promote(a, b)...)
# Once the elements have the same type, they can be added.
# For example, via primitive operations exposed by the processor.
+(a::Float64, b::Float64) = Core.add(a, b)</code></pre><h3 id="Trait-based-dispatch" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Trait-based-dispatch">Trait-based dispatch</a><a id="Trait-based-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Trait-based-dispatch" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Trait-based-dispatch">トレイトベースのディスパッチ</a><a id="Trait-based-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Trait-based-dispatch" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">A natural extension to the iterated dispatch above is to add a layer to method selection that allows to dispatch on sets of types which are independent from the sets defined by the type hierarchy. We could construct such a set by writing out a <code>Union</code> of the types in question, but then this set would not be extensible as <code>Union</code>-types cannot be altered after creation. However, such an extensible set can be programmed with a design pattern often referred to as a <a href="https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633#issuecomment-54537633">"Holy-trait"</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記の反復ディスパッチの自然な拡張は、型階層によって定義されたセットとは独立した型のセットに基づいてディスパッチを行うメソッド選択のレイヤーを追加することです。このようなセットは、問題の型の<code>Union</code>を書き出すことで構築できますが、その場合、このセットは拡張可能ではなく、<code>Union</code>型は作成後に変更できません。しかし、このような拡張可能なセットは、しばしば<a href="https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633#issuecomment-54537633">「ホーリートレイト」</a>と呼ばれるデザインパターンを使用してプログラムできます。</span></p><p data-translated="true"><span class="original-text">This pattern is implemented by defining a generic function which computes a different singleton value (or type) for each trait-set to which the function arguments may belong to. If this function is pure there is no impact on performance compared to normal dispatch.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このパターンは、関数引数が属する可能性のある各トレイトセットに対して異なるシングルトン値（または型）を計算する汎用関数を定義することで実装されます。この関数が純粋であれば、通常のディスパッチと比較してパフォーマンスに影響はありません。</span></p><p data-translated="true"><span class="original-text">The example in the previous section glossed over the implementation details of <a href="../../base/collections/index.html#Base.map"><code>map</code></a> and <a href="../../base/base/index.html#Base.promote"><code>promote</code></a>, which both operate in terms of these traits. When iterating over a matrix, such as in the implementation of <code>map</code>, one important question is what order to use to traverse the data. When <code>AbstractArray</code> subtypes implement the <a href="../../base/arrays/index.html#Base.IndexStyle"><code>Base.IndexStyle</code></a> trait, other functions such as <code>map</code> can dispatch on this information to pick the best algorithm (see <a href="../interfaces/index.html#man-interface-array">Abstract Array Interface</a>). This means that each subtype does not need to implement a custom version of <code>map</code>, since the generic definitions + trait classes will enable the system to select the fastest version. Here is a toy implementation of <code>map</code> illustrating the trait-based dispatch:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">前のセクションの例では、これらのトレイトに基づいて動作する<a href="../../base/collections/index.html#Base.map"><code>map</code></a>と<a href="../../base/base/index.html#Base.promote"><code>promote</code></a>の実装の詳細を省略しました。行列を反復処理する際、例えば<code>map</code>の実装において、データを横断するために使用する順序は重要な質問です。<code>AbstractArray</code>のサブタイプが<a href="../../base/arrays/index.html#Base.IndexStyle"><code>Base.IndexStyle</code></a>トレイトを実装すると、<code>map</code>のような他の関数はこの情報に基づいて最適なアルゴリズムを選択するためにディスパッチできます（詳細は<a href="../interfaces/index.html#man-interface-array">抽象配列インターフェース</a>を参照）。これは、各サブタイプが<code>map</code>のカスタムバージョンを実装する必要がないことを意味します。なぜなら、汎用定義とトレイトクラスがシステムに最速のバージョンを選択させるからです。以下は、トレイトベースのディスパッチを示す<code>map</code>の簡単な実装です。</span></p><pre><code class="language-julia hljs">map(f, a::AbstractArray, b::AbstractArray) = map(Base.IndexStyle(a, b), f, a, b)
# generic implementation:
map(::Base.IndexCartesian, f, a::AbstractArray, b::AbstractArray) = ...
# linear-indexing implementation (faster)
map(::Base.IndexLinear, f, a::AbstractArray, b::AbstractArray) = ...</code></pre><p data-translated="true"><span class="original-text">This trait-based approach is also present in the <a href="../../base/base/index.html#Base.promote"><code>promote</code></a> mechanism employed by the scalar <code>+</code>. It uses <a href="../../base/base/index.html#Base.promote_type"><code>promote_type</code></a>, which returns the optimal common type to compute the operation given the two types of the operands. This makes it possible to reduce the problem of implementing every function for every pair of possible type arguments, to the much smaller problem of implementing a conversion operation from each type to a common type, plus a table of preferred pair-wise promotion rules.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このトレイトベースのアプローチは、スカラー<code>+</code>によって使用される<a href="../../base/base/index.html#Base.promote"><code>promote</code></a>メカニズムにも存在します。これは、オペランドの2つの型を考慮して操作を計算するための最適な共通型を返す<a href="../../base/base/index.html#Base.promote_type"><code>promote_type</code></a>を使用します。これにより、すべての可能な型引数のペアに対してすべての関数を実装する問題を、各型から共通型への変換操作を実装するというはるかに小さな問題に減らすことができます。さらに、好ましいペアワイズ昇格ルールのテーブルも必要です。</span></p><h3 id="Output-type-computation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Output-type-computation">Output-type computation</a><a id="Output-type-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Output-type-computation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Output-type-computation">出力型計算</a><a id="Output-type-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Output-type-computation" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The discussion of trait-based promotion provides a transition into our next design pattern: computing the output element type for a matrix operation.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">トレイトベースの昇格に関する議論は、行列操作の出力要素型を計算する次のデザインパターンへの移行を提供します。</span></p><p data-translated="true"><span class="original-text">For implementing primitive operations, such as addition, we use the <a href="../../base/base/index.html#Base.promote_type"><code>promote_type</code></a> function to compute the desired output type. (As before, we saw this at work in the <code>promote</code> call in the call to <code>+</code>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">基本的な操作、例えば加算を実装するために、<a href="../../base/base/index.html#Base.promote_type"><code>promote_type</code></a> 関数を使用して、望ましい出力型を計算します。（以前と同様に、<code>+</code> の呼び出しにおける <code>promote</code> の呼び出しでこれを確認しました。）</span></p><p data-translated="true"><span class="original-text">For more complex functions on matrices, it may be necessary to compute the expected return type for a more complex sequence of operations. This is often performed by the following steps:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">行列に対するより複雑な関数の場合、より複雑な操作のシーケンスに対して期待される戻り型を計算する必要があるかもしれません。これは通常、以下のステップで実行されます：</span></p><ol><li data-translated="true"><span class="original-text">Write a small function <code>op</code> that expresses the set of operations performed by the kernel of the algorithm.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">アルゴリズムのカーネルによって実行される操作のセットを表現する小さな関数 <code>op</code> を書きます。</span></li><li data-translated="true"><span class="original-text">Compute the element type <code>R</code> of the result matrix as <code>promote_op(op, argument_types...)</code>, where <code>argument_types</code> is computed from <code>eltype</code> applied to each input array.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">結果行列の要素型 <code>R</code> を <code>promote_op(op, argument_types...)</code> として計算します。ここで、<code>argument_types</code> は各入力配列に適用された <code>eltype</code> から計算されます。</span></li><li data-translated="true"><span class="original-text">Build the output matrix as <code>similar(R, dims)</code>, where <code>dims</code> are the desired dimensions of the output array.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">出力行列を <code>similar(R, dims)</code> として構築します。ここで、<code>dims</code> は出力配列の望ましい次元です。</span></li></ol><p data-translated="true"><span class="original-text">For a more specific example, a generic square-matrix multiply pseudo-code might look like:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より具体的な例として、一般的な正方行列の乗算の擬似コードは次のようになります：</span></p><pre><code class="language-julia hljs">function matmul(a::AbstractMatrix, b::AbstractMatrix)
    op = (ai, bi) -&gt; ai * bi + ai * bi

    ## this is insufficient because it assumes `one(eltype(a))` is constructable:
    # R = typeof(op(one(eltype(a)), one(eltype(b))))

    ## this fails because it assumes `a[1]` exists and is representative of all elements of the array
    # R = typeof(op(a[1], b[1]))

    ## this is incorrect because it assumes that `+` calls `promote_type`
    ## but this is not true for some types, such as Bool:
    # R = promote_type(ai, bi)

    # this is wrong, since depending on the return value
    # of type-inference is very brittle (as well as not being optimizable):
    # R = Base.return_types(op, (eltype(a), eltype(b)))

    ## but, finally, this works:
    R = promote_op(op, eltype(a), eltype(b))
    ## although sometimes it may give a larger type than desired
    ## it will always give a correct type

    output = similar(b, R, (size(a, 1), size(b, 2)))
    if size(a, 2) &gt; 0
        for j in 1:size(b, 2)
            for i in 1:size(a, 1)
                ## here we don't use `ab = zero(R)`,
                ## since `R` might be `Any` and `zero(Any)` is not defined
                ## we also must declare `ab::R` to make the type of `ab` constant in the loop,
                ## since it is possible that typeof(a * b) != typeof(a * b + a * b) == R
                ab::R = a[i, 1] * b[1, j]
                for k in 2:size(a, 2)
                    ab += a[i, k] * b[k, j]
                end
                output[i, j] = ab
            end
        end
    end
    return output
end</code></pre><h3 id="Separate-convert-and-kernel-logic" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Separate-convert-and-kernel-logic">Separate convert and kernel logic</a><a id="Separate-convert-and-kernel-logic-1"></a><a class="docs-heading-anchor-permalink" href="#Separate-convert-and-kernel-logic" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Separate-convert-and-kernel-logic">変換とカーネルロジックを分離する</a><a id="Separate-convert-and-kernel-logic-1"></a><a class="docs-heading-anchor-permalink" href="#Separate-convert-and-kernel-logic" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">One way to significantly cut down on compile-times and testing complexity is to isolate the logic for converting to the desired type and the computation. This lets the compiler specialize and inline the conversion logic independent from the rest of the body of the larger kernel.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コンパイル時間とテストの複雑さを大幅に削減する方法の一つは、望ましい型への変換と計算のロジックを分離することです。これにより、コンパイラは大きなカーネルの本体から独立して変換ロジックを特化させ、インライン化することができます。</span></p><p data-translated="true"><span class="original-text">This is a common pattern seen when converting from a larger class of types to the one specific argument type that is actually supported by the algorithm:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、アルゴリズムによって実際にサポートされている特定の引数型に対して、より大きな型のクラスから変換する際に見られる一般的なパターンです：</span></p><pre><code class="language-julia hljs">complexfunction(arg::Int) = ...
complexfunction(arg::Any) = complexfunction(convert(Int, arg))

matmul(a::T, b::T) = ...
matmul(a, b) = matmul(promote(a, b)...)</code></pre><h2 id="Parametrically-constrained-Varargs-methods" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Parametrically-constrained-Varargs-methods">Parametrically-constrained Varargs methods</a><a id="Parametrically-constrained-Varargs-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Parametrically-constrained-Varargs-methods" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Parametrically-constrained-Varargs-methods">パラメトリック制約付きVarargsメソッド</a><a id="Parametrically-constrained-Varargs-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Parametrically-constrained-Varargs-methods" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Function parameters can also be used to constrain the number of arguments that may be supplied to a "varargs" function (<a href="../functions/index.html#Varargs-Functions">Varargs Functions</a>). The notation <code>Vararg{T,N}</code> is used to indicate such a constraint. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数のパラメータは、"varargs" 関数 (<a href="../functions/index.html#Varargs-Functions">Varargs Functions</a>) に供給できる引数の数を制約するためにも使用できます。このような制約を示すために <code>Vararg{T,N}</code> という表記が使用されます。例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; bar(a,b,x::Vararg{Any,2}) = (a,b,x)
bar (generic function with 1 method)

julia&gt; bar(1,2,3)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)
The function `bar` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  bar(::Any, ::Any, ::Any, !Matched::Any)
   @ Main none:1

Stacktrace:
[...]

julia&gt; bar(1,2,3,4)
(1, 2, (3, 4))

julia&gt; bar(1,2,3,4,5)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)
The function `bar` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  bar(::Any, ::Any, ::Any, ::Any)
   @ Main none:1

Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">More usefully, it is possible to constrain varargs methods by a parameter. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より便利なことに、パラメータによって varargs メソッドを制約することが可能です。例えば：</span></p><pre><code class="language-julia hljs">function getindex(A::AbstractArray{T,N}, indices::Vararg{Number,N}) where {T,N}</code></pre><p data-translated="true"><span class="original-text">would be called only when the number of <code>indices</code> matches the dimensionality of the array.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">は、<code>indices</code> の数が配列の次元数と一致する場合にのみ呼び出されます。</span></p><p data-translated="true"><span class="original-text">When only the type of supplied arguments needs to be constrained <code>Vararg{T}</code> can be equivalently written as <code>T...</code>. For instance <code>f(x::Int...) = x</code> is a shorthand for <code>f(x::Vararg{Int}) = x</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">供給された引数の型のみを制約する必要がある場合、<code>Vararg{T}</code> は <code>T...</code> と同等に書くことができます。例えば <code>f(x::Int...) = x</code> は <code>f(x::Vararg{Int}) = x</code> の短縮形です。</span></p><h2 id="Note-on-Optional-and-keyword-Arguments" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Note-on-Optional-and-keyword-Arguments">Note on Optional and keyword Arguments</a><a id="Note-on-Optional-and-keyword-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Note-on-Optional-and-keyword-Arguments" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Note-on-Optional-and-keyword-Arguments">オプショナル引数とキーワード引数に関する注意</a><a id="Note-on-Optional-and-keyword-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Note-on-Optional-and-keyword-Arguments" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">As mentioned briefly in <a href="../functions/index.html#man-functions">Functions</a>, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../functions/index.html#man-functions">関数</a>で簡単に触れたように、オプショナル引数は複数のメソッド定義の構文として実装されています。例えば、この定義は：</span></p><pre><code class="language-julia hljs">f(a=1,b=2) = a+2b</code></pre><p data-translated="true"><span class="original-text">translates to the following three methods:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次の3つのメソッドに変換されます：</span></p><pre><code class="language-julia hljs">f(a,b) = a+2b
f(a) = f(a,2)
f() = f(1,2)</code></pre><p data-translated="true"><span class="original-text">This means that calling <code>f()</code> is equivalent to calling <code>f(1,2)</code>. In this case the result is <code>5</code>, because <code>f(1,2)</code> invokes the first method of <code>f</code> above. However, this need not always be the case. If you define a fourth method that is more specialized for integers:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、<code>f()</code> を呼び出すことが <code>f(1,2)</code> を呼び出すことと同等であることを意味します。この場合、結果は <code>5</code> です。なぜなら、<code>f(1,2)</code> は上記の <code>f</code> の最初のメソッドを呼び出すからです。しかし、これは常にそうである必要はありません。整数に特化した4番目のメソッドを定義すると：</span></p><pre><code class="language-julia hljs">f(a::Int,b::Int) = a-2b</code></pre><p data-translated="true"><span class="original-text">then the result of both <code>f()</code> and <code>f(1,2)</code> is <code>-3</code>. In other words, optional arguments are tied to a function, not to any specific method of that function. It depends on the types of the optional arguments which method is invoked. When optional arguments are defined in terms of a global variable, the type of the optional argument may even change at run-time.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">その場合、<code>f()</code> と <code>f(1,2)</code> の両方の結果は <code>-3</code> になります。言い換えれば、オプショナル引数は関数に結びついており、その関数の特定のメソッドには結びついていません。どのメソッドが呼び出されるかは、オプショナル引数の型によって決まります。オプショナル引数がグローバル変数に基づいて定義されている場合、オプショナル引数の型は実行時に変更されることさえあります。</span></p><p data-translated="true"><span class="original-text">Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not participate in method dispatch. Methods are dispatched based only on positional arguments, with keyword arguments processed after the matching method is identified.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キーワード引数は、通常の位置引数とはかなり異なる動作をします。特に、メソッドディスパッチには参加しません。メソッドは位置引数のみに基づいてディスパッチされ、キーワード引数は一致するメソッドが特定された後に処理されます。</span></p><h2 id="Function-like-objects" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Function-like-objects">Function-like objects</a><a id="Function-like-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Function-like-objects" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Function-like-objects">関数のようなオブジェクト</a><a id="Function-like-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Function-like-objects" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Methods are associated with types, so it is possible to make any arbitrary Julia object "callable" by adding methods to its type. (Such "callable" objects are sometimes called "functors.")</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メソッドは型に関連付けられているため、型にメソッドを追加することで任意のJuliaオブジェクトを「呼び出し可能」にすることができます。（このような「呼び出し可能」なオブジェクトは時々「ファンクタ」と呼ばれます。）</span></p><p data-translated="true"><span class="original-text">For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function evaluating the polynomial:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、ポリノミアルの係数を格納する型を定義できますが、ポリノミアルを評価する関数のように振る舞います：</span></p><pre><code class="language-julia-repl hljs">julia&gt; struct Polynomial{R}
           coeffs::Vector{R}
       end

julia&gt; function (p::Polynomial)(x)
           v = p.coeffs[end]
           for i = (length(p.coeffs)-1):-1:1
               v = v*x + p.coeffs[i]
           end
           return v
       end

julia&gt; (p::Polynomial)() = p(5)</code></pre><p data-translated="true"><span class="original-text">Notice that the function is specified by type instead of by name. As with normal functions there is a terse syntax form. In the function body, <code>p</code> will refer to the object that was called. A <code>Polynomial</code> can be used as follows:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数は名前ではなく型によって指定されることに注意してください。通常の関数と同様に、簡潔な構文形式があります。関数の本体内では、<code>p</code>は呼び出されたオブジェクトを参照します。<code>Polynomial</code>は次のように使用できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])

julia&gt; p(3)
931

julia&gt; p()
2551</code></pre><p data-translated="true"><span class="original-text">This mechanism is also the key to how type constructors and closures (inner functions that refer to their surrounding environment) work in Julia.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このメカニズムは、型コンストラクタやクロージャ（周囲の環境を参照する内部関数）がJuliaでどのように機能するかの鍵でもあります。</span></p><h2 id="Empty-generic-functions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Empty-generic-functions">Empty generic functions</a><a id="Empty-generic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Empty-generic-functions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Empty-generic-functions">空のジェネリック関数</a><a id="Empty-generic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Empty-generic-functions" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Occasionally it is useful to introduce a generic function without yet adding methods. This can be used to separate interface definitions from implementations. It might also be done for the purpose of documentation or code readability. The syntax for this is an empty <code>function</code> block without a tuple of arguments:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">時折、メソッドを追加する前にジェネリック関数を導入することが有用です。これはインターフェース定義と実装を分離するために使用できます。また、ドキュメントやコードの可読性のために行われることもあります。これに対する構文は、引数のタプルなしの空の<code>function</code>ブロックです：</span></p><pre><code class="language-julia hljs">function emptyfunc end</code></pre><h2 id="man-method-design-ambiguities" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-method-design-ambiguities">Method design and the avoidance of ambiguities</a><a id="man-method-design-ambiguities-1"></a><a class="docs-heading-anchor-permalink" href="#man-method-design-ambiguities" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-method-design-ambiguities">メソッド設計と曖昧さの回避</a><a id="man-method-design-ambiguities-1"></a><a class="docs-heading-anchor-permalink" href="#man-method-design-ambiguities" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges. In particular, in more complex method hierarchies it is not uncommon for <a href="#man-ambiguities">ambiguities</a> to arise.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaのメソッドの多態性はその最も強力な特徴の一つですが、この力を利用することは設計上の課題を引き起こすことがあります。特に、より複雑なメソッド階層では、<a href="#man-ambiguities">曖昧さ</a>が発生することは珍しくありません。</span></p><p data-translated="true"><span class="original-text">Above, it was pointed out that one can resolve ambiguities like</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記では、曖昧さを解決する方法が指摘されました。</span></p><pre><code class="language-julia hljs">f(x, y::Int) = 1
f(x::Int, y) = 2</code></pre><p data-translated="true"><span class="original-text">by defining a method</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メソッドを定義することによって</span></p><pre><code class="language-julia hljs">f(x::Int, y::Int) = 3</code></pre><p data-translated="true"><span class="original-text">This is often the right strategy; however, there are circumstances where following this advice mindlessly can be counterproductive. In particular, the more methods a generic function has, the more possibilities there are for ambiguities. When your method hierarchies get more complicated than this simple example, it can be worth your while to think carefully about alternative strategies.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これはしばしば正しい戦略ですが、このアドバイスに盲目的に従うことが逆効果になる状況もあります。特に、ジェネリック関数が持つメソッドの数が多くなるほど、曖昧さの可能性が増します。この単純な例よりもメソッド階層が複雑になると、代替戦略について慎重に考える価値があります。</span></p><p data-translated="true"><span class="original-text">Below we discuss particular challenges and some alternative ways to resolve such issues.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">以下では、特定の課題とそれらの問題を解決するためのいくつかの代替方法について議論します。</span></p><h3 id="Tuple-and-NTuple-arguments" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Tuple-and-NTuple-arguments">Tuple and NTuple arguments</a><a id="Tuple-and-NTuple-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Tuple-and-NTuple-arguments" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Tuple-and-NTuple-arguments">タプルとNTuple引数</a><a id="Tuple-and-NTuple-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Tuple-and-NTuple-arguments" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text"><code>Tuple</code> (and <code>NTuple</code>) arguments present special challenges. For example,</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Tuple</code>（および <code>NTuple</code>）引数は特別な課題を提示します。例えば、</span></p><pre><code class="language-julia hljs">f(x::NTuple{N,Int}) where {N} = 1
f(x::NTuple{N,Float64}) where {N} = 2</code></pre><p data-translated="true"><span class="original-text">are ambiguous because of the possibility that <code>N == 0</code>: there are no elements to determine whether the <code>Int</code> or <code>Float64</code> variant should be called. To resolve the ambiguity, one approach is define a method for the empty tuple:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">は <code>N == 0</code> の可能性があるため曖昧です：どの <code>Int</code> または <code>Float64</code> バリアントを呼び出すべきかを決定する要素がありません。曖昧さを解決するための一つのアプローチは、空のタプルのためにメソッドを定義することです：</span></p><pre><code class="language-julia hljs">f(x::Tuple{}) = 3</code></pre><p data-translated="true"><span class="original-text">Alternatively, for all methods but one you can insist that there is at least one element in the tuple:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">あるいは、1つを除くすべてのメソッドに対して、タプルに少なくとも1つの要素があることを要求することができます：</span></p><pre><code class="language-julia hljs">f(x::NTuple{N,Int}) where {N} = 1           # this is the fallback
f(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64</code></pre><h3 id="man-methods-orthogonalize" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-methods-orthogonalize">Orthogonalize your design</a><a id="man-methods-orthogonalize-1"></a><a class="docs-heading-anchor-permalink" href="#man-methods-orthogonalize" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-methods-orthogonalize">設計を直交化する</a><a id="man-methods-orthogonalize-1"></a><a class="docs-heading-anchor-permalink" href="#man-methods-orthogonalize" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">When you might be tempted to dispatch on two or more arguments, consider whether a "wrapper" function might make for a simpler design. For example, instead of writing multiple variants:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">2つ以上の引数でディスパッチすることに誘惑されるかもしれませんが、"ラッパー"関数がよりシンプルな設計をもたらすかどうかを考えてみてください。例えば、複数のバリアントを書く代わりに：</span></p><pre><code class="language-julia hljs">f(x::A, y::A) = ...
f(x::A, y::B) = ...
f(x::B, y::A) = ...
f(x::B, y::B) = ...</code></pre><p data-translated="true"><span class="original-text">you might consider defining</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">定義を考慮するかもしれません</span></p><pre><code class="language-julia hljs">f(x::A, y::A) = ...
f(x, y) = f(g(x), g(y))</code></pre><p data-translated="true"><span class="original-text">where <code>g</code> converts the argument to type <code>A</code>. This is a very specific example of the more general principle of <a href="https://en.wikipedia.org/wiki/Orthogonality_(programming)">orthogonal design</a>, in which separate concepts are assigned to separate methods. Here, <code>g</code> will most likely need a fallback definition</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで <code>g</code> は引数を型 <code>A</code> に変換します。これは、別々の概念が別々のメソッドに割り当てられるという、より一般的な原則である <a href="https://en.wikipedia.org/wiki/Orthogonality_(programming)">直交設計</a> の非常に特定の例です。ここで、<code>g</code> はおそらくフォールバック定義が必要になります。</span></p><pre><code class="language-julia hljs">g(x::A) = x</code></pre><p data-translated="true"><span class="original-text">A related strategy exploits <code>promote</code> to bring <code>x</code> and <code>y</code> to a common type:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関連する戦略は、<code>promote</code> を利用して <code>x</code> と <code>y</code> を共通の型に持ってくることです：</span></p><pre><code class="language-julia hljs">f(x::T, y::T) where {T} = ...
f(x, y) = f(promote(x, y)...)</code></pre><p data-translated="true"><span class="original-text">One risk with this design is the possibility that if there is no suitable promotion method converting <code>x</code> and <code>y</code> to the same type, the second method will recurse on itself infinitely and trigger a stack overflow.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この設計のリスクの一つは、<code>x</code> と <code>y</code> を同じ型に変換する適切なプロモーションメソッドがない場合、2番目のメソッドが無限に自己再帰し、スタックオーバーフローを引き起こす可能性があることです。</span></p><h3 id="Dispatch-on-one-argument-at-a-time" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Dispatch-on-one-argument-at-a-time">Dispatch on one argument at a time</a><a id="Dispatch-on-one-argument-at-a-time-1"></a><a class="docs-heading-anchor-permalink" href="#Dispatch-on-one-argument-at-a-time" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Dispatch-on-one-argument-at-a-time">1つの引数ごとにディスパッチ</a><a id="Dispatch-on-one-argument-at-a-time-1"></a><a class="docs-heading-anchor-permalink" href="#Dispatch-on-one-argument-at-a-time" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all possible variants, then consider introducing a "name cascade" where (for example) you dispatch on the first argument and then call an internal method:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複数の引数でディスパッチする必要があり、フォールバックが多すぎてすべての可能なバリアントを定義するのが実用的でない場合は、最初の引数でディスパッチし、その後内部メソッドを呼び出す「名前カスケード」を導入することを検討してください：</span></p><pre><code class="language-julia hljs">f(x::A, y) = _fA(x, y)
f(x::B, y) = _fB(x, y)</code></pre><p data-translated="true"><span class="original-text">Then the internal methods <code>_fA</code> and <code>_fB</code> can dispatch on <code>y</code> without concern about ambiguities with each other with respect to <code>x</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">その後、内部メソッド <code>_fA</code> と <code>_fB</code> は、<code>x</code> に関して互いにあいまいさを気にせずに <code>y</code> にディスパッチできます。</span></p><p data-translated="true"><span class="original-text">Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users to further customize the behavior of <code>f</code> by defining further specializations of your exported function <code>f</code>. Instead, they have to define specializations for your internal methods <code>_fA</code> and <code>_fB</code>, and this blurs the lines between exported and internal methods.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この戦略には少なくとも1つの大きな欠点があることに注意してください：多くの場合、ユーザーがエクスポートされた関数 <code>f</code> のさらなる特殊化を定義することで <code>f</code> の動作をさらにカスタマイズすることはできません。代わりに、彼らは内部メソッド <code>_fA</code> と <code>_fB</code> の特殊化を定義しなければならず、これによりエクスポートされたメソッドと内部メソッドの境界が曖昧になります。</span></p><h3 id="Abstract-containers-and-element-types" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Abstract-containers-and-element-types">Abstract containers and element types</a><a id="Abstract-containers-and-element-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-containers-and-element-types" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Abstract-containers-and-element-types">抽象コンテナと要素型</a><a id="Abstract-containers-and-element-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-containers-and-element-types" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">Where possible, try to avoid defining methods that dispatch on specific element types of abstract containers. For example,</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">可能な限り、抽象コンテナの特定の要素型にディスパッチするメソッドの定義を避けるようにしてください。例えば、</span></p><pre><code class="language-julia hljs">-(A::AbstractArray{T}, b::Date) where {T&lt;:Date}</code></pre><p data-translated="true"><span class="original-text">generates ambiguities for anyone who defines a method</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">メソッドを定義する誰にとってもあいまいさを生じさせます。</span></p><pre><code class="language-julia hljs">-(A::MyArrayType{T}, b::T) where {T}</code></pre><p data-translated="true"><span class="original-text">The best approach is to avoid defining <em>either</em> of these methods: instead, rely on a generic method <code>-(A::AbstractArray, b)</code> and make sure this method is implemented with generic calls (like <code>similar</code> and <code>-</code>) that do the right thing for each container type and element type <em>separately</em>. This is just a more complex variant of the advice to <a href="#man-methods-orthogonalize">orthogonalize</a> your methods.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最良のアプローチは、これらのメソッドの<em>いずれか</em>を定義しないことです。代わりに、一般的なメソッド<code>-(A::AbstractArray, b)</code>に依存し、このメソッドが各コンテナタイプおよび要素タイプに対して<em>個別に</em>正しい動作をするように、<code>similar</code>や<code>-</code>のような一般的な呼び出しで実装されていることを確認してください。これは、メソッドを<a href="#man-methods-orthogonalize">直交化</a>するというアドバイスのより複雑なバリアントに過ぎません。</span></p><p data-translated="true"><span class="original-text">When this approach is not possible, it may be worth starting a discussion with other developers about resolving the ambiguity; just because one method was defined first does not necessarily mean that it can't be modified or eliminated. As a last resort, one developer can define the "band-aid" method</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このアプローチが不可能な場合、他の開発者と曖昧さを解決するための議論を始める価値があるかもしれません。最初に定義されたメソッドがあるからといって、それが修正または削除できないわけではありません。最後の手段として、ある開発者が曖昧さを力任せに解決する「バンドエイド」メソッドを定義することができます。</span></p><pre><code class="language-julia hljs">-(A::MyArrayType{T}, b::Date) where {T&lt;:Date} = ...</code></pre><p data-translated="true"><span class="original-text">that resolves the ambiguity by brute force.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">それは、力任せに曖昧さを解決します。</span></p><h3 id="Complex-method-&quot;cascades&quot;-with-default-arguments" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Complex-method-&quot;cascades&quot;-with-default-arguments">Complex method "cascades" with default arguments</a><a id="Complex-method-&quot;cascades&quot;-with-default-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-method-&quot;cascades&quot;-with-default-arguments" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Complex-method-&quot;cascades&quot;-with-default-arguments">デフォルト引数を持つ複雑なメソッド「カスケード」</a><a id="Complex-method-&quot;cascades&quot;-with-default-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-method-&quot;cascades&quot;-with-default-arguments" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">If you are defining a method "cascade" that supplies defaults, be careful about dropping any arguments that correspond to potential defaults. For example, suppose you're writing a digital filtering algorithm and you have a method that handles the edges of the signal by applying padding:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デフォルトを提供する「カスケード」メソッドを定義する場合、潜在的なデフォルトに対応する引数を落とさないように注意してください。例えば、デジタルフィルタリングアルゴリズムを書いていて、信号のエッジをパディングを適用して処理するメソッドがあるとします：</span></p><pre><code class="language-julia hljs">function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel)  # now perform the "real" computation
end</code></pre><p data-translated="true"><span class="original-text">This will run afoul of a method that supplies default padding:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは、デフォルトのパディングを提供するメソッドと衝突します：</span></p><pre><code class="language-julia hljs">myfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by default</code></pre><p data-translated="true"><span class="original-text">Together, these two methods generate an infinite recursion with <code>A</code> constantly growing bigger.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これら2つのメソッドは、<code>A</code>が常に大きくなり続ける無限再帰を生成します。</span></p><p data-translated="true"><span class="original-text">The better design would be to define your call hierarchy like this:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より良い設計は、呼び出し階層を次のように定義することです：</span></p><pre><code class="language-julia hljs">struct NoPad end  # indicate that no padding is desired, or that it's already applied

myfilter(A, kernel) = myfilter(A, kernel, Replicate())  # default boundary conditions

function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel, NoPad())  # indicate the new boundary conditions
end

# other padding methods go here

function myfilter(A, kernel, ::NoPad)
    # Here's the "real" implementation of the core computation
end</code></pre><p data-translated="true"><span class="original-text"><code>NoPad</code> is supplied in the same argument position as any other kind of padding, so it keeps the dispatch hierarchy well organized and with reduced likelihood of ambiguities. Moreover, it extends the "public" <code>myfilter</code> interface: a user who wants to control the padding explicitly can call the <code>NoPad</code> variant directly.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>NoPad</code>は、他の種類のパディングと同じ引数の位置で提供されるため、ディスパッチ階層を適切に整理し、曖昧さの可能性を減少させます。さらに、これは「公開」<code>myfilter</code>インターフェースを拡張します。パディングを明示的に制御したいユーザーは、<code>NoPad</code>バリアントを直接呼び出すことができます。</span></p><h2 id="Defining-methods-in-local-scope" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Defining-methods-in-local-scope">Defining methods in local scope</a><a id="Defining-methods-in-local-scope-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-methods-in-local-scope" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Defining-methods-in-local-scope">ローカルスコープでのメソッドの定義</a><a id="Defining-methods-in-local-scope-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-methods-in-local-scope" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">You can define methods within a <a href="../variables-and-scoping/index.html#scope-of-variables">local scope</a>, for example</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ローカルスコープ内にメソッドを定義することができます。例えば、<a href="../variables-and-scoping/index.html#scope-of-variables">local scope</a>。</span></p><pre><code class="language-julia-repl hljs">julia&gt; function f(x)
           g(y::Int) = y + x
           g(y) = y - x
           g
       end
f (generic function with 1 method)

julia&gt; h = f(3);

julia&gt; h(4)
7

julia&gt; h(4.0)
1.0</code></pre><p data-translated="true"><span class="original-text">However, you should <em>not</em> define local methods conditionally or subject to control flow, as in</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、条件付きまたは制御フローに従ってローカルメソッドを定義することは<em>避けるべき</em>です。例えば、</span></p><pre><code class="language-julia hljs">function f2(inc)
    if inc
        g(x) = x + 1
    else
        g(x) = x - 1
    end
end

function f3()
    function g end
    return g
    g() = 0
end</code></pre><p data-translated="true"><span class="original-text">as it is not clear what function will end up getting defined. In the future, it might be an error to define local methods in this manner.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">どの関数が最終的に定義されるかが不明だからです。将来的には、このようにローカルメソッドを定義することはエラーになる可能性があります。</span></p><p data-translated="true"><span class="original-text">For cases like this use anonymous functions instead:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このような場合は、代わりに無名関数を使用してください：</span></p><pre><code class="language-julia hljs">function f2(inc)
    g = if inc
        x -&gt; x + 1
    else
        x -&gt; x - 1
    end
end</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1" data-translated="true"><span class="original-text"><a class="tag is-link" href="#citeref-1">1</a>In C++ or Java, for example, in a method call like <code>obj.meth(arg1,arg2)</code>, the object obj "receives" the method call and is implicitly passed to the method via the <code>this</code> keyword, rather than as an explicit method argument. When the current <code>this</code> object is the receiver of a method call, it can be omitted altogether, writing just <code>meth(arg1,arg2)</code>, with <code>this</code> implied as the receiving object.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tag is-link" href="#citeref-1">1</a>C++やJavaの場合、例えば、<code>obj.meth(arg1,arg2)</code>のようなメソッド呼び出しでは、オブジェクトobjがメソッド呼び出しを「受け取り」、<code>this</code>キーワードを介してメソッドに暗黙的に渡されます。現在の<code>this</code>オブジェクトがメソッド呼び出しの受信者である場合、<code>this</code>を省略して<code>meth(arg1,arg2)</code>と書くことができ、<code>this</code>は受信オブジェクトとして暗黙的に示されます。</span></li><li class="footnote" id="footnote-Clarke61" data-translated="true"><span class="original-text"><a class="tag is-link" href="#citeref-Clarke61">Clarke61</a>Arthur C. Clarke, <em>Profiles of the Future</em> (1961): Clarke's Third Law.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tag is-link" href="#citeref-Clarke61">Clarke61</a>アーサー・C・クラーク、<em>Profiles of the Future</em> (1961)：クラークの第三法則。</span></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/index.html">« Types</a><a class="docs-footer-nextpage" href="../constructors/index.html">Constructors »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>