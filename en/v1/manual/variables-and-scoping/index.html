<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Scope of Variables · The Julia Language</title><meta name="title" content="Scope of Variables · The Julia Language"><meta property="og:title" content="Scope of Variables · The Julia Language"><meta property="twitter:title" content="Scope of Variables · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/variables-and-scoping/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/variables-and-scoping/"><link rel="canonical" href="index.html"><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li class="is-active"><a class="tocitem" href="">Scope of Variables</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Global-Scope"><span>Global Scope</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Global-Scope"><span>グローバルスコープ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#local-scope"><span>Local Scope</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#local-scope"><span>ローカルスコープ</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Constants"><span>Constants</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Constants"><span>定数</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-typed-globals"><span>Typed Globals</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-typed-globals"><span>型付きグローバル</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">変数のスコープ</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">変数のスコープ</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/variables-and-scoping.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="scope-of-variables" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#scope-of-variables">Scope of Variables</a><a id="scope-of-variables-1"></a><a class="docs-heading-anchor-permalink" href="#scope-of-variables" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#scope-of-variables">変数のスコープ</a><a id="scope-of-variables-1"></a><a class="docs-heading-anchor-permalink" href="#scope-of-variables" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">The <em>scope</em> of a variable is the region of code within which a variable is accessible. Variable scoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have arguments called <code>x</code> without the two <code>x</code>'s referring to the same thing. Similarly, there are many other cases where different blocks of code can use the same name without referring to the same thing. The rules for when the same variable name does or doesn't refer to the same thing are called scope rules; this section spells them out in detail.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">変数の<em>スコープ</em>は、変数にアクセスできるコードの領域です。変数のスコープは、変数名の衝突を避けるのに役立ちます。この概念は直感的です：2つの関数は、両方とも<code>x</code>という引数を持つことができますが、2つの<code>x</code>は同じものを指すわけではありません。同様に、異なるコードブロックが同じ名前を使用しても、同じものを指さない場合が多くあります。同じ変数名が同じものを指すかどうかのルールはスコープルールと呼ばれ、このセクションではそれを詳細に説明します。</span></p><p data-translated="true"><span class="original-text">Certain constructs in the language introduce <em>scope blocks</em>, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, <em>global scope</em> and <em>local scope</em>. The latter can be nested. There is also a distinction in Julia between constructs which introduce a "hard scope" and those which only introduce a "soft scope", which affects whether <a href="https://en.wikipedia.org/wiki/Variable_shadowing">shadowing</a> a global variable by the same name is allowed or not.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">言語の特定の構文は<em>スコープブロック</em>を導入し、これは一連の変数のスコープとなるコードの領域です。変数のスコープは任意のソース行のセットではなく、常にこれらのブロックのいずれかと一致します。Juliaには主に2種類のスコープ、<em>グローバルスコープ</em>と<em>ローカルスコープ</em>があります。後者はネスト可能です。また、Juliaには「ハードスコープ」を導入する構文と「ソフトスコープ」だけを導入する構文の区別があり、これが同名のグローバル変数を<code>shadowing</code>することが許可されるかどうかに影響します。</span></p><div class="admonition is-info" id="Summary-450dfcc4f0e95335"><header class="admonition-header">Summary<a class="admonition-anchor" href="#Summary-450dfcc4f0e95335" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Variables defined in global scope may be undefined in inner local scopes, depending on where the code is run, in order to balance safety and convenience. The hard and soft local scoping rules define the interplay between global and local variables.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバルスコープで定義された変数は、コードが実行される場所によっては内部のローカルスコープでは未定義である可能性があります。これは安全性と利便性のバランスを取るためです。ハードおよびソフトローカルスコープルールは、グローバル変数とローカル変数の相互作用を定義します。</span></p><p data-translated="true"><span class="original-text">However, variables defined only in local scope behave consistently in all contexts. If the variable is already defined, it will be reused. If the variable is not defined, it will be made available to the current and inner scopes (but not outer scopes).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、ローカルスコープでのみ定義された変数は、すべてのコンテキストで一貫して動作します。変数がすでに定義されている場合は、それが再利用されます。変数が定義されていない場合は、現在のスコープおよび内部スコープで利用可能になります（ただし外部スコープではありません）。</span></p></div></div><div class="admonition is-success" id="A-Common-Confusion-2479cb3548c466db"><header class="admonition-header">A Common Confusion<a class="admonition-anchor" href="#A-Common-Confusion-2479cb3548c466db" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">If you run into an unexpectedly undefined variable,</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">予期しない未定義の変数に遭遇した場合、</span></p><pre><code class="language-julia hljs"># Print the numbers 1 through 5
i = 0
while i &lt; 5
    i += 1     # ERROR: UndefVarError: `i` not defined
    println(i)
end</code></pre><p data-translated="true"><span class="original-text">a simple fix is to change all global variable definitions into local definitions by wrapping the code in a <code>let</code> block or <code>function</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">簡単な修正は、コードを<code>let</code>ブロックまたは<code>function</code>でラップして、すべてのグローバル変数の定義をローカル定義に変更することです。</span></p><pre><code class="language-julia hljs"># Print the numbers 1 through 5
let i = 0
    while i &lt; 5
        i += 1     # Now outer `i` is defined in the inner scope of the while loop
        println(i)
    end
end</code></pre><p data-translated="true"><span class="original-text">This is a common source of confusion when writing procedural scripts, but it becomes a non-issue if code is moved inside functions or executed interactively in the REPL.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは手続き型スクリプトを書く際の一般的な混乱の原因ですが、コードが関数内に移動されるか、REPLで対話的に実行されると、問題ではなくなります。</span></p><p data-translated="true"><span class="original-text">See also the <a href="../../base/base/index.html#global"><code>global</code></a> and <a href="../../base/base/index.html#local"><code>local</code></a> keywords to explicitly achieve any desired scoping behavior.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#global"><code>global</code></a>および<a href="../../base/base/index.html#local"><code>local</code></a>キーワードを参照して、望ましいスコープ動作を明示的に達成してください。</span></p></div></div><h3 id="man-scope-table" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-scope-table">Scope Constructs</a><a id="man-scope-table-1"></a><a class="docs-heading-anchor-permalink" href="#man-scope-table" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-scope-table">スコープ構造</a><a id="man-scope-table-1"></a><a class="docs-heading-anchor-permalink" href="#man-scope-table" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">The constructs introducing scope blocks are:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">スコープブロックを導入する構造は次のとおりです：</span></p><table><tbody><tr><th style="text-align: left" data-translated="true"><span class="original-text">Construct</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">構造</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Scope Type Introduced</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">導入されたスコープタイプ</span></th><th style="text-align: left" data-translated="true"><span class="original-text">Scope Types Able to Contain Construct</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">構造を含むことができるスコープタイプ</span></th></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/base/index.html#module"><code>module</code></a>, <a href="../../base/base/index.html#baremodule"><code>baremodule</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#module"><code>module</code></a>, <a href="../../base/base/index.html#baremodule"><code>baremodule</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">global</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバル</span></td><td style="text-align: left" data-translated="true"><span class="original-text">global</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバル</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/base/index.html#struct"><code>struct</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#struct"><code>struct</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">local (hard)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ローカル（ハード）</span></td><td style="text-align: left" data-translated="true"><span class="original-text">global</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバル</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/base/index.html#macro"><code>macro</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#macro"><code>macro</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">local (hard)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ローカル（ハード）</span></td><td style="text-align: left" data-translated="true"><span class="original-text">global</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバル</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/base/index.html#for"><code>for</code></a>, <a href="../../base/base/index.html#while"><code>while</code></a>, <a href="../../base/base/index.html#try"><code>try</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#for"><code>for</code></a>, <a href="../../base/base/index.html#while"><code>while</code></a>, <a href="../../base/base/index.html#try"><code>try</code></a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">local (soft)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ローカル（ソフト）</span></td><td style="text-align: left" data-translated="true"><span class="original-text">global, local</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバル、ローカル</span></td></tr><tr><td style="text-align: left" data-translated="true"><span class="original-text"><a href="../../base/base/index.html#function"><code>function</code></a>, <a href="../../base/base/index.html#do"><code>do</code></a>, <a href="../../base/base/index.html#let"><code>let</code></a>, <a href="../arrays/index.html#man-comprehensions">comprehensions</a>, <a href="../arrays/index.html#man-generators">generators</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#function"><code>function</code></a>、<a href="../../base/base/index.html#do"><code>do</code></a>、<a href="../../base/base/index.html#let"><code>let</code></a>、<a href="../arrays/index.html#man-comprehensions">comprehensions</a>、<a href="../arrays/index.html#man-generators">generators</a></span></td><td style="text-align: left" data-translated="true"><span class="original-text">local (hard)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ローカル（ハード）</span></td><td style="text-align: left" data-translated="true"><span class="original-text">global, local</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバル、ローカル</span></td></tr></tbody></table><p data-translated="true"><span class="original-text">Notably missing from this table are <a href="../control-flow/index.html#man-compound-expressions">begin blocks</a> and <a href="../control-flow/index.html#man-conditional-evaluation">if blocks</a> which do <em>not</em> introduce new scopes. The three types of scopes follow somewhat different rules which will be explained below.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この表に欠けているのは、<a href="../control-flow/index.html#man-compound-expressions">beginブロック</a>と<a href="../control-flow/index.html#man-conditional-evaluation">ifブロック</a>で、これらは新しいスコープを導入しません。3つのタイプのスコープは、以下で説明するように、やや異なるルールに従います。</span></p><p data-translated="true"><span class="original-text">Julia uses <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope#Lexical_scope_vs._dynamic_scope">lexical scoping</a>, meaning that a function's scope does not inherit from its caller's scope, but from the scope in which the function was defined. For example, in the following code the <code>x</code> inside <code>foo</code> refers to the <code>x</code> in the global scope of its module <code>Bar</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは<a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope#Lexical_scope_vs._dynamic_scope">レキシカルスコープ</a>を使用しており、これは関数のスコープが呼び出し元のスコープからではなく、関数が定義されたスコープから継承されることを意味します。例えば、以下のコードでは、<code>foo</code>内の<code>x</code>は、そのモジュール<code>Bar</code>のグローバルスコープの<code>x</code>を指します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; module Bar
           x = 1
           foo() = x
       end;</code></pre><p data-translated="true"><span class="original-text">and not a <code>x</code> in the scope where <code>foo</code> is used:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そして、<code>foo</code>が使用されるスコープ内の<code>x</code>ではありません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; import .Bar

julia&gt; x = -1;

julia&gt; Bar.foo()
1</code></pre><p data-translated="true"><span class="original-text">Thus <em>lexical scope</em> means that what a variable in a particular piece of code refers to can be deduced from the code in which it appears alone and does not depend on how the program executes. A scope nested inside another scope can "see" variables in all the outer scopes in which it is contained. Outer scopes, on the other hand, cannot see variables in inner scopes.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、<em>レキシカルスコープ</em>とは、特定のコードの中の変数が何を指すかを、そのコードが単独で現れる場所から推測でき、プログラムの実行方法に依存しないことを意味します。あるスコープが別のスコープの中にネストされている場合、そのスコープは含まれているすべての外側のスコープの変数を「見る」ことができます。一方、外側のスコープは内側のスコープの変数を見ることができません。</span></p><h2 id="Global-Scope" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Global-Scope">Global Scope</a><a id="Global-Scope-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Scope" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Global-Scope">グローバルスコープ</a><a id="Global-Scope-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Scope" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Each module introduces a new global scope, separate from the global scope of all other modules—there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the <a href="../modules/index.html#modules">using or import</a> statements or through qualified access using the dot-notation, i.e. each module is a so-called <em>namespace</em> as well as a first-class data structure associating names with values.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">各モジュールは、新しいグローバルスコープを導入します。他のすべてのモジュールのグローバルスコープとは別のものであり、包括的なグローバルスコープは存在しません。モジュールは、<a href="../modules/index.html#modules">using または import</a> ステートメントを通じて、またはドット表記を使用した修飾アクセスを通じて、他のモジュールの変数を自分のスコープに導入できます。つまり、各モジュールは、名前と値を関連付けるファーストクラスのデータ構造であるいわゆる <em>名前空間</em> です。</span></p><p data-translated="true"><span class="original-text">If a top-level expression contains a variable declaration with keyword <code>local</code>, then that variable is not accessible outside that expression. The variable inside the expression does not affect global variables of the same name. An example is to declare <code>local x</code> in a <code>begin</code> or <code>if</code> block at the top-level:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">トップレベルの式に <code>local</code> キーワードを持つ変数宣言が含まれている場合、その変数はその式の外部からはアクセスできません。式内の変数は、同じ名前のグローバル変数には影響を与えません。例として、トップレベルで <code>begin</code> または <code>if</code> ブロック内に <code>local x</code> を宣言することが挙げられます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = 1
       begin
           local x = 0
           @show x
       end
       @show x;
x = 0
x = 1</code></pre><p data-translated="true"><span class="original-text">Note that the interactive prompt (aka REPL) is in the global scope of the module <code>Main</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">インタラクティブプロンプト（別名 REPL）は、モジュール <code>Main</code> のグローバルスコープにあることに注意してください。</span></p><h2 id="local-scope" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#local-scope">Local Scope</a><a id="local-scope-1"></a><a class="docs-heading-anchor-permalink" href="#local-scope" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#local-scope">ローカルスコープ</a><a id="local-scope-1"></a><a class="docs-heading-anchor-permalink" href="#local-scope" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">A new local scope is introduced by most code blocks (see above <a href="#man-scope-table">table</a> for a complete list). If such a block is syntactically nested inside of another local scope, the scope it creates is nested inside of all the local scopes that it appears within, which are all ultimately nested inside of the global scope of the module in which the code is evaluated. Variables in outer scopes are visible from any scope they contain — meaning that they can be read and written in inner scopes — unless there is a local variable with the same name that "shadows" the outer variable of the same name. This is true even if the outer local is declared after (in the sense of textually below) an inner block. When we say that a variable "exists" in a given scope, this means that a variable by that name exists in any of the scopes that the current scope is nested inside of, including the current one.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ほとんどのコードブロックによって新しいローカルスコープが導入されます（完全なリストについては上記の<a href="#man-scope-table">テーブル</a>を参照してください）。そのようなブロックが別のローカルスコープの内部に構文的にネストされている場合、作成されるスコープは、その中に現れるすべてのローカルスコープの内部にネストされ、最終的にはコードが評価されるモジュールのグローバルスコープの内部にネストされます。外側のスコープの変数は、それらを含む任意のスコープから可視であり、つまり内部スコープで読み書きできます。ただし、同じ名前のローカル変数が外側の変数を「シャドウ」している場合は除きます。これは、外側のローカルが内部ブロックの後（テキスト的に下に）に宣言されている場合でも当てはまります。変数が特定のスコープに「存在する」と言うとき、それはその名前の変数が現在のスコープがネストされている任意のスコープに存在することを意味します。</span></p><p data-translated="true"><span class="original-text">Some programming languages require explicitly declaring new variables before using them. Explicit declaration works in Julia too: in any local scope, writing <code>local x</code> declares a new local variable in that scope, regardless of whether there is already a variable named <code>x</code> in an outer scope or not. Declaring each new variable like this is somewhat verbose and tedious, however, so Julia, like many other languages, considers assignment to a variable name that doesn't already exist to implicitly declare that variable. If the current scope is global, the new variable is global; if the current scope is local, the new variable is local to the innermost local scope and will be visible inside of that scope but not outside of it. If you assign to an existing local, it <em>always</em> updates that existing local: you can only shadow a local by explicitly declaring a new local in a nested scope with the <code>local</code> keyword. In particular, this applies to variables assigned in inner functions, which may surprise users coming from Python where assignment in an inner function creates a new local unless the variable is explicitly declared to be non-local.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">いくつかのプログラミング言語では、新しい変数を使用する前に明示的に宣言する必要があります。明示的な宣言はJuliaでも機能します：任意のローカルスコープで <code>local x</code> と書くことで、そのスコープ内に新しいローカル変数が宣言されます。外側のスコープにすでに <code>x</code> という名前の変数が存在するかどうかに関係なくです。ただし、このように各新しい変数を宣言するのはやや冗長で面倒です。そのため、Juliaは他の多くの言語と同様に、すでに存在しない変数名への代入を暗黙的にその変数を宣言するものと見なします。現在のスコープがグローバルであれば、新しい変数はグローバルになります。現在のスコープがローカルであれば、新しい変数は最も内側のローカルスコープにローカルであり、そのスコープ内では可視ですが、その外側では可視ではありません。既存のローカルに代入すると、それは<em>常に</em>その既存のローカルを更新します。ローカルをシャドウするには、<code>local</code> キーワードを使用してネストされたスコープで新しいローカルを明示的に宣言する必要があります。特に、これは内部関数で代入された変数に適用されます。これは、Pythonから来たユーザーには驚くべきことかもしれません。なぜなら、内部関数での代入は、変数が明示的に非ローカルとして宣言されていない限り、新しいローカルを作成するからです。</span></p><p data-translated="true"><span class="original-text">Mostly this is pretty intuitive, but as with many things that behave intuitively, the details are more subtle than one might naïvely imagine.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ほとんどの場合、これは非常に直感的ですが、直感的に振る舞う多くのことと同様に、詳細は単純に思えるよりも微妙です。</span></p><p data-translated="true"><span class="original-text">When <code>x = &lt;value&gt;</code> occurs in a local scope, Julia applies the following rules to decide what the expression means based on where the assignment expression occurs and what <code>x</code> already refers to at that location:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>x = &lt;value&gt;</code> がローカルスコープ内で発生する場合、Juliaは代入式が発生する場所とその場所で <code>x</code> がすでに指しているものに基づいて、式の意味を決定するために以下のルールを適用します。</span></p><ol><li data-translated="true"><span class="original-text"><strong>Existing local:</strong> If <code>x</code> is <em>already a local variable</em>, then the existing local <code>x</code> is assigned;</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>既存のローカル:</strong> もし <code>x</code> が <em>すでにローカル変数である</em> なら、既存のローカル <code>x</code> に代入されます。</span></li><li data-translated="true"><span class="original-text"><strong>Hard scope:</strong> If <code>x</code> is <em>not already a local variable</em> and assignment occurs inside of any hard scope construct (i.e. within a <code>let</code> block, function, struct or macro body, comprehension, or generator), a new local named <code>x</code> is created in the scope of the assignment;</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><strong>ハードスコープ:</strong> もし <code>x</code> が <em>まだローカル変数でない</em> なら、かつ代入が任意のハードスコープ構造（すなわち、<code>let</code> ブロック、関数、構造体またはマクロ本体、内包表現、またはジェネレーター）の内部で発生する場合、代入のスコープ内に新しいローカル <code>x</code> が作成されます。</span></li><li><strong>Soft scope:</strong> If <code>x</code> is <em>not already a local variable</em> and all of the scope constructs containing the assignment are soft scopes (loops, <code>try</code>/<code>catch</code> blocks), the behavior depends on whether the global variable <code>x</code> is defined:<ul><li data-translated="true"><span class="original-text">if global <code>x</code> is <em>undefined</em>, a new local named <code>x</code> is created in the scope of the assignment;</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もしグローバルな<code>x</code>が<em>未定義</em>であれば、代入のスコープ内に新しいローカル<code>x</code>が作成されます。</span></li><li>if global <code>x</code> is <em>defined</em>, the assignment is considered ambiguous:<ul><li data-translated="true"><span class="original-text">in <em>non-interactive</em> contexts (files, eval), an ambiguity warning is printed and a new local is created;</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><em>非対話的</em>なコンテキスト（ファイル、eval）では、曖昧さの警告が表示され、新しいローカルが作成されます。</span></li><li data-translated="true"><span class="original-text">in <em>interactive</em> contexts (REPL, notebooks), the global variable <code>x</code> is assigned.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><em>対話的</em>なコンテキスト（REPL、ノートブック）では、グローバル変数<code>x</code>が代入されます。</span></li></ul></li></ul></li></ol><p data-translated="true"><span class="original-text">You may note that in non-interactive contexts the hard and soft scope behaviors are identical except that a warning is printed when an implicitly local variable (i.e. not declared with <code>local x</code>) shadows a global. In interactive contexts, the rules follow a more complex heuristic for the sake of convenience. This is covered in depth in examples that follow.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">非対話的なコンテキストでは、ハードスコープとソフトスコープの動作は同一であることに注意してください。ただし、暗黙的にローカル変数（つまり、<code>local x</code>で宣言されていない）がグローバルを隠す場合には警告が表示されます。対話的なコンテキストでは、便利さのためにより複雑なヒューリスティックに従います。これは、続く例で詳しく説明されます。</span></p><p data-translated="true"><span class="original-text">Now that you know the rules, let's look at some examples. Each example is assumed to be evaluated in a fresh REPL session so that the only globals in each snippet are the ones that are assigned in that block of code.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ルールを理解したところで、いくつかの例を見てみましょう。各例は新しいREPLセッションで評価されると仮定し、そのコードブロック内で代入されたグローバル変数のみが存在します。</span></p><p data-translated="true"><span class="original-text">We'll begin with a nice and clear-cut situation—assignment inside of a hard scope, in this case a function body, when no local variable by that name already exists:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">まずは、ハードスコープ内での代入という明確な状況から始めましょう。この場合、関数の本体内で、同名のローカル変数が既に存在しないときです。</span></p><pre><code class="language-julia-repl hljs">julia&gt; function greet()
           x = "hello" # new local
           println(x)
       end
greet (generic function with 1 method)

julia&gt; greet()
hello

julia&gt; x # global
ERROR: UndefVarError: `x` not defined in `Main`</code></pre><p data-translated="true"><span class="original-text">Inside of the <code>greet</code> function, the assignment <code>x = "hello"</code> causes <code>x</code> to be a new local variable in the function's scope. There are two relevant facts: the assignment occurs in local scope and there is no existing local <code>x</code> variable. Since <code>x</code> is local, it doesn't matter if there is a global named <code>x</code> or not. Here for example we define <code>x = 123</code> before defining and calling <code>greet</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>greet</code>関数内で、代入<code>x = "hello"</code>は、<code>x</code>を関数のスコープ内の新しいローカル変数にします。関連する2つの事実があります：代入はローカルスコープ内で行われ、既存のローカル<code>x</code>変数は存在しません。<code>x</code>がローカルであるため、グローバルに<code>x</code>が存在するかどうかは関係ありません。ここでは、例えば<code>greet</code>を定義して呼び出す前に<code>x = 123</code>を定義します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = 123 # global
123

julia&gt; function greet()
           x = "hello" # new local
           println(x)
       end
greet (generic function with 1 method)

julia&gt; greet()
hello

julia&gt; x # global
123</code></pre><p data-translated="true"><span class="original-text">Since the <code>x</code> in <code>greet</code> is local, the value (or lack thereof) of the global <code>x</code> is unaffected by calling <code>greet</code>. The hard scope rule doesn't care whether a global named <code>x</code> exists or not: assignment to <code>x</code> in a hard scope is local (unless <code>x</code> is declared global).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>greet</code>内の<code>x</code>がローカルであるため、グローバル<code>x</code>の値（または存在しない場合）は、<code>greet</code>を呼び出しても影響を受けません。ハードスコープのルールは、グローバルに<code>x</code>が存在するかどうかを気にしません：ハードスコープ内の<code>x</code>への代入はローカルです（<code>x</code>がグローバルとして宣言されていない限り）。</span></p><p data-translated="true"><span class="original-text">The next clear cut situation we'll consider is when there is already a local variable named <code>x</code>, in which case <code>x = &lt;value&gt;</code> always assigns to this existing local <code>x</code>. This is true whether the assignment occurs in the same local scope, an inner local scope in the same function body, or in the body of a function nested inside of another function, also known as a <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closure</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次に考慮する明確な状況は、すでに<code>x</code>というローカル変数が存在する場合です。この場合、<code>x = &lt;value&gt;</code>は常にこの既存のローカル<code>x</code>に代入します。これは、代入が同じローカルスコープ内で行われる場合、同じ関数本体内の内側のローカルスコープで行われる場合、または別の関数内にネストされた関数の本体内で行われる場合（クロージャとして知られる）でも同様です。</span></p><p data-translated="true"><span class="original-text">We'll use the <code>sum_to</code> function, which computes the sum of integers from one up to <code>n</code>, as an example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>n</code>までの整数の合計を計算する<code>sum_to</code>関数を例として使用します：</span></p><pre><code class="language-julia hljs">function sum_to(n)
    s = 0 # new local
    for i = 1:n
        s = s + i # assign existing local
    end
    return s # same local
end</code></pre><p data-translated="true"><span class="original-text">As in the previous example, the first assignment to <code>s</code> at the top of <code>sum_to</code> causes <code>s</code> to be a new local variable in the body of the function. The <code>for</code> loop has its own inner local scope within the function scope. At the point where <code>s = s + i</code> occurs, <code>s</code> is already a local variable, so the assignment updates the existing <code>s</code> instead of creating a new local. We can test this out by calling <code>sum_to</code> in the REPL:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">前の例と同様に、<code>s</code>への最初の代入は、<code>sum_to</code>の関数本体内で新しいローカル変数となります。<code>for</code>ループは関数スコープ内に独自の内部ローカルスコープを持っています。<code>s = s + i</code>が発生する時点で、<code>s</code>はすでにローカル変数であるため、代入は新しいローカルを作成するのではなく、既存の<code>s</code>を更新します。これを確認するために、REPLで<code>sum_to</code>を呼び出してみましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function sum_to(n)
           s = 0 # new local
           for i = 1:n
               s = s + i # assign existing local
           end
           return s # same local
       end
sum_to (generic function with 1 method)

julia&gt; sum_to(10)
55

julia&gt; s # global
ERROR: UndefVarError: `s` not defined in `Main`</code></pre><p data-translated="true"><span class="original-text">Since <code>s</code> is local to the function <code>sum_to</code>, calling the function has no effect on the global variable <code>s</code>. We can also see that the update <code>s = s + i</code> in the <code>for</code> loop must have updated the same <code>s</code> created by the initialization <code>s = 0</code> since we get the correct sum of 55 for the integers 1 through 10.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>s</code>は関数<code>sum_to</code>にローカルであるため、関数を呼び出してもグローバル変数<code>s</code>には影響を与えません。また、<code>for</code>ループ内の更新<code>s = s + i</code>は、初期化<code>s = 0</code>によって作成された同じ<code>s</code>を更新していることがわかります。これは、1から10までの整数の合計55を正しく得られるからです。</span></p><p data-translated="true"><span class="original-text">Let's dig into the fact that the <code>for</code> loop body has its own scope for a second by writing a slightly more verbose variation which we'll call <code>sum_to_def</code>, in which we save the sum <code>s + i</code> in a variable <code>t</code> before updating <code>s</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">少し冗長なバリエーションを作成して、<code>sum_to_def</code>と呼ぶことにしましょう。この中では、<code>s</code>を更新する前に、合計<code>s + i</code>を変数<code>t</code>に保存します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function sum_to_def(n)
           s = 0 # new local
           for i = 1:n
               t = s + i # new local `t`
               s = t # assign existing local `s`
           end
           return s, @isdefined(t)
       end
sum_to_def (generic function with 1 method)

julia&gt; sum_to_def(10)
(55, false)</code></pre><p data-translated="true"><span class="original-text">This version returns <code>s</code> as before but it also uses the <code>@isdefined</code> macro to return a boolean indicating whether there is a local variable named <code>t</code> defined in the function's outermost local scope. As you can see, there is no <code>t</code> defined outside of the <code>for</code> loop body. This is because of the hard scope rule again: since the assignment to <code>t</code> occurs inside of a function, which introduces a hard scope, the assignment causes <code>t</code> to become a new local variable in the local scope where it appears, i.e. inside of the loop body. Even if there were a global named <code>t</code>, it would make no difference—the hard scope rule isn't affected by anything in global scope.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このバージョンは以前と同様に<code>s</code>を返しますが、<code>@isdefined</code>マクロを使用して、関数の最も外側のローカルスコープに<code>t</code>という名前のローカル変数が定義されているかどうかを示すブール値も返します。ご覧の通り、<code>for</code>ループ本体の外には<code>t</code>は定義されていません。これは再びハードスコープルールによるものです：<code>t</code>への代入が関数内で発生するため、ハードスコープを導入し、代入により<code>t</code>は出現するローカルスコープ内で新しいローカル変数になります。つまり、ループ本体内です。たとえグローバルに<code>t</code>という名前の変数があったとしても、影響はありません—ハードスコープルールはグローバルスコープの何にも影響されません。</span></p><p data-translated="true"><span class="original-text">Note that the local scope of a for loop body is no different from the local scope of an inner function. This means that we could rewrite this example so that the loop body is implemented as a call to an inner helper function and it behaves the same way:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">注意すべきは、<code>for</code>ループ本体のローカルスコープは、内部関数のローカルスコープと何ら変わらないということです。これは、ループ本体を内部ヘルパー関数への呼び出しとして実装するようにこの例を書き換えることができ、同じように動作することを意味します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; function sum_to_def_closure(n)
           function loop_body(i)
               t = s + i # new local `t`
               s = t # assign same local `s` as below
           end
           s = 0 # new local
           for i = 1:n
               loop_body(i)
           end
           return s, @isdefined(t)
       end
sum_to_def_closure (generic function with 1 method)

julia&gt; sum_to_def_closure(10)
(55, false)</code></pre><p data-translated="true"><span class="original-text">This example illustrates a couple of key points:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この例は、いくつかの重要なポイントを示しています：</span></p><ol><li><p data-translated="true"><span class="original-text">Inner function scopes are just like any other nested local scope. In particular, if a variable is already a local outside of an inner function and you assign to it in the inner function, the outer local variable is updated.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">内部関数スコープは、他のすべてのネストされたローカルスコープと同じです。特に、変数が内部関数の外でローカルであり、内部関数内でそれに代入すると、外側のローカル変数が更新されます。</span></p></li><li><p data-translated="true"><span class="original-text">It doesn't matter if the definition of an outer local happens below where it is updated, the rule remains the same. The entire enclosing local scope is parsed and its locals determined before inner local meanings are resolved.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">外側のローカルの定義が更新される場所の下にあっても、それは問題ではありません。ルールは同じままです。すべての外側のローカルスコープは解析され、そのローカルが決定されてから、内部ローカルの意味が解決されます。</span></p></li></ol><p data-translated="true"><span class="original-text">This design means that you can generally move code in or out of an inner function without changing its meaning, which facilitates a number of common idioms in the language using closures (see <a href="../functions/index.html#Do-Block-Syntax-for-Function-Arguments">do blocks</a>).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この設計により、一般的に内部関数にコードを移動したり、外に出したりしても意味が変わらないため、クロージャを使用した言語の一般的なイディオムを促進します（<a href="../functions/index.html#Do-Block-Syntax-for-Function-Arguments">doブロック</a>を参照）。</span></p><p data-translated="true"><span class="original-text">Let's move onto some more ambiguous cases covered by the soft scope rule. We'll explore this by extracting the bodies of the <code>greet</code> and <code>sum_to_def</code> functions into soft scope contexts. First, let's put the body of <code>greet</code> in a <code>for</code> loop—which is soft, rather than hard—and evaluate it in the REPL:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次に、ソフトスコープルールによってカバーされるいくつかのあいまいなケースに移りましょう。<code>greet</code>と<code>sum_to_def</code>関数の本体をソフトスコープコンテキストに抽出することでこれを探ります。まず、<code>greet</code>の本体を<code>for</code>ループに入れましょう—これはハードではなくソフトです—そしてREPLで評価します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; for i = 1:3
           x = "hello" # new local
           println(x)
       end
hello
hello
hello

julia&gt; x
ERROR: UndefVarError: `x` not defined in `Main`</code></pre><p data-translated="true"><span class="original-text">Since the global <code>x</code> is not defined when the <code>for</code> loop is evaluated, the first clause of the soft scope rule applies and <code>x</code> is created as local to the <code>for</code> loop and therefore global <code>x</code> remains undefined after the loop executes. Next, let's consider the body of <code>sum_to_def</code> extracted into global scope, fixing its argument to <code>n = 10</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバル<code>x</code>が<code>for</code>ループが評価されるときに定義されていないため、ソフトスコープルールの最初の条項が適用され、<code>x</code>は<code>for</code>ループにローカルとして作成される。そのため、ループが実行された後もグローバル<code>x</code>は未定義のままである。次に、引数を<code>n = 10</code>に固定した<code>sum_to_def</code>の本体をグローバルスコープに抽出して考えてみよう。</span></p><pre><code class="language-julia hljs">s = 0
for i = 1:10
    t = s + i
    s = t
end
s
@isdefined(t)</code></pre><p data-translated="true"><span class="original-text">What does this code do? Hint: it's a trick question. The answer is "it depends." If this code is entered interactively, it behaves the same way it does in a function body. But if the code appears in a file, it  prints an ambiguity warning and throws an undefined variable error. Let's see it working in the REPL first:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このコードは何をしますか？ヒント：これはトリック質問です。答えは「それは依存します。」です。このコードがインタラクティブに入力されると、関数本体での動作と同じになります。しかし、コードがファイルに現れると、曖昧さの警告を表示し、未定義の変数エラーをスローします。まず、REPLで動作を見てみましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; s = 0 # global
0

julia&gt; for i = 1:10
           t = s + i # new local `t`
           s = t # assign global `s`
       end

julia&gt; s # global
55

julia&gt; @isdefined(t) # global
false</code></pre><p data-translated="true"><span class="original-text">The REPL approximates being in the body of a function by deciding whether assignment inside the loop assigns to a global or creates new local based on whether a global variable by that name is defined or not. If a global by the name exists, then the assignment updates it. If no global exists, then the assignment creates a new local variable. In this example we see both cases in action:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">REPLは、ループ内の代入がグローバルに割り当てられるか、新しいローカルを作成するかを、同名のグローバル変数が定義されているかどうかに基づいて決定することによって、関数の本体にいることを近似します。同名のグローバルが存在する場合、代入はそれを更新します。グローバルが存在しない場合、代入は新しいローカル変数を作成します。この例では、両方のケースが実行されるのを見ることができます：</span></p><ul><li data-translated="true"><span class="original-text">There is no global named <code>t</code>, so <code>t = s + i</code> creates a new <code>t</code> that is local to the <code>for</code> loop;</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバル<code>t</code>は存在しないため、<code>t = s + i</code>は<code>for</code>ループにローカルな新しい<code>t</code>を作成します。</span></li><li data-translated="true"><span class="original-text">There is a global named <code>s</code>, so <code>s = t</code> assigns to it.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバル<code>s</code>は存在するため、<code>s = t</code>はそれに代入します。</span></li></ul><p data-translated="true"><span class="original-text">The second fact is why execution of the loop changes the global value of <code>s</code> and the first fact is why <code>t</code> is still undefined after the loop executes. Now, let's try evaluating this same code as though it were in a file instead:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">2つ目の事実は、ループの実行がグローバルの<code>s</code>の値を変更する理由であり、最初の事実はループが実行された後も<code>t</code>が未定義のままである理由です。では、同じコードをファイル内にあるかのように評価してみましょう：</span></p><pre><code class="language-julia-repl hljs">julia&gt; code = """
       s = 0 # global
       for i = 1:10
           t = s + i # new local `t`
           s = t # new local `s` with warning
       end
       s, # global
       @isdefined(t) # global
       """;

julia&gt; include_string(Main, code)
┌ Warning: Assignment to `s` in soft scope is ambiguous because a global variable by the same name exists: `s` will be treated as a new local. Disambiguate by using `local s` to suppress this warning or `global s` to assign to the existing global variable.
└ @ string:4
ERROR: LoadError: UndefVarError: `s` not defined in local scope</code></pre><p data-translated="true"><span class="original-text">Here we use <a href="../../base/base/index.html#Base.include_string"><code>include_string</code></a>, to evaluate <code>code</code> as though it were the contents of a file. We could also save <code>code</code> to a file and then call <code>include</code> on that file—the result would be the same. As you can see, this behaves quite different from evaluating the same code in the REPL. Let's break down what's happening here:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、<a href="../../base/base/index.html#Base.include_string"><code>include_string</code></a>を使用して、<code>code</code>をファイルの内容であるかのように評価します。また、<code>code</code>をファイルに保存し、そのファイルに対して<code>include</code>を呼び出すこともできます—結果は同じになります。ご覧の通り、これはREPLで同じコードを評価するのとはかなり異なる動作をします。ここで何が起こっているのかを分解してみましょう：</span></p><ul><li data-translated="true"><span class="original-text">global <code>s</code> is defined with the value <code>0</code> before the loop is evaluated</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバル<code>s</code>は、ループが評価される前に値<code>0</code>で定義されています。</span></li><li data-translated="true"><span class="original-text">the assignment <code>s = t</code> occurs in a soft scope—a <code>for</code> loop outside of any function body or other hard scope construct</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">代入<code>s = t</code>は、関数本体や他のハードスコープ構造の外にあるソフトスコープ—<code>for</code>ループ内で発生します。</span></li><li data-translated="true"><span class="original-text">therefore the second clause of the soft scope rule applies, and the assignment is ambiguous so a warning is emitted</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">したがって、ソフトスコープルールの2番目の条項が適用され、代入は曖昧であるため、警告が発生します。</span></li><li data-translated="true"><span class="original-text">execution continues, making <code>s</code> local to the <code>for</code> loop body</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">実行は続行され、<code>s</code>は<code>for</code>ループ本体にローカルになります。</span></li><li data-translated="true"><span class="original-text">since <code>s</code> is local to the <code>for</code> loop, it is undefined when <code>t = s + i</code> is evaluated, causing an error</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>s</code>が<code>for</code>ループにローカルであるため、<code>t = s + i</code>が評価されるときに未定義となり、エラーが発生します。</span></li><li data-translated="true"><span class="original-text">evaluation stops there, but if it got to <code>s</code> and <code>@isdefined(t)</code>, it would return <code>0</code> and <code>false</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">評価はそこで停止しますが、もし<code>s</code>と<code>@isdefined(t)</code>に到達した場合、<code>0</code>と<code>false</code>を返します。</span></li></ul><p data-translated="true"><span class="original-text">This demonstrates some important aspects of scope: in a scope, each variable can only have one meaning, and that meaning is determined regardless of the order of expressions. The presence of the expression <code>s = t</code> in the loop causes <code>s</code> to be local to the loop, which means that it is also local when it appears on the right hand side of <code>t = s + i</code>, even though that expression appears first and is evaluated first. One might imagine that the <code>s</code> on the first line of the loop could be global while the <code>s</code> on the second line of the loop is local, but that's not possible since the two lines are in the same scope block and each variable can only mean one thing in a given scope.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これはスコープのいくつかの重要な側面を示しています：スコープ内では、各変数は一つの意味しか持てず、その意味は式の順序に関係なく決定されます。ループ内の式<code>s = t</code>の存在は<code>s</code>をループにローカルにし、これは<code>t = s + i</code>の右側に現れるときもローカルであることを意味します。たとえその式が最初に現れ、最初に評価されてもです。ループの最初の行の<code>s</code>がグローバルで、2行目の<code>s</code>がローカルであると想像するかもしれませんが、それは不可能です。なぜなら、2行は同じスコープブロック内にあり、各変数は特定のスコープ内で一つの意味しか持てないからです。</span></p><h4 id="on-soft-scope" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#on-soft-scope">On Soft Scope</a><a id="on-soft-scope-1"></a><a class="docs-heading-anchor-permalink" href="#on-soft-scope" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#on-soft-scope">ソフトスコープについて</a><a id="on-soft-scope-1"></a><a class="docs-heading-anchor-permalink" href="#on-soft-scope" title="Permalink"></a></span></h4><p data-translated="true"><span class="original-text">We have now covered all the local scope rules, but before wrapping up this section, perhaps a few words should be said about why the ambiguous soft scope case is handled differently in interactive and non-interactive contexts. There are two obvious questions one could ask:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これでローカルスコープのルールはすべてカバーしましたが、このセクションを締めくくる前に、インタラクティブおよび非インタラクティブなコンテキストであいまいなソフトスコープのケースが異なる扱いを受ける理由について少し触れるべきかもしれません。考えられる明らかな質問が2つあります：</span></p><ol><li data-translated="true"><span class="original-text">Why doesn't it just work like the REPL everywhere?</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">なぜどこでもREPLのように動作しないのですか？</span></li><li data-translated="true"><span class="original-text">Why doesn't it just work like in files everywhere? And maybe skip the warning?</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">なぜどこでもファイルのように動作しないのですか？そして警告をスキップすることはできないのでしょうか？</span></li></ol><p data-translated="true"><span class="original-text">In Julia ≤ 0.6, all global scopes did work like the current REPL: when <code>x = &lt;value&gt;</code> occurred in a loop (or <code>try</code>/<code>catch</code>, or <code>struct</code> body) but outside of a function body (or <code>let</code> block or comprehension), it was decided based on whether a global named <code>x</code> was defined or not whether <code>x</code> should be local to the loop. This behavior has the advantage of being intuitive and convenient since it approximates the behavior inside of a function body as closely as possible. In particular, it makes it easy to move code back and forth between a function body and the REPL when trying to debug the behavior of a function. However, it has some downsides. First, it's quite a complex behavior: many people over the years were confused about this behavior and complained that it was complicated and hard both to explain and understand. Fair point. Second, and arguably worse, is that it's bad for programming "at scale." When you see a small piece of code in one place like this, it's quite clear what's going on:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia ≤ 0.6では、すべてのグローバルスコープは現在のREPLのように動作しました：<code>x = &lt;value&gt;</code>がループ内（または<code>try</code>/<code>catch</code>、または<code>struct</code>本体）で発生したが、関数本体（または<code>let</code>ブロックや内包表記）の外にある場合、グローバルに名付けられた<code>x</code>が定義されているかどうかに基づいて<code>x</code>がループにローカルであるべきかどうかが決定されました。この動作は直感的で便利であり、関数本体内の動作にできるだけ近づけるという利点があります。特に、関数の動作をデバッグしようとする際に、コードを関数本体とREPLの間で簡単に移動できるようにします。しかし、いくつかの欠点もあります。まず、この動作は非常に複雑です：多くの人々がこの動作について混乱し、説明や理解が難しいと不満を持っていました。もっともな意見です。第二に、そしておそらくそれ以上に悪いのは、「スケールでのプログラミング」にとって悪いことです。このように小さなコードの断片を見ると、何が起こっているのかは非常に明確です：</span></p><pre><code class="language-julia hljs">s = 0
for i = 1:10
    s += i
end</code></pre><p data-translated="true"><span class="original-text">Obviously the intention is to modify the existing global variable <code>s</code>. What else could it mean? However, not all real world code is so short or so clear. We found that code like the following often occurs in the wild:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">明らかに意図は既存のグローバル変数<code>s</code>を修正することです。他に何が考えられるでしょうか？しかし、実際のコードは必ずしもこれほど短く明確ではありません。以下のようなコードが実際に発生することがよくあります：</span></p><pre><code class="language-julia hljs">x = 123

# much later
# maybe in a different file

for i = 1:10
    x = "hello"
    println(x)
end

# much later
# maybe in yet another file
# or maybe back in the first one where `x = 123`

y = x + 234</code></pre><p data-translated="true"><span class="original-text">It's far less clear what should happen here. Since <code>x + "hello"</code> is a method error, it seems probable that the intention is for <code>x</code> to be local to the <code>for</code> loop. But runtime values and what methods happen to exist cannot be used to determine the scopes of variables. With the Julia ≤ 0.6 behavior, it's especially concerning that someone might have written the <code>for</code> loop first, had it working just fine, but later when someone else adds a new global far away—possibly in a different file—the code suddenly changes meaning and either breaks noisily or, worse still, silently does the wrong thing. This kind of <a href="https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)">"spooky action at a distance"</a> is something that good programming language designs should prevent.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで何が起こるべきかははっきりしません。<code>x + "hello"</code> がメソッドエラーであるため、<code>x</code> が <code>for</code> ループにローカルであることが意図されている可能性が高いです。しかし、実行時の値や存在するメソッドによって変数のスコープを決定することはできません。Julia ≤ 0.6 の動作では、誰かが最初に <code>for</code> ループを書き、それがうまく動作していたのに、後で別の誰かが遠くの新しいグローバルを追加した場合（おそらく別のファイルで）、コードの意味が突然変わり、騒々しく壊れるか、さらに悪いことに、静かに間違ったことをする可能性があることが特に懸念されます。この種の <a href="https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)">「距離のある場所での不気味な作用」</a> は、良いプログラミング言語の設計が防ぐべきものです。</span></p><p data-translated="true"><span class="original-text">So in Julia 1.0, we simplified the rules for scope: in any local scope, assignment to a name that wasn't already a local variable created a new local variable. This eliminated the notion of soft scope entirely as well as removing the potential for spooky action. We uncovered and fixed a significant number of bugs due to the removal of soft scope, vindicating the choice to get rid of it. And there was much rejoicing! Well, no, not really. Because some people were angry that they now had to write:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">そこで、Julia 1.0 ではスコープのルールを簡素化しました：任意のローカルスコープ内で、すでにローカル変数でない名前への代入は新しいローカル変数を作成しました。これにより、ソフトスコープの概念が完全に排除され、不気味な作用の可能性も取り除かれました。ソフトスコープの削除により、多くのバグが発見され修正され、これを排除する選択が正当化されました。そして、多くの喜びがありました！まあ、実際にはそうではありません。なぜなら、ある人々は今や次のように書かなければならないことに怒っていたからです：</span></p><pre><code class="language-julia hljs">s = 0
for i = 1:10
    global s += i
end</code></pre><p data-translated="true"><span class="original-text">Do you see that <code>global</code> annotation in there? Hideous. Obviously this situation could not be tolerated. But seriously, there are two main issues with requiring <code>global</code> for this kind of top-level code:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">その中にある <code>global</code> 注釈が見えますか？ひどいです。明らかにこの状況は容認できません。しかし、真剣に言うと、この種のトップレベルコードに <code>global</code> を要求することには二つの主な問題があります：</span></p><ol><li><p data-translated="true"><span class="original-text">It's no longer convenient to copy and paste the code from inside a function body into the REPL to debug it—you have to add <code>global</code> annotations and then remove them again to go back;</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">関数本体内のコードを REPL にコピー＆ペーストしてデバッグするのがもはや便利ではありません—<code>global</code> 注釈を追加し、戻るために再度削除しなければなりません；</span></p></li><li><p data-translated="true"><span class="original-text">Beginners will write this kind of code without the <code>global</code> and have no idea why their code doesn't work—the error that they get is that <code>s</code> is undefined, which does not seem to enlighten anyone who happens to make this mistake.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">初心者はこの種のコードを <code>global</code> なしで書き、なぜ自分のコードが動作しないのか全く理解できません—彼らが受け取るエラーは <code>s</code> が未定義であるというもので、これはこの間違いを犯した誰にとっても明らかではありません。</span></p></li></ol><p data-translated="true"><span class="original-text">As of Julia 1.5, this code works without the <code>global</code> annotation in interactive contexts like the REPL or Jupyter notebooks (just like Julia 0.6) and in files and other non-interactive contexts, it prints this very direct warning:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia 1.5 以降、このコードは REPL や Jupyter ノートブックのようなインタラクティブなコンテキストでは <code>global</code> 注釈なしで動作します（Julia 0.6 と同様に）し、ファイルや他の非インタラクティブなコンテキストでは、この非常に直接的な警告が表示されます：</span></p><blockquote><p data-translated="true"><span class="original-text">Assignment to <code>s</code> in soft scope is ambiguous because a global variable by the same name exists: <code>s</code> will be treated as a new local. Disambiguate by using <code>local s</code> to suppress this warning or <code>global s</code> to assign to the existing global variable.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>s</code> へのソフトスコープでの代入は、同じ名前のグローバル変数が存在するため曖昧です：<code>s</code> は新しいローカルとして扱われます。この警告を抑制するには <code>local s</code> を使用して明確にするか、既存のグローバル変数に代入するには <code>global s</code> を使用してください。</span></p></blockquote><p data-translated="true"><span class="original-text">This addresses both issues while preserving the "programming at scale" benefits of the 1.0 behavior: global variables have no spooky effect on the meaning of code that may be far away; in the REPL copy-and-paste debugging works and beginners don't have any issues; any time someone either forgets a <code>global</code> annotation or accidentally shadows an existing global with a local in a soft scope, which would be confusing anyway, they get a nice clear warning.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これは両方の問題に対処しながら、1.0 の動作の「スケールでのプログラミング」の利点を保持します：グローバル変数は、遠くにあるかもしれないコードの意味に不気味な影響を与えません；REPL ではコピー＆ペーストデバッグが機能し、初心者は問題を抱えません；誰かが <code>global</code> 注釈を忘れたり、ソフトスコープ内でローカルによって既存のグローバルを影にした場合（それは混乱を招くでしょう）、彼らは明確な警告を受け取ります。</span></p><p data-translated="true"><span class="original-text">An important property of this design is that any code that executes in a file without a warning will behave the same way in a fresh REPL. And on the flip side, if you take a REPL session and save it to file, if it behaves differently than it did in the REPL, then you will get a warning.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この設計の重要な特性は、警告なしでファイル内で実行されるコードは、新しい REPL でも同じように動作するということです。そして逆に、REPL セッションをファイルに保存し、それが REPL での動作と異なる場合、警告が表示されます。</span></p><h3 id="Let-Blocks" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Let-Blocks">Let Blocks</a><a id="Let-Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Let-Blocks" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Let-Blocks">Let Blocks</a><a id="Let-Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Let-Blocks" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text"><code>let</code> statements create a new <em>hard scope</em> block (see above) and introduce new variable bindings each time they run. The variable need not be immediately assigned:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>let</code> 文は新しい <em>ハードスコープ</em> ブロックを作成し（上記参照）、実行されるたびに新しい変数バインディングを導入します。変数は即座に割り当てられる必要はありません。</span></p><pre><code class="language-julia-repl hljs">julia&gt; var1 = let x
           for i in 1:5
               (i == 4) &amp;&amp; (x = i; break)
           end
           x
       end
4</code></pre><p data-translated="true"><span class="original-text">Whereas assignments might reassign a new value to an existing value location, <code>let</code> always creates a new location. This difference is usually not important, and is only detectable in the case of variables that outlive their scope via closures. The <code>let</code> syntax accepts a comma-separated series of assignments and variable names:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">代入が既存の値の場所に新しい値を再割り当てする可能性があるのに対し、<code>let</code> は常に新しい場所を作成します。この違いは通常重要ではなく、クロージャを介してスコープを超えて生存する変数の場合にのみ検出可能です。<code>let</code> 構文はカンマ区切りの一連の代入と変数名を受け入れます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; x, y, z = -1, -1, -1;

julia&gt; let x = 1, z
           println("x: $x, y: $y") # x is local variable, y the global
           println("z: $z") # errors as z has not been assigned yet but is local
       end
x: 1, y: -1
ERROR: UndefVarError: `z` not defined in local scope</code></pre><p data-translated="true"><span class="original-text">The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like <code>let x = x</code> since the two <code>x</code> variables are distinct and have separate storage. Here is an example where the behavior of <code>let</code> is needed:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">代入は順番に評価され、右辺の各式は左辺の新しい変数が導入される前のスコープで評価されます。したがって、<code>let x = x</code> のような記述は意味があります。なぜなら、2つの <code>x</code> 変数は異なり、別々のストレージを持っているからです。以下は <code>let</code> の動作が必要な例です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Fs = Vector{Any}(undef, 2); i = 1;

julia&gt; while i &lt;= 2
           Fs[i] = ()-&gt;i
           global i += 1
       end

julia&gt; Fs[1]()
3

julia&gt; Fs[2]()
3</code></pre><p data-translated="true"><span class="original-text">Here we create and store two closures that return variable <code>i</code>. However, it is always the same variable <code>i</code>, so the two closures behave identically. We can use <code>let</code> to create a new binding for <code>i</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここでは、変数 <code>i</code> を返す2つのクロージャを作成して保存します。しかし、常に同じ変数 <code>i</code> であるため、2つのクロージャは同一の動作をします。<code>let</code> を使用して <code>i</code> の新しいバインディングを作成できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; Fs = Vector{Any}(undef, 2); i = 1;

julia&gt; while i &lt;= 2
           let i = i
               Fs[i] = ()-&gt;i
           end
           global i += 1
       end

julia&gt; Fs[1]()
1

julia&gt; Fs[2]()
2</code></pre><p data-translated="true"><span class="original-text">Since the <code>begin</code> construct does not introduce a new scope, it can be useful to use a zero-argument <code>let</code> to just introduce a new scope block without creating any new bindings immediately:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>begin</code> 構文は新しいスコープを導入しないため、即座に新しいバインディングを作成せずに新しいスコープブロックを導入するために、引数なしの <code>let</code> を使用することが有用です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; let
           local x = 1
           let
               local x = 2
           end
           x
       end
1</code></pre><p data-translated="true"><span class="original-text">Since <code>let</code> introduces a new scope block, the inner local <code>x</code> is a different variable than the outer local <code>x</code>. This particular example is equivalent to:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>let</code> が新しいスコープブロックを導入するため、内側のローカル <code>x</code> は外側のローカル <code>x</code> とは異なる変数です。この特定の例は次のように等価です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; let x = 1
           let x = 2
           end
           x
       end
1</code></pre><h3 id="Loops-and-Comprehensions" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Loops-and-Comprehensions">Loops and Comprehensions</a><a id="Loops-and-Comprehensions-1"></a><a class="docs-heading-anchor-permalink" href="#Loops-and-Comprehensions" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Loops-and-Comprehensions">ループとコンプリヘンション</a><a id="Loops-and-Comprehensions-1"></a><a class="docs-heading-anchor-permalink" href="#Loops-and-Comprehensions" title="Permalink"></a></span></h3><p data-translated="true"><span class="original-text">In loops and <a href="../arrays/index.html#man-comprehensions">comprehensions</a>, new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a <code>let</code> block, as demonstrated by this example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ループと <a href="../arrays/index.html#man-comprehensions">コンプリヘンション</a> では、ボディスコープで導入された新しい変数は、各ループ反復ごとに新たに割り当てられます。これは、ループボディが <code>let</code> ブロックで囲まれているかのように示されます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; Fs = Vector{Any}(undef, 2);

julia&gt; for j = 1:2
           Fs[j] = ()-&gt;j
       end

julia&gt; Fs[1]()
1

julia&gt; Fs[2]()
2</code></pre><p data-translated="true"><span class="original-text">A <code>for</code> loop or comprehension iteration variable is always a new variable:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>for</code> ループまたはコンプリヘンションの反復変数は常に新しい変数です。</span></p><pre><code class="language-julia-repl hljs">julia&gt; function f()
           i = 0
           for i = 1:3
               # empty
           end
           return i
       end;

julia&gt; f()
0</code></pre><p data-translated="true"><span class="original-text">However, it is occasionally useful to reuse an existing local variable as the iteration variable. This can be done conveniently by adding the keyword <code>outer</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、既存のローカル変数を反復変数として再利用することが時折有用です。これは、キーワード <code>outer</code> を追加することで便利に行えます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; function f()
           i = 0
           for outer i = 1:3
               # empty
           end
           return i
       end;

julia&gt; f()
3</code></pre><h2 id="Constants" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Constants">Constants</a><a id="Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Constants" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Constants">定数</a><a id="Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Constants" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">A common use of variables is giving names to specific, unchanging values. Such variables are only assigned once. This intent can be conveyed to the compiler using the <a href="../../base/base/index.html#const"><code>const</code></a> keyword:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">変数の一般的な使用法は、特定の不変の値に名前を付けることです。このような変数は一度だけ割り当てられます。この意図は、<a href="../../base/base/index.html#const"><code>const</code></a>キーワードを使用してコンパイラに伝えることができます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; const e  = 2.71828182845904523536;

julia&gt; const pi = 3.14159265358979323846;</code></pre><p data-translated="true"><span class="original-text">Multiple variables can be declared in a single <code>const</code> statement:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">複数の変数は、単一の<code>const</code>文で宣言できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; const a, b = 1, 2
(1, 2)</code></pre><p data-translated="true"><span class="original-text">The <code>const</code> declaration should only be used in global scope on globals. It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a <code>const</code> declaration solves this performance problem.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>const</code>宣言は、グローバルスコープのグローバル変数にのみ使用するべきです。グローバル変数を含むコードを最適化することはコンパイラにとって難しいです。なぜなら、その値（または型）がほぼいつでも変わる可能性があるからです。グローバル変数が変わらない場合、<code>const</code>宣言を追加することでこのパフォーマンスの問題を解決できます。</span></p><p data-translated="true"><span class="original-text">Local constants are quite different. The compiler is able to determine automatically when a local variable is constant, so local constant declarations are not necessary, and in fact are currently not supported.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ローカル定数は全く異なります。コンパイラはローカル変数が定数であるかどうかを自動的に判断できるため、ローカル定数の宣言は必要なく、実際には現在サポートされていません。</span></p><p data-translated="true"><span class="original-text">Special top-level assignments, such as those performed by the <code>function</code> and <code>struct</code> keywords, are constant by default.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>function</code>や<code>struct</code>キーワードによって行われる特別なトップレベルの割り当ては、デフォルトで定数です。</span></p><p data-translated="true"><span class="original-text">Note that <code>const</code> only affects the variable binding; the variable may be bound to a mutable object (such as an array), and that object may still be modified. Additionally when one tries to assign a value to a variable that is declared constant the following scenarios are possible:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>const</code>は変数のバインディングにのみ影響を与えることに注意してください。変数は可変オブジェクト（配列など）にバインドされる可能性があり、そのオブジェクトは依然として変更される可能性があります。さらに、定数として宣言された変数に値を割り当てようとすると、次のシナリオが考えられます。</span></p><ul><li data-translated="true"><span class="original-text">Attempting to replace a constant without the const <code>keyword</code> is disallowed:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">const <code>keyword</code>なしで定数を置き換えようとすることは許可されていません。</span></li></ul><pre><code class="language-julia-repl hljs">julia&gt; const x = 1.0
1.0

julia&gt; x = 1
ERROR: invalid assignment to constant x. This redefinition may be permitted using the `const` keyword.</code></pre><ul><li data-translated="true"><span class="original-text">All other defefinitions of constants are permitted, but may cause significant re-compilation:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">他のすべての定数の定義は許可されていますが、重大な再コンパイルを引き起こす可能性があります。</span></li></ul><pre><code class="language-julia-repl hljs">julia&gt; const y = 1.0
1.0

julia&gt; const y = 2.0
2.0</code></pre><div class="admonition is-compat" id="Julia-1.12-b3099eeecf8491c2"><header class="admonition-header">Julia 1.12<a class="admonition-anchor" href="#Julia-1.12-b3099eeecf8491c2" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Prior to julia 1.12, redefinition of constants was poorly supported. It was restricted to redefinition of constants of the same type and could lead to observably incorrect behavior or crashes. Constant redefinition is highly discouraged in versions of julia prior to 1.12. See the manual for prior julia versions for further information.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">julia 1.12以前では、定数の再定義は十分にサポートされていませんでした。同じ型の定数の再定義に制限されており、観察可能な誤動作やクラッシュを引き起こす可能性がありました。julia 1.12以前のバージョンでは、定数の再定義は強く推奨されていません。以前のjuliaバージョンのマニュアルを参照してください。</span></p></div></div><h2 id="man-typed-globals" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-typed-globals">Typed Globals</a><a id="man-typed-globals-1"></a><a class="docs-heading-anchor-permalink" href="#man-typed-globals" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-typed-globals">型付きグローバル</a><a id="man-typed-globals-1"></a><a class="docs-heading-anchor-permalink" href="#man-typed-globals" title="Permalink"></a></span></h2><div class="admonition is-compat" id="Julia-1.8-b0272c013c240077"><header class="admonition-header">Julia 1.8<a class="admonition-anchor" href="#Julia-1.8-b0272c013c240077" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">Support for typed globals was added in Julia 1.8</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型付きグローバルのサポートはJulia 1.8で追加されました</span></p></div></div><p data-translated="true"><span class="original-text">Similar to being declared as constants, global bindings can also be declared to always be of a constant type. This can either be done without assigning an actual value using the syntax <code>global x::T</code> or upon assignment as <code>x::T = 123</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">定数として宣言されるのと同様に、グローバルバインディングも常に定数型であることを宣言できます。これは、実際の値を割り当てずに<code>global x::T</code>という構文を使用するか、割り当て時に<code>x::T = 123</code>として行うことができます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; x::Float64 = 2.718
2.718

julia&gt; f() = x
f (generic function with 1 method)

julia&gt; Base.return_types(f)
1-element Vector{Any}:
 Float64</code></pre><p data-translated="true"><span class="original-text">For any assignment to a global, Julia will first try to convert it to the appropriate type using <a href="../../base/base/index.html#Base.convert"><code>convert</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">グローバルへの任意の割り当てに対して、Juliaはまず<a href="../../base/base/index.html#Base.convert"><code>convert</code></a>を使用して適切な型に変換しようとします:</span></p><pre><code class="language-julia-repl hljs">julia&gt; global y::Int

julia&gt; y = 1.0
1.0

julia&gt; y
1

julia&gt; y = 3.14
ERROR: InexactError: Int64(3.14)
Stacktrace:
[...]</code></pre><p data-translated="true"><span class="original-text">The type does not need to be concrete, but annotations with abstract types typically have little performance benefit.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">型は具体的である必要はありませんが、抽象型での注釈は通常、パフォーマンス上の利点がほとんどありません。</span></p><p data-translated="true"><span class="original-text">Once a global has either been assigned to or its type has been set, the binding type is not allowed to change:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一度グローバルに割り当てられるか、その型が設定されると、バインディングの型は変更できなくなります:</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = 1
1

julia&gt; global x::Int
ERROR: cannot set type for global x. It already has a value or is already set to a different type.
Stacktrace:
[...]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../control-flow/index.html">« Control Flow</a><a class="docs-footer-nextpage" href="../types/index.html">Types »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>