<!DOCTYPE html><html lang="en" class=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Strings · The Julia Language</title><meta name="title" content="Strings · The Julia Language"><meta property="og:title" content="Strings · The Julia Language"><meta property="twitter:title" content="Strings · The Julia Language"><meta name="description" content="Documentation for The Julia Language."><meta property="og:description" content="Documentation for The Julia Language."><meta property="twitter:description" content="Documentation for The Julia Language."><meta property="og:url" content="https://docs.julialang.org/en/v1/manual/strings/"><meta property="twitter:url" content="https://docs.julialang.org/en/v1/manual/strings/"><link rel="canonical" href="index.html"><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-HL02FD570L&amp;cx=c&amp;gtm=4e5bi1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark=""><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary=""><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="documenter" src="../../assets/documenter.js"></script><style id="ai-toggle-style">
                .original-text { transition: opacity 0.3s; }
                body[data-view-mode="translation-only"] .original-text { display: none !important; }
                
                #ai-toggle-btn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 10px 20px;
                    font-family: sans-serif;
                    font-size: 14px;
                    cursor: pointer;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    transition: transform 0.2s, background 0.2s;
                }
                #ai-toggle-btn:hover { transform: scale(1.05); background: #0056b3; }
                #ai-toggle-btn:active { transform: scale(0.95); }
            </style></head><body data-view-mode="translation-only"><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../index.html"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../index.html">Julia Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../index.html">Julia ドキュメント</a></span></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked=""><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../getting-started/index.html">Getting Started</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../getting-started/index.html">はじめに</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../installation/index.html">Installation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../installation/index.html">インストール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables/index.html">Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables/index.html">変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">Integers and Floating-Point Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../integers-and-floating-point-numbers/index.html">整数と浮動小数点数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../mathematical-operations/index.html">Mathematical Operations and Elementary Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../mathematical-operations/index.html">数学的操作と基本関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../complex-and-rational-numbers/index.html">Complex and Rational Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../complex-and-rational-numbers/index.html">複素数と有理数</a></span></li><li class="is-active"><a class="tocitem" href="">Strings</a><ul class="internal"><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-characters"><span>Characters</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-characters"><span>キャラクター</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#String-Basics"><span>String Basics</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#String-Basics"><span>文字列の基本</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Unicode-and-UTF-8"><span>Unicode and UTF-8</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Unicode-and-UTF-8"><span>UnicodeとUTF-8</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-concatenation"><span>Concatenation</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-concatenation"><span>連結</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#string-interpolation"><span>Interpolation</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#string-interpolation"><span>補間</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Triple-Quoted-String-Literals"><span>Triple-Quoted String Literals</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Triple-Quoted-String-Literals"><span>三重引用符付き文字列リテラル</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#Common-Operations"><span>Common Operations</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#Common-Operations"><span>一般的な操作</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#non-standard-string-literals"><span>Non-Standard String Literals</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#non-standard-string-literals"><span>非標準文字列リテラル</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-regex-literals"><span>Regular Expressions</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-regex-literals"><span>正規表現</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-byte-array-literals"><span>Byte Array Literals</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-byte-array-literals"><span>バイト配列リテラル</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-version-number-literals"><span>Version Number Literals</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-version-number-literals"><span>バージョン番号リテラル</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-raw-string-literals"><span>Raw String Literals</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-raw-string-literals"><span>生文字列リテラル</span></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="#man-annotated-strings"><span>Annotated Strings</span></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="#man-annotated-strings"><span>注釈付き文字列</span></a></span></li></ul></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../functions/index.html">Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../functions/index.html">関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../control-flow/index.html">Control Flow</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../control-flow/index.html">制御フロー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../variables-and-scoping/index.html">Scope of Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../variables-and-scoping/index.html">変数のスコープ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../types/index.html">Types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../types/index.html">型</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../methods/index.html">Methods</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../methods/index.html">メソッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../constructors/index.html">Constructors</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../constructors/index.html">コンストラクタ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../conversion-and-promotion/index.html">Conversion and Promotion</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../conversion-and-promotion/index.html">変換と昇格</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../interfaces/index.html">Interfaces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../interfaces/index.html">インターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../modules/index.html">Modules</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../modules/index.html">モジュール</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../documentation/index.html">Documentation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../documentation/index.html">ドキュメント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../metaprogramming/index.html">Metaprogramming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../metaprogramming/index.html">メタプログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../arrays/index.html">Single- and multi-dimensional Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../arrays/index.html">単次元および多次元配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../missing/index.html">Missing Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../missing/index.html">欠損値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../networking-and-streams/index.html">Networking and Streams</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../networking-and-streams/index.html">ネットワーキングとストリーム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../parallel-computing/index.html">Parallel Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../parallel-computing/index.html">並列計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../asynchronous-programming/index.html">Asynchronous Programming</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../asynchronous-programming/index.html">非同期プログラミング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../distributed-computing/index.html">Multi-processing and Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../distributed-computing/index.html">マルチプロセッシングと分散計算</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../running-external-programs/index.html">Running External Programs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../running-external-programs/index.html">外部プログラムの実行</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">Calling C and Fortran Code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../calling-c-and-fortran-code/index.html">CおよびFortranコードの呼び出し</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../handling-operating-system-variation/index.html">Handling Operating System Variation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../handling-operating-system-variation/index.html">オペレーティングシステムのバリエーションの取り扱い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../environment-variables/index.html">Environment Variables</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../environment-variables/index.html">環境変数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../embedding/index.html">Embedding Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../embedding/index.html">Juliaの埋め込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../code-loading/index.html">Code Loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../code-loading/index.html">コードの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../stacktraces/index.html">Stack Traces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../memory-management/index.html">Memory Management and Garbage Collection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../memory-management/index.html">メモリ管理とガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../performance-tips/index.html">Performance Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../performance-tips/index.html">パフォーマンスのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../workflow-tips/index.html">Workflow Tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../workflow-tips/index.html">ワークフローのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../style-guide/index.html">Style Guide</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../style-guide/index.html">スタイルガイド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../faq/index.html">Frequently Asked Questions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../faq/index.html">よくある質問</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../noteworthy-differences/index.html">Noteworthy Differences from other Languages</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../noteworthy-differences/index.html">他の言語との注目すべき違い</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../unicode-input/index.html">Unicode Input</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../unicode-input/index.html">Unicode入力</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../command-line-interface/index.html">Command-line Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../command-line-interface/index.html">コマンドラインインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../worldage/index.html">The World Age mechanism</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../worldage/index.html">ワールドエイジメカニズム</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/base/index.html">Essentials</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/base/index.html">基本事項</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/collections/index.html">Collections and Data Structures</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/collections/index.html">コレクションとデータ構造</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/math/index.html">Mathematics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/math/index.html">数学</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/numbers/index.html">Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/numbers/index.html">数値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/strings/index.html">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/strings/index.html">文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/arrays/index.html">Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/arrays/index.html">配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/parallel/index.html">Tasks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/parallel/index.html">タスク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/multi-threading/index.html">Multi-Threading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/multi-threading/index.html">マルチスレッド</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/scopedvalues/index.html">Scoped Values</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/scopedvalues/index.html">スコープ付き値</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/constants/index.html">Constants</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/constants/index.html">定数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/file/index.html">Filesystem</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/file/index.html">ファイルシステム</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/io-network/index.html">I/O and Network</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/io-network/index.html">入出力とネットワーク</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/punctuation/index.html">Punctuation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/punctuation/index.html">句読点</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/sort/index.html">Sorting and Related Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/sort/index.html">ソートと関連関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/iterators/index.html">Iteration utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/iterators/index.html">反復ユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/reflection/index.html">Reflection and introspection</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/reflection/index.html">リフレクションとイントロスペクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/c/index.html">C Interface</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/c/index.html">Cインターフェース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/libc/index.html">C Standard Library</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/libc/index.html">C標準ライブラリ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/stacktraces/index.html">StackTraces</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/stacktraces/index.html">スタックトレース</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../base/simd-types/index.html">SIMD Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../base/simd-types/index.html">SIMDサポート</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/ArgTools/index.html">ArgTools</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Artifacts/index.html">Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Artifacts/index.html">アーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Base64/index.html">Base64</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/CRC32c/index.html">CRC32c</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Dates/index.html">Dates</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Dates/index.html">日付</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">Delimited Files</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/DelimitedFiles/index.html">区切りファイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Distributed/index.html">Distributed Computing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Distributed/index.html">分散コンピューティング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Downloads/index.html">Downloads</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Downloads/index.html">ダウンロード</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/FileWatching/index.html">File Events</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/FileWatching/index.html">ファイルイベント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Future/index.html">Future</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">Interactive Utilities</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/InteractiveUtils/index.html">インタラクティブユーティリティ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia Syntax Highlighting</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/JuliaSyntaxHighlighting/index.html">Julia構文ハイライト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">Lazy Artifacts</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LazyArtifacts/index.html">レイジーアーティファクト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibCURL/index.html">LibCURL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LibGit2/index.html">LibGit2</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Libdl/index.html">Dynamic Linker</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Libdl/index.html">動的リンカー</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">Linear Algebra</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/LinearAlgebra/index.html">線形代数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Logging/index.html">Logging</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Logging/index.html">ロギング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Markdown/index.html">Markdown</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Markdown/index.html">マークダウン</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Mmap/index.html">Memory-mapped I/O</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Mmap/index.html">メモリマップI/O</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">Network Options</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/NetworkOptions/index.html">ネットワークオプション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Pkg/index.html">Pkg</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Printf/index.html">Printf</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Profile/index.html">Profiling</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Profile/index.html">プロファイリング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/REPL/index.html">The Julia REPL</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/REPL/index.html">Julia REPL</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Random/index.html">Random Numbers</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Random/index.html">乱数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SHA/index.html">SHA</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Serialization/index.html">Serialization</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Serialization/index.html">シリアライゼーション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">Shared Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SharedArrays/index.html">共有配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Sockets/index.html">Sockets</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Sockets/index.html">ソケット</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">Sparse Arrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/SparseArrays/index.html">スパース配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Statistics/index.html">Statistics</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Statistics/index.html">統計</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">StyledStrings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/StyledStrings/index.html">スタイル付き文字列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/TOML/index.html">TOML</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Tar/index.html">Tar</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Test/index.html">Unit Testing</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Test/index.html">単体テスト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/UUIDs/index.html">UUIDs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../stdlib/Unicode/index.html">Unicode</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/init/index.html">Initialization of the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/init/index.html">Juliaランタイムの初期化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ast/index.html">Julia ASTs</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/types/index.html">More about types</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/types/index.html">型についての詳細</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/object/index.html">Memory layout of Julia Objects</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/object/index.html">Juliaオブジェクトのメモリレイアウト</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/eval/index.html">Eval of Julia code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/eval/index.html">JuliaコードのEval</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/callconv/index.html">Calling Conventions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/callconv/index.html">呼び出し規約</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/compiler/index.html">High-level Overview of the Native-Code Generation Process</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/compiler/index.html">ネイティブコード生成プロセスの高レベル概要</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/functions/index.html">Julia Functions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/functions/index.html">Julia関数</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/cartesian/index.html">Base.Cartesian</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/meta/index.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/meta/index.html">コンパイラとの対話（<code>:meta</code>メカニズム）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/subarrays/index.html">SubArrays</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/subarrays/index.html">サブ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union Optimizations</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/isbitsunionarrays/index.html">isbits Union最適化</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sysimg/index.html">System Image Building</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sysimg/index.html">システムイメージビルディング</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/pkgimg/index.html">Package Images</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/pkgimg/index.html">パッケージイメージ</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">Custom LLVM Passes</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm-passes/index.html">カスタムLLVMパス</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/llvm/index.html">Working with LLVM</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/llvm/index.html">LLVMとの連携</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/stdio/index.html">printf() and stdio in the Julia runtime</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/stdio/index.html">printf()とJuliaランタイムのstdio</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/boundscheck/index.html">Bounds checking</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/boundscheck/index.html">境界チェック</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/locks/index.html">Proper maintenance and care of multi-threading locks</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/locks/index.html">マルチスレッドロックの適切なメンテナンスと管理</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">Arrays with custom indices</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/offset-arrays/index.html">カスタムインデックスを持つ配列</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/require/index.html">Module loading</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/require/index.html">モジュールの読み込み</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/inference/index.html">Inference</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/inference/index.html">推論</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA-form IR</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/ssair/index.html">Julia SSA形式IR</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/EscapeAnalysis/index.html"><code>EscapeAnalysis</code></a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/aot/index.html">Ahead of Time Compilation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/aot/index.html">事前コンパイル</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc-sa/index.html">Static analyzer annotations for GC correctness in C code</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc-sa/index.html">CコードにおけるGCの正確性のための静的解析者注釈</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/gc/index.html">Garbage Collection in Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/gc/index.html">Juliaにおけるガーベジコレクション</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/jit/index.html">JIT Design and Implementation</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/jit/index.html">JITの設計と実装</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/builtins/index.html">Core.Builtins</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">Fixing precompilation hangs due to open tasks or IO</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/precompile_hang/index.html">オープンタスクやIOによるプリコンパイルのハングを修正する</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/backtraces/index.html">Reporting and analyzing crashes (segfaults)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/backtraces/index.html">クラッシュ（セグメンテーションフォルト）の報告と分析</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdb debugging tips</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/debuggingtips/index.html">gdbデバッグのヒント</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/valgrind/index.html">Using Valgrind with Julia</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/valgrind/index.html">JuliaでValgrindを使用する</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/external_profilers/index.html">External Profiler Support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/external_profilers/index.html">外部プロファイラのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/sanitizers/index.html">Sanitizer support</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/sanitizers/index.html">サニタイザーのサポート</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/probes/index.html">Instrumenting Julia with DTrace, and bpftrace</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/probes/index.html">DTraceおよびbpftraceを使用したJuliaの計測</a></span></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/build/index.html">Building Julia (Detailed)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/build/index.html">Juliaのビルド（詳細）</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/linux/index.html">Linux</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/macos/index.html">macOS</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/windows/index.html">Windows</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/freebsd/index.html">FreeBSD</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/arm/index.html">ARM (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/riscv/index.html">RISC-V (Linux)</a></span></li><li data-translated="true"><span class="original-text"><a class="tocitem" href="../../devdocs/build/distributing/index.html">Binary distributions</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="tocitem" href="../../devdocs/build/distributing/index.html">バイナリ配布</a></span></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li data-translated="true"><span class="original-text"><a class="is-disabled">Manual</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="is-disabled">マニュアル</a></span></li><li class="is-active" data-translated="true"><span class="original-text"><a href="">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">文字列</a></span></li></ul><ul class="is-hidden-tablet"><li class="is-active" data-translated="true"><span class="original-text"><a href="">Strings</a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="">文字列</a></span></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/strings.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-strings" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-strings">Strings</a><a id="man-strings-1"></a><a class="docs-heading-anchor-permalink" href="#man-strings" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-strings">文字列</a><a id="man-strings-1"></a><a class="docs-heading-anchor-permalink" href="#man-strings" title="Permalink"></a></span></h1><p data-translated="true"><span class="original-text">Strings are finite sequences of characters. Of course, the real trouble comes when one asks what a character is. The characters that English speakers are familiar with are the letters <code>A</code>, <code>B</code>, <code>C</code>, etc., together with numerals and common punctuation symbols. These characters are standardized together with a mapping to integer values between 0 and 127 by the <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> standard. There are, of course, many other characters used in non-English languages, including variants of the ASCII characters with accents and other modifications, related scripts such as Cyrillic and Greek, and scripts completely unrelated to ASCII and English, including Arabic, Chinese, Hebrew, Hindi, Japanese, and Korean. The <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> standard tackles the complexities of what exactly a character is, and is generally accepted as the definitive standard addressing this problem. Depending on your needs, you can either ignore these complexities entirely and just pretend that only ASCII characters exist, or you can write code that can handle any of the characters or encodings that one may encounter when handling non-ASCII text. Julia makes dealing with plain ASCII text simple and efficient, and handling Unicode is as simple and efficient as possible. In particular, you can write C-style string code to process ASCII strings, and they will work as expected, both in terms of performance and semantics. If such code encounters non-ASCII text, it will gracefully fail with a clear error message, rather than silently introducing corrupt results. When this happens, modifying the code to handle non-ASCII data is straightforward.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列は有限の文字の列です。もちろん、実際の問題は「文字とは何か」と尋ねるときに発生します。英語話者が馴染みのある文字は、<code>A</code>、<code>B</code>、<code>C</code>などの文字、数字、一般的な句読点記号です。これらの文字は、<a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>標準によって、0から127の整数値へのマッピングとともに標準化されています。もちろん、アクセントやその他の修正を加えたASCII文字のバリエーション、キリル文字やギリシャ文字などの関連スクリプト、アラビア語、中国語、ヘブライ語、ヒンディー語、日本語、韓国語など、ASCIIや英語とは完全に無関係なスクリプトを含む、他の多くの文字が非英語の言語で使用されています。<a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>標準は、文字とは正確に何かという複雑さに取り組み、この問題に対処するための決定的な標準として一般的に受け入れられています。ニーズに応じて、これらの複雑さを完全に無視してASCII文字のみが存在するかのように振る舞うことも、非ASCIIテキストを扱う際に遭遇する可能性のある任意の文字やエンコーディングを処理できるコードを書くこともできます。JuliaはプレーンなASCIIテキストの取り扱いを簡単かつ効率的にし、Unicodeの処理もできる限り簡単かつ効率的です。特に、Cスタイルの文字列コードを書いてASCII文字列を処理することができ、パフォーマンスと意味論の両方において期待通りに動作します。そのようなコードが非ASCIIテキストに遭遇した場合、明確なエラーメッセージで優雅に失敗し、静かに破損した結果を導入することはありません。この場合、非ASCIIデータを処理するようにコードを修正するのは簡単です。</span></p><p data-translated="true"><span class="original-text">There are a few noteworthy high-level features about Julia's strings:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaの文字列に関するいくつかの注目すべき高レベルの特徴があります：</span></p><ul><li data-translated="true"><span class="original-text">The built-in concrete type used for strings (and string literals) in Julia is <a href="../../base/strings/index.html#Core.String-Tuple{AbstractString}"><code>String</code></a>. This supports the full range of <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> characters via the <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> encoding. (A <a href="../../base/strings/index.html#Base.transcode"><code>transcode</code></a> function is provided to convert to/from other Unicode encodings.)</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaで文字列（および文字列リテラル）に使用される組み込みの具体的な型は<a href="../../base/strings/index.html#Core.String-Tuple{AbstractString}"><code>String</code></a>です。これは、<a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>文字の全範囲を<a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>エンコーディングを介してサポートします。（他のUnicodeエンコーディングへの変換のために<a href="../../base/strings/index.html#Base.transcode"><code>transcode</code></a>関数が提供されています。）</span></li><li data-translated="true"><span class="original-text">All string types are subtypes of the abstract type <code>AbstractString</code>, and external packages define additional <code>AbstractString</code> subtypes (e.g. for other encodings). If you define a function expecting a string argument, you should declare the type as <code>AbstractString</code> in order to accept any string type.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべての文字列型は抽象型<code>AbstractString</code>のサブタイプであり、外部パッケージは追加の<code>AbstractString</code>サブタイプ（例えば、他のエンコーディング用）を定義します。文字列引数を期待する関数を定義する場合は、任意の文字列型を受け入れるために型を<code>AbstractString</code>として宣言する必要があります。</span></li><li data-translated="true"><span class="original-text">Like C and Java, but unlike most dynamic languages, Julia has a first-class type for representing a single character, called <a href="../../base/strings/index.html#Core.AbstractChar"><code>AbstractChar</code></a>. The built-in <a href="../../base/strings/index.html#Core.Char"><code>Char</code></a> subtype of <code>AbstractChar</code> is a 32-bit primitive type that can represent any Unicode character (and which is based on the UTF-8 encoding).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">CやJavaと同様に、ほとんどの動的言語とは異なり、Juliaには単一の文字を表すためのファーストクラスの型があり、これを<a href="../../base/strings/index.html#Core.AbstractChar"><code>AbstractChar</code></a>と呼びます。組み込みの<a href="../../base/strings/index.html#Core.Char"><code>Char</code></a>サブタイプは<code>AbstractChar</code>の32ビットのプリミティブ型で、任意のUnicode文字を表すことができ（UTF-8エンコーディングに基づいています）。</span></li><li data-translated="true"><span class="original-text">As in Java, strings are immutable: the value of an <code>AbstractString</code> object cannot be changed. To construct a different string value, you construct a new string from parts of other strings.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Javaと同様に、文字列は不変です：<code>AbstractString</code>オブジェクトの値は変更できません。異なる文字列値を構築するには、他の文字列の部分から新しい文字列を構築します。</span></li><li data-translated="true"><span class="original-text">Conceptually, a string is a <em>partial function</em> from indices to characters: for some index values, no character value is returned, and instead an exception is thrown. This allows for efficient indexing into strings by the byte index of an encoded representation rather than by a character index, which cannot be implemented both efficiently and simply for variable-width encodings of Unicode strings.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">概念的には、文字列はインデックスから文字への<em>部分関数</em>です：いくつかのインデックス値に対しては、文字値が返されず、代わりに例外がスローされます。これにより、Unicode文字列の可変幅エンコーディングに対して効率的かつ単純に実装できない文字インデックスではなく、エンコードされた表現のバイトインデックスによる文字列への効率的なインデックス付けが可能になります。</span></li></ul><h2 id="man-characters" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-characters">Characters</a><a id="man-characters-1"></a><a class="docs-heading-anchor-permalink" href="#man-characters" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-characters">文字</a><a id="man-characters-1"></a><a class="docs-heading-anchor-permalink" href="#man-characters" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">A <code>Char</code> value represents a single character: it is just a 32-bit primitive type with a special literal representation and appropriate arithmetic behaviors, and which can be converted to a numeric value representing a <a href="https://en.wikipedia.org/wiki/Code_point">Unicode code point</a>.  (Julia packages may define other subtypes of <code>AbstractChar</code>, e.g. to optimize operations for other <a href="https://en.wikipedia.org/wiki/Character_encoding">text encodings</a>.) Here is how <code>Char</code> values are input and shown (note that character literals are delimited with single quotes, not double quotes):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Char</code>値は単一の文字を表します：これは特別なリテラル表現と適切な算術動作を持つ32ビットのプリミティブ型であり、<a href="https://en.wikipedia.org/wiki/Code_point">Unicodeコードポイント</a>を表す数値に変換できます。（Juliaパッケージは、他の<a href="https://en.wikipedia.org/wiki/Character_encoding">テキストエンコーディング</a>の操作を最適化するために、<code>AbstractChar</code>の他のサブタイプを定義することがあります。）ここでは、<code>Char</code>値の入力と表示の方法を示します（文字リテラルは二重引用符ではなく単一引用符で区切られていることに注意してください）：</span></p><pre><code class="language-julia-repl hljs">julia&gt; c = 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; typeof(c)
Char</code></pre><p data-translated="true"><span class="original-text">You can easily convert a <code>Char</code> to its integer value, i.e. code point:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Char</code>をその整数値、すなわちコードポイントに簡単に変換できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; c = Int('x')
120

julia&gt; typeof(c)
Int64</code></pre><p data-translated="true"><span class="original-text">On 32-bit architectures, <a href="../../base/base/index.html#Core.typeof"><code>typeof(c)</code></a> will be <a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a>. You can convert an integer value back to a <code>Char</code> just as easily:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">32ビットアーキテクチャでは、<a href="../../base/base/index.html#Core.typeof"><code>typeof(c)</code></a>は<a href="../../base/numbers/index.html#Core.Int32"><code>Int32</code></a>になります。整数値を<code>Char</code>に戻すのも同様に簡単です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Char(120)
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)</code></pre><p data-translated="true"><span class="original-text">Not all integer values are valid Unicode code points, but for performance, the <code>Char</code> conversion does not check that every character value is valid. If you want to check that each converted value is a valid code point, use the <a href="../../base/strings/index.html#Base.isvalid-Tuple{Any}"><code>isvalid</code></a> function:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">すべての整数値が有効なUnicodeコードポイントであるわけではありませんが、パフォーマンスのために、<code>Char</code>変換はすべての文字値が有効であるかどうかをチェックしません。変換された各値が有効なコードポイントであることを確認したい場合は、<a href="../../base/strings/index.html#Base.isvalid-Tuple{Any}"><code>isvalid</code></a>関数を使用してください：</span></p><pre><code class="language-julia-repl hljs">julia&gt; Char(0x110000)
'\U110000': Unicode U+110000 (category In: Invalid, too high)

julia&gt; isvalid(Char, 0x110000)
false</code></pre><p data-translated="true"><span class="original-text">As of this writing, the valid Unicode code points are <code>U+0000</code> through <code>U+D7FF</code> and <code>U+E000</code> through <code>U+10FFFF</code>. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">執筆時点で、有効なUnicodeコードポイントは<code>U+0000</code>から<code>U+D7FF</code>および<code>U+E000</code>から<code>U+10FFFF</code>です。これらはすべて理解可能な意味が割り当てられているわけではなく、アプリケーションによって解釈可能であるとも限りませんが、これらの値はすべて有効なUnicode文字と見なされます。</span></p><p data-translated="true"><span class="original-text">You can input any Unicode character in single quotes using <code>\u</code> followed by up to four hexadecimal digits or <code>\U</code> followed by up to eight hexadecimal digits (the longest valid value only requires six):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">任意のUnicode文字を単一引用符で入力することができ、<code>\u</code>の後に最大4桁の16進数を、または<code>\U</code>の後に最大8桁の16進数を続けて入力できます（最も長い有効値は6桁のみを必要とします）：</span></p><pre><code class="language-julia-repl hljs">julia&gt; '\u0'
'\0': ASCII/Unicode U+0000 (category Cc: Other, control)

julia&gt; '\u78'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; '\u2200'
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia&gt; '\U10ffff'
'\U10ffff': Unicode U+10FFFF (category Cn: Other, not assigned)</code></pre><p data-translated="true"><span class="original-text">Julia uses your system's locale and language settings to determine which characters can be printed as-is and which must be output using the generic, escaped <code>\u</code> or <code>\U</code> input forms. In addition to these Unicode escape forms, all of <a href="https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes#Backslash_escapes">C's traditional escaped input forms</a> can also be used:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは、システムのロケールと言語設定を使用して、どの文字をそのまま印刷できるか、どの文字を一般的なエスケープ形式で出力する必要があるかを判断します。これらのUnicodeエスケープ形式に加えて、すべての<a href="https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes#Backslash_escapes">Cの従来のエスケープ入力形式</a>も使用できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; Int('\0')
0

julia&gt; Int('\t')
9

julia&gt; Int('\n')
10

julia&gt; Int('\e')
27

julia&gt; Int('\x7f')
127

julia&gt; Int('\177')
127</code></pre><p data-translated="true"><span class="original-text">You can do comparisons and a limited amount of arithmetic with <code>Char</code> values:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">あなたは<code>Char</code>値を使って比較や限られた量の算術を行うことができます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; 'A' &lt; 'a'
true

julia&gt; 'A' &lt;= 'a' &lt;= 'Z'
false

julia&gt; 'A' &lt;= 'X' &lt;= 'Z'
true

julia&gt; 'x' - 'a'
23

julia&gt; 'A' + 1
'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)</code></pre><h2 id="String-Basics" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#String-Basics">String Basics</a><a id="String-Basics-1"></a><a class="docs-heading-anchor-permalink" href="#String-Basics" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#String-Basics">文字列の基本</a><a id="String-Basics-1"></a><a class="docs-heading-anchor-permalink" href="#String-Basics" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">String literals are delimited by double quotes or triple double quotes (not single quotes):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列リテラルは二重引用符または三重の二重引用符（単一引用符ではなく）で区切られます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; str = "Hello, world.\n"
"Hello, world.\n"

julia&gt; """Contains "quote" characters"""
"Contains \"quote\" characters"</code></pre><p data-translated="true"><span class="original-text">Long lines in strings can be broken up by preceding the newline with a backslash (<code>\</code>):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列内の長い行は、改行の前にバックスラッシュ（<code>\</code>）を置くことで分割できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; "This is a long \
       line"
"This is a long line"</code></pre><p data-translated="true"><span class="original-text">If you want to extract a character from a string, you index into it:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列から文字を抽出したい場合は、インデックスを使用します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; str[begin]
'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia&gt; str[1]
'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia&gt; str[6]
',': ASCII/Unicode U+002C (category Po: Punctuation, other)

julia&gt; str[end]
'\n': ASCII/Unicode U+000A (category Cc: Other, control)</code></pre><p data-translated="true"><span class="original-text">Many Julia objects, including strings, can be indexed with integers. The index of the first element (the first character of a string) is returned by <a href="../../base/collections/index.html#Base.firstindex"><code>firstindex(str)</code></a>, and the index of the last element (character) with <a href="../../base/collections/index.html#Base.lastindex"><code>lastindex(str)</code></a>. The keywords <code>begin</code> and <code>end</code> can be used inside an indexing operation as shorthand for the first and last indices, respectively, along the given dimension. String indexing, like most indexing in Julia, is 1-based: <code>firstindex</code> always returns <code>1</code> for any <code>AbstractString</code>. As we will see below, however, <code>lastindex(str)</code> is <em>not</em> in general the same as <code>length(str)</code> for a string, because some Unicode characters can occupy multiple "code units".</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">多くのJuliaオブジェクト、特に文字列は整数でインデックス指定できます。最初の要素（文字列の最初の文字）のインデックスは<a href="../../base/collections/index.html#Base.firstindex"><code>firstindex(str)</code></a>によって返され、最後の要素（文字）のインデックスは<a href="../../base/collections/index.html#Base.lastindex"><code>lastindex(str)</code></a>によって返されます。キーワード<code>begin</code>と<code>end</code>は、指定された次元に沿った最初と最後のインデックスの省略形としてインデックス操作内で使用できます。文字列のインデックス指定は、Juliaのほとんどのインデックス指定と同様に1ベースです：<code>firstindex</code>は、任意の<code>AbstractString</code>に対して常に<code>1</code>を返します。しかし、以下で見るように、<code>lastindex(str)</code>は一般的には<code>length(str)</code>と同じではありません。なぜなら、一部のUnicode文字は複数の「コードユニット」を占有することができるからです。</span></p><p data-translated="true"><span class="original-text">You can perform arithmetic and other operations with <a href="../../base/base/index.html#end"><code>end</code></a>, just like a normal value:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/base/index.html#end"><code>end</code></a>を通常の値のように使って算術や他の操作を行うことができます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; str[end-1]
'.': ASCII/Unicode U+002E (category Po: Punctuation, other)

julia&gt; str[end÷2]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)</code></pre><p data-translated="true"><span class="original-text">Using an index less than <code>begin</code> (<code>1</code>) or greater than <code>end</code> raises an error:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>begin</code>（<code>1</code>）未満または<code>end</code>を超えるインデックスを使用するとエラーが発生します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; str[begin-1]
ERROR: BoundsError: attempt to access 14-codeunit String at index [0]
[...]

julia&gt; str[end+1]
ERROR: BoundsError: attempt to access 14-codeunit String at index [15]
[...]</code></pre><p data-translated="true"><span class="original-text">You can also extract a substring using range indexing:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">範囲インデックスを使用して部分文字列を抽出することもできます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; str[4:9]
"lo, wo"</code></pre><p data-translated="true"><span class="original-text">Notice that the expressions <code>str[k]</code> and <code>str[k:k]</code> do not give the same result:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">式 <code>str[k]</code> と <code>str[k:k]</code> が同じ結果を返さないことに注意してください：</span></p><pre><code class="language-julia-repl hljs">julia&gt; str[6]
',': ASCII/Unicode U+002C (category Po: Punctuation, other)

julia&gt; str[6:6]
","</code></pre><p data-translated="true"><span class="original-text">The former is a single character value of type <code>Char</code>, while the latter is a string value that happens to contain only a single character. In Julia these are very different things.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">前者は <code>Char</code> 型の単一文字の値であり、後者は単一の文字のみを含む文字列の値です。Julia では、これらは非常に異なるものです。</span></p><p data-translated="true"><span class="original-text">Range indexing makes a copy of the selected part of the original string. Alternatively, it is possible to create a view into a string using the type <a href="../../base/strings/index.html#Base.SubString"><code>SubString</code></a>. More simply, using the <a href="../../base/arrays/index.html#Base.@views"><code>@views</code></a> macro on a block of code converts all string slices into substrings. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">範囲インデックスは、元の文字列の選択された部分のコピーを作成します。あるいは、<a href="../../base/strings/index.html#Base.SubString"><code>SubString</code></a> 型を使用して文字列へのビューを作成することも可能です。より簡単には、コードブロックに <a href="../../base/arrays/index.html#Base.@views"><code>@views</code></a> マクロを使用すると、すべての文字列スライスがサブ文字列に変換されます。例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; str = "long string"
"long string"

julia&gt; substr = SubString(str, 1, 4)
"long"

julia&gt; typeof(substr)
SubString{String}

julia&gt; @views typeof(str[1:4]) # @views converts slices to SubStrings
SubString{String}</code></pre><p data-translated="true"><span class="original-text">Several standard functions like <a href="../../base/strings/index.html#Base.chop"><code>chop</code></a>, <a href="../../base/strings/index.html#Base.chomp"><code>chomp</code></a> or <a href="../../base/strings/index.html#Base.strip"><code>strip</code></a> return a <a href="../../base/strings/index.html#Base.SubString"><code>SubString</code></a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">いくつかの標準関数（<a href="../../base/strings/index.html#Base.chop"><code>chop</code></a>、<a href="../../base/strings/index.html#Base.chomp"><code>chomp</code></a>、または <a href="../../base/strings/index.html#Base.strip"><code>strip</code></a> など）は <a href="../../base/strings/index.html#Base.SubString"><code>SubString</code></a> を返します。</span></p><h2 id="Unicode-and-UTF-8" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Unicode-and-UTF-8">Unicode and UTF-8</a><a id="Unicode-and-UTF-8-1"></a><a class="docs-heading-anchor-permalink" href="#Unicode-and-UTF-8" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Unicode-and-UTF-8">Unicode と UTF-8</a><a id="Unicode-and-UTF-8-1"></a><a class="docs-heading-anchor-permalink" href="#Unicode-and-UTF-8" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Julia fully supports Unicode characters and strings. As <a href="#man-characters">discussed above</a>, in character literals, Unicode code points can be represented using Unicode <code>\u</code> and <code>\U</code> escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia は Unicode 文字と文字列を完全にサポートしています。<a href="#man-characters">上で説明したように</a>、文字リテラルでは、Unicode コードポイントは Unicode <code>\u</code> および <code>\U</code> エスケープシーケンス、ならびにすべての標準 C エスケープシーケンスを使用して表現できます。これらは文字列リテラルを書くためにも使用できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; s = "\u2200 x \u2203 y"
"∀ x ∃ y"</code></pre><p data-translated="true"><span class="original-text">Whether these Unicode characters are displayed as escapes or shown as special characters depends on your terminal's locale settings and its support for Unicode. String literals are encoded using the UTF-8 encoding. UTF-8 is a variable-width encoding, meaning that not all characters are encoded in the same number of bytes ("code units"). In UTF-8, ASCII characters — i.e. those with code points less than 0x80 (128) – are encoded as they are in ASCII, using a single byte, while code points 0x80 and above are encoded using multiple bytes — up to four per character.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらの Unicode 文字がエスケープとして表示されるか、特別な文字として表示されるかは、ターミナルのロケール設定と Unicode のサポートに依存します。文字列リテラルは UTF-8 エンコーディングを使用してエンコードされます。UTF-8 は可変幅エンコーディングであり、すべての文字が同じバイト数（「コードユニット」）でエンコードされるわけではありません。UTF-8 では、ASCII 文字（すなわち、コードポイントが 0x80（128）未満の文字）は、ASCII と同様に単一バイトでエンコードされ、コードポイント 0x80 以上は複数バイト（最大 4 バイト）でエンコードされます。</span></p><p data-translated="true"><span class="original-text">String indices in Julia refer to code units (= bytes for UTF-8), the fixed-width building blocks that are used to encode arbitrary characters (code points). This means that not every index into a <code>String</code> is necessarily a valid index for a character. If you index into a string at such an invalid byte index, an error is thrown:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia の文字列インデックスはコードユニット（UTF-8 のバイト）を指し、任意の文字（コードポイント）をエンコードするために使用される固定幅の構成要素です。これは、<code>String</code> へのすべてのインデックスが必ずしも文字の有効なインデックスであるとは限らないことを意味します。無効なバイトインデックスで文字列にインデックスを付けると、エラーが発生します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; s[1]
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia&gt; s[2]
ERROR: StringIndexError: invalid index [2], valid nearby indices [1]=&gt;'∀', [4]=&gt;' '
Stacktrace:
[...]

julia&gt; s[3]
ERROR: StringIndexError: invalid index [3], valid nearby indices [1]=&gt;'∀', [4]=&gt;' '
Stacktrace:
[...]

julia&gt; s[4]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)</code></pre><p data-translated="true"><span class="original-text">In this case, the character <code>∀</code> is a three-byte character, so the indices 2 and 3 are invalid and the next character's index is 4; this next valid index can be computed by <a href="../../base/arrays/index.html#Base.nextind"><code>nextind(s,1)</code></a>, and the next index after that by <code>nextind(s,4)</code> and so on.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この場合、文字 <code>∀</code> は 3 バイトの文字であるため、インデックス 2 と 3 は無効であり、次の文字のインデックスは 4 です。この次の有効なインデックスは <a href="../../base/arrays/index.html#Base.nextind"><code>nextind(s,1)</code></a> によって計算でき、その次のインデックスは <code>nextind(s,4)</code> などによって計算できます。</span></p><p data-translated="true"><span class="original-text">Since <code>end</code> is always the last valid index into a collection, <code>end-1</code> references an invalid byte index if the second-to-last character is multibyte.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>end</code> は常にコレクションへの最後の有効なインデックスであるため、<code>end-1</code> は、最後から 2 番目の文字がマルチバイトの場合、無効なバイトインデックスを参照します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; s[end-1]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)

julia&gt; s[end-2]
ERROR: StringIndexError: invalid index [9], valid nearby indices [7]=&gt;'∃', [10]=&gt;' '
Stacktrace:
[...]

julia&gt; s[prevind(s, end, 2)]
'∃': Unicode U+2203 (category Sm: Symbol, math)</code></pre><p data-translated="true"><span class="original-text">The first case works, because the last character <code>y</code> and the space are one-byte characters, whereas <code>end-2</code> indexes into the middle of the <code>∃</code> multibyte representation. The correct way for this case is using <code>prevind(s, lastindex(s), 2)</code> or, if you're using that value to index into <code>s</code> you can write <code>s[prevind(s, end, 2)]</code> and <code>end</code> expands to <code>lastindex(s)</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初のケースは機能します。なぜなら、最後の文字 <code>y</code> とスペースは1バイトの文字であり、<code>end-2</code> は <code>∃</code> のマルチバイト表現の中間にインデックスを付けるからです。このケースの正しい方法は <code>prevind(s, lastindex(s), 2)</code> を使用するか、その値を <code>s</code> にインデックスするために使用する場合は <code>s[prevind(s, end, 2)]</code> と書くことができ、<code>end</code> は <code>lastindex(s)</code> に展開されます。</span></p><p data-translated="true"><span class="original-text">Extraction of a substring using range indexing also expects valid byte indices or an error is thrown:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">範囲インデックスを使用したサブストリングの抽出も、有効なバイトインデックスを期待します。そうでない場合はエラーが発生します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; s[1:1]
"∀"

julia&gt; s[1:2]
ERROR: StringIndexError: invalid index [2], valid nearby indices [1]=&gt;'∀', [4]=&gt;' '
Stacktrace:
[...]

julia&gt; s[1:4]
"∀ "</code></pre><p data-translated="true"><span class="original-text">Because of variable-length encodings, the number of characters in a string (given by <a href="../../base/arrays/index.html#Base.length-Tuple{AbstractArray}"><code>length(s)</code></a>) is not always the same as the last index. If you iterate through the indices 1 through <a href="../../base/collections/index.html#Base.lastindex"><code>lastindex(s)</code></a> and index into <code>s</code>, the sequence of characters returned when errors aren't thrown is the sequence of characters comprising the string <code>s</code>. Thus <code>length(s) &lt;= lastindex(s)</code>, since each character in a string must have its own index. The following is an inefficient and verbose way to iterate through the characters of <code>s</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">可変長エンコーディングのため、文字列内の文字数（<a href="../../base/arrays/index.html#Base.length-Tuple{AbstractArray}"><code>length(s)</code></a> で示される）は、必ずしも最後のインデックスと同じではありません。インデックス 1 から <a href="../../base/collections/index.html#Base.lastindex"><code>lastindex(s)</code></a> までを反復し、<code>s</code> にインデックスを付けると、エラーが発生しない場合に返される文字のシーケンスは、文字列 <code>s</code> を構成する文字のシーケンスです。したがって、<code>length(s) &lt;= lastindex(s)</code> です。文字列内の各文字は独自のインデックスを持たなければなりません。以下は、<code>s</code> の文字を反復するための非効率的で冗長な方法です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; for i = firstindex(s):lastindex(s)
           try
               println(s[i])
           catch
               # ignore the index error
           end
       end
∀

x

∃

y</code></pre><p data-translated="true"><span class="original-text">The blank lines actually have spaces on them. Fortunately, the above awkward idiom is unnecessary for iterating through the characters in a string, since you can just use the string as an iterable object, no exception handling required:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">空白行には実際にスペースがあります。幸いなことに、上記の不格好なイディオムは、文字列内の文字を反復するためには不要です。文字列をイテラブルオブジェクトとして使用するだけで、例外処理は必要ありません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; for c in s
           println(c)
       end
∀

x

∃

y</code></pre><p data-translated="true"><span class="original-text">If you need to obtain valid indices for a string, you can use the <a href="../../base/arrays/index.html#Base.nextind"><code>nextind</code></a> and <a href="../../base/arrays/index.html#Base.prevind"><code>prevind</code></a> functions to increment/decrement to the next/previous valid index, as mentioned above. You can also use the <a href="../../base/arrays/index.html#Base.eachindex"><code>eachindex</code></a> function to iterate over the valid character indices:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列の有効なインデックスを取得する必要がある場合は、上記で述べたように <a href="../../base/arrays/index.html#Base.nextind"><code>nextind</code></a> および <a href="../../base/arrays/index.html#Base.prevind"><code>prevind</code></a> 関数を使用して次の/前の有効なインデックスにインクリメント/デクリメントできます。また、<a href="../../base/arrays/index.html#Base.eachindex"><code>eachindex</code></a> 関数を使用して有効な文字インデックスを反復することもできます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; collect(eachindex(s))
7-element Vector{Int64}:
  1
  4
  5
  6
  7
 10
 11</code></pre><p data-translated="true"><span class="original-text">To access the raw code units (bytes for UTF-8) of the encoding, you can use the <a href="../../base/strings/index.html#Base.codeunit"><code>codeunit(s,i)</code></a> function, where the index <code>i</code> runs consecutively from <code>1</code> to <a href="../../base/strings/index.html#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits(s)</code></a>. The <a href="../../base/strings/index.html#Base.codeunits"><code>codeunits(s)</code></a> function returns an <code>AbstractVector{UInt8}</code> wrapper that lets you access these raw codeunits (bytes) as an array.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">エンコーディングの生のコードユニット（UTF-8 のバイト）にアクセスするには、<a href="../../base/strings/index.html#Base.codeunit"><code>codeunit(s,i)</code></a> 関数を使用できます。ここで、インデックス <code>i</code> は <code>1</code> から <a href="../../base/strings/index.html#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits(s)</code></a> まで連続して実行されます。<a href="../../base/strings/index.html#Base.codeunits"><code>codeunits(s)</code></a> 関数は、これらの生のコードユニット（バイト）に配列としてアクセスできる <code>AbstractVector{UInt8}</code> ラッパーを返します。</span></p><p data-translated="true"><span class="original-text">Strings in Julia can contain invalid UTF-8 code unit sequences. This convention allows to treat any byte sequence as a <code>String</code>. In such situations a rule is that when parsing a sequence of code units from left to right characters are formed by the longest sequence of 8-bit code units that matches the start of one of the following bit patterns (each <code>x</code> can be <code>0</code> or <code>1</code>):</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Julia の文字列には無効な UTF-8 コードユニットシーケンスが含まれている可能性があります。この規約により、任意のバイトシーケンスを <code>String</code> として扱うことができます。そのような状況では、左から右にコードユニットのシーケンスを解析する際のルールは、次のビットパターンのいずれかの開始に一致する最長の8ビットコードユニットのシーケンスによって文字が形成されるというものです（各 <code>x</code> は <code>0</code> または <code>1</code> になり得ます）：</span></p><ul><li data-translated="true"><span class="original-text"><code>0xxxxxxx</code>;</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>0xxxxxxx</code>;</span></li><li data-translated="true"><span class="original-text"><code>110xxxxx</code> <code>10xxxxxx</code>;</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>110xxxxx</code> <code>10xxxxxx</code>;</span></li><li data-translated="true"><span class="original-text"><code>1110xxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code>;</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>1110xxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code>;</span></li><li data-translated="true"><span class="original-text"><code>11110xxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code>;</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>11110xxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code>;</span></li><li data-translated="true"><span class="original-text"><code>10xxxxxx</code>;</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>10xxxxxx</code>;</span></li><li data-translated="true"><span class="original-text"><code>11111xxx</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>11111xxx</code>.</span></li></ul><p data-translated="true"><span class="original-text">In particular this means that overlong and too-high code unit sequences and prefixes thereof are treated as a single invalid character rather than multiple invalid characters. This rule may be best explained with an example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特に、これは過長および高すぎるコードユニットシーケンスとその接頭辞が、複数の無効な文字ではなく、単一の無効な文字として扱われることを意味します。このルールは、例を用いて説明するのが最も良いかもしれません：</span></p><pre><code class="language-julia-repl hljs">julia&gt; s = "\xc0\xa0\xe2\x88\xe2|"
"\xc0\xa0\xe2\x88\xe2|"

julia&gt; foreach(display, s)
'\xc0\xa0': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)
'\xe2\x88': Malformed UTF-8 (category Ma: Malformed, bad data)
'\xe2': Malformed UTF-8 (category Ma: Malformed, bad data)
'|': ASCII/Unicode U+007C (category Sm: Symbol, math)

julia&gt; isvalid.(collect(s))
4-element BitArray{1}:
 0
 0
 0
 1

julia&gt; s2 = "\xf7\xbf\xbf\xbf"
"\U1fffff"

julia&gt; foreach(display, s2)
'\U1fffff': Unicode U+1FFFFF (category In: Invalid, too high)</code></pre><p data-translated="true"><span class="original-text">We can see that the first two code units in the string <code>s</code> form an overlong encoding of space character. It is invalid, but is accepted in a string as a single character. The next two code units form a valid start of a three-byte UTF-8 sequence. However, the fifth code unit <code>\xe2</code> is not its valid continuation. Therefore code units 3 and 4 are also interpreted as malformed characters in this string. Similarly code unit 5 forms a malformed character because <code>|</code> is not a valid continuation to it. Finally the string <code>s2</code> contains one too high code point.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列<code>s</code>の最初の2つのコードユニットは、スペース文字の過長エンコーディングを形成しています。これは無効ですが、文字列内では単一の文字として受け入れられます。次の2つのコードユニットは、3バイトのUTF-8シーケンスの有効な開始を形成します。しかし、5番目のコードユニット<code>\xe2</code>は、その有効な継続ではありません。したがって、コードユニット3と4もこの文字列では不正な文字として解釈されます。同様に、コードユニット5は不正な文字を形成します。なぜなら、<code>|</code>はそれに対する有効な継続ではないからです。最後に、文字列<code>s2</code>には1つの高すぎるコードポイントが含まれています。</span></p><p data-translated="true"><span class="original-text">Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the <a href="https://github.com/JuliaStrings/LegacyStrings.jl">LegacyStrings.jl</a> package implements <code>UTF16String</code> and <code>UTF32String</code> types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on <a href="#man-byte-array-literals">byte array literals</a>. The <a href="../../base/strings/index.html#Base.transcode"><code>transcode</code></a> function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">JuliaはデフォルトでUTF-8エンコーディングを使用しており、新しいエンコーディングのサポートはパッケージによって追加できます。例えば、<a href="https://github.com/JuliaStrings/LegacyStrings.jl">LegacyStrings.jl</a>パッケージは<code>UTF16String</code>および<code>UTF32String</code>タイプを実装しています。他のエンコーディングに関する追加の議論や、それらのサポートを実装する方法は、現時点ではこの文書の範囲を超えています。UTF-8エンコーディングの問題についてのさらなる議論は、以下の<a href="#man-byte-array-literals">バイト配列リテラル</a>に関するセクションを参照してください。<a href="../../base/strings/index.html#Base.transcode"><code>transcode</code></a>関数は、主に外部データやライブラリと作業するために、さまざまなUTF-xxエンコーディング間でデータを変換するために提供されています。</span></p><h2 id="man-concatenation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-concatenation">Concatenation</a><a id="man-concatenation-1"></a><a class="docs-heading-anchor-permalink" href="#man-concatenation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-concatenation">連結</a><a id="man-concatenation-1"></a><a class="docs-heading-anchor-permalink" href="#man-concatenation" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">One of the most common and useful string operations is concatenation:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最も一般的で便利な文字列操作の1つは連結です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; greet = "Hello"
"Hello"

julia&gt; whom = "world"
"world"

julia&gt; string(greet, ", ", whom, ".\n")
"Hello, world.\n"</code></pre><p data-translated="true"><span class="original-text">It's important to be aware of potentially dangerous situations such as concatenation of invalid UTF-8 strings. The resulting string may contain different characters than the input strings, and its number of characters may be lower than sum of numbers of characters of the concatenated strings, e.g.:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">無効なUTF-8文字列の連結のような潜在的に危険な状況に注意することが重要です。結果の文字列は、入力文字列とは異なる文字を含む可能性があり、その文字数は連結された文字列の文字数の合計よりも少なくなる場合があります。例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; a, b = "\xe2\x88", "\x80"
("\xe2\x88", "\x80")

julia&gt; c = string(a, b)
"∀"

julia&gt; collect.([a, b, c])
3-element Vector{Vector{Char}}:
 ['\xe2\x88']
 ['\x80']
 ['∀']

julia&gt; length.([a, b, c])
3-element Vector{Int64}:
 1
 1
 1</code></pre><p data-translated="true"><span class="original-text">This situation can happen only for invalid UTF-8 strings. For valid UTF-8 strings concatenation preserves all characters in strings and additivity of string lengths.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この状況は無効なUTF-8文字列に対してのみ発生する可能性があります。有効なUTF-8文字列の場合、連結は文字列内のすべての文字を保持し、文字列の長さの加算性を保ちます。</span></p><p data-translated="true"><span class="original-text">Julia also provides <a href="../../base/math/#Base.:*-Tuple{Any, Vararg{Any}}#Base.:*-Tuple{Any, Vararg{Any}}"><code>*</code></a> for string concatenation:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは文字列の連結のために<a href="../../base/math/#Base.:*-Tuple{Any, Vararg{Any}}#Base.:*-Tuple{Any, Vararg{Any}}"><code>*</code></a>も提供しています。</span></p><pre><code class="language-julia-repl hljs">julia&gt; greet * ", " * whom * ".\n"
"Hello, world.\n"</code></pre><p data-translated="true"><span class="original-text">While <code>*</code> may seem like a surprising choice to users of languages that provide <code>+</code> for string concatenation, this use of <code>*</code> has precedent in mathematics, particularly in abstract algebra.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>*</code>は文字列の連結のために<code>+</code>を提供する言語のユーザーには驚くべき選択に思えるかもしれませんが、この<code>*</code>の使用は数学、特に抽象代数において前例があります。</span></p><p data-translated="true"><span class="original-text">In mathematics, <code>+</code> usually denotes a <em>commutative</em> operation, where the order of the operands does not matter. An example of this is matrix addition, where <code>A + B == B + A</code> for any matrices <code>A</code> and <code>B</code> that have the same shape. In contrast, <code>*</code> typically denotes a <em>noncommutative</em> operation, where the order of the operands <em>does</em> matter. An example of this is matrix multiplication, where in general <code>A * B != B * A</code>. As with matrix multiplication, string concatenation is noncommutative: <code>greet * whom != whom * greet</code>. As such, <code>*</code> is a more natural choice for an infix string concatenation operator, consistent with common mathematical use.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">数学において、<code>+</code>は通常<em>可換</em>演算を示し、オペランドの順序は重要ではありません。これの例は行列の加算であり、同じ形状の任意の行列<code>A</code>と<code>B</code>に対して<code>A + B == B + A</code>が成り立ちます。対照的に、<code>*</code>は通常<em>非可換</em>演算を示し、オペランドの順序が<em>重要</em>です。これの例は行列の乗算であり、一般に<code>A * B != B * A</code>が成り立ちます。行列の乗算と同様に、文字列の連結も非可換です：<code>greet * whom != whom * greet</code>。したがって、<code>*</code>は一般的な数学的使用に一致した中置文字列連結演算子としてより自然な選択です。</span></p><p data-translated="true"><span class="original-text">More precisely, the set of all finite-length strings <em>S</em> together with the string concatenation operator <code>*</code> forms a <a href="https://en.wikipedia.org/wiki/Free_monoid">free monoid</a> (<em>S</em>, <code>*</code>). The identity element of this set is the empty string, <code>""</code>. Whenever a free monoid is not commutative, the operation is typically represented as <code>\cdot</code>, <code>*</code>, or a similar symbol, rather than <code>+</code>, which as stated usually implies commutativity.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">より正確には、すべての有限長文字列の集合<em>S</em>と文字列連結演算子<code>*</code>は<a href="https://en.wikipedia.org/wiki/Free_monoid">自由モノイド</a>(<em>S</em>, <code>*</code>)を形成します。この集合の単位元は空文字列<code>""</code>です。自由モノイドが可換でない場合、演算は通常<code>\cdot</code>、<code>*</code>、または類似の記号で表され、<code>+</code>は通常可換性を示唆します。</span></p><h2 id="string-interpolation" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#string-interpolation">Interpolation</a><a id="string-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#string-interpolation" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#string-interpolation">補間</a><a id="string-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#string-interpolation" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Constructing strings using concatenation can become a bit cumbersome, however. To reduce the need for these verbose calls to <a href="../../base/strings/index.html#Base.string"><code>string</code></a> or repeated multiplications, Julia allows interpolation into string literals using <code>$</code>, as in Perl:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ただし、連結を使用して文字列を構築することは少し面倒になることがあります。<a href="../../base/strings/index.html#Base.string"><code>string</code></a>への冗長な呼び出しや繰り返しの乗算の必要性を減らすために、JuliaはPerlのように文字列リテラルへの補間を<code>$</code>を使用して許可します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; greet = "Hello"; whom = "world";

julia&gt; "$greet, $whom.\n"
"Hello, world.\n"</code></pre><p data-translated="true"><span class="original-text">This is more readable and convenient and equivalent to the above string concatenation – the system rewrites this apparent single string literal into the call <code>string(greet, ", ", whom, ".\n")</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これはより読みやすく便利で、上記の文字列連結と同等です – システムはこの明らかな単一の文字列リテラルを呼び出し<code>string(greet, ", ", whom, ".\n")</code>に書き換えます。</span></p><p data-translated="true"><span class="original-text">The shortest complete expression after the <code>$</code> is taken as the expression whose value is to be interpolated into the string. Thus, you can interpolate any expression into a string using parentheses:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>$</code>の後の最短の完全な式が、文字列に補間される値を持つ式として取られます。したがって、括弧を使用して任意の式を文字列に補間できます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; "1 + 2 = $(1 + 2)"
"1 + 2 = 3"</code></pre><p data-translated="true"><span class="original-text">Both concatenation and string interpolation call <a href="../../base/strings/index.html#Base.string"><code>string</code></a> to convert objects into string form. However, <code>string</code> actually just returns the output of <a href="../../base/io-network/index.html#Base.print"><code>print</code></a>, so new types should add methods to <a href="../../base/io-network/index.html#Base.print"><code>print</code></a> or <a href="../../base/io-network/index.html#Base.show-Tuple{IO, Any}"><code>show</code></a> instead of <code>string</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">連結と文字列補間の両方が、オブジェクトを文字列形式に変換するために<a href="../../base/strings/index.html#Base.string"><code>string</code></a>を呼び出します。ただし、<code>string</code>は実際には<a href="../../base/io-network/index.html#Base.print"><code>print</code></a>の出力を返すだけなので、新しい型は<code>string</code>の代わりに<a href="../../base/io-network/index.html#Base.print"><code>print</code></a>または<a href="../../base/io-network/index.html#Base.show-Tuple{IO, Any}"><code>show</code></a>にメソッドを追加する必要があります。</span></p><p data-translated="true"><span class="original-text">Most non-<code>AbstractString</code> objects are converted to strings closely corresponding to how they are entered as literal expressions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ほとんどの非<code>AbstractString</code>オブジェクトは、リテラル式として入力された方法に密接に対応する文字列に変換されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; v = [1,2,3]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; "v: $v"
"v: [1, 2, 3]"</code></pre><p data-translated="true"><span class="original-text"><a href="../../base/strings/index.html#Base.string"><code>string</code></a> is the identity for <code>AbstractString</code> and <code>AbstractChar</code> values, so these are interpolated into strings as themselves, unquoted and unescaped:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/strings/index.html#Base.string"><code>string</code></a> は <code>AbstractString</code> と <code>AbstractChar</code> の値のアイデンティティであるため、これらは文字列にそのまま、引用符なしでエスケープなしで埋め込まれます。</span></p><pre><code class="language-julia-repl hljs">julia&gt; c = 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; "hi, $c"
"hi, x"</code></pre><p data-translated="true"><span class="original-text">To include a literal <code>$</code> in a string literal, escape it with a backslash:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列リテラルにリテラル <code>$</code> を含めるには、バックスラッシュでエスケープします。</span></p><pre><code class="language-julia-repl hljs">julia&gt; print("I have \$100 in my account.\n")
I have $100 in my account.</code></pre><h2 id="Triple-Quoted-String-Literals" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Triple-Quoted-String-Literals">Triple-Quoted String Literals</a><a id="Triple-Quoted-String-Literals-1"></a><a class="docs-heading-anchor-permalink" href="#Triple-Quoted-String-Literals" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Triple-Quoted-String-Literals">トリプルクオーテッド文字列リテラル</a><a id="Triple-Quoted-String-Literals-1"></a><a class="docs-heading-anchor-permalink" href="#Triple-Quoted-String-Literals" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">When strings are created using triple-quotes (<code>"""..."""</code>) they have some special behavior that can be useful for creating longer blocks of text.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">トリプルクオート (<code>"""..."""</code>) を使用して文字列が作成されると、長いテキストブロックを作成するのに便利な特別な動作があります。</span></p><p data-translated="true"><span class="original-text">First, triple-quoted strings are also dedented to the level of the least-indented line. This is useful for defining strings within code that is indented. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">まず、トリプルクオート文字列は、最もインデントが少ない行のレベルにデデントされます。これは、インデントされたコード内で文字列を定義するのに便利です。例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; str = """
           Hello,
           world.
         """
"  Hello,\n  world.\n"</code></pre><p data-translated="true"><span class="original-text">In this case the final (empty) line before the closing <code>"""</code> sets the indentation level.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この場合、閉じる <code>"""</code> の前の最終（空の）行がインデントレベルを設定します。</span></p><p data-translated="true"><span class="original-text">The dedentation level is determined as the longest common starting sequence of spaces or tabs in all lines, excluding the line following the opening <code>"""</code> and lines containing only spaces or tabs (the line containing the closing <code>"""</code> is always included). Then for all lines, excluding the text following the opening <code>"""</code>, the common starting sequence is removed (including lines containing only spaces and tabs if they start with this sequence), e.g.:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">デデントレベルは、開く <code>"""</code> の後の行と、スペースまたはタブのみを含む行を除外したすべての行における、スペースまたはタブの最長の共通の開始シーケンスとして決定されます（閉じる <code>"""</code> を含む行は常に含まれます）。次に、開く <code>"""</code> の後のテキストを除くすべての行に対して、共通の開始シーケンスが削除されます（このシーケンスで始まるスペースとタブのみを含む行も含む）、例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; """    This
         is
           a test"""
"    This\nis\n  a test"</code></pre><p data-translated="true"><span class="original-text">Next, if the opening <code>"""</code> is followed by a newline, the newline is stripped from the resulting string.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">次に、開く <code>"""</code> の後に改行が続く場合、その改行は結果の文字列から削除されます。</span></p><pre><code class="language-julia hljs">"""hello"""</code></pre><p data-translated="true"><span class="original-text">is equivalent to</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">は次のように等価です</span></p><pre><code class="language-julia hljs">"""
hello"""</code></pre><p data-translated="true"><span class="original-text">but</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">しかし</span></p><pre><code class="language-julia hljs">"""

hello"""</code></pre><p data-translated="true"><span class="original-text">will contain a literal newline at the beginning.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初にリテラルの改行が含まれます。</span></p><p data-translated="true"><span class="original-text">Stripping of the newline is performed after the dedentation. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">改行の削除は、デデンテーションの後に行われます。例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; """
         Hello,
         world."""
"Hello,\nworld."</code></pre><p data-translated="true"><span class="original-text">If the newline is removed using a backslash, dedentation will be respected as well:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">バックスラッシュを使用して改行を削除した場合、デデンテーションも尊重されます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; """
         Averylong\
         word"""
"Averylongword"</code></pre><p data-translated="true"><span class="original-text">Trailing whitespace is left unaltered.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">末尾の空白はそのまま残されます。</span></p><p data-translated="true"><span class="original-text">Triple-quoted string literals can contain <code>"</code> characters without escaping.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">三重引用符で囲まれた文字列リテラルは、エスケープせずに<code>"</code>文字を含むことができます。</span></p><p data-translated="true"><span class="original-text">Note that line breaks in literal strings, whether single- or triple-quoted, result in a newline (LF) character <code>\n</code> in the string, even if your editor uses a carriage return <code>\r</code> (CR) or CRLF combination to end lines. To include a CR in a string, use an explicit escape <code>\r</code>; for example, you can enter the literal string <code>"a CRLF line ending\r\n"</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">リテラル文字列内の改行は、単一引用符または三重引用符で囲まれていても、文字列内に改行（LF）文字<code>\n</code>を生成します。たとえエディタがキャリッジリターン<code>\r</code>（CR）またはCRLFの組み合わせを使用して行を終了させていてもです。文字列にCRを含めるには、明示的なエスケープ<code>\r</code>を使用します。例えば、リテラル文字列<code>"a CRLF line ending\r\n"</code>を入力できます。</span></p><h2 id="Common-Operations" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#Common-Operations">Common Operations</a><a id="Common-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Operations" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#Common-Operations">一般的な操作</a><a id="Common-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Operations" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">You can lexicographically compare strings using the standard comparison operators:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">標準の比較演算子を使用して、文字列を辞書式に比較できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; "abracadabra" &lt; "xylophone"
true

julia&gt; "abracadabra" == "xylophone"
false

julia&gt; "Hello, world." != "Goodbye, world."
true

julia&gt; "1 + 2 = 3" == "1 + 2 = $(1 + 2)"
true</code></pre><p data-translated="true"><span class="original-text">You can search for the index of a particular character using the <a href="../../base/arrays/index.html#Base.findfirst-Tuple{Any}"><code>findfirst</code></a> and <a href="../../base/arrays/index.html#Base.findlast-Tuple{Any}"><code>findlast</code></a> functions:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特定の文字のインデックスを検索するには、<a href="../../base/arrays/index.html#Base.findfirst-Tuple{Any}"><code>findfirst</code></a>および<a href="../../base/arrays/index.html#Base.findlast-Tuple{Any}"><code>findlast</code></a>関数を使用できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; findfirst('o', "xylophone")
4

julia&gt; findlast('o', "xylophone")
7

julia&gt; findfirst('z', "xylophone")</code></pre><p data-translated="true"><span class="original-text">You can start the search for a character at a given offset by using the functions <a href="../../base/arrays/index.html#Base.findnext-Tuple{Any, Integer}"><code>findnext</code></a> and <a href="../../base/arrays/index.html#Base.findprev-Tuple{Any, Integer}"><code>findprev</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">特定のオフセットから文字の検索を開始するには、<a href="../../base/arrays/index.html#Base.findnext-Tuple{Any, Integer}"><code>findnext</code></a>および<a href="../../base/arrays/index.html#Base.findprev-Tuple{Any, Integer}"><code>findprev</code></a>関数を使用します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; findnext('o', "xylophone", 1)
4

julia&gt; findnext('o', "xylophone", 5)
7

julia&gt; findprev('o', "xylophone", 5)
4

julia&gt; findnext('o', "xylophone", 8)</code></pre><p data-translated="true"><span class="original-text">You can use the <a href="../../base/strings/index.html#Base.occursin"><code>occursin</code></a> function to check if a substring is found within a string:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列内に部分文字列が存在するかどうかを確認するには、<a href="../../base/strings/index.html#Base.occursin"><code>occursin</code></a> 関数を使用できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; occursin("world", "Hello, world.")
true

julia&gt; occursin("o", "Xylophon")
true

julia&gt; occursin("a", "Xylophon")
false

julia&gt; occursin('o', "Xylophon")
true</code></pre><p data-translated="true"><span class="original-text">The last example shows that <a href="../../base/strings/index.html#Base.occursin"><code>occursin</code></a> can also look for a character literal.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最後の例では、<a href="../../base/strings/index.html#Base.occursin"><code>occursin</code></a> が文字リテラルを探すこともできることを示しています。</span></p><p data-translated="true"><span class="original-text">Two other handy string functions are <a href="../../base/arrays/index.html#Base.repeat"><code>repeat</code></a> and <a href="../../base/strings/index.html#Base.join"><code>join</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">他に便利な文字列関数としては、<a href="../../base/arrays/index.html#Base.repeat"><code>repeat</code></a> と <a href="../../base/strings/index.html#Base.join"><code>join</code></a> があります：</span></p><pre><code class="language-julia-repl hljs">julia&gt; repeat(".:Z:.", 10)
".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:."

julia&gt; join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"</code></pre><p data-translated="true"><span class="original-text">Some other useful functions include:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">他にも役立つ関数には次のものがあります：</span></p><ul><li data-translated="true"><span class="original-text"><a href="../../base/collections/index.html#Base.firstindex"><code>firstindex(str)</code></a> gives the minimal (byte) index that can be used to index into <code>str</code> (always 1 for strings, not necessarily true for other containers).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/collections/index.html#Base.firstindex"><code>firstindex(str)</code></a> は、<code>str</code> にインデックスを付けるために使用できる最小（バイト）インデックスを返します（文字列の場合は常に1、他のコンテナでは必ずしもそうではありません）。</span></li><li data-translated="true"><span class="original-text"><a href="../../base/collections/index.html#Base.lastindex"><code>lastindex(str)</code></a> gives the maximal (byte) index that can be used to index into <code>str</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/collections/index.html#Base.lastindex"><code>lastindex(str)</code></a> は、<code>str</code> にインデックスを付けるために使用できる最大（バイト）インデックスを返します。</span></li><li data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.length-Tuple{AbstractArray}"><code>length(str)</code></a> the number of characters in <code>str</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.length-Tuple{AbstractArray}"><code>length(str)</code></a> は、<code>str</code> の文字数を返します。</span></li><li data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.length-Tuple{AbstractArray}"><code>length(str, i, j)</code></a> the number of valid character indices in <code>str</code> from <code>i</code> to <code>j</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.length-Tuple{AbstractArray}"><code>length(str, i, j)</code></a> は、<code>i</code> から <code>j</code> までの <code>str</code> の有効な文字インデックスの数を返します。</span></li><li data-translated="true"><span class="original-text"><a href="../../base/strings/index.html#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits(str)</code></a> number of <a href="https://en.wikipedia.org/wiki/Character_encoding#Terminology#Terminology">code units</a> in a string.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/strings/index.html#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits(str)</code></a> は、文字列内の <a href="https://en.wikipedia.org/wiki/Character_encoding#Terminology#Terminology">コードユニット</a> の数を返します。</span></li><li data-translated="true"><span class="original-text"><a href="../../base/strings/index.html#Base.codeunit"><code>codeunit(str, i)</code></a> gives the code unit value in the string <code>str</code> at index <code>i</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/strings/index.html#Base.codeunit"><code>codeunit(str, i)</code></a> は、インデックス <code>i</code> の文字列 <code>str</code> におけるコードユニットの値を返します。</span></li><li data-translated="true"><span class="original-text"><a href="../../base/strings/index.html#Base.thisind"><code>thisind(str, i)</code></a> given an arbitrary index into a string find the first index of the character into which the index points.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/strings/index.html#Base.thisind"><code>thisind(str, i)</code></a> は、文字列内の任意のインデックスを指定して、そのインデックスが指す文字の最初のインデックスを見つけます。</span></li><li data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.nextind"><code>nextind(str, i, n=1)</code></a> find the start of the <code>n</code>th character starting after index <code>i</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.nextind"><code>nextind(str, i, n=1)</code></a> は、インデックス <code>i</code> の後に始まる <code>n</code> 番目の文字の開始位置を見つけます。</span></li><li data-translated="true"><span class="original-text"><a href="../../base/arrays/index.html#Base.prevind"><code>prevind(str, i, n=1)</code></a> find the start of the <code>n</code>th character starting before index <code>i</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/arrays/index.html#Base.prevind"><code>prevind(str, i, n=1)</code></a> は、インデックス <code>i</code> の前に始まる <code>n</code> 番目の文字の開始位置を見つけます。</span></li></ul><h2 id="non-standard-string-literals" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#non-standard-string-literals">Non-Standard String Literals</a><a id="non-standard-string-literals-1"></a><a class="docs-heading-anchor-permalink" href="#non-standard-string-literals" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#non-standard-string-literals">非標準文字列リテラル</a><a id="non-standard-string-literals-1"></a><a class="docs-heading-anchor-permalink" href="#non-standard-string-literals" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not quite what is needed. For these kinds of situations, Julia provides non-standard string literals. A non-standard string literal looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and may behave differently from a normal string literal.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列を構築したり文字列の意味を使用したりしたい状況がありますが、標準の文字列構造の動作が必要なものとは少し異なる場合があります。このような状況のために、Juliaは非標準文字列リテラルを提供します。非標準文字列リテラルは、通常の二重引用符で囲まれた文字列リテラルのように見えますが、すぐに識別子で接頭辞が付けられ、通常の文字列リテラルとは異なる動作をすることがあります。</span></p><p data-translated="true"><span class="original-text"><a href="#man-regex-literals">Regular expressions</a>, <a href="#man-byte-array-literals">byte array literals</a>, and <a href="#man-version-number-literals">version number literals</a>, as described below, are some examples of non-standard string literals. Users and packages may also define new non-standard string literals. Further documentation is given in the <a href="../metaprogramming/index.html#meta-non-standard-string-literals">Metaprogramming</a> section.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="#man-regex-literals">正規表現</a>、<a href="#man-byte-array-literals">バイト配列リテラル</a>、および <a href="#man-version-number-literals">バージョン番号リテラル</a> は、以下に説明する非標準文字列リテラルのいくつかの例です。ユーザーやパッケージも新しい非標準文字列リテラルを定義することができます。さらなるドキュメントは <a href="../metaprogramming/index.html#meta-non-standard-string-literals">メタプログラミング</a> セクションに記載されています。</span></p><h2 id="man-regex-literals" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-regex-literals">Regular Expressions</a><a id="man-regex-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-regex-literals" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-regex-literals">正規表現</a><a id="man-regex-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-regex-literals" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Sometimes you are not looking for an exact string, but a particular <em>pattern</em>. For example, suppose you are trying to extract a single date from a large text file. You don’t know what that date is (that’s why you are searching for it), but you do know it will look something like <code>YYYY-MM-DD</code>. Regular expressions allow you to specify these patterns and search for them.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">時には、正確な文字列を探しているのではなく、特定の <em>パターン</em> を探していることがあります。例えば、大きなテキストファイルから単一の日付を抽出しようとしているとします。その日付が何であるかはわかりません（それを探している理由です）が、それは <code>YYYY-MM-DD</code> のように見えることは知っています。正規表現を使用すると、これらのパターンを指定して検索することができます。</span></p><p data-translated="true"><span class="original-text">Julia uses version 2 of Perl-compatible regular expressions (regexes), as provided by the <a href="https://www.pcre.org/">PCRE</a> library (see the <a href="https://www.pcre.org/current/doc/html/pcre2syntax.html">PCRE2 syntax description</a> for more details). Regular expressions are related to strings in two ways: the obvious connection is that regular expressions are used to find regular patterns in strings; the other connection is that regular expressions are themselves input as strings, which are parsed into a state machine that can be used to efficiently search for patterns in strings. In Julia, regular expressions are input using non-standard string literals prefixed with various identifiers beginning with <code>r</code>. The most basic regular expression literal without any options turned on just uses <code>r"..."</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Juliaは、<a href="https://www.pcre.org/">PCRE</a>ライブラリによって提供されるPerl互換正規表現（regexes）のバージョン2を使用しています（詳細については<a href="https://www.pcre.org/current/doc/html/pcre2syntax.html">PCRE2構文の説明</a>を参照してください）。正規表現は、文字列に対して2つの方法で関連しています。明らかな関連は、正規表現が文字列内の正規パターンを見つけるために使用されることです。もう1つの関連は、正規表現自体が文字列として入力され、文字列内のパターンを効率的に検索するために使用される状態遷移機械に解析されることです。Juliaでは、正規表現は <code>r</code> で始まるさまざまな識別子で接頭辞が付けられた非標準文字列リテラルを使用して入力されます。オプションがオンになっていない最も基本的な正規表現リテラルは、単に <code>r"..."</code> を使用します。</span></p><pre><code class="language-julia-repl hljs">julia&gt; re = r"^\s*(?:#|$)"
r"^\s*(?:#|$)"

julia&gt; typeof(re)
Regex</code></pre><p data-translated="true"><span class="original-text">To check if a regex matches a string, use <a href="../../base/strings/index.html#Base.occursin"><code>occursin</code></a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">正規表現が文字列に一致するかどうかを確認するには、<a href="../../base/strings/index.html#Base.occursin"><code>occursin</code></a> を使用します:</span></p><pre><code class="language-julia-repl hljs">julia&gt; occursin(r"^\s*(?:#|$)", "not a comment")
false

julia&gt; occursin(r"^\s*(?:#|$)", "# a comment")
true</code></pre><p data-translated="true"><span class="original-text">As one can see here, <a href="../../base/strings/index.html#Base.occursin"><code>occursin</code></a> simply returns true or false, indicating whether a match for the given regex occurs in the string. Commonly, however, one wants to know not just whether a string matched, but also <em>how</em> it matched. To capture this information about a match, use the <a href="../../base/strings/index.html#Base.match"><code>match</code></a> function instead:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ここで見ることができるように、<a href="../../base/strings/index.html#Base.occursin"><code>occursin</code></a>は単に真または偽を返し、指定された正規表現が文字列に存在するかどうかを示します。しかし、一般的には、文字列が一致したかどうかだけでなく、<em>どのように</em>一致したかも知りたいものです。この一致に関する情報を取得するには、代わりに<a href="../../base/strings/index.html#Base.match"><code>match</code></a>関数を使用します:</span></p><pre><code class="language-julia-repl hljs">julia&gt; match(r"^\s*(?:#|$)", "not a comment")

julia&gt; match(r"^\s*(?:#|$)", "# a comment")
RegexMatch("#")</code></pre><p data-translated="true"><span class="original-text">If the regular expression does not match the given string, <a href="../../base/strings/index.html#Base.match"><code>match</code></a> returns <a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a> – a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">正規表現が指定された文字列に一致しない場合、<a href="../../base/strings/index.html#Base.match"><code>match</code></a>は<a href="../../base/constants/index.html#Core.nothing"><code>nothing</code></a>を返します。これは、インタラクティブプロンプトで何も表示しない特別な値です。表示しないことを除けば、これは完全に通常の値であり、プログラム的にテストすることができます:</span></p><pre><code class="language-julia hljs">m = match(r"^\s*(?:#|$)", line)
if m === nothing
    println("not a comment")
else
    println("blank or comment")
end</code></pre><p data-translated="true"><span class="original-text">If a regular expression does match, the value returned by <a href="../../base/strings/index.html#Base.match"><code>match</code></a> is a <a href="../../base/strings/index.html#Base.RegexMatch"><code>RegexMatch</code></a> object. These objects record how the expression matches, including the substring that the pattern matches and any captured substrings, if there are any. This example only captures the portion of the substring that matches, but perhaps we want to capture any non-blank text after the comment character. We could do the following:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">正規表現が一致する場合、<a href="../../base/strings/index.html#Base.match"><code>match</code></a>によって返される値は<a href="../../base/strings/index.html#Base.RegexMatch"><code>RegexMatch</code></a>オブジェクトです。これらのオブジェクトは、パターンが一致する部分文字列や、もしあればキャプチャされた部分文字列を含む、一致の方法を記録します。この例では、一致する部分文字列の部分のみをキャプチャしますが、コメント文字の後の空白でないテキストをキャプチャしたいかもしれません。次のようにすることができます:</span></p><pre><code class="language-julia-repl hljs">julia&gt; m = match(r"^\s*(?:#\s*(.*?)\s*$)", "# a comment ")
RegexMatch("# a comment ", 1="a comment")</code></pre><p data-translated="true"><span class="original-text">When calling <a href="../../base/strings/index.html#Base.match"><code>match</code></a>, you have the option to specify an index at which to start the search. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/strings/index.html#Base.match"><code>match</code></a>を呼び出すとき、検索を開始するインデックスを指定するオプションがあります。例えば:</span></p><pre><code class="language-julia-repl hljs">julia&gt; m = match(r"[0-9]","aaaa1aaaa2aaaa3",1)
RegexMatch("1")

julia&gt; m = match(r"[0-9]","aaaa1aaaa2aaaa3",6)
RegexMatch("2")

julia&gt; m = match(r"[0-9]","aaaa1aaaa2aaaa3",11)
RegexMatch("3")</code></pre><p data-translated="true"><span class="original-text">You can extract the following info from a <code>RegexMatch</code> object:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>RegexMatch</code>オブジェクトから次の情報を抽出できます:</span></p><ul><li data-translated="true"><span class="original-text">the entire substring matched: <code>m.match</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">一致した全体の部分文字列: <code>m.match</code></span></li><li data-translated="true"><span class="original-text">the captured substrings as an array of strings: <code>m.captures</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キャプチャされた部分文字列の配列: <code>m.captures</code></span></li><li data-translated="true"><span class="original-text">the offset at which the whole match begins: <code>m.offset</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">全体の一致が始まるオフセット: <code>m.offset</code></span></li><li data-translated="true"><span class="original-text">the offsets of the captured substrings as a vector: <code>m.offsets</code></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キャプチャされた部分文字列のオフセットをベクトルとして: <code>m.offsets</code></span></li></ul><p data-translated="true"><span class="original-text">For when a capture doesn't match, instead of a substring, <code>m.captures</code> contains <code>nothing</code> in that position, and <code>m.offsets</code> has a zero offset (recall that indices in Julia are 1-based, so a zero offset into a string is invalid). Here is a pair of somewhat contrived examples:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キャプチャが一致しない場合、部分文字列の代わりに、<code>m.captures</code>はその位置に<code>nothing</code>を含み、<code>m.offsets</code>はゼロオフセットを持ちます（Juliaではインデックスは1ベースであるため、文字列へのゼロオフセットは無効です）。ここにいくつかのやや作り話的な例があります:</span></p><pre><code class="language-julia-repl hljs">julia&gt; m = match(r"(a|b)(c)?(d)", "acd")
RegexMatch("acd", 1="a", 2="c", 3="d")

julia&gt; m.match
"acd"

julia&gt; m.captures
3-element Vector{Union{Nothing, SubString{String}}}:
 "a"
 "c"
 "d"

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Vector{Int64}:
 1
 2
 3

julia&gt; m = match(r"(a|b)(c)?(d)", "ad")
RegexMatch("ad", 1="a", 2=nothing, 3="d")

julia&gt; m.match
"ad"

julia&gt; m.captures
3-element Vector{Union{Nothing, SubString{String}}}:
 "a"
 nothing
 "d"

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Vector{Int64}:
 1
 0
 2</code></pre><p data-translated="true"><span class="original-text">It is convenient to have captures returned as an array so that one can use destructuring syntax to bind them to local variables. As a convenience, the <code>RegexMatch</code> object implements iterator methods that pass through to the <code>captures</code> field, so you can destructure the match object directly:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キャプチャが配列として返されるのは便利で、分割構文を使用してそれらをローカル変数にバインドできます。便利なことに、<code>RegexMatch</code>オブジェクトは、<code>captures</code>フィールドを通過するイテレーターメソッドを実装しているため、マッチオブジェクトを直接分割できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; first, second, third = m; first
"a"</code></pre><p data-translated="true"><span class="original-text">Captures can also be accessed by indexing the <code>RegexMatch</code> object with the number or name of the capture group:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キャプチャは、キャプチャグループの番号または名前で<code>RegexMatch</code>オブジェクトをインデックスすることでもアクセスできます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; m=match(r"(?&lt;hour&gt;\d+):(?&lt;minute&gt;\d+)","12:45")
RegexMatch("12:45", hour="12", minute="45")

julia&gt; m[:minute]
"45"

julia&gt; m[2]
"45"</code></pre><p data-translated="true"><span class="original-text">Captures can be referenced in a substitution string when using <a href="../../base/collections/index.html#Base.replace-Tuple{Any, Vararg{Pair}}"><code>replace</code></a> by using <code>\n</code> to refer to the nth capture group and prefixing the substitution string with <code>s</code>. Capture group 0 refers to the entire match object. Named capture groups can be referenced in the substitution with <code>\g&lt;groupname&gt;</code>. For example:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">キャプチャグループは、<a href="../../base/collections/index.html#Base.replace-Tuple{Any, Vararg{Pair}}"><code>replace</code></a>を使用する際に置換文字列で参照できます。<code>\n</code>を使用してn番目のキャプチャグループを参照し、置換文字列を<code>s</code>でプレフィックスします。キャプチャグループ0は、全体のマッチオブジェクトを参照します。名前付きキャプチャグループは、置換で<code>\g&lt;groupname&gt;</code>を使用して参照できます。例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; replace("first second", r"(\w+) (?&lt;agroup&gt;\w+)" =&gt; s"\g&lt;agroup&gt; \1")
"second first"</code></pre><p data-translated="true"><span class="original-text">Numbered capture groups can also be referenced as <code>\g&lt;n&gt;</code> for disambiguation, as in:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">番号付きキャプチャグループは、曖昧さを避けるために<code>\g&lt;n&gt;</code>としても参照できます。例えば：</span></p><pre><code class="language-julia-repl hljs">julia&gt; replace("a", r"." =&gt; s"\g&lt;0&gt;1")
"a1"</code></pre><p data-translated="true"><span class="original-text">You can modify the behavior of regular expressions by some combination of the flags <code>i</code>, <code>m</code>, <code>s</code>, and <code>x</code> after the closing double quote mark. These flags have the same meaning as they do in Perl, as explained in this excerpt from the <a href="https://perldoc.perl.org/perlre#Modifiers#Modifiers">perlre manpage</a>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">正規表現の動作は、閉じる二重引用符の後に<code>i</code>、<code>m</code>、<code>s</code>、および<code>x</code>のフラグの組み合わせによって変更できます。これらのフラグは、<a href="https://perldoc.perl.org/perlre#Modifiers#Modifiers">perlreマニュアルページ</a>のこの抜粋で説明されているように、Perlと同じ意味を持ちます：</span></p><pre><code class="nohighlight hljs">i   Do case-insensitive pattern matching.

    If locale matching rules are in effect, the case map is taken
    from the current locale for code points less than 255, and
    from Unicode rules for larger code points. However, matches
    that would cross the Unicode rules/non-Unicode rules boundary
    (ords 255/256) will not succeed.

m   Treat string as multiple lines. That is, change "^" and "$"
    from matching the start or end of the string to matching the
    start or end of any line anywhere within the string.

s   Treat string as single line. That is, change "." to match any
    character whatsoever, even a newline, which normally it would
    not match.

    Used together, as r""ms, they let the "." match any character
    whatsoever, while still allowing "^" and "$" to match,
    respectively, just after and just before newlines within the
    string.

x   Tells the regular expression parser to ignore most whitespace
    that is neither backslashed nor within a character class. You
    can use this to break up your regular expression into
    (slightly) more readable parts. The '#' character is also
    treated as a metacharacter introducing a comment, just as in
    ordinary code.</code></pre><p data-translated="true"><span class="original-text">For example, the following regex has all three flags turned on:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例えば、次の正規表現はすべてのフラグがオンになっています：</span></p><pre><code class="language-julia-repl hljs">julia&gt; r"a+.*b+.*d$"ism
r"a+.*b+.*d$"ims

julia&gt; match(r"a+.*b+.*d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")</code></pre><p data-translated="true"><span class="original-text">The <code>r"..."</code> literal is constructed without interpolation and unescaping (except for quotation mark <code>"</code> which still has to be escaped). Here is an example showing the difference from standard string literals:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>r"..."</code>リテラルは、補間やエスケープなしで構築されます（引用符<code>"</code>はエスケープする必要があります）。標準の文字列リテラルとの違いを示す例は次のとおりです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = 10
10

julia&gt; r"$x"
r"$x"

julia&gt; "$x"
"10"

julia&gt; r"\x"
r"\x"

julia&gt; "\x"
ERROR: syntax: invalid escape sequence</code></pre><p data-translated="true"><span class="original-text">Triple-quoted regex strings, of the form <code>r"""..."""</code>, are also supported (and may be convenient for regular expressions containing quotation marks or newlines).</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">三重引用の正規表現文字列、形式<code>r"""..."""</code>もサポートされています（引用符や改行を含む正規表現に便利です）。</span></p><p data-translated="true"><span class="original-text">The <code>Regex()</code> constructor may be used to create a valid regex string programmatically. This permits using the contents of string variables and other string operations when constructing the regex string. Any of the regex codes above can be used within the single string argument to <code>Regex()</code>. Here are some examples:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>Regex()</code>コンストラクタを使用して、プログラム的に有効な正規表現文字列を作成できます。これにより、正規表現文字列を構築する際に文字列変数の内容や他の文字列操作を使用できます。上記の正規表現コードのいずれかを<code>Regex()</code>の単一の文字列引数内で使用できます。いくつかの例を示します：</span></p><pre><code class="language-julia-repl hljs">julia&gt; using Dates

julia&gt; d = Date(1962,7,10)
1962-07-10

julia&gt; regex_d = Regex("Day " * string(day(d)))
r"Day 10"

julia&gt; match(regex_d, "It happened on Day 10")
RegexMatch("Day 10")

julia&gt; name = "Jon"
"Jon"

julia&gt; regex_name = Regex("[\"( ]\\Q$name\\E[\") ]")  # interpolate value of name
r"[\"( ]\QJon\E[\") ]"

julia&gt; match(regex_name, " Jon ")
RegexMatch(" Jon ")

julia&gt; match(regex_name, "[Jon]") === nothing
true</code></pre><p data-translated="true"><span class="original-text">Note the use of the <code>\Q...\E</code> escape sequence. All characters between the <code>\Q</code> and the <code>\E</code> are interpreted as literal characters. This is convenient for matching characters that would otherwise be regex metacharacters. However, caution is needed when using this feature together with string interpolation, since the interpolated string might itself contain the <code>\E</code> sequence, unexpectedly terminating literal matching. User inputs need to be sanitized before inclusion in a regex.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>\Q...\E</code>エスケープシーケンスの使用に注意してください。<code>\Q</code>と<code>\E</code>の間のすべての文字はリテラル文字として解釈されます。これは、そうでなければ正規表現のメタキャラクターである文字を一致させるのに便利です。ただし、この機能を文字列補間と一緒に使用する際には注意が必要です。補間された文字列自体が<code>\E</code>シーケンスを含む可能性があり、リテラルマッチングが予期せず終了することがあります。ユーザー入力は、正規表現に含める前にサニタイズする必要があります。</span></p><h2 id="man-byte-array-literals" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-byte-array-literals">Byte Array Literals</a><a id="man-byte-array-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-byte-array-literals" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-byte-array-literals">バイト配列リテラル</a><a id="man-byte-array-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-byte-array-literals" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Another useful non-standard string literal is the byte-array string literal: <code>b"..."</code>. This form lets you use string notation to express read only literal byte arrays – i.e. arrays of <a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a> values. The type of those objects is <code>CodeUnits{UInt8, String}</code>. The rules for byte array literals are the following:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">もう一つの便利な非標準文字列リテラルはバイト配列文字列リテラルです：<code>b"..."</code>。この形式では、文字列表記を使用して読み取り専用のリテラルバイト配列、すなわち<a href="../../base/numbers/index.html#Core.UInt8"><code>UInt8</code></a>値の配列を表現できます。これらのオブジェクトの型は<code>CodeUnits{UInt8, String}</code>です。バイト配列リテラルのルールは以下の通りです：</span></p><ul><li data-translated="true"><span class="original-text">ASCII characters and ASCII escapes produce a single byte.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ASCII文字とASCIIエスケープは単一のバイトを生成します。</span></li><li data-translated="true"><span class="original-text"><code>\x</code> and octal escape sequences produce the <em>byte</em> corresponding to the escape value.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>\x</code>および8進数エスケープシーケンスは、エスケープ値に対応する<em>バイト</em>を生成します。</span></li><li data-translated="true"><span class="original-text">Unicode escape sequences produce a sequence of bytes encoding that code point in UTF-8.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">Unicodeエスケープシーケンスは、そのコードポイントをUTF-8でエンコードしたバイトのシーケンスを生成します。</span></li></ul><p data-translated="true"><span class="original-text">There is some overlap between these rules since the behavior of <code>\x</code> and octal escapes less than 0x80 (128) are covered by both of the first two rules, but here these rules agree. Together, these rules allow one to easily use ASCII characters, arbitrary byte values, and UTF-8 sequences to produce arrays of bytes. Here is an example using all three:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これらのルールには重複があり、<code>\x</code>および0x80（128）未満の8進数エスケープの動作は最初の2つのルールの両方でカバーされていますが、ここではこれらのルールが一致します。これらのルールを組み合わせることで、ASCII文字、任意のバイト値、およびUTF-8シーケンスを簡単に使用してバイトの配列を生成できます。以下は、3つすべてを使用した例です：</span></p><pre><code class="language-julia-repl hljs">julia&gt; b"DATA\xff\u2200"
8-element Base.CodeUnits{UInt8, String}:
 0x44
 0x41
 0x54
 0x41
 0xff
 0xe2
 0x88
 0x80</code></pre><p data-translated="true"><span class="original-text">The ASCII string "DATA" corresponds to the bytes 68, 65, 84, 65. <code>\xff</code> produces the single byte 255. The Unicode escape <code>\u2200</code> is encoded in UTF-8 as the three bytes 226, 136, 128. Note that the resulting byte array does not correspond to a valid UTF-8 string:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">ASCII文字列"DATA"はバイト68、65、84、65に対応します。<code>\xff</code>は単一のバイト255を生成します。Unicodeエスケープ<code>\u2200</code>はUTF-8で3バイト226、136、128としてエンコードされます。結果のバイト配列は有効なUTF-8文字列に対応しないことに注意してください：</span></p><pre><code class="language-julia-repl hljs">julia&gt; isvalid("DATA\xff\u2200")
false</code></pre><p data-translated="true"><span class="original-text">As it was mentioned <code>CodeUnits{UInt8, String}</code> type behaves like read only array of <code>UInt8</code> and if you need a standard vector you can convert it using <code>Vector{UInt8}</code>:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">前述のように、<code>CodeUnits{UInt8, String}</code>型は<code>UInt8</code>の読み取り専用配列のように振る舞い、標準ベクターが必要な場合は<code>Vector{UInt8}</code>を使用して変換できます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; x = b"123"
3-element Base.CodeUnits{UInt8, String}:
 0x31
 0x32
 0x33

julia&gt; x[1]
0x31

julia&gt; x[1] = 0x32
ERROR: CanonicalIndexError: setindex! not defined for Base.CodeUnits{UInt8, String}
[...]

julia&gt; Vector{UInt8}(x)
3-element Vector{UInt8}:
 0x31
 0x32
 0x33</code></pre><p data-translated="true"><span class="original-text">Also observe the significant distinction between <code>\xff</code> and <code>\uff</code>: the former escape sequence encodes the <em>byte 255</em>, whereas the latter escape sequence represents the <em>code point 255</em>, which is encoded as two bytes in UTF-8:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">また、<code>\xff</code>と<code>\uff</code>の間には重要な違いがあることに注意してください：前者のエスケープシーケンスは<em>バイト255</em>をエンコードし、後者のエスケープシーケンスは<em>コードポイント255</em>を表し、これはUTF-8で2バイトとしてエンコードされます：</span></p><pre><code class="language-julia-repl hljs">julia&gt; b"\xff"
1-element Base.CodeUnits{UInt8, String}:
 0xff

julia&gt; b"\uff"
2-element Base.CodeUnits{UInt8, String}:
 0xc3
 0xbf</code></pre><p data-translated="true"><span class="original-text">Character literals use the same behavior.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字リテラルは同じ動作を使用します。</span></p><p data-translated="true"><span class="original-text">For code points less than <code>\u80</code>, it happens that the UTF-8 encoding of each code point is just the single byte produced by the corresponding <code>\x</code> escape, so the distinction can safely be ignored. For the escapes <code>\x80</code> through <code>\xff</code> as compared to <code>\u80</code> through <code>\uff</code>, however, there is a major difference: the former escapes all encode single bytes, which – unless followed by very specific continuation bytes – do not form valid UTF-8 data, whereas the latter escapes all represent Unicode code points with two-byte encodings.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">コードポイントが<code>\u80</code>未満の場合、各コードポイントのUTF-8エンコーディングは対応する<code>\x</code>エスケープによって生成される単一バイトに過ぎないため、その区別は無視しても安全です。しかし、<code>\x80</code>から<code>\xff</code>までのエスケープと<code>\u80</code>から<code>\uff</code>までのエスケープには大きな違いがあります。前者のエスケープはすべて単一バイトをエンコードしており、非常に特定の継続バイトが続かない限り、有効なUTF-8データを形成しません。一方、後者のエスケープはすべて2バイトエンコーディングでUnicodeコードポイントを表します。</span></p><p data-translated="true"><span class="original-text">If this is all extremely confusing, try reading <a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">"The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets"</a>. It's an excellent introduction to Unicode and UTF-8, and may help alleviate some confusion regarding the matter.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">これが非常に混乱する場合は、<a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">「すべてのソフトウェア開発者が絶対に知っておくべきUnicodeと文字セットについての絶対的な最小限」</a>を読んでみてください。これはUnicodeとUTF-8の優れた入門書であり、この問題に関する混乱を軽減するのに役立つかもしれません。</span></p><h2 id="man-version-number-literals" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-version-number-literals">Version Number Literals</a><a id="man-version-number-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-version-number-literals" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-version-number-literals">バージョン番号リテラル</a><a id="man-version-number-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-version-number-literals" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Version numbers can easily be expressed with non-standard string literals of the form <a href="../../base/base/index.html#Base.@v_str"><code>v"..."</code></a>. Version number literals create <a href="../../base/base/index.html#Base.VersionNumber"><code>VersionNumber</code></a> objects which follow the specifications of <a href="https://semver.org/spec/v2.0.0-rc.2.html">semantic versioning 2.0.0-rc2</a>, and therefore are composed of major, minor and patch numeric values, followed by pre-release and build alphanumeric annotations. For example, <code>v"0.2.1-rc1+win64"</code> is broken into major version <code>0</code>, minor version <code>2</code>, patch version <code>1</code>, pre-release <code>rc1</code> and build <code>win64</code>. When entering a version literal, everything except the major version number is optional, therefore e.g.  <code>v"0.2"</code> is equivalent to <code>v"0.2.0"</code> (with empty pre-release/build annotations), <code>v"2"</code> is equivalent to <code>v"2.0.0"</code>, and so on.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">バージョン番号は、<a href="../../base/base/index.html#Base.@v_str"><code>v"..."</code></a>の形式の非標準文字列リテラルで簡単に表現できます。バージョン番号リテラルは、<a href="../../base/base/index.html#Base.VersionNumber"><code>VersionNumber</code></a>オブジェクトを作成し、<a href="https://semver.org/spec/v2.0.0-rc.2.html">セマンティックバージョニング2.0.0-rc2</a>の仕様に従い、メジャー、マイナー、パッチの数値値の後に、プレリリースおよびビルドの英数字注釈が続きます。例えば、<code>v"0.2.1-rc1+win64"</code>は、メジャーバージョン<code>0</code>、マイナーバージョン<code>2</code>、パッチバージョン<code>1</code>、プレリリース<code>rc1</code>、ビルド<code>win64</code>に分解されます。バージョンリテラルを入力する際、メジャーバージョン番号以外はすべてオプションであるため、例えば<code>v"0.2"</code>は<code>v"0.2.0"</code>（空のプレリリース/ビルド注釈付き）と同等であり、<code>v"2"</code>は<code>v"2.0.0"</code>と同等です。</span></p><p data-translated="true"><span class="original-text"><code>VersionNumber</code> objects are mostly useful to easily and correctly compare two (or more) versions. For example, the constant <a href="../../base/constants/index.html#Base.VERSION"><code>VERSION</code></a> holds Julia version number as a <code>VersionNumber</code> object, and therefore one can define some version-specific behavior using simple statements as:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><code>VersionNumber</code>オブジェクトは、2つ（またはそれ以上）のバージョンを簡単かつ正確に比較するために主に便利です。例えば、定数<a href="../../base/constants/index.html#Base.VERSION"><code>VERSION</code></a>は、Juliaのバージョン番号を<code>VersionNumber</code>オブジェクトとして保持しているため、次のような簡単な文を使用してバージョン特有の動作を定義できます。</span></p><pre><code class="language-julia hljs">if v"0.2" &lt;= VERSION &lt; v"0.3-"
    # do something specific to 0.2 release series
end</code></pre><p data-translated="true"><span class="original-text">Note that in the above example the non-standard version number <code>v"0.3-"</code> is used, with a trailing <code>-</code>: this notation is a Julia extension of the standard, and it's used to indicate a version which is lower than any <code>0.3</code> release, including all of its pre-releases. So in the above example the code would only run with stable <code>0.2</code> versions, and exclude such versions as <code>v"0.3.0-rc1"</code>. In order to also allow for unstable (i.e. pre-release) <code>0.2</code> versions, the lower bound check should be modified like this: <code>v"0.2-" &lt;= VERSION</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">上記の例では、非標準のバージョン番号<code>v"0.3-"</code>が使用されており、末尾に<code>-</code>があります。この表記は、標準のJulia拡張であり、<code>0.3</code>リリースのすべてのプレリリースを含む、<code>0.3</code>よりも低いバージョンを示すために使用されます。したがって、上記の例では、コードは安定した<code>0.2</code>バージョンでのみ実行され、<code>v"0.3.0-rc1"</code>のようなバージョンは除外されます。不安定（すなわちプレリリース）の<code>0.2</code>バージョンも許可するために、下限チェックは次のように修正する必要があります：<code>v"0.2-" &lt;= VERSION</code>。</span></p><p data-translated="true"><span class="original-text">Another non-standard version specification extension allows one to use a trailing <code>+</code> to express an upper limit on build versions, e.g.  <code>VERSION &gt; v"0.2-rc1+"</code> can be used to mean any version above <code>0.2-rc1</code> and any of its builds: it will return <code>false</code> for version <code>v"0.2-rc1+win64"</code> and <code>true</code> for <code>v"0.2-rc2"</code>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">別の非標準のバージョン仕様拡張により、末尾に<code>+</code>を使用してビルドバージョンの上限を表現できます。例えば、<code>VERSION &gt; v"0.2-rc1+"</code>は、<code>0.2-rc1</code>およびそのビルドのいずれかを超えるバージョンを意味するために使用できます：これは、<code>v"0.2-rc1+win64"</code>に対して<code>false</code>を返し、<code>v"0.2-rc2"</code>に対して<code>true</code>を返します。</span></p><p data-translated="true"><span class="original-text">It is good practice to use such special versions in comparisons (particularly, the trailing <code>-</code> should always be used on upper bounds unless there's a good reason not to), but they must not be used as the actual version number of anything, as they are invalid in the semantic versioning scheme.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このような特別なバージョンを比較に使用することは良い習慣です（特に、上限には常に末尾に<code>-</code>を使用すべきですが、そうしない良い理由がない限り）、ただし、セマンティックバージョニングスキームでは無効であるため、実際のバージョン番号として使用してはいけません。</span></p><p data-translated="true"><span class="original-text">Besides being used for the <a href="../../base/constants/index.html#Base.VERSION"><code>VERSION</code></a> constant, <code>VersionNumber</code> objects are widely used in the <code>Pkg</code> module, to specify packages versions and their dependencies.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">定数<a href="../../base/constants/index.html#Base.VERSION"><code>VERSION</code></a>に使用されるだけでなく、<code>VersionNumber</code>オブジェクトは、パッケージのバージョンやその依存関係を指定するために<code>Pkg</code>モジュールで広く使用されています。</span></p><h2 id="man-raw-string-literals" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-raw-string-literals">Raw String Literals</a><a id="man-raw-string-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-raw-string-literals" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-raw-string-literals">生文字列リテラル</a><a id="man-raw-string-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-raw-string-literals" title="Permalink"></a></span></h2><p data-translated="true"><span class="original-text">Raw strings without interpolation or unescaping can be expressed with non-standard string literals of the form <code>raw"..."</code>. Raw string literals create ordinary <code>String</code> objects which contain the enclosed contents exactly as entered with no interpolation or unescaping. This is useful for strings which contain code or markup in other languages which use <code>$</code> or <code>\</code> as special characters.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">補間やエスケープなしの生文字列は、<code>raw"..."</code>の形式の非標準文字リテラルで表現できます。生文字列リテラルは、補間やエスケープなしで入力された内容をそのまま含む通常の<code>String</code>オブジェクトを作成します。これは、<code>$</code>や<code>\</code>を特殊文字として使用する他の言語のコードやマークアップを含む文字列に便利です。</span></p><p data-translated="true"><span class="original-text">The exception is that quotation marks still must be escaped, e.g. <code>raw"\""</code> is equivalent to <code>"\""</code>. To make it possible to express all strings, backslashes then also must be escaped, but only when appearing right before a quote character:</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">例外として、引用符は依然としてエスケープする必要があります。例えば、<code>raw"\""</code>は<code>"\""</code>と同等です。すべての文字列を表現できるようにするために、バックスラッシュもエスケープする必要がありますが、これは引用文字の直前に現れる場合のみです：</span></p><pre><code class="language-julia-repl hljs">julia&gt; println(raw"\\ \\\"")
\\ \"</code></pre><p data-translated="true"><span class="original-text">Notice that the first two backslashes appear verbatim in the output, since they do not precede a quote character. However, the next backslash character escapes the backslash that follows it, and the last backslash escapes a quote, since these backslashes appear before a quote.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">最初の2つのバックスラッシュは、引用文字の前に来ないため、出力にそのまま表示されることに注意してください。しかし、次のバックスラッシュはそれに続くバックスラッシュをエスケープし、最後のバックスラッシュは引用をエスケープします。これらのバックスラッシュは引用の前に現れます。</span></p><h2 id="man-annotated-strings" data-translated="true"><span class="original-text"><a class="docs-heading-anchor" href="#man-annotated-strings">Annotated Strings</a><a id="man-annotated-strings-1"></a><a class="docs-heading-anchor-permalink" href="#man-annotated-strings" title="Permalink"></a></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a class="docs-heading-anchor" href="#man-annotated-strings">注釈付き文字列</a><a id="man-annotated-strings-1"></a><a class="docs-heading-anchor-permalink" href="#man-annotated-strings" title="Permalink"></a></span></h2><div class="admonition is-info" id="Note-c8a39957cfa5109f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c8a39957cfa5109f" title="Permalink"></a></header><div class="admonition-body"><p data-translated="true"><span class="original-text">The API for AnnotatedStrings is considered experimental and is subject to change between Julia versions.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">AnnotatedStringsのAPIは実験的と見なされており、Juliaのバージョン間で変更される可能性があります。</span></p></div></div><p data-translated="true"><span class="original-text">It is sometimes useful to be able to hold metadata relating to regions of a string. A <a href="../../base/strings/index.html#Base.AnnotatedString"><code>AnnotatedString</code></a> wraps another string and allows for regions of it to be annotated with labelled values (<code>:label =&gt; value</code>). All generic string operations are applied to the underlying string. However, when possible, styling information is preserved. This means you can manipulate a <a href="../../base/strings/index.html#Base.AnnotatedString"><code>AnnotatedString</code></a> —taking substrings, padding them, concatenating them with other strings— and the metadata annotations will "come along for the ride".</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">文字列の領域に関連するメタデータを保持できることが時々便利です。<a href="../../base/strings/index.html#Base.AnnotatedString"><code>AnnotatedString</code></a>は別の文字列をラップし、その一部をラベル付き値（<code>:label =&gt; value</code>）で注釈を付けることを可能にします。すべての一般的な文字列操作は、基になる文字列に適用されます。しかし、可能な場合は、スタイリング情報が保持されます。これは、<a href="../../base/strings/index.html#Base.AnnotatedString"><code>AnnotatedString</code></a>を操作できることを意味します—部分文字列を取得したり、パディングしたり、他の文字列と連結したりしても、メタデータの注釈は「一緒に付いてくる」ことになります。</span></p><p data-translated="true"><span class="original-text">This string type is fundamental to the <a href="../../stdlib/StyledStrings/index.html#stdlib-styledstrings">StyledStrings stdlib</a>, which uses <code>:face</code>-labelled annotations to hold styling information.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">この文字列型は、<a href="../../stdlib/StyledStrings/index.html#stdlib-styledstrings">StyledStrings stdlib</a>の基本であり、<code>:face</code>ラベル付きの注釈を使用してスタイリング情報を保持します。</span></p><p data-translated="true"><span class="original-text">When concatenating a <a href="../../base/strings/index.html#Base.AnnotatedString"><code>AnnotatedString</code></a>, take care to use <a href="../../base/strings/index.html#Base.annotatedstring"><code>annotatedstring</code></a> instead of <a href="../../base/strings/index.html#Base.string"><code>string</code></a> if you want to keep the string annotations.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/strings/index.html#Base.AnnotatedString"><code>AnnotatedString</code></a>を連結する際は、文字列の注釈を保持したい場合は、<a href="../../base/strings/index.html#Base.annotatedstring"><code>annotatedstring</code></a>を使用するように注意してください。<a href="../../base/strings/index.html#Base.string"><code>string</code></a>ではなく。</span></p><pre><code class="language-julia-repl hljs">julia&gt; str = Base.AnnotatedString("hello there",
               [(1:5, :word, :greeting), (7:11, :label, 1)])
"hello there"

julia&gt; length(str)
11

julia&gt; lpad(str, 14)
"   hello there"

julia&gt; typeof(lpad(str, 7))
Base.AnnotatedString{String}

julia&gt; str2 = Base.AnnotatedString(" julia", [(2:6, :face, :magenta)])
" julia"

julia&gt; Base.annotatedstring(str, str2)
"hello there julia"

julia&gt; str * str2 == Base.annotatedstring(str, str2) # *-concatenation still works
true</code></pre><p data-translated="true"><span class="original-text">The annotations of a <a href="../../base/strings/index.html#Base.AnnotatedString"><code>AnnotatedString</code></a> can be accessed and modified via the <a href="../../base/strings/index.html#Base.annotations"><code>annotations</code></a> and <a href="../../base/strings/index.html#Base.annotate!"><code>annotate!</code></a> functions.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="../../base/strings/index.html#Base.AnnotatedString"><code>AnnotatedString</code></a>の注釈は、<a href="../../base/strings/index.html#Base.annotations"><code>annotations</code></a>および<a href="../../base/strings/index.html#Base.annotate!"><code>annotate!</code></a>関数を介してアクセスおよび変更できます。</span></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../complex-and-rational-numbers/index.html">« Complex and Rational Numbers</a><a class="docs-footer-nextpage" href="../functions/index.html">Functions »</a><div class="flexbox-break"></div><p class="footer-message" data-translated="true"><span class="original-text">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> と <a href="https://julialang.org/">Juliaプログラミング言語</a> によって提供されています。</span></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title" data-translated="true"><span class="original-text">Settings</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">設定</span></p><button class="delete"></button></header><section class="modal-card-body"><p data-translated="true"><span class="original-text"><label class="label">Theme</label></span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;"><label class="label">テーマ</label></span></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr><p data-translated="true"><span class="original-text">This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Thursday 20 November 2025 17:03">Thursday 20 November 2025</span>. Using Julia version 1.12.2.</span><span class="ai_translation" style="margin-top: 0.5em; margin-bottom: 1.2em; display: block;">このドキュメントは <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> バージョン 1.16.0 を使用して <span class="colophon-date" title="2025年11月20日木曜日 17:03">2025年11月20日木曜日</span> に生成されました。Julia バージョン 1.12.2 を使用しています。</span></p></section><footer class="modal-card-foot"></footer></div></div></div>
<button id="ai-toggle-btn">原文を表示</button><script>
                document.getElementById('ai-toggle-btn').onclick = function() {
                    const body = document.body;
                    const btn = document.getElementById('ai-toggle-btn');
                    const currentMode = body.getAttribute('data-view-mode');
                    if (currentMode === 'translation-only') {
                        body.removeAttribute('data-view-mode');
                        btn.textContent = '原文を非表示';
                    } else {
                        body.setAttribute('data-view-mode', 'translation-only');
                        btn.textContent = '原文を表示';
                    }
                };
            </script></body></html>